// import * as React from 'react';
// import React__default, { useState as useState$1, useEffect as useEffect$2, useCallback, Children, isValidElement, cloneElement, createElement, useReducer as useReducer$1, useRef as useRef$2, useLayoutEffect, createContext, useContext, Component, PureComponent, useMemo } from 'react';
// import * as PropTypes from 'prop-types';
// import PropTypes__default, { PropTypes as PropTypes$1 } from 'prop-types';
// import MuiAccordion from '@mui/material/Accordion';
// import MuiAccordionDetails from '@mui/material/AccordionDetails';
// import MuiAccordionSummary from '@mui/material/AccordionSummary';
// import MuiAlert from '@mui/material/Alert';
// import AddIcon from '@mui/icons-material/Add';
// import AddCircleIcon from '@mui/icons-material/AddCircle';
// import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown';
// import ArrowForwardIosIcon from '@mui/icons-material/ArrowForwardIos';
// import ArrowUpwardIconRounded from '@mui/icons-material/ArrowUpwardRounded';
// import ArrowDownwardRoundedIcon from '@mui/icons-material/ArrowDownwardRounded';
// import AssignmentIndIcon from '@mui/icons-material/AssignmentInd';
// import BusinessCenterOutlinedIcon from '@mui/icons-material/BusinessCenterOutlined';
// import ChatIcon from '@mui/icons-material/Chat';
// import CancelIcon from '@mui/icons-material/Cancel';
// import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
// import CloseIcon from '@mui/icons-material/Close';
// import CollectionsBookmarkIcon from '@mui/icons-material/CollectionsBookmark';
// import DashboardIcon from '@mui/icons-material/Dashboard';
// import DateRange$1 from '@mui/icons-material/DateRange';
// import DehazeIcon from '@mui/icons-material/Dehaze';
// import EditIcon from '@mui/icons-material/Edit';
// import EmojiEventsIcon from '@mui/icons-material/EmojiEvents';
// import ExitToAppIcon from '@mui/icons-material/ExitToApp';
// import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
// import FiberManualRecordIcon from '@mui/icons-material/FiberManualRecord';
// import FormatListNumberedIcon from '@mui/icons-material/FormatListNumbered';
// import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
// import HomeIcon from '@mui/icons-material/Home';
// import InfoIcon from '@mui/icons-material/Info';
// import InsertLinkIcon from '@mui/icons-material/InsertLink';
// import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
// import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
// import ListIcon from '@mui/icons-material/List';
// import LockIcon from '@mui/icons-material/Lock';
// import MessageIcon from '@mui/icons-material/Message';
// import MoreVertIcon from '@mui/icons-material/MoreVert';
// import NavigateBeforeIcon from '@mui/icons-material/NavigateBefore';
// import NavigateNextIcon from '@mui/icons-material/NavigateNext';
// import NotificationsNoneOutlinedIcon from '@mui/icons-material/NotificationsNoneOutlined';
// import OpenWithIcon from '@mui/icons-material/OpenWith';
// import PeopleIcon from '@mui/icons-material/People';
// import PlaceIcon from '@mui/icons-material/Place';
// import PlaylistAddCheckIcon from '@mui/icons-material/PlaylistAddCheck';
// import ReceiptLongOutlinedIcon from '@mui/icons-material/ReceiptLongOutlined';
// import RefreshIcon from '@mui/icons-material/Refresh';
// import RepeatIcon from '@mui/icons-material/Repeat';
// import SaveIcon from '@mui/icons-material/SaveOutlined';
// import SendIcon from '@mui/icons-material/Send';
// import SearchIcon from '@mui/icons-material/Search';
// import SettingsIcon from '@mui/icons-material/Settings';
// import SettingsBackupRestoreIcon from '@mui/icons-material/SettingsBackupRestore';
// import ShoppingCartIcon from '@mui/icons-material/ShoppingCart';
// import ViewListIcon from '@mui/icons-material/ViewList';
// import WatchLaterIcon from '@mui/icons-material/WatchLater';
// import DragIndicatorIcon from '@mui/icons-material/DragIndicator';
// import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
// import ArrowUpwardIcon from '@mui/icons-material/ArrowUpward';
// import FilterListIcon from '@mui/icons-material/FilterList';
// import CheckIcon from '@mui/icons-material/Check';
// import DeleteIcon from '@mui/icons-material/Delete';
// import SignalCellular4BarIcon from '@mui/icons-material/SignalCellular4Bar';
// import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
// import PersonIcon from '@mui/icons-material/Person';
// import MoreHorizIcon from '@mui/icons-material/MoreHoriz';
// import SortIcon from '@mui/icons-material/Sort';
// import GTranslateIcon from '@mui/icons-material/GTranslate';
// import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';
// import ReportProblemOutlinedIcon from '@mui/icons-material/ReportProblemOutlined';
// import GetAppIcon from '@mui/icons-material/GetApp';
// import FileCopyIcon from '@mui/icons-material/FileCopy';
// import VisibilityIcon from '@mui/icons-material/Visibility';
// import VisibilityOffIcon from '@mui/icons-material/VisibilityOff';
// import PlayArrowIcon from '@mui/icons-material/PlayArrow';
// import FolderIcon from '@mui/icons-material/Folder';
// import FolderOpenIcon from '@mui/icons-material/FolderOpen';
// import EmailIcon from '@mui/icons-material/Email';
// import PhoneIcon from '@mui/icons-material/Phone';
// import LocationOnIcon from '@mui/icons-material/LocationOn';
// import PrintIcon from '@mui/icons-material/Print';
// import DatasetOutlinedIcon from '@mui/icons-material/DatasetOutlined';
// import DatasetLinkedOutlinedIcon from '@mui/icons-material/DatasetLinkedOutlined';
// import NoteAddOutlinedIcon from '@mui/icons-material/NoteAddOutlined';
// import DescriptionOutlinedIcon from '@mui/icons-material/DescriptionOutlined';
// import DashboardCustomizeOutlinedIcon from '@mui/icons-material/DashboardCustomizeOutlined';
// import DownloadDoneOutlinedIcon from '@mui/icons-material/DownloadDoneOutlined';
// import UpdateOutlinedIcon from '@mui/icons-material/UpdateOutlined';
// import ThreePIcon from '@mui/icons-material/ThreeP';
// import SavedFiltersIcon from '@mui/icons-material/Tune';
// import styled, { css, keyframes } from 'styled-components';
// import MuiCollapse from '@mui/material/Collapse';
// import MuiAvatar from '@mui/material/Avatar';
// import MuiBackdrop from '@mui/material/Backdrop';
// import MuiBadge from '@mui/material/Badge';
// import MuiTable from '@mui/material/Table';
// import MuiTableBody from '@mui/material/TableBody';
// import MuiTableCell from '@mui/material/TableCell';
// import MuiTableContainer from '@mui/material/TableContainer';
// import MuiTableHead from '@mui/material/TableHead';
// import MuiTableRow from '@mui/material/TableRow';
// import Button$2 from '@mui/material/Button';
// import MuiCard from '@mui/material/Card';
// import MuiCardActionArea from '@mui/material/CardActionArea';
// import ClickAwayListener from '@mui/material/ClickAwayListener';
// import { TextField as TextField$1, generateUtilityClass as generateUtilityClass$1, generateUtilityClasses as generateUtilityClasses$1, unstable_composeClasses, useControlled as useControlled$1, useEventCallback as useEventCallback$1, alpha as alpha$2, FormLabel as FormLabel$1, Pagination as Pagination$2, TablePagination as TablePagination$1, switchClasses, inputBaseClasses, formHelperTextClasses, formLabelClasses, darken as darken$2, stepConnectorClasses, stepLabelClasses, stepIconClasses } from '@mui/material';
// import { zoomLevel } from 'zoom-level';
// import { DraggableCore } from 'react-draggable';
// import TextField$2 from '@mui/material/TextField';
// import longFormatters$1 from 'date-fns/_lib/format/longFormatters';
// import { useThemeProps, styled as styled$1, alpha as alpha$1, useTheme as useTheme$2, darken as darken$1, lighten as lighten$1, createTheme as createTheme$1 } from '@mui/material/styles';
// import { jsx, jsxs } from 'react/jsx-runtime';
// import Typography from '@mui/material/Typography';
// import Grid from '@mui/material/Grid';
// import IconButton$1 from '@mui/material/IconButton';
// import { unstable_useEnhancedEffect, useForkRef as useForkRef$1, useControlled as useControlled$2, createSvgIcon, capitalize as capitalize$1, unstable_useId, useEventCallback as useEventCallback$2, ownerDocument as ownerDocument$1 } from '@mui/material/utils';
// import Grow$1 from '@mui/material/Grow';
// import Paper$1 from '@mui/material/Paper';
// import Popper$1 from '@mui/material/Popper';
// import TrapFocus from '@mui/material/Unstable_TrapFocus';
// import DialogActions$1 from '@mui/material/DialogActions';
// import InputAdornment$1 from '@mui/material/InputAdornment';
// import { ThemeContext } from '@mui/styled-engine';
// import Fade from '@mui/material/Fade';
// import ButtonBase from '@mui/material/ButtonBase';
// import ReactDOM from 'react-dom';
// import Tab$1 from '@mui/material/Tab';
// import Tabs$1, { tabsClasses } from '@mui/material/Tabs';
// import MuiDivider from '@mui/material/Divider';
// import MuiDrawer from '@mui/material/Drawer';
// import moment from 'moment-timezone';
// import MuiImageList from '@mui/material/ImageList';
// import Highlighter$1 from 'react-highlight-words';
// import MuiLabel from '@mui/material/FormControlLabel';
// import MuiMenuList from '@mui/material/MenuList';
// import MuiLink from '@mui/material/Link';
// import MuiList from '@mui/material/List';
// import MuiListItem from '@mui/material/ListItem';
// import CircularProgress from '@mui/material/CircularProgress';
// import MuiMenuItem from '@mui/material/MenuItem';
// import DialogContent$1 from '@mui/material/DialogContent';
// import LinearProgress from '@mui/material/LinearProgress';
// import MuiRadio from '@mui/material/Radio';
// import Chip from '@mui/material/Chip';
// import MuiStep from '@mui/material/Step';
// import MuiStepLabel from '@mui/material/StepLabel';
// import Steppers from '@mui/material/Stepper';
// import humanizeDuration from 'humanize-duration';
// import MuiTooltip from '@mui/material/Tooltip';
// import unsupportedProp from '@mui/utils/unsupportedProp';
// import elementTypeAcceptingRef from '@mui/utils/elementTypeAcceptingRef';
// import MuiCheckbox from '@mui/material/Checkbox';
// import MuiPopover from '@mui/material/Popover';
// import IcomoonReact from 'icomoon-react';
// import MuiMenu from '@mui/material/Menu';
// import MuiListItemIcon from '@mui/material/ListItemIcon';
// import MuiListItemText from '@mui/material/ListItemText';
// import MuiAutoComplete from '@mui/material/Autocomplete';
// import Box from '@mui/material/Box';
// import MuiCardContent from '@mui/material/CardContent';
// import cx$1 from 'classnames';
// import Switch from '@mui/material/Switch';
// import MuiSnackbar from '@mui/material/Snackbar';
// import MuiFab from '@mui/material/Fab';
// import MuiFormControl from '@mui/material/FormControl';
// import { GridStack } from 'gridstack';
// import 'gridstack/dist/gridstack.css';
// import isNil$1 from 'lodash/isNil';
// import isFunction from 'lodash/isFunction';
// import range$1 from 'lodash/range';
// import get from 'lodash/get';
// import sortBy from 'lodash/sortBy';
// import throttle$1 from 'lodash/throttle';
// import find from 'lodash/find';
// import every from 'lodash/every';
// import isString from 'lodash/isString';
// import isNan from 'lodash/isNaN';
// import lodashIsNumber from 'lodash/isNumber';
// import mapValues from 'lodash/mapValues';
// import * as d3Scales from 'victory-vendor/d3-scale';
// import { scalePoint } from 'victory-vendor/d3-scale';
// import { symbolCircle, symbol, symbolCross, symbolDiamond, symbolSquare, symbolStar, symbolTriangle, symbolWye, stack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, area, line, curveLinear, curveBasisClosed, curveBasisOpen, curveBasis, curveBumpX, curveBumpY, curveLinearClosed, curveMonotoneX, curveMonotoneY, curveNatural, curveStep, curveStepAfter, curveStepBefore } from 'victory-vendor/d3-shape';
// import max from 'lodash/max';
// import min from 'lodash/min';
// import flatMap from 'lodash/flatMap';
// import upperFirst from 'lodash/upperFirst';
// import isEqual$1 from 'lodash/isEqual';
// import isObject from 'lodash/isObject';
// import { isFragment } from 'react-is';
// import uniqBy from 'lodash/uniqBy';
// import 'react-transition-group';
// import last from 'lodash/last';
// import isPlainObject$1 from 'lodash/isPlainObject';
// import isBoolean from 'lodash/isBoolean';
// import some from 'lodash/some';
// import EventEmitter from 'eventemitter3';
// import MuiDialogTitle from '@mui/material/DialogTitle';
// import Dialog from '@mui/material/Dialog';
// import MuiInputLabel from '@mui/material/InputLabel';
// import MuiSelect from '@mui/material/Select';
// import MuiBreadcrumbs from '@mui/material/Breadcrumbs';
// import MuiRadioGroup from '@mui/material/RadioGroup';
// import MuiSlider from '@mui/material/Slider';
// import MuiToolBar from '@mui/material/Toolbar';
// import MuiAppBar from '@mui/material/AppBar';
// import eachDeep from 'deepdash/eachDeep';
// import { useTable, useFilters, useSortBy, usePagination, useRowSelect, useRowState } from 'react-table';
// import 'fontsource-open-sans';
// import cloneObject from 'date-fns/_lib/cloneObject/index.js';
// import toInteger$1 from 'date-fns/_lib/toInteger/index.js';
// import getTimezoneOffsetInMilliseconds$1 from 'date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js';

// function Accordion(_ref) {
//   var children = _ref.children,
//     defaultExpanded = _ref.defaultExpanded,
//     disabled = _ref.disabled,
//     disableGutters = _ref.disableGutters,
//     onChange = _ref.onChange,
//     square = _ref.square,
//     className = _ref.className,
//     elevation = _ref.elevation,
//     expanded = _ref.expanded;
//   return /*#__PURE__*/React__default.createElement(MuiAccordion, {
//     defaultExpanded: defaultExpanded,
//     disabled: disabled,
//     disableGutters: disableGutters,
//     onChange: onChange,
//     square: square,
//     className: className,
//     elevation: elevation,
//     expanded: expanded
//   }, children);
// }

// // PropType check
// Accordion.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * If true, expands the accordion by default.
//    */
//   defaultExpanded: PropTypes__default.bool,
//   /**
//    * If true, the component is disabled.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * If true, it removes the margin between two expanded accordion items and the increase of height.
//    */
//   disableGutters: PropTypes__default.bool,
//   /**
//    * Callback fired when the expand/collapse state is changed.
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * If true, rounded corners are disabled.
//    */
//   square: PropTypes__default.bool,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Elevation of the compoent.
//    */
//   elevation: PropTypes__default.number,
//   /**
//    * If true, expands the accordion, otherwise collapse it. Setting this prop enables control over the accordion.
//    */
//   expanded: PropTypes__default.bool
// };
// Accordion.defaultProps = {
//   defaultExpanded: false,
//   disabled: false,
//   disableGutters: false,
//   onChange: undefined,
//   square: false,
//   className: undefined,
//   elevation: 0,
//   expanded: undefined
// };

// function AccordionDetails(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiAccordionDetails, {
//     className: className
//   }, children);
// }

// // PropType check
// AccordionDetails.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string
// };
// AccordionDetails.defaultProps = {
//   children: undefined,
//   className: undefined
// };

// function AccordionSummary(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     expandIcon = _ref.expandIcon;
//   return /*#__PURE__*/React__default.createElement(MuiAccordionSummary, {
//     className: className,
//     expandIcon: expandIcon
//   }, children);
// }

// // PropType check
// AccordionSummary.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * The icon to display as the expand indicator.
//    */
//   expandIcon: PropTypes__default.node
// };
// AccordionSummary.defaultProps = {
//   children: undefined,
//   className: undefined,
//   expandIcon: undefined
// };

// function _iterableToArrayLimit$b(r, l) {
//   var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
//   if (null != t) {
//     var e,
//       n,
//       i,
//       u,
//       a = [],
//       f = !0,
//       o = !1;
//     try {
//       if (i = (t = t.call(r)).next, 0 === l) {
//         if (Object(t) !== t) return;
//         f = !1;
//       } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
//     } catch (r) {
//       o = !0, n = r;
//     } finally {
//       try {
//         if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
//       } finally {
//         if (o) throw n;
//       }
//     }
//     return a;
//   }
// }
// function ownKeys$z(e, r) {
//   var t = Object.keys(e);
//   if (Object.getOwnPropertySymbols) {
//     var o = Object.getOwnPropertySymbols(e);
//     r && (o = o.filter(function (r) {
//       return Object.getOwnPropertyDescriptor(e, r).enumerable;
//     })), t.push.apply(t, o);
//   }
//   return t;
// }
// function _objectSpread2$1(e) {
//   for (var r = 1; r < arguments.length; r++) {
//     var t = null != arguments[r] ? arguments[r] : {};
//     r % 2 ? ownKeys$z(Object(t), !0).forEach(function (r) {
//       _defineProperty$C(e, r, t[r]);
//     }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$z(Object(t)).forEach(function (r) {
//       Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
//     });
//   }
//   return e;
// }
// function _regeneratorRuntime() {
//   _regeneratorRuntime = function () {
//     return e;
//   };
//   var t,
//     e = {},
//     r = Object.prototype,
//     n = r.hasOwnProperty,
//     o = Object.defineProperty || function (t, e, r) {
//       t[e] = r.value;
//     },
//     i = "function" == typeof Symbol ? Symbol : {},
//     a = i.iterator || "@@iterator",
//     c = i.asyncIterator || "@@asyncIterator",
//     u = i.toStringTag || "@@toStringTag";
//   function define(t, e, r) {
//     return Object.defineProperty(t, e, {
//       value: r,
//       enumerable: !0,
//       configurable: !0,
//       writable: !0
//     }), t[e];
//   }
//   try {
//     define({}, "");
//   } catch (t) {
//     define = function (t, e, r) {
//       return t[e] = r;
//     };
//   }
//   function wrap(t, e, r, n) {
//     var i = e && e.prototype instanceof Generator ? e : Generator,
//       a = Object.create(i.prototype),
//       c = new Context(n || []);
//     return o(a, "_invoke", {
//       value: makeInvokeMethod(t, r, c)
//     }), a;
//   }
//   function tryCatch(t, e, r) {
//     try {
//       return {
//         type: "normal",
//         arg: t.call(e, r)
//       };
//     } catch (t) {
//       return {
//         type: "throw",
//         arg: t
//       };
//     }
//   }
//   e.wrap = wrap;
//   var h = "suspendedStart",
//     l = "suspendedYield",
//     f = "executing",
//     s = "completed",
//     y = {};
//   function Generator() {}
//   function GeneratorFunction() {}
//   function GeneratorFunctionPrototype() {}
//   var p = {};
//   define(p, a, function () {
//     return this;
//   });
//   var d = Object.getPrototypeOf,
//     v = d && d(d(values([])));
//   v && v !== r && n.call(v, a) && (p = v);
//   var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
//   function defineIteratorMethods(t) {
//     ["next", "throw", "return"].forEach(function (e) {
//       define(t, e, function (t) {
//         return this._invoke(e, t);
//       });
//     });
//   }
//   function AsyncIterator(t, e) {
//     function invoke(r, o, i, a) {
//       var c = tryCatch(t[r], t, o);
//       if ("throw" !== c.type) {
//         var u = c.arg,
//           h = u.value;
//         return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
//           invoke("next", t, i, a);
//         }, function (t) {
//           invoke("throw", t, i, a);
//         }) : e.resolve(h).then(function (t) {
//           u.value = t, i(u);
//         }, function (t) {
//           return invoke("throw", t, i, a);
//         });
//       }
//       a(c.arg);
//     }
//     var r;
//     o(this, "_invoke", {
//       value: function (t, n) {
//         function callInvokeWithMethodAndArg() {
//           return new e(function (e, r) {
//             invoke(t, n, e, r);
//           });
//         }
//         return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
//       }
//     });
//   }
//   function makeInvokeMethod(e, r, n) {
//     var o = h;
//     return function (i, a) {
//       if (o === f) throw new Error("Generator is already running");
//       if (o === s) {
//         if ("throw" === i) throw a;
//         return {
//           value: t,
//           done: !0
//         };
//       }
//       for (n.method = i, n.arg = a;;) {
//         var c = n.delegate;
//         if (c) {
//           var u = maybeInvokeDelegate(c, n);
//           if (u) {
//             if (u === y) continue;
//             return u;
//           }
//         }
//         if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
//           if (o === h) throw o = s, n.arg;
//           n.dispatchException(n.arg);
//         } else "return" === n.method && n.abrupt("return", n.arg);
//         o = f;
//         var p = tryCatch(e, r, n);
//         if ("normal" === p.type) {
//           if (o = n.done ? s : l, p.arg === y) continue;
//           return {
//             value: p.arg,
//             done: n.done
//           };
//         }
//         "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
//       }
//     };
//   }
//   function maybeInvokeDelegate(e, r) {
//     var n = r.method,
//       o = e.iterator[n];
//     if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
//     var i = tryCatch(o, e.iterator, r.arg);
//     if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
//     var a = i.arg;
//     return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
//   }
//   function pushTryEntry(t) {
//     var e = {
//       tryLoc: t[0]
//     };
//     1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
//   }
//   function resetTryEntry(t) {
//     var e = t.completion || {};
//     e.type = "normal", delete e.arg, t.completion = e;
//   }
//   function Context(t) {
//     this.tryEntries = [{
//       tryLoc: "root"
//     }], t.forEach(pushTryEntry, this), this.reset(!0);
//   }
//   function values(e) {
//     if (e || "" === e) {
//       var r = e[a];
//       if (r) return r.call(e);
//       if ("function" == typeof e.next) return e;
//       if (!isNaN(e.length)) {
//         var o = -1,
//           i = function next() {
//             for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
//             return next.value = t, next.done = !0, next;
//           };
//         return i.next = i;
//       }
//     }
//     throw new TypeError(typeof e + " is not iterable");
//   }
//   return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
//     value: GeneratorFunctionPrototype,
//     configurable: !0
//   }), o(GeneratorFunctionPrototype, "constructor", {
//     value: GeneratorFunction,
//     configurable: !0
//   }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
//     var e = "function" == typeof t && t.constructor;
//     return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
//   }, e.mark = function (t) {
//     return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
//   }, e.awrap = function (t) {
//     return {
//       __await: t
//     };
//   }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
//     return this;
//   }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
//     void 0 === i && (i = Promise);
//     var a = new AsyncIterator(wrap(t, r, n, o), i);
//     return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
//       return t.done ? t.value : a.next();
//     });
//   }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
//     return this;
//   }), define(g, "toString", function () {
//     return "[object Generator]";
//   }), e.keys = function (t) {
//     var e = Object(t),
//       r = [];
//     for (var n in e) r.push(n);
//     return r.reverse(), function next() {
//       for (; r.length;) {
//         var t = r.pop();
//         if (t in e) return next.value = t, next.done = !1, next;
//       }
//       return next.done = !0, next;
//     };
//   }, e.values = values, Context.prototype = {
//     constructor: Context,
//     reset: function (e) {
//       if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
//     },
//     stop: function () {
//       this.done = !0;
//       var t = this.tryEntries[0].completion;
//       if ("throw" === t.type) throw t.arg;
//       return this.rval;
//     },
//     dispatchException: function (e) {
//       if (this.done) throw e;
//       var r = this;
//       function handle(n, o) {
//         return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
//       }
//       for (var o = this.tryEntries.length - 1; o >= 0; --o) {
//         var i = this.tryEntries[o],
//           a = i.completion;
//         if ("root" === i.tryLoc) return handle("end");
//         if (i.tryLoc <= this.prev) {
//           var c = n.call(i, "catchLoc"),
//             u = n.call(i, "finallyLoc");
//           if (c && u) {
//             if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
//             if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
//           } else if (c) {
//             if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
//           } else {
//             if (!u) throw new Error("try statement without catch or finally");
//             if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
//           }
//         }
//       }
//     },
//     abrupt: function (t, e) {
//       for (var r = this.tryEntries.length - 1; r >= 0; --r) {
//         var o = this.tryEntries[r];
//         if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
//           var i = o;
//           break;
//         }
//       }
//       i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
//       var a = i ? i.completion : {};
//       return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
//     },
//     complete: function (t, e) {
//       if ("throw" === t.type) throw t.arg;
//       return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
//     },
//     finish: function (t) {
//       for (var e = this.tryEntries.length - 1; e >= 0; --e) {
//         var r = this.tryEntries[e];
//         if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
//       }
//     },
//     catch: function (t) {
//       for (var e = this.tryEntries.length - 1; e >= 0; --e) {
//         var r = this.tryEntries[e];
//         if (r.tryLoc === t) {
//           var n = r.completion;
//           if ("throw" === n.type) {
//             var o = n.arg;
//             resetTryEntry(r);
//           }
//           return o;
//         }
//       }
//       throw new Error("illegal catch attempt");
//     },
//     delegateYield: function (e, r, n) {
//       return this.delegate = {
//         iterator: values(e),
//         resultName: r,
//         nextLoc: n
//       }, "next" === this.method && (this.arg = t), y;
//     }
//   }, e;
// }
// function _toPrimitive$B(t, r) {
//   if ("object" != typeof t || !t) return t;
//   var e = t[Symbol.toPrimitive];
//   if (void 0 !== e) {
//     var i = e.call(t, r || "default");
//     if ("object" != typeof i) return i;
//     throw new TypeError("@@toPrimitive must return a primitive value.");
//   }
//   return ("string" === r ? String : Number)(t);
// }
// function _toPropertyKey$B(t) {
//   var i = _toPrimitive$B(t, "string");
//   return "symbol" == typeof i ? i : String(i);
// }
// function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
//   try {
//     var info = gen[key](arg);
//     var value = info.value;
//   } catch (error) {
//     reject(error);
//     return;
//   }
//   if (info.done) {
//     resolve(value);
//   } else {
//     Promise.resolve(value).then(_next, _throw);
//   }
// }
// function _asyncToGenerator(fn) {
//   return function () {
//     var self = this,
//       args = arguments;
//     return new Promise(function (resolve, reject) {
//       var gen = fn.apply(self, args);
//       function _next(value) {
//         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
//       }
//       function _throw(err) {
//         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
//       }
//       _next(undefined);
//     });
//   };
// }
// function _defineProperty$C(obj, key, value) {
//   key = _toPropertyKey$B(key);
//   if (key in obj) {
//     Object.defineProperty(obj, key, {
//       value: value,
//       enumerable: true,
//       configurable: true,
//       writable: true
//     });
//   } else {
//     obj[key] = value;
//   }
//   return obj;
// }
// function _extends$v() {
//   _extends$v = Object.assign ? Object.assign.bind() : function (target) {
//     for (var i = 1; i < arguments.length; i++) {
//       var source = arguments[i];
//       for (var key in source) {
//         if (Object.prototype.hasOwnProperty.call(source, key)) {
//           target[key] = source[key];
//         }
//       }
//     }
//     return target;
//   };
//   return _extends$v.apply(this, arguments);
// }
// function _objectWithoutPropertiesLoose$l(source, excluded) {
//   if (source == null) return {};
//   var target = {};
//   var sourceKeys = Object.keys(source);
//   var key, i;
//   for (i = 0; i < sourceKeys.length; i++) {
//     key = sourceKeys[i];
//     if (excluded.indexOf(key) >= 0) continue;
//     target[key] = source[key];
//   }
//   return target;
// }
// function _objectWithoutProperties$j(source, excluded) {
//   if (source == null) return {};
//   var target = _objectWithoutPropertiesLoose$l(source, excluded);
//   var key, i;
//   if (Object.getOwnPropertySymbols) {
//     var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
//     for (i = 0; i < sourceSymbolKeys.length; i++) {
//       key = sourceSymbolKeys[i];
//       if (excluded.indexOf(key) >= 0) continue;
//       if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
//       target[key] = source[key];
//     }
//   }
//   return target;
// }
// function _taggedTemplateLiteral$1(strings, raw) {
//   if (!raw) {
//     raw = strings.slice(0);
//   }
//   return Object.freeze(Object.defineProperties(strings, {
//     raw: {
//       value: Object.freeze(raw)
//     }
//   }));
// }
// function _slicedToArray$b(arr, i) {
//   return _arrayWithHoles$c(arr) || _iterableToArrayLimit$b(arr, i) || _unsupportedIterableToArray$m(arr, i) || _nonIterableRest$c();
// }
// function _toConsumableArray$d(arr) {
//   return _arrayWithoutHoles$d(arr) || _iterableToArray$e(arr) || _unsupportedIterableToArray$m(arr) || _nonIterableSpread$d();
// }
// function _arrayWithoutHoles$d(arr) {
//   if (Array.isArray(arr)) return _arrayLikeToArray$m(arr);
// }
// function _arrayWithHoles$c(arr) {
//   if (Array.isArray(arr)) return arr;
// }
// function _iterableToArray$e(iter) {
//   if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
// }
// function _unsupportedIterableToArray$m(o, minLen) {
//   if (!o) return;
//   if (typeof o === "string") return _arrayLikeToArray$m(o, minLen);
//   var n = Object.prototype.toString.call(o).slice(8, -1);
//   if (n === "Object" && o.constructor) n = o.constructor.name;
//   if (n === "Map" || n === "Set") return Array.from(o);
//   if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$m(o, minLen);
// }
// function _arrayLikeToArray$m(arr, len) {
//   if (len == null || len > arr.length) len = arr.length;
//   for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
//   return arr2;
// }
// function _nonIterableSpread$d() {
//   throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
// }
// function _nonIterableRest$c() {
//   throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
// }

// var _templateObject$1E;
// var StyledDiv$7 = styled.div(_templateObject$1E || (_templateObject$1E = _taggedTemplateLiteral$1(["\nfont-size: ", "rem;\ndisplay:inherit;\n"])), function (props) {
//   return props.size;
// });

// var icons$1 = {
//   Add: AddIcon,
//   AddCircle: AddCircleIcon,
//   AdhocView: NoteAddOutlinedIcon,
//   AlreadyImported: DownloadDoneOutlinedIcon,
//   ARDashboard: DashboardCustomizeOutlinedIcon,
//   ArrowDropDown: ArrowDropDownIcon,
//   ArrowForwardIos: ArrowForwardIosIcon,
//   ArrowUpwardRounded: ArrowUpwardIconRounded,
//   ArrowDownwardRounded: ArrowDownwardRoundedIcon,
//   AssignmentInd: AssignmentIndIcon,
//   BusinessCenterOutlined: BusinessCenterOutlinedIcon,
//   Cancel: CancelIcon,
//   Chat: ChatIcon,
//   CheckCircleOutline: CheckCircleOutlineIcon,
//   Close: CloseIcon,
//   CollectionsBookmark: CollectionsBookmarkIcon,
//   Dashboard: DashboardIcon,
//   DateRangeIcon: DateRange$1,
//   Dehaze: DehazeIcon,
//   Domain: DatasetOutlinedIcon,
//   Edit: EditIcon,
//   EmojiEvents: EmojiEventsIcon,
//   ExitToApp: ExitToAppIcon,
//   ExpandMore: ExpandMoreIcon,
//   FiberManualRecord: FiberManualRecordIcon,
//   FormatListNumbered: FormatListNumberedIcon,
//   HelpOutline: HelpOutlineIcon,
//   Home: HomeIcon,
//   Info: InfoIcon,
//   InsertLink: InsertLinkIcon,
//   KeyboardArrowDown: KeyboardArrowDownIcon,
//   KeyboardArrowUp: KeyboardArrowUpIcon,
//   List: ListIcon,
//   Lock: LockIcon,
//   Message: MessageIcon,
//   MoreVert: MoreVertIcon,
//   NavigateBefore: NavigateBeforeIcon,
//   NavigateNext: NavigateNextIcon,
//   NotificationsNoneOutlined: NotificationsNoneOutlinedIcon,
//   OpenWith: OpenWithIcon,
//   People: PeopleIcon,
//   Place: PlaceIcon,
//   PlaylistAddCheck: PlaylistAddCheckIcon,
//   ReceiptLongOutlined: ReceiptLongOutlinedIcon,
//   Repeat: RepeatIcon,
//   Refresh: RefreshIcon,
//   Save: SaveIcon,
//   Search: SearchIcon,
//   Send: SendIcon,
//   Settings: SettingsIcon,
//   SettingsBackupRestore: SettingsBackupRestoreIcon,
//   ShoppingCart: ShoppingCartIcon,
//   ViewList: ViewListIcon,
//   WatchLater: WatchLaterIcon,
//   DragIndicator: DragIndicatorIcon,
//   ArrowDownward: ArrowDownwardIcon,
//   ArrowUpward: ArrowUpwardIcon,
//   FilterIcon: FilterListIcon,
//   Check: CheckIcon,
//   Delete: DeleteIcon,
//   SignalCellular4Bar: SignalCellular4BarIcon,
//   InfoOutlined: InfoOutlinedIcon,
//   Person: PersonIcon,
//   MoreHoriz: MoreHorizIcon,
//   Sort: SortIcon,
//   GTranslate: GTranslateIcon,
//   ErrorOutlined: ErrorOutlineIcon,
//   ReportProblemOutlined: ReportProblemOutlinedIcon,
//   GetApp: GetAppIcon,
//   FileCopy: FileCopyIcon,
//   Visibility: VisibilityIcon,
//   VisibilityOff: VisibilityOffIcon,
//   PlayArrow: PlayArrowIcon,
//   FolderIcon: FolderIcon,
//   FolderOpenIcon: FolderOpenIcon,
//   Email: EmailIcon,
//   Phone: PhoneIcon,
//   LocationOn: LocationOnIcon,
//   Print: PrintIcon,
//   Report: DescriptionOutlinedIcon,
//   Topic: DatasetLinkedOutlinedIcon,
//   UpdateAvailable: UpdateOutlinedIcon,
//   ThreeP: ThreePIcon,
//   SavedFilters: SavedFiltersIcon
// };

// /**
//  * Component for render material icons.
//  * NOTE: Update this story when ever you add new MaterialIcon.
//  */

// function MaterialIcon(_ref) {
//   var iconName = _ref.iconName,
//     size = _ref.size,
//     className = _ref.className;
//   var Icon = icons$1[iconName];
//   return /*#__PURE__*/React__default.createElement(StyledDiv$7, {
//     size: size,
//     className: className
//   }, /*#__PURE__*/React__default.createElement(Icon, null));
// }

// // PropType check
// MaterialIcon.propTypes = {
//   /**
//    * Name of the icon
//    */
//   iconName: PropTypes__default.oneOf(Object.keys(icons$1)),
//   /**
//    * Size of the icon in rem
//    */
//   size: PropTypes__default.number,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// MaterialIcon.defaultProps = {
//   iconName: undefined,
//   size: 1.5,
//   className: undefined
// };

// /**
//  * This is the base atom component for alerts. Do not use this directly at page level.
//  */
// function BaseAlert(_ref) {
//   var severity = _ref.severity,
//     variant = _ref.variant,
//     onClose = _ref.onClose,
//     elevation = _ref.elevation,
//     children = _ref.children,
//     closeText = _ref.closeText,
//     showIcon = _ref.showIcon;
//   var customIconMapping = {
//     success: /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "CheckCircleOutline",
//       size: 1.25
//     })
//   };
//   return /*#__PURE__*/React__default.createElement(MuiAlert, {
//     icon: showIcon && customIconMapping[severity],
//     variant: variant,
//     severity: severity,
//     elevation: elevation,
//     closeText: closeText,
//     onClose: onClose
//   }, children);
// }

// // PropType check
// BaseAlert.propTypes = {
//   /**
//    * The severity of the alert.
//    */
//   severity: PropTypes__default.oneOf(['error', 'info', 'success', 'warning']),
//   /**
//    *The variant for the alert to use.
//    */

//   variant: PropTypes__default.oneOf(['filled', 'outlined', 'standard']),
//   /**
//    * Elevation for the alert.
//    */
//   elevation: PropTypes__default.number,
//   /**
//    * Override the default label for the close icon button
//    */
//   closeText: PropTypes__default.string,
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Show the Icon.
//    */
//   showIcon: PropTypes__default.bool
// };
// BaseAlert.defaultProps = {
//   severity: 'success',
//   variant: 'outlined',
//   elevation: 0,
//   closeText: undefined,
//   onClose: undefined,
//   children: undefined,
//   showIcon: true
// };

// function Collapse(_ref) {
//   var children = _ref.children,
//     expand = _ref.expand;
//   return /*#__PURE__*/React__default.createElement(MuiCollapse, {
//     "in": expand
//   }, children);
// }
// Collapse.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * expand or collapse the content
//    */
//   expand: PropTypes__default.bool
// };
// Collapse.defaultProps = {
//   children: undefined,
//   expand: true
// };

// /**
//  * Alert component is used to display important messages to the user.
//  * It can be closed using close icon.
//  * This component also support autohiding.
//  */
// function Alert(_ref) {
//   var severity = _ref.severity,
//     variant = _ref.variant,
//     onClose = _ref.onClose,
//     children = _ref.children,
//     open = _ref.open,
//     timeOut = _ref.timeOut,
//     closeText = _ref.closeText;
//   if (timeOut) {
//     // Hide the Alert based on timeout
//     window.setTimeout(function () {
//       onClose();
//     }, timeOut);
//   }
//   var closeLable;
//   if (!closeText) {
//     closeLable = "close ".concat(severity, " notification");
//   } else {
//     closeLable = closeText;
//   }
//   return /*#__PURE__*/React__default.createElement(Collapse, {
//     expand: open
//   }, /*#__PURE__*/React__default.createElement(BaseAlert, {
//     severity: severity,
//     variant: variant,
//     closeText: closeLable,
//     onClose: onClose
//   }, children));
// }

// // PropType check
// Alert.propTypes = {
//   /**
//    * The severity of the alert.
//    */
//   severity: PropTypes__default.oneOf(['error', 'info', 'success', 'warning']),
//   /**
//    *The variant to use.
//    */

//   variant: PropTypes__default.oneOf(['filled', 'outlined', 'standard']),
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Getter state varible for open/close the alert.
//    */

//   open: PropTypes__default.bool,
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * Timeout for alert to close.
//    */
//   timeOut: PropTypes__default.number,
//   /**
//    * Override the default label for the close icon button
//    */
//   closeText: PropTypes__default.string
// };
// Alert.defaultProps = {
//   severity: 'success',
//   variant: 'outlined',
//   children: undefined,
//   open: false,
//   onClose: undefined,
//   timeOut: undefined,
//   closeText: undefined
// };

// var _templateObject$1D;
// var StyledMuiAvatar = styled(MuiAvatar)(_templateObject$1D || (_templateObject$1D = _taggedTemplateLiteral$1(["\n      height:", "rem;\n      width:", "rem;\n"])), function (props) {
//   return props.height;
// }, function (props) {
//   return props.width;
// });

// /**
//  * The Avatar component is used to represent user, and displays the profile picture, initials or fallback icon.
//  */
// function Avatar(_ref) {
//   var height = _ref.height,
//     width = _ref.width,
//     variant = _ref.variant,
//     src = _ref.src,
//     alt = _ref.alt,
//     ariaLabel = _ref.ariaLabel,
//     className = _ref.className,
//     children = _ref.children;
//   return /*#__PURE__*/React__default.createElement(StyledMuiAvatar, {
//     height: height,
//     width: width,
//     variant: variant,
//     src: src,
//     alt: alt,
//     "aria-label": ariaLabel,
//     className: className
//   }, children);
// }

// // PropType check
// Avatar.propTypes = {
//   /**
//    * height of the image
//    */

//   height: PropTypes__default.number,
//   /**
//    * width of the image
//    */

//   width: PropTypes__default.number,
//   /**
//    * Base Avatar Variant
//    */
//   variant: PropTypes__default.oneOf(['circular', 'rounded', 'square']),
//   /**
//    * image url
//    */

//   src: PropTypes__default.string,
//   /**
//    * alternate text of profile image
//    */
//   alt: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for avatar
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node
// };
// Avatar.defaultProps = {
//   /**
//    * height of the image
//    */

//   height: 2,
//   /**
//    * width of the image
//    */

//   width: 2,
//   /**
//    * Base Avatar Variant
//    */
//   variant: 'circular',
//   /**
//    * Image url
//    */
//   src: '',
//   /**
//    * alternate text of profile image
//    */
//   alt: 'profile image',
//   /**
//    * aria label for of avatar
//    */
//   ariaLabel: null,
//   /**
//    * className property to support styled function.
//    */
//   className: '',
//   /**
//    * The content of the component.
//    */
//   children: undefined
// };

// /**
//  * Component to render Backdrop
//  */
// function Backdrop(_ref) {
//   var open = _ref.open,
//     invisible = _ref.invisible,
//     children = _ref.children,
//     onClick = _ref.onClick,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiBackdrop, {
//     open: open,
//     invisible: invisible,
//     className: className,
//     onClick: onClick
//   }, children);
// }
// Backdrop.propTypes = {
//   /**
//    * If true, the component is shown.
//    */
//   open: PropTypes__default.bool.isRequired,
//   /**
//    * If true, the backdrop is invisible. It can be used when rendering a popover or a custom select component.
//    */
//   invisible: PropTypes__default.bool,
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Override or extend the styles applied to the component.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node
// };
// Backdrop.defaultProps = {
//   invisible: false,
//   onClick: undefined,
//   children: undefined,
//   className: undefined
// };

// var _templateObject$1C;
// var StyledMuiBadge = styled(MuiBadge)(_templateObject$1C || (_templateObject$1C = _taggedTemplateLiteral$1(["\n  ", "\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return "\n& .MuiBadge-colorPrimary{\n  color: ".concat(theme.variables.leftNavParentColor, ";\n  background-color: ").concat(theme.variables.brandDanger, ";\n  border-color: ").concat(theme.variables.leftNavParentColor, ";\n  border: solid;\n  border-width: 1px;\n}\n  ");
// });

// /**
//  * Badges show notifications, counts, or status information on navigation items and icons.
//  */
// function Badge(_ref) {
//   var anchorOrigin = _ref.anchorOrigin,
//     badgeContent = _ref.badgeContent,
//     color = _ref.color,
//     overlap = _ref.overlap,
//     variant = _ref.variant,
//     children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledMuiBadge, {
//     anchorOrigin: anchorOrigin,
//     badgeContent: badgeContent,
//     color: color,
//     overlap: overlap,
//     variant: variant,
//     className: className
//   }, children);
// }
// Badge.propTypes = {
//   /**
//    * The anchor of the badge.
//    */
//   anchorOrigin: PropTypes__default.shape({
//     horizontal: PropTypes__default.oneOf(['left', 'right']).isRequired,
//     vertical: PropTypes__default.oneOf(['bottom', 'top']).isRequired
//   }),
//   /**
//    * color of the badge content
//    */
//   color: PropTypes__default.string,
//   /**
//    * content to be shown in badge
//    */
//   badgeContent: PropTypes__default.number,
//   /**
//    * children to which badge is attached
//    */
//   children: PropTypes__default.node,
//   /**
//    * overlap 'circular'/'rectangular'
//    */
//   overlap: PropTypes__default.string,
//   /**
//    * standard badge/dot badge
//    */
//   variant: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Badge.defaultProps = {
//   anchorOrigin: {
//     horizontal: 'left',
//     vertical: 'top'
//   },
//   color: 'primary',
//   badgeContent: 2,
//   children: null,
//   overlap: 'circular',
//   variant: 'standard',
//   className: undefined
// };

// /**
//  * A table displays sets of data. It can be fully customised. If a table contains static data use DataGrid to generate a basic table. If the table uses dynamic data, dynamic actions, or complex interactivity such as sorting, filtering or drag and drop use Datagrid to generate a Grid.
//  */
// function BasicTable(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiTable, {
//     className: className
//   }, children);
// }
// BasicTable.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string
// };
// BasicTable.defaultProps = {
//   className: ''
// };

// function BasicTableBody(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     innerRef = _ref.innerRef,
//     dropProviderProps = _ref.dropProviderProps;
//   return /*#__PURE__*/React__default.createElement(MuiTableBody, _extends$v({
//     className: className,
//     ref: innerRef
//   }, dropProviderProps.droppableProps), children);
// }
// BasicTableBody.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Props applied to the container component if used
//    */
//   dropProviderProps: PropTypes__default.shape({
//     droppableProps: PropTypes__default.shape({})
//   }),
//   /**
//    * Element ref
//    */
//   innerRef: PropTypes__default.func
// };
// BasicTableBody.defaultProps = {
//   children: undefined,
//   className: '',
//   innerRef: undefined,
//   dropProviderProps: {}
// };

// /**
//  * The component used to render a <th> or a <td> element.
//  */
// function BasicTableCell(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     align = _ref.align,
//     sortDirection = _ref.sortDirection,
//     component = _ref.component,
//     scope = _ref.scope,
//     role = _ref.role,
//     ariaLabel = _ref.ariaLabel,
//     id = _ref.id,
//     style = _ref.style,
//     ariaSort = _ref.ariaSort;
//   return /*#__PURE__*/React__default.createElement(MuiTableCell, {
//     className: className,
//     align: align,
//     sortDirection: sortDirection,
//     component: component,
//     scope: scope,
//     role: role,
//     "aria-label": ariaLabel,
//     id: id,
//     style: style,
//     "aria-sort": ariaSort
//   }, children);
// }
// BasicTableCell.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * TableCell align
//    */
//   align: PropTypes__default.oneOf(['center', 'inherit', 'justify', 'left', 'right']),
//   /**
//    * aria-sort direction
//    */
//   sortDirection: PropTypes__default.oneOf(['asc', 'desc', 'false']),
//   /**
//    * Type of cell
//    */
//   component: PropTypes__default.string,
//   /**
//    * scope of cell
//    */
//   scope: PropTypes__default.string,
//   /**
//    * Role of cell
//    */
//   role: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute.
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * Value of aria-sort attribute.
//    */
//   ariaSort: PropTypes__default.string,
//   /**
//    * Id of the cell
//    */
//   id: PropTypes__default.string,
//   /**
//    * styles of the cell
//    */
//   style: PropTypes__default.shape({})
// };
// BasicTableCell.defaultProps = {
//   children: undefined,
//   className: '',
//   align: 'inherit',
//   sortDirection: undefined,
//   component: '',
//   scope: undefined,
//   role: undefined,
//   ariaLabel: null,
//   id: undefined,
//   style: undefined,
//   ariaSort: null
// };

// function BasicTableContainer(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     component = _ref.component;
//   return /*#__PURE__*/React__default.createElement(MuiTableContainer, {
//     className: className,
//     component: component
//   }, children);
// }
// BasicTableContainer.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The component used for the root node. Either a string to use a HTML element or a component.
//    */
//   component: PropTypes__default.elementType
// };
// BasicTableContainer.defaultProps = {
//   children: undefined,
//   className: '',
//   component: 'div'
// };

// function BasicTableHead(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiTableHead, {
//     className: className
//   }, children);
// }
// BasicTableHead.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string
// };
// BasicTableHead.defaultProps = {
//   children: undefined,
//   className: ''
// };

// var _templateObject$1B;
// var StyledMuiTableRow = styled(MuiTableRow)(_templateObject$1B || (_templateObject$1B = _taggedTemplateLiteral$1(["\n  &.MuiTableRow-root {\n    &:nth-of-type(odd) {\n      background-color: ", ";\n    }\n  }\n"])), function (props) {
//   return props.striped ? props.theme.variables.tableBgAccent : 'none';
// });

// function BasicTableRow(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     hover = _ref.hover,
//     striped = _ref.striped,
//     innerRef = _ref.innerRef,
//     dragProviderProps = _ref.dragProviderProps,
//     role = _ref.role,
//     style = _ref.style,
//     tabIndex = _ref.tabIndex;
//   return /*#__PURE__*/React__default.createElement(StyledMuiTableRow, _extends$v({
//     className: className,
//     hover: hover,
//     striped: striped ? 1 : 0,
//     ref: innerRef
//   }, dragProviderProps.draggableProps, dragProviderProps.dragHandleProps, {
//     role: role,
//     style: style,
//     tabIndex: tabIndex
//   }), children);
// }
// BasicTableRow.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * If true, the table row will shade on hover..
//    */
//   hover: PropTypes__default.bool,
//   /**
//    * To enable striped rows.
//    */
//   striped: PropTypes__default.bool,
//   /**
//    * Props applied to the container component if used
//    */
//   dragProviderProps: PropTypes__default.shape({
//     draggableProps: PropTypes__default.shape({}),
//     dragHandleProps: PropTypes__default.shape({})
//   }),
//   /**
//    * Element ref
//    */
//   innerRef: PropTypes__default.func,
//   /**
//    * Role of the tr element
//    */
//   role: PropTypes__default.string,
//   /**
//    * styles of the tr element
//    */
//   style: PropTypes__default.shape({}),
//   /**
//    * To set tabindex
//    */
//   tabIndex: PropTypes__default.number
// };
// BasicTableRow.defaultProps = {
//   children: undefined,
//   className: '',
//   hover: false,
//   striped: false,
//   innerRef: undefined,
//   dragProviderProps: {},
//   role: undefined,
//   style: undefined,
//   tabIndex: undefined
// };

// var _templateObject$1A;
// var StyledText$1 = styled.p(_templateObject$1A || (_templateObject$1A = _taggedTemplateLiteral$1(["\nfont-size: 0.875rem;\nfont-weight: normal;\nline-height: 1.1rem;\n"])));

// /**
//  * BodyText component is used to display body text.
//  */

// function BodyText(_ref) {
//   var text = _ref.text,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledText$1, {
//     className: className
//   }, text);
// }

// // PropType check
// BodyText.propTypes = {
//   /**
//    * body text
//    */
//   text: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// BodyText.defaultProps = {
//   /**
//    * default text
//    */
//   text: '',
//   /**
//    * className property to support styled function.
//    */
//   className: ''
// };

// let globalId = 0;
// function useGlobalId(idOverride) {
//   const [defaultId, setDefaultId] = React.useState(idOverride);
//   const id = idOverride || defaultId;
//   React.useEffect(() => {
//     if (defaultId == null) {
//       // Fallback to this default id when possible.
//       // Use the incrementing value for client-side rendering only.
//       // We can't use it server-side.
//       // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem
//       globalId += 1;
//       setDefaultId(`mui-${globalId}`);
//     }
//   }, [defaultId]);
//   return id;
// }

// // downstream bundlers may remove unnecessary concatenation, but won't remove toString call -- Workaround for https://github.com/webpack/webpack/issues/14814
// const maybeReactUseId = React['useId'.toString()];
// /**
//  *
//  * @example <div id={useId()} />
//  * @param idOverride
//  * @returns {string}
//  */
// function useId$1(idOverride) {
//   if (maybeReactUseId !== undefined) {
//     const reactId = maybeReactUseId();
//     return idOverride != null ? idOverride : reactId;
//   }
//   // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.
//   return useGlobalId(idOverride);
// }

// /**
//  * A react hook to generate a random id, if id does not exist
//  * @param {String} id if the parameter is not valid, it generated a random id and assigns
//  * @returns {String} new/same id
//  */
// var useId = function useId(id) {
//   return useId$1(id);
// };

// /**
//  * SumTotal wrapper for Material-UI Button component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  * Refer to other Button components in Molecules section.
//  */
// function SumtButtonWrapper(_ref) {
//   var idProp = _ref.id,
//     onClick = _ref.onClick,
//     disableRipple = _ref.disableRipple,
//     disableElevation = _ref.disableElevation,
//     disabled = _ref.disabled,
//     color = _ref.color,
//     endIcon = _ref.endIcon,
//     startIcon = _ref.startIcon,
//     variant = _ref.variant,
//     size = _ref.size,
//     className = _ref.className,
//     children = _ref.children,
//     component = _ref.component,
//     path = _ref.path,
//     ariaLabel = _ref.ariaLabel,
//     ariaExpanded = _ref.ariaExpanded,
//     ariaHasPopUp = _ref.ariaHasPopUp,
//     onKeyDown = _ref.onKeyDown,
//     role = _ref.role,
//     disableFocusRipple = _ref.disableFocusRipple,
//     onMouseDown = _ref.onMouseDown,
//     tabIndex = _ref.tabIndex,
//     ariaLive = _ref.ariaLive,
//     ariaDescribedby = _ref.ariaDescribedby;
//   var id = useId(idProp);
//   var buttonRole;
//   if (role) {
//     buttonRole = role;
//   } else {
//     buttonRole = path ? 'link' : 'button';
//   }
//   return /*#__PURE__*/React__default.createElement(Button$2, {
//     id: id,
//     variant: variant,
//     disableRipple: disableRipple,
//     disableElevation: disableElevation,
//     disabled: disabled,
//     onClick: onClick,
//     endIcon: endIcon,
//     startIcon: startIcon,
//     className: className,
//     color: color,
//     size: size,
//     component: component,
//     to: path,
//     onKeyDown: onKeyDown,
//     onMouseDown: onMouseDown,
//     role: buttonRole,
//     "aria-label": ariaLabel,
//     "aria-expanded": ariaExpanded,
//     "aria-haspopup": ariaHasPopUp,
//     "aria-live": ariaLive,
//     disableFocusRipple: disableFocusRipple,
//     tabIndex: tabIndex,
//     "aria-describedby": ariaDescribedby
//   }, children);
// }
// SumtButtonWrapper.propTypes = {
//   /**
//    * Id of the button
//    */
//   id: PropTypes__default.string,
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * If true, the ripple effect will be disabled
//    */
//   disableRipple: PropTypes__default.bool,
//   /**
//    * If true, no elevation is used
//    */
//   disableElevation: PropTypes__default.bool,
//   /**
//    * Disabled state of the button
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Base Button Variant
//    */
//   variant: PropTypes__default.oneOf(['text', 'contained', 'outlined']),
//   /**
//    * Size of th button
//    */
//   size: PropTypes__default.oneOf(['large', 'medium', 'small']),
//   /**
//    * color
//    */
//   color: PropTypes__default.oneOf(['default', 'primary', 'inherit']),
//   /**
//    * End icon node
//    */
//   endIcon: PropTypes__default.node,
//   /**
//    * Start icon node
//    */
//   startIcon: PropTypes__default.node,
//   /**
//    * Text of the button
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class Name
//    */
//   className: PropTypes__default.string,
//   /**
//    * The component used for the root node.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * path to navigate, only applicable when component is `Link`
//    */
//   path: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * Value of aria-expanded attribute to be used for button
//    */
//   ariaExpanded: PropTypes__default.bool,
//   /**
//    * Value of aria-haspopup attribute to be used for button
//    */
//   ariaHasPopUp: PropTypes__default.bool,
//   /**
//    * On onKeyDown handler
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * Role for button
//    */
//   role: PropTypes__default.string,
//   /**
//    * If true, the focus ripple effect will be disabled
//    */
//   disableFocusRipple: PropTypes__default.bool,
//   /**
//    * On onMouseDown handler
//    */
//   onMouseDown: PropTypes__default.func,
//   /**
//    * tab index for button
//    */
//   tabIndex: PropTypes__default.number,
//   /**
//    * Value of aria-live attribute to be used for button
//    */
//   ariaLive: PropTypes__default.string,
//   /**
//    * Value of aria-describedby attribute to be used for button
//    */
//   ariaDescribedby: PropTypes__default.string
// };
// SumtButtonWrapper.defaultProps = {
//   id: undefined,
//   variant: 'outlined',
//   color: 'inherit',
//   size: 'medium',
//   disableElevation: true,
//   disableRipple: false,
//   disabled: false,
//   endIcon: undefined,
//   startIcon: undefined,
//   className: undefined,
//   onClick: undefined,
//   component: 'button',
//   path: undefined,
//   ariaLabel: undefined,
//   ariaExpanded: undefined,
//   ariaHasPopUp: undefined,
//   onKeyDown: undefined,
//   role: undefined,
//   disableFocusRipple: false,
//   onMouseDown: undefined,
//   tabIndex: 0,
//   ariaLive: undefined,
//   ariaDescribedby: undefined
// };

// /**
//  * Button component is used to trigger an action or event, such as
//  * - Submitting a form
//  * - Opening a dialog
//  * - Canceling an action
//  */
// function Button$1(_ref) {
//   var id = _ref.id,
//     className = _ref.className,
//     onClick = _ref.onClick,
//     disabled = _ref.disabled,
//     variant = _ref.variant,
//     size = _ref.size,
//     children = _ref.children,
//     startIcon = _ref.startIcon,
//     endIcon = _ref.endIcon,
//     disableFocusRipple = _ref.disableFocusRipple,
//     ariaLive = _ref.ariaLive,
//     ariaDescribedby = _ref.ariaDescribedby;
//   var muiVariant = 'outlined';
//   var muiColor = 'primary';
//   if (variant === 'primary') {
//     muiVariant = 'contained';
//   } else if (variant === 'text') {
//     muiVariant = 'text';
//   } else {
//     muiVariant = 'outlined';
//   }
//   return /*#__PURE__*/React__default.createElement(SumtButtonWrapper, {
//     id: id,
//     disabled: disabled,
//     onClick: onClick,
//     className: className,
//     color: muiColor,
//     variant: muiVariant,
//     size: size,
//     startIcon: startIcon,
//     endIcon: endIcon,
//     disableFocusRipple: disableFocusRipple,
//     ariaLive: ariaLive,
//     ariaDescribedby: ariaDescribedby
//   }, children);
// }
// Button$1.propTypes = {
//   /**
//    * Id of the button
//    */
//   id: PropTypes__default.string,
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Disabled state of the button
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Button variant
//    */
//   variant: PropTypes__default.oneOf(['primary', 'secondary', 'text']),
//   /**
//    * Size of button
//    */
//   size: PropTypes__default.oneOf(['large', 'medium', 'small']),
//   /**
//    * Text on the button
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class Name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Start icon node
//    */
//   startIcon: PropTypes__default.node,
//   /**
//    * End icon node
//    */
//   endIcon: PropTypes__default.node,
//   /**
//    * If true, the focus ripple effect will be disabled
//    */
//   disableFocusRipple: PropTypes__default.bool,
//   /**
//    * Value of aria-live attribute to be used for button
//    */
//   ariaLive: PropTypes__default.string,
//   /**
//    * Value of aria-describedby attribute to be used for button
//    */
//   ariaDescribedby: PropTypes__default.string
// };
// Button$1.defaultProps = {
//   id: undefined,
//   variant: 'secondary',
//   size: 'medium',
//   disabled: false,
//   className: undefined,
//   onClick: undefined,
//   startIcon: undefined,
//   endIcon: undefined,
//   disableFocusRipple: false,
//   ariaLive: undefined,
//   ariaDescribedby: undefined
// };

// var _templateObject$1z;
// var StyledMuiCard = styled(MuiCard)(_templateObject$1z || (_templateObject$1z = _taggedTemplateLiteral$1(["\n  width: ", ";\n  height: ", ";\n"])), function (props) {
//   return props.width;
// }, function (props) {
//   return props.height;
// });

// /**
//  * Card is a flexible component used to group and display content in a clear and concise format.
//  */
// function Card(_ref) {
//   var id = _ref.id,
//     variant = _ref.variant,
//     height = _ref.height,
//     width = _ref.width,
//     children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledMuiCard, {
//     id: id,
//     variant: variant,
//     height: height,
//     width: width,
//     className: className
//   }, children);
// }
// // PropType check
// Card.propTypes = {
//   /**
//    * Card id
//    */
//   id: PropTypes__default.string,
//   /**
//    * Card variant
//    */
//   variant: PropTypes__default.string,
//   /**
//    * Card height
//    */
//   height: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * Card width
//    */
//   width: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * Card className
//    */
//   className: PropTypes__default.string,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node
// };
// Card.defaultProps = {
//   id: 'Card',
//   variant: 'elevation',
//   height: '9.25rem',
//   width: '26rem',
//   children: undefined,
//   className: null
// };

// function CardActionArea(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     onClick = _ref.onClick;
//   return /*#__PURE__*/React__default.createElement(MuiCardActionArea, {
//     className: className,
//     onClick: onClick
//   }, children);
// }
// // PropType check
// CardActionArea.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * On click for the card
//    */
//   onClick: PropTypes__default.func
// };
// CardActionArea.defaultProps = {
//   children: undefined,
//   className: undefined,
//   onClick: undefined
// };

// /**
//  *
//  * @returns {Promise<Boolean>}
//  */
// var requiresPadding = function requiresPadding(src, availableWidth, availableHeight) {
//   return new Promise(function (resolve, reject) {
//     // So Resize them propotionately and check what matches 1st and add padding if hight matches .
//     var image = new Image();
//     image.src = src;
//     // For cached Images on load will not trigger.
//     if (image.width && image.height) {
//       resolve(evaluatePaddingRequirement(image, availableWidth, availableHeight));
//       return;
//     }
//     image.onload = function () {
//       resolve(evaluatePaddingRequirement(image, availableWidth, availableHeight));
//     };
//     image.onerror = function () {
//       reject();
//     };
//   });
// };
// var evaluatePaddingRequirement = function evaluatePaddingRequirement(image, availableWidth, availableHeight) {
//   var width = image.width,
//     height = image.height;
//   // logic for landscape image fix the avilable width
//   var resizedHeight = height * (availableWidth / width);
//   var resizedWidth = availableWidth;

//   // if the image is portrait then lock the avilable hight .
//   if (resizedHeight > availableHeight) {
//     resizedWidth = width * (availableHeight / height);
//     resizedHeight = availableHeight;
//   }
//   if (resizedHeight >= availableHeight && resizedWidth < availableWidth - 1) {
//     return true;
//   }
//   return false;
// };

// var _templateObject$1y, _templateObject2$T;
// var ImageGradientContainer = styled.div(_templateObject$1y || (_templateObject$1y = _taggedTemplateLiteral$1(["\n  display: table;\n  width: ", "px;\n  height: ", "px;\n  background: linear-gradient(120deg, silver, #e7e7e7, #fff, #f0f0f0, #dcdcdc);\n  img {\n    max-width: ", "px;\n    max-height: ", "px;\n    min-height: 1.25rem;\n  }\n"])), function (_ref) {
//   var width = _ref.width;
//   return width;
// }, function (_ref2) {
//   var height = _ref2.height;
//   return height;
// }, function (_ref3) {
//   var width = _ref3.width;
//   return width;
// }, function (_ref4) {
//   var height = _ref4.height;
//   return height;
// });
// var ImageWrapper = styled.div(_templateObject2$T || (_templateObject2$T = _taggedTemplateLiteral$1(["\n  text-align: center;\n  vertical-align: middle;\n  display: table-cell;\n  img {\n    margin: 0;\n    display: inline-block;\n    vertical-align: middle;\n    .image-padding & {\n      padding: 0.625rem 0;\n    }\n  }\n"])));

// /**
//  * Component for activity cards, preview and similar functionality for 16x9 cards
//  */
// function CardImage(_ref) {
//   var src = _ref.src,
//     defaultImage = _ref["default"],
//     role = _ref.role,
//     size = _ref.size,
//     onLoad = _ref.onLoad;
//   var _useState = useState$1(false),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     padding = _useState2[0],
//     setPadding = _useState2[1];
//   var _useState3 = useState$1(false),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     useDefault = _useState4[0],
//     setUseDefault = _useState4[1];
//   var _useState5 = useState$1({
//       width: 0,
//       height: 0
//     }),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     dimensions = _useState6[0],
//     setDimensions = _useState6[1];
//   useEffect$2(function () {
//     setDimensions(function () {
//       // By default expect the gradiant to be of large size if nothing is passed as attribute value.
//       var availableWidth = 221;
//       var availableHeight = 124;
//       if (size === 'medium') {
//         availableWidth = 177;
//         availableHeight = 100;
//       } else if (size === 'small') {
//         availableWidth = 124;
//         availableHeight = 70;
//       }
//       return {
//         width: availableWidth,
//         height: availableHeight
//       };
//     });
//   }, [size]);
//   var switchToDefault = useCallback(function () {
//     _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
//       var paddingResult;
//       return _regeneratorRuntime().wrap(function _callee$(_context) {
//         while (1) switch (_context.prev = _context.next) {
//           case 0:
//             _context.next = 2;
//             return requiresPadding(defaultImage, dimensions.width, dimensions.height);
//           case 2:
//             paddingResult = _context.sent;
//             setPadding(paddingResult);
//             setUseDefault(true);
//           case 5:
//           case "end":
//             return _context.stop();
//         }
//       }, _callee);
//     }))();
//   }, [defaultImage, dimensions]);
//   useEffect$2(function () {
//     if (!dimensions.width) {
//       return;
//     }
//     if (!src) {
//       switchToDefault();
//       return;
//     }
//     _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
//       var paddingResult;
//       return _regeneratorRuntime().wrap(function _callee2$(_context2) {
//         while (1) switch (_context2.prev = _context2.next) {
//           case 0:
//             _context2.prev = 0;
//             _context2.next = 3;
//             return requiresPadding(src, dimensions.width, dimensions.height);
//           case 3:
//             paddingResult = _context2.sent;
//             setPadding(paddingResult);
//             setUseDefault(false);
//             onLoad({
//               success: true
//             });
//             _context2.next = 13;
//             break;
//           case 9:
//             _context2.prev = 9;
//             _context2.t0 = _context2["catch"](0);
//             switchToDefault();
//             onLoad({
//               success: false
//             });
//           case 13:
//           case "end":
//             return _context2.stop();
//         }
//       }, _callee2, null, [[0, 9]]);
//     }))();
//   }, [src, defaultImage, dimensions, onLoad, switchToDefault]);
//   return /*#__PURE__*/React__default.createElement(ImageGradientContainer, {
//     width: dimensions.width,
//     height: dimensions.height,
//     className: padding ? 'image-padding' : '',
//     role: role
//   }, /*#__PURE__*/React__default.createElement(ImageWrapper, null, /*#__PURE__*/React__default.createElement("img", {
//     src: !useDefault ? src : defaultImage,
//     alt: ""
//   })));
// }
// CardImage.propTypes = {
//   /**
//    * image url for the card
//    */
//   src: PropTypes__default.string.isRequired,
//   /**
//    * default image src if actual `src` has failed to load or invalid
//    */
//   "default": PropTypes__default.string,
//   /**
//    * [Role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles) applied to the card element.
//    */
//   role: PropTypes__default.string,
//   /**
//    * Size of card
//    */
//   size: PropTypes__default.oneOf(['large', 'medium', 'small']),
//   /**
//    * On load handler. sends true/false parameter to determine success/failure { sucess: true/false }
//    */
//   onLoad: PropTypes__default.func
// };
// CardImage.defaultProps = {
//   role: 'presentation',
//   size: 'large',
//   "default": undefined,
//   onLoad: function onLoad() {
//     return null;
//   }
// };

// /**
//  * Component for Closing an open item when clicked away/outside of it.
//  * The children passed to this component gets closed on away/outside click.
//  * This component is used in TopMenu for closing the MegaMenus on away/outside click.
//  */

// function CloseOnClickAway(_ref) {
//   var close = _ref.close,
//     children = _ref.children;
//   return /*#__PURE__*/React__default.createElement(ClickAwayListener, {
//     onClickAway: close
//   }, children);
// }

// // PropType check
// CloseOnClickAway.propTypes = {
//   /**
//    * Child elements for the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * Close function
//    */
//   close: PropTypes__default.func
// };
// CloseOnClickAway.defaultProps = {
//   children: undefined,
//   close: function close() {}
// };

// /**
//  * Component for Closing an open item on click of Escape.
//  * The children passed to this component gets closed on Escape click.
//  * This component is used in TopMenu for closing the MegaMenus on Escape click.
//  */

// function CloseOnEscape(_ref) {
//   var close = _ref.close,
//     children = _ref.children;
//   var closeOnEsc = useCallback(function (event) {
//     if (event.keyCode === 27) {
//       close();
//     }
//   }, [close]);
//   useEffect$2(function () {
//     document.addEventListener('keydown', closeOnEsc, false);
//     return function () {
//       document.removeEventListener('keydown', closeOnEsc, false);
//     };
//   }, [closeOnEsc]);
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children);
// }

// // PropType check
// CloseOnEscape.propTypes = {
//   /**
//    * Child elements for the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * Close function
//    */
//   close: PropTypes__default.func
// };
// CloseOnEscape.defaultProps = {
//   children: undefined,
//   close: function close() {}
// };

// /**
//  * The Collapse component is used to create regions of content that can expand/collapse with a simple animation.
//  * It helps to hide content that's not immediately relevant to the user.
//  */
// var CollapseTransition = function CollapseTransition(_ref) {
//   var show = _ref.show,
//     children = _ref.children;
//   return /*#__PURE__*/React__default.createElement(MuiCollapse, {
//     "in": show
//   }, children);
// };
// CollapseTransition.propTypes = {
//   /**
//    * If `true`, the component will show.
//    */
//   show: PropTypes__default.bool,
//   /**
//    * children to collapse transition needs to apply
//    */
//   children: PropTypes__default.node
// };
// CollapseTransition.defaultProps = {
//   show: false,
//   children: undefined
// };

// /**
//  * Combox is used for collecting list of options to be select (replacement for HTML Select).
//  */
// function ComboBox(_ref) {
//   var idProp = _ref.id,
//     onChange = _ref.onChange,
//     renderValue = _ref.renderValue,
//     IconComponent = _ref.IconComponent,
//     inputProps = _ref.inputProps,
//     disabled = _ref.disabled,
//     value = _ref.value,
//     required = _ref.required,
//     label = _ref.label,
//     name = _ref.name,
//     helperText = _ref.helperText,
//     error = _ref.error,
//     className = _ref.className,
//     children = _ref.children,
//     isNative = _ref.isNative,
//     menuProps = _ref.menuProps;
//   var id = useId(idProp);
//   /*
//     We used TextField, because material already provides with combination of helperText and label
//     which we don't have to map them again manually using Material UI SELECT
//   */
//   return /*#__PURE__*/React__default.createElement(TextField$1, {
//     select: true,
//     SelectProps: {
//       "native": isNative,
//       MenuProps: menuProps,
//       renderValue: renderValue,
//       IconComponent: IconComponent
//     },
//     variant: "outlined",
//     id: id,
//     onChange: onChange,
//     inputProps: inputProps,
//     disabled: disabled,
//     value: value,
//     required: required,
//     label: label,
//     helperText: helperText,
//     name: name,
//     error: error,
//     className: className
//   }, children);
// }
// ComboBox.propTypes = {
//   /**
//    * Id of the input
//    */
//   id: PropTypes__default.string,
//   /**
//    * On change handler
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Customize selected value appearance
//    */
//   renderValue: PropTypes__default.func,
//   /**
//    * Attributes applied to the select element.
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * Disable the combobox
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Value of the combobox
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * Required select option
//    */
//   required: PropTypes__default.bool,
//   /**
//    * Label of the combobox
//    */
//   label: PropTypes__default.string,
//   /**
//    * Name of the combobox
//    */
//   name: PropTypes__default.string,
//   /**
//    * Helpertext of the combobox
//    */
//   helperText: PropTypes__default.string,
//   /**
//    * If `true`, the label will be displayed in an error state.
//    */
//   error: PropTypes__default.bool,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Options of the combobox
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * If true, the component will be using a native select element.
//    */
//   isNative: PropTypes__default.bool,
//   /**
//    * Attributes applied to the menu element used within select.
//    */
//   menuProps: PropTypes__default.shape({}),
//   /**
//    * The icon that is used for the Select Arrow
//    */
//   IconComponent: PropTypes__default.elementType
// };
// ComboBox.defaultProps = {
//   id: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   renderValue: null,
//   IconComponent: ArrowDropDownIcon,
//   inputProps: {},
//   value: '',
//   disabled: false,
//   required: false,
//   label: '',
//   name: '',
//   helperText: '',
//   error: false,
//   className: '',
//   isNative: true,
//   menuProps: {}
// };

// function ComboBoxOption(_ref) {
//   var label = _ref.label,
//     value = _ref.value;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("option", {
//     value: value
//   }, label));
// }
// ComboBoxOption.propTypes = {
//   /**
//    * value of option
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * label of option
//    */
//   label: PropTypes__default.string
// };
// ComboBoxOption.defaultProps = {
//   value: undefined,
//   label: ''
// };

// var _templateObject$1x;
// var StyledDiv$6 = styled.div(_templateObject$1x || (_templateObject$1x = _taggedTemplateLiteral$1(["\n  width: ", "rem;\n  overflow: hidden;\n  padding: 0.0625rem 0 0.75rem 0;\n  height: 100%;\n  background-color: ", ";\n"])), function (props) {
//   return props.width;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// });

// /**
//  * ControlPanel shows a list of navigation items and is mainly used as a navigation aid in the content area.
//  */
// function ControlPanel(_ref) {
//   var topPosition = _ref.topPosition,
//     width = _ref.width,
//     children = _ref.children,
//     className = _ref.className,
//     footer = _ref.footer,
//     role = _ref.role,
//     ariaLabel = _ref.ariaLabel,
//     id = _ref.id;
//   return /*#__PURE__*/React__default.createElement(StyledDiv$6, {
//     id: id,
//     top: topPosition,
//     width: width,
//     className: className,
//     role: role,
//     "aria-label": ariaLabel
//   }, children, /*#__PURE__*/React__default.createElement("div", {
//     style: {
//       flex: 1
//     }
//   }), footer);
// }
// ControlPanel.propTypes = {
//   /**
//    * children to panel
//    */
//   children: PropTypes__default.node,
//   /**
//    * position of panel from top
//    */
//   topPosition: PropTypes__default.number,
//   /**
//    * width of panel
//    */
//   width: PropTypes__default.number,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * footer of panel
//    */
//   footer: PropTypes__default.node,
//   /**
//    * role attribute to be set to the control panel
//    */
//   role: PropTypes__default.string,
//   /**
//    * value of aria-label attribute to be used for control panel
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * id property of the control panel
//    */
//   id: PropTypes__default.string
// };
// ControlPanel.defaultProps = {
//   children: null,
//   topPosition: 0,
//   className: '',
//   width: 5.625,
//   footer: null,
//   role: undefined,
//   ariaLabel: null,
//   id: undefined
// };

// var isArray$1 = Array.isArray;
// var toClassName = function (val) {
//     var str = '';
//     if (typeof val === 'string')
//         str += val;
//     else if (typeof val === 'object') {
//         var tmp = void 0;
//         if (isArray$1(val)) {
//             var i = 0;
//             var l = val.length;
//             while (i < l) {
//                 tmp = toClassName(val[i++]);
//                 if (tmp) {
//                     if (str) {
//                         str += ' ';
//                     }
//                     str += tmp;
//                 }
//             }
//         }
//         else {
//             // eslint-disable-next-line guard-for-in
//             for (tmp in val) {
//                 if (tmp && val[tmp]) {
//                     if (str) {
//                         str += ' ';
//                     }
//                     str += tmp;
//                 }
//             }
//         }
//     }
//     return str;
// };
// function cnb() {
//     var l = arguments.length;
//     var i = 0;
//     var n;
//     var tmp;
//     var str = '';
//     while (i < l) {
//         n = arguments[i++];
//         if (n) {
//             tmp = toClassName(n);
//             if (tmp) {
//                 if (str) {
//                     str += ' ';
//                 }
//                 str += tmp;
//             }
//         }
//     }
//     return str;
// }

// /******************************************************************************
// Copyright (c) Microsoft Corporation.

// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted.

// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
// OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
// ***************************************************************************** */
// /* global Reflect, Promise */

// var extendStatics = function(d, b) {
//     extendStatics = Object.setPrototypeOf ||
//         ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
//     return extendStatics(d, b);
// };

// function __extends(d, b) {
//     if (typeof b !== "function" && b !== null)
//         throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
//     extendStatics(d, b);
//     function __() { this.constructor = d; }
//     d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
// }

// var __assign$1 = function() {
//     __assign$1 = Object.assign || function __assign(t) {
//         for (var s, i = 1, n = arguments.length; i < n; i++) {
//             s = arguments[i];
//             for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
//         }
//         return t;
//     };
//     return __assign$1.apply(this, arguments);
// };

// function __rest$1(s, e) {
//     var t = {};
//     for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
//         t[p] = s[p];
//     if (s != null && typeof Object.getOwnPropertySymbols === "function")
//         for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
//             if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
//                 t[p[i]] = s[p[i]];
//         }
//     return t;
// }

// function __spreadArray$1(to, from, pack) {
//     if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
//         if (ar || !(i in from)) {
//             if (!ar) ar = Array.prototype.slice.call(from, 0, i);
//             ar[i] = from[i];
//         }
//     }
//     return to.concat(ar || Array.prototype.slice.call(from));
// }

// function _typeof$G(obj) {
//   "@babel/helpers - typeof";

//   return _typeof$G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
//     return typeof obj;
//   } : function (obj) {
//     return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
//   }, _typeof$G(obj);
// }

// var doc = (typeof document === "undefined" ? "undefined" : _typeof$G(document)) === 'object' ? document : null;
// var isBrowser$2 = typeof window !== 'undefined' && typeof navigator !== 'undefined' && typeof document !== 'undefined';
// var isUndef = function isUndef(v) {
//   return typeof v === 'undefined';
// };
// var isFun = function isFun(v) {
//   return typeof v === 'function';
// };
// var isNum = function isNum(v) {
//   return typeof v === 'number';
// };
// /**
//  * @description Will return renderer result if presented, div element otherwise.
//  * If renderer is presented it'll receive `elementRef` function which should be used as HTMLElement's ref.
//  *
//  * @param props {ElementPropsWithElementRefAndRenderer}
//  * @param elementRef {ElementRef}
//  */

// var renderDivWithRenderer = function renderDivWithRenderer(props, elementRef) {
//   if (isFun(props.renderer)) {
//     props.elementRef = elementRef;
//     var renderer = props.renderer;
//     delete props.renderer;
//     return renderer(props);
//   }

//   delete props.elementRef;
//   return React.createElement("div", __assign$1({}, props, {
//     ref: elementRef
//   }));
// };

// var getInnerSize = function getInnerSize(el, dimension, padding1, padding2) {
//   var styles = getComputedStyle(el);

//   if (styles.boxSizing === 'border-box') {
//     return Math.max(0, (Number.parseFloat(styles[dimension]) || 0) - (Number.parseFloat(styles[padding1]) || 0) - (Number.parseFloat(styles[padding2]) || 0));
//   }

//   return Number.parseFloat(styles[dimension]) || 0;
// };
// /**
//  * @description Return element's height without padding
//  */


// var getInnerHeight = function getInnerHeight(el) {
//   return getInnerSize(el, 'height', 'paddingTop', 'paddingBottom');
// };
// /**
//  * @description Return element's width without padding
//  */

// var getInnerWidth = function getInnerWidth(el) {
//   return getInnerSize(el, 'width', 'paddingLeft', 'paddingRight');
// };
// /**
//  * @description Return unique UUID v4
//  */

// var uuid = function uuid() {
//   // eslint-disable-next-line @typescript-eslint/no-shadow
//   var uuid = '';

//   for (var i = 0; i < 32; i++) {
//     switch (i) {
//       case 8:
//       case 20:
//         {
//           uuid += "-".concat(Math.trunc(Math.random() * 16).toString(16));
//           break;
//         }

//       case 12:
//         {
//           uuid += '-4';
//           break;
//         }

//       case 16:
//         {
//           uuid += "-".concat((Math.random() * 16 | 0 & 3 | 8).toString(16));
//           break;
//         }

//       default:
//         {
//           uuid += Math.trunc(Math.random() * 16).toString(16);
//         }
//     }
//   }

//   return uuid;
// };
// /**
//  * @description Calculate thumb size for given viewport and track parameters
//  *
//  * @param {number} contentSize - Scrollable content size
//  * @param {number} viewportSize - Viewport size
//  * @param {number} trackSize - Track size thumb can move
//  * @param {number} minimalSize - Minimal thumb's size
//  * @param {number} maximalSize - Maximal thumb's size
//  */

// var calcThumbSize = function calcThumbSize(contentSize, viewportSize, trackSize, minimalSize, maximalSize) {
//   if (viewportSize >= contentSize) {
//     return 0;
//   }

//   var thumbSize = viewportSize / contentSize * trackSize;

//   if (isNum(maximalSize)) {
//     thumbSize = Math.min(maximalSize, thumbSize);
//   }

//   if (isNum(minimalSize)) {
//     thumbSize = Math.max(minimalSize, thumbSize);
//   }

//   return thumbSize;
// };
// /**
//  * @description Calculate thumb offset for given viewport, track and thumb parameters
//  *
//  * @param {number} contentSize - Scrollable content size
//  * @param {number} viewportSize - Viewport size
//  * @param {number} trackSize - Track size thumb can move
//  * @param {number} thumbSize - Thumb size
//  * @param {number} scroll - Scroll value to represent
//  */

// var calcThumbOffset = function calcThumbOffset(contentSize, viewportSize, trackSize, thumbSize, scroll) {
//   if (!scroll || !thumbSize || viewportSize >= contentSize) {
//     return 0;
//   }

//   return (trackSize - thumbSize) * scroll / (contentSize - viewportSize);
// };
// /**
//  * @description Calculate scroll for given viewport, track and thumb parameters
//  *
//  * @param {number} contentSize - Scrollable content size
//  * @param {number} viewportSize - Viewport size
//  * @param {number} trackSize - Track size thumb can move
//  * @param {number} thumbSize - Thumb size
//  * @param {number} thumbOffset - Thumb's offset representing the scroll
//  */

// var calcScrollForThumbOffset = function calcScrollForThumbOffset(contentSize, viewportSize, trackSize, thumbSize, thumbOffset) {
//   if (!thumbOffset || !thumbSize || viewportSize >= contentSize) {
//     return 0;
//   }

//   return thumbOffset * (contentSize - viewportSize) / (trackSize - thumbSize);
// };
// /**
//  * @description Returns scrollbar width specific for current environment. Can return undefined if DOM is not ready yet.
//  */

// var getScrollbarWidth = function getScrollbarWidth(force) {
//   if (force === void 0) {
//     force = false;
//   }

//   if (!doc) {
//     getScrollbarWidth._cache = 0;
//     return getScrollbarWidth._cache;
//   }

//   if (!force && !isUndef(getScrollbarWidth._cache)) {
//     return getScrollbarWidth._cache;
//   }

//   var el = doc.createElement('div');
//   el.setAttribute('style', 'position:absolute;width:100px;height:100px;top:-999px;left:-999px;overflow:scroll;');
//   doc.body.append(el);
//   /* istanbul ignore next */

//   if (el.clientWidth === 0) {
//     // Do not even cache this value because there is no calculations. Issue https://github.com/xobotyi/react-scrollbars-custom/issues/123
//     el.remove();
//     return;
//   }

//   getScrollbarWidth._cache = 100 - el.clientWidth;
//   el.remove();
//   return getScrollbarWidth._cache;
// };
// /**
//  * @description Detect need of horizontal scroll reverse while RTL.
//  */

// var shouldReverseRtlScroll = function shouldReverseRtlScroll(force) {
//   if (force === void 0) {
//     force = false;
//   }

//   if (!force && !isUndef(shouldReverseRtlScroll._cache)) {
//     return shouldReverseRtlScroll._cache;
//   }

//   if (!doc) {
//     shouldReverseRtlScroll._cache = false;
//     return shouldReverseRtlScroll._cache;
//   }

//   var el = doc.createElement('div');
//   var child = doc.createElement('div');
//   el.append(child);
//   el.setAttribute('style', 'position:absolute;width:100px;height:100px;top:-999px;left:-999px;overflow:scroll;direction:rtl');
//   child.setAttribute('style', 'width:1000px;height:1000px');
//   doc.body.append(el);
//   el.scrollLeft = -50;
//   shouldReverseRtlScroll._cache = el.scrollLeft === -50;
//   el.remove();
//   return shouldReverseRtlScroll._cache;
// };

// var Emittr =
// /** @class */
// function () {
//   function Emittr(maxHandlers) {
//     if (maxHandlers === void 0) {
//       maxHandlers = 10;
//     }

//     this.setMaxHandlers(maxHandlers);
//     this._handlers = Object.create(null);
//   }

//   Emittr._callEventHandlers = function (emitter, handlers, args) {
//     if (!handlers.length) {
//       return;
//     }

//     if (handlers.length === 1) {
//       Reflect.apply(handlers[0], emitter, args);
//       return;
//     }

//     handlers = __spreadArray$1([], handlers, true);
//     var idx;

//     for (idx = 0; idx < handlers.length; idx++) {
//       Reflect.apply(handlers[idx], emitter, args);
//     }
//   };

//   Emittr.prototype.setMaxHandlers = function (count) {
//     if (!isNum(count) || count <= 0) {
//       throw new TypeError("Expected maxHandlers to be a positive number, got '".concat(count, "' of type ").concat(_typeof$G(count)));
//     }

//     this._maxHandlers = count;
//     return this;
//   };

//   Emittr.prototype.getMaxHandlers = function () {
//     return this._maxHandlers;
//   };

//   Emittr.prototype.emit = function (name) {
//     var args = [];

//     for (var _i = 1; _i < arguments.length; _i++) {
//       args[_i - 1] = arguments[_i];
//     }

//     if (_typeof$G(this._handlers[name]) !== 'object' || !Array.isArray(this._handlers[name])) {
//       return false;
//     }

//     Emittr._callEventHandlers(this, this._handlers[name], args);

//     return true;
//   };

//   Emittr.prototype.on = function (name, handler) {
//     Emittr._addHandler(this, name, handler);

//     return this;
//   };

//   Emittr.prototype.prependOn = function (name, handler) {
//     Emittr._addHandler(this, name, handler, true);

//     return this;
//   };

//   Emittr.prototype.once = function (name, handler) {
//     if (!isFun(handler)) {
//       throw new TypeError("Expected event handler to be a function, got ".concat(_typeof$G(handler)));
//     }

//     Emittr._addHandler(this, name, this._wrapOnceHandler(name, handler));

//     return this;
//   };

//   Emittr.prototype.prependOnce = function (name, handler) {
//     if (!isFun(handler)) {
//       throw new TypeError("Expected event handler to be a function, got ".concat(_typeof$G(handler)));
//     }

//     Emittr._addHandler(this, name, this._wrapOnceHandler(name, handler), true);

//     return this;
//   };

//   Emittr.prototype.off = function (name, handler) {
//     Emittr._removeHandler(this, name, handler);

//     return this;
//   };

//   Emittr.prototype.removeAllHandlers = function () {
//     var handlers = this._handlers;
//     this._handlers = Object.create(null);
//     var removeHandlers = handlers.removeHandler;
//     delete handlers.removeHandler;
//     var idx;
//     var eventName; // eslint-disable-next-line guard-for-in,no-restricted-syntax

//     for (eventName in handlers) {
//       for (idx = handlers[eventName].length - 1; idx >= 0; idx--) {
//         Emittr._callEventHandlers(this, removeHandlers, [eventName, handlers[eventName][idx].handler || handlers[eventName][idx]]);
//       }
//     }

//     return this;
//   };

//   Emittr.prototype._wrapOnceHandler = function (name, handler) {
//     var onceState = {
//       fired: false,
//       handler: handler,
//       wrappedHandler: undefined,
//       emitter: this,
//       event: name
//     };

//     var wrappedHandler = Emittr._onceWrapper.bind(onceState);

//     onceState.wrappedHandler = wrappedHandler;
//     wrappedHandler.handler = handler;
//     wrappedHandler.event = name;
//     return wrappedHandler;
//   };

//   Emittr._addHandler = function (emitter, name, handler, prepend) {
//     if (prepend === void 0) {
//       prepend = false;
//     }

//     if (!isFun(handler)) {
//       throw new TypeError("Expected event handler to be a function, got ".concat(_typeof$G(handler)));
//     }

//     emitter._handlers[name] = emitter._handlers[name] || [];
//     emitter.emit('addHandler', name, handler);

//     if (prepend) {
//       emitter._handlers[name].unshift(handler);
//     } else {
//       emitter._handlers[name].push(handler);
//     }

//     return emitter;
//   };

//   Emittr._onceWrapper = function _onceWrapper() {
//     var args = [];

//     for (var _i = 0; _i < arguments.length; _i++) {
//       args[_i] = arguments[_i];
//     }

//     if (!this.fired) {
//       this.fired = true;
//       this.emitter.off(this.event, this.wrappedHandler);
//       Reflect.apply(this.handler, this.emitter, args);
//     }
//   };

//   Emittr._removeHandler = function (emitter, name, handler) {
//     if (!isFun(handler)) {
//       throw new TypeError("Expected event handler to be a function, got ".concat(_typeof$G(handler)));
//     }

//     if (isUndef(emitter._handlers[name]) || !emitter._handlers[name].length) {
//       return emitter;
//     }

//     var idx = -1;

//     if (emitter._handlers[name].length === 1) {
//       if (emitter._handlers[name][0] === handler || emitter._handlers[name][0].handler === handler) {
//         idx = 0;
//         handler = emitter._handlers[name][0].handler || emitter._handlers[name][0];
//       }
//     } else {
//       for (idx = emitter._handlers[name].length - 1; idx >= 0; idx--) {
//         if (emitter._handlers[name][idx] === handler || emitter._handlers[name][idx].handler === handler) {
//           handler = emitter._handlers[name][idx].handler || emitter._handlers[name][idx];
//           break;
//         }
//       }
//     }

//     if (idx === -1) {
//       return emitter;
//     }

//     if (idx === 0) {
//       emitter._handlers[name].shift();
//     } else {
//       emitter._handlers[name].splice(idx, 1);
//     }

//     emitter.emit('removeHandler', name, handler);
//     return emitter;
//   };

//   return Emittr;
// }();

// var RAFLoop =
// /** @class */
// function () {
//   function RAFLoop() {
//     var _this = this;
//     /**
//      * @description List of targets to update
//      */


//     this.targets = [];
//     /**
//      * @description ID of requested animation frame. Valuable only if loop is active and has items to iterate.
//      */

//     this.animationFrameID = 0;
//     /**
//      * @description Loop's state.
//      */

//     this._isActive = false;
//     /**
//      * @description Start the loop if it wasn't yet.
//      */

//     this.start = function () {
//       if (!_this._isActive && _this.targets.length) {
//         _this._isActive = true;
//         if (_this.animationFrameID) cancelAnimationFrame(_this.animationFrameID);
//         _this.animationFrameID = requestAnimationFrame(_this.rafCallback);
//       }

//       return _this;
//     };
//     /**
//      * @description Stop the loop if is was active.
//      */


//     this.stop = function () {
//       if (_this._isActive) {
//         _this._isActive = false;
//         if (_this.animationFrameID) cancelAnimationFrame(_this.animationFrameID);
//         _this.animationFrameID = 0;
//       }

//       return _this;
//     };
//     /**
//      * @description Add target to the iteration list if it's not there.
//      */


//     this.addTarget = function (target, silent) {
//       if (silent === void 0) {
//         silent = false;
//       }

//       if (!_this.targets.includes(target)) {
//         _this.targets.push(target);

//         if (_this.targets.length === 1 && !silent) _this.start();
//       }

//       return _this;
//     };
//     /**
//      * @description Remove target from iteration list if it was there.
//      */


//     this.removeTarget = function (target) {
//       var idx = _this.targets.indexOf(target);

//       if (idx !== -1) {
//         _this.targets.splice(idx, 1);

//         if (_this.targets.length === 0) _this.stop();
//       }

//       return _this;
//     };
//     /**
//      * @description Callback that called each animation frame.
//      */


//     this.rafCallback = function () {
//       if (!_this._isActive) {
//         return 0;
//       }

//       for (var i = 0; i < _this.targets.length; i++) {
//         if (!_this.targets[i]._unmounted) _this.targets[i].update();
//       }

//       _this.animationFrameID = requestAnimationFrame(_this.rafCallback);
//       return _this.animationFrameID;
//     };
//   }

//   Object.defineProperty(RAFLoop.prototype, "isActive", {
//     /**
//      * @description Loop's state.
//      */
//     get: function get() {
//       return this._isActive;
//     },
//     enumerable: false,
//     configurable: true
//   });
//   return RAFLoop;
// }();
// var Loop = new RAFLoop();

// var AXIS_DIRECTION;

// (function (AXIS_DIRECTION) {
//   AXIS_DIRECTION["X"] = "x";
//   AXIS_DIRECTION["Y"] = "y";
// })(AXIS_DIRECTION || (AXIS_DIRECTION = {}));

// var TRACK_CLICK_BEHAVIOR;

// (function (TRACK_CLICK_BEHAVIOR) {
//   TRACK_CLICK_BEHAVIOR["JUMP"] = "jump";
//   TRACK_CLICK_BEHAVIOR["STEP"] = "step";
// })(TRACK_CLICK_BEHAVIOR || (TRACK_CLICK_BEHAVIOR = {}));

// var ScrollbarThumb =
// /** @class */
// function (_super) {
//   __extends(ScrollbarThumb, _super);

//   function ScrollbarThumb() {
//     var _this = _super !== null && _super.apply(this, arguments) || this;

//     _this.element = null;
//     _this.initialOffsetX = 0;
//     _this.initialOffsetY = 0;
//     _this.elementRefHack = React.createRef();
//     _this.lastDragData = {
//       x: 0,
//       y: 0,
//       deltaX: 0,
//       deltaY: 0,
//       lastX: 0,
//       lastY: 0
//     };

//     _this.handleOnDragStart = function (ev, data) {
//       if (!_this.element) {
//         _this.handleOnDragStop(ev, data);

//         return;
//       }

//       if (isBrowser$2) {
//         _this.prevUserSelect = document.body.style.userSelect;
//         document.body.style.userSelect = 'none';
//         _this.prevOnSelectStart = document.onselectstart;
//         document.addEventListener('selectstart', ScrollbarThumb.selectStartReplacer);
//       }

//       if (_this.props.onDragStart) {
//         _this.props.onDragStart(_this.lastDragData = {
//           x: data.x - _this.initialOffsetX,
//           y: data.y - _this.initialOffsetY,
//           lastX: data.lastX - _this.initialOffsetX,
//           lastY: data.lastY - _this.initialOffsetY,
//           deltaX: data.deltaX,
//           deltaY: data.deltaY
//         });
//       }

//       _this.element.classList.add('dragging');
//     };

//     _this.handleOnDrag = function (ev, data) {
//       if (!_this.element) {
//         _this.handleOnDragStop(ev, data);

//         return;
//       }

//       if (_this.props.onDrag) {
//         _this.props.onDrag(_this.lastDragData = {
//           x: data.x - _this.initialOffsetX,
//           y: data.y - _this.initialOffsetY,
//           lastX: data.lastX - _this.initialOffsetX,
//           lastY: data.lastY - _this.initialOffsetY,
//           deltaX: data.deltaX,
//           deltaY: data.deltaY
//         });
//       }
//     };

//     _this.handleOnDragStop = function (ev, data) {
//       var resultData = data ? {
//         x: data.x - _this.initialOffsetX,
//         y: data.y - _this.initialOffsetY,
//         lastX: data.lastX - _this.initialOffsetX,
//         lastY: data.lastY - _this.initialOffsetY,
//         deltaX: data.deltaX,
//         deltaY: data.deltaY
//       } : _this.lastDragData;
//       if (_this.props.onDragEnd) _this.props.onDragEnd(resultData);
//       if (_this.element) _this.element.classList.remove('dragging');

//       if (isBrowser$2) {
//         document.body.style.userSelect = _this.prevUserSelect;

//         if (_this.prevOnSelectStart) {
//           document.addEventListener('selectstart', _this.prevOnSelectStart);
//         }

//         _this.prevOnSelectStart = null;
//       }

//       _this.initialOffsetX = 0;
//       _this.initialOffsetY = 0;
//       _this.lastDragData = {
//         x: 0,
//         y: 0,
//         deltaX: 0,
//         deltaY: 0,
//         lastX: 0,
//         lastY: 0
//       };
//     };

//     _this.handleOnMouseDown = function (ev) {
//       if (!_this.element) {
//         return;
//       }

//       ev.preventDefault();
//       ev.stopPropagation();

//       if (!isUndef(ev.offsetX)) {
//         /* istanbul ignore next */
//         _this.initialOffsetX = ev.offsetX;
//         /* istanbul ignore next */

//         _this.initialOffsetY = ev.offsetY;
//       } else {
//         var rect = _this.element.getBoundingClientRect();

//         _this.initialOffsetX = (ev.clientX || ev.touches[0].clientX) - rect.left;
//         _this.initialOffsetY = (ev.clientY || ev.touches[0].clientY) - rect.top;
//       }
//     };

//     _this.elementRef = function (ref) {
//       if (isFun(_this.props.elementRef)) _this.props.elementRef(ref);
//       _this.element = ref; // eslint-disable-next-line @typescript-eslint/ban-ts-comment
//       // @ts-ignore

//       _this.elementRefHack.current = ref;
//     };

//     return _this;
//   }

//   ScrollbarThumb.prototype.componentDidMount = function () {
//     if (!this.element) {
//       this.setState(function () {
//         throw new Error("<ScrollbarThumb> Element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
//       });
//     }
//   };

//   ScrollbarThumb.prototype.componentWillUnmount = function () {
//     this.handleOnDragStop();
//     this.elementRef(null);
//   };

//   ScrollbarThumb.prototype.render = function () {
//     var _a = this.props;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.elementRef;
//         var axis = _a.axis;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onDrag;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onDragEnd;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onDragStart;
//         var props = __rest$1(_a, ["elementRef", "axis", "onDrag", "onDragEnd", "onDragStart"]);

//     props.className = cnb('ScrollbarsCustom-Thumb', axis === AXIS_DIRECTION.X ? 'ScrollbarsCustom-ThumbX' : 'ScrollbarsCustom-ThumbY', props.className);

//     if (props.renderer) {
//       props.axis = axis;
//     }

//     return React.createElement(DraggableCore, {
//       allowAnyClick: false,
//       enableUserSelectHack: false,
//       onMouseDown: this.handleOnMouseDown,
//       onDrag: this.handleOnDrag,
//       onStart: this.handleOnDragStart,
//       onStop: this.handleOnDragStop,
//       nodeRef: this.elementRefHack
//     }, renderDivWithRenderer(props, this.elementRef));
//   };

//   ScrollbarThumb.selectStartReplacer = function () {
//     return false;
//   };

//   return ScrollbarThumb;
// }(React.Component);

// var ScrollbarTrack =
// /** @class */
// function (_super) {
//   __extends(ScrollbarTrack, _super);

//   function ScrollbarTrack() {
//     var _this = _super !== null && _super.apply(this, arguments) || this;

//     _this.element = null;

//     _this.elementRef = function (ref) {
//       if (isFun(_this.props.elementRef)) _this.props.elementRef(ref);
//       _this.element = ref;
//     };

//     _this.handleClick = function (ev) {
//       if (!ev || !_this.element || ev.button !== 0) {
//         return;
//       }

//       if (isFun(_this.props.onClick) && ev.target === _this.element) {
//         if (!isUndef(ev.offsetX)) {
//           _this.props.onClick(ev, {
//             axis: _this.props.axis,
//             offset: _this.props.axis === AXIS_DIRECTION.X ? ev.offsetX : ev.offsetY
//           });
//         } else {
//           // support for old browsers

//           /* istanbul ignore next */
//           var rect = _this.element.getBoundingClientRect();
//           /* istanbul ignore next */


//           _this.props.onClick(ev, {
//             axis: _this.props.axis,
//             offset: _this.props.axis === AXIS_DIRECTION.X ? (ev.clientX || ev.touches[0].clientX) - rect.left : (ev.clientY || ev.touches[0].clientY) - rect.top
//           });
//         }
//       }

//       return true;
//     };

//     return _this;
//   }

//   ScrollbarTrack.prototype.componentDidMount = function () {
//     if (!this.element) {
//       this.setState(function () {
//         throw new Error("Element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
//       });
//       return;
//     }

//     this.element.addEventListener('click', this.handleClick);
//   };

//   ScrollbarTrack.prototype.componentWillUnmount = function () {
//     if (this.element) {
//       this.element.removeEventListener('click', this.handleClick);
//       this.element = null;
//       this.elementRef(null);
//     }
//   };

//   ScrollbarTrack.prototype.render = function () {
//     var _a = this.props;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.elementRef;
//         var axis = _a.axis;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onClick;
//         var props = __rest$1(_a, ["elementRef", "axis", "onClick"]);

//     props.className = cnb('ScrollbarsCustom-Track', axis === AXIS_DIRECTION.X ? 'ScrollbarsCustom-TrackX' : 'ScrollbarsCustom-TrackY', props.className);

//     if (props.renderer) {
//       props.axis = axis;
//     }

//     return renderDivWithRenderer(props, this.elementRef);
//   };

//   return ScrollbarTrack;
// }(React.Component);

// var style$2 = {
//   holder: {
//     position: 'relative',
//     width: '100%',
//     height: '100%'
//   },
//   wrapper: {
//     position: 'absolute',
//     top: 0,
//     left: 0,
//     bottom: 0,
//     right: 0
//   },
//   content: {
//     boxSizing: 'border-box'
//   },
//   track: {
//     common: {
//       position: 'absolute',
//       overflow: 'hidden',
//       borderRadius: 4,
//       background: 'rgba(0,0,0,.1)',
//       userSelect: 'none'
//     },
//     x: {
//       height: 10,
//       width: 'calc(100% - 20px)',
//       bottom: 0,
//       left: 10
//     },
//     y: {
//       width: 10,
//       height: 'calc(100% - 20px)',
//       top: 10
//     }
//   },
//   thumb: {
//     common: {
//       cursor: 'pointer',
//       borderRadius: 4,
//       background: 'rgba(0,0,0,.4)'
//     },
//     x: {
//       height: '100%',
//       width: 0
//     },
//     y: {
//       width: '100%',
//       height: 0
//     }
//   }
// };

// var pageZoomLevel = isBrowser$2 ? zoomLevel() : 1;

// if (isBrowser$2) {
//   window.addEventListener('resize', function () {
//     pageZoomLevel = zoomLevel();
//   }, {
//     passive: true
//   });
// }

// var ScrollbarContext = React.createContext({
//   parentScrollbar: null
// });

// var Scrollbar =
// /** @class */
// function (_super) {
//   __extends(Scrollbar, _super);

//   function Scrollbar(props) {
//     var _this = _super.call(this, props) || this;
//     /**
//      * @description Get current scroll-related values.<br/>
//      * If <i>force</i> if truthy - will recalculate them instead of returning cached values.
//      *
//      * @return ScrollState
//      */


//     _this.getScrollState = function (force) {
//       if (force === void 0) {
//         force = false;
//       }

//       if (_this.scrollValues && !force) {
//         return __assign$1({}, _this.scrollValues);
//       }

//       var scrollState = {
//         clientHeight: 0,
//         clientWidth: 0,
//         contentScrollHeight: 0,
//         contentScrollWidth: 0,
//         scrollHeight: 0,
//         scrollWidth: 0,
//         scrollTop: 0,
//         scrollLeft: 0,
//         scrollYBlocked: false,
//         scrollXBlocked: false,
//         scrollYPossible: false,
//         scrollXPossible: false,
//         trackYVisible: false,
//         trackXVisible: false,
//         zoomLevel: pageZoomLevel * 1,
//         isRTL: undefined
//       };
//       var props = _this.props;
//       scrollState.isRTL = _this.state.isRTL;
//       scrollState.scrollYBlocked = props.noScroll || props.noScrollY;
//       scrollState.scrollXBlocked = props.noScroll || props.noScrollX;

//       if (_this.scrollerElement) {
//         scrollState.clientHeight = _this.scrollerElement.clientHeight;
//         scrollState.clientWidth = _this.scrollerElement.clientWidth;
//         scrollState.scrollHeight = _this.scrollerElement.scrollHeight;
//         scrollState.scrollWidth = _this.scrollerElement.scrollWidth;
//         scrollState.scrollTop = _this.scrollerElement.scrollTop;
//         scrollState.scrollLeft = _this.scrollerElement.scrollLeft;
//         scrollState.scrollYPossible = !scrollState.scrollYBlocked && scrollState.scrollHeight > scrollState.clientHeight;
//         scrollState.scrollXPossible = !scrollState.scrollXBlocked && scrollState.scrollWidth > scrollState.clientWidth;
//         scrollState.trackYVisible = scrollState.scrollYPossible || props.permanentTracks || props.permanentTrackY;
//         scrollState.trackXVisible = scrollState.scrollXPossible || props.permanentTracks || props.permanentTrackX;
//       }

//       if (_this.contentElement) {
//         scrollState.contentScrollHeight = _this.contentElement.scrollHeight;
//         scrollState.contentScrollWidth = _this.contentElement.scrollWidth;
//       }

//       return scrollState;
//     };
//     /**
//      * @description Scroll to top border
//      */


//     _this.scrollToTop = function () {
//       if (_this.scrollerElement) {
//         _this.scrollerElement.scrollTop = 0;
//       }

//       return _this;
//     };
//     /**
//      * @description Scroll to left border
//      */


//     _this.scrollToLeft = function () {
//       if (_this.scrollerElement) {
//         _this.scrollerElement.scrollLeft = 0;
//       }

//       return _this;
//     };
//     /**
//      * @description Scroll to bottom border
//      */


//     _this.scrollToBottom = function () {
//       if (_this.scrollerElement) {
//         _this.scrollerElement.scrollTop = _this.scrollerElement.scrollHeight - _this.scrollerElement.clientHeight;
//       }

//       return _this;
//     };
//     /**
//      * @description Scroll to right border
//      */


//     _this.scrollToRight = function () {
//       if (_this.scrollerElement) {
//         _this.scrollerElement.scrollLeft = _this.scrollerElement.scrollWidth - _this.scrollerElement.clientWidth;
//       }

//       return _this;
//     };
//     /**
//      * @description Set the scrolls at given coordinates.<br/>
//      * If coordinate is undefined - current scroll value will persist.
//      */


//     _this.scrollTo = function (x, y) {
//       if (_this.scrollerElement) {
//         if (isNum(x)) _this.scrollerElement.scrollLeft = x;
//         if (isNum(y)) _this.scrollerElement.scrollTop = y;
//       }

//       return _this;
//     };
//     /**
//      * @description Center the viewport at given coordinates.<br/>
//      * If coordinate is undefined - current scroll value will persist.
//      */


//     _this.centerAt = function (x, y) {
//       if (_this.scrollerElement) {
//         if (isNum(x)) _this.scrollerElement.scrollLeft = x - _this.scrollerElement.clientWidth / 2;
//         if (isNum(y)) _this.scrollerElement.scrollTop = y - _this.scrollerElement.clientHeight / 2;
//       }

//       return _this;
//     };

//     _this.update = function (force) {
//       if (force === void 0) {
//         force = false;
//       }

//       if (!_this.scrollerElement) {
//         return;
//       } // autodetect direction if not defined


//       if (isUndef(_this.state.isRTL)) {
//         _this.setState({
//           isRTL: getComputedStyle(_this.scrollerElement).direction === 'rtl'
//         });

//         return _this.getScrollState();
//       }

//       var scrollState = _this.getScrollState(true);

//       var prevScrollState = __assign$1({}, _this.scrollValues);

//       var props = _this.props;
//       var bitmask = 0;

//       if (!force) {
//         if (prevScrollState.clientHeight !== scrollState.clientHeight) bitmask |= Math.trunc(1);
//         if (prevScrollState.clientWidth !== scrollState.clientWidth) bitmask |= 1 << 1;
//         if (prevScrollState.scrollHeight !== scrollState.scrollHeight) bitmask |= 1 << 2;
//         if (prevScrollState.scrollWidth !== scrollState.scrollWidth) bitmask |= 1 << 3;
//         if (prevScrollState.scrollTop !== scrollState.scrollTop) bitmask |= 1 << 4;
//         if (prevScrollState.scrollLeft !== scrollState.scrollLeft) bitmask |= 1 << 5;
//         if (prevScrollState.scrollYBlocked !== scrollState.scrollYBlocked) bitmask |= 1 << 6;
//         if (prevScrollState.scrollXBlocked !== scrollState.scrollXBlocked) bitmask |= 1 << 7;
//         if (prevScrollState.scrollYPossible !== scrollState.scrollYPossible) bitmask |= 1 << 8;
//         if (prevScrollState.scrollXPossible !== scrollState.scrollXPossible) bitmask |= 1 << 9;
//         if (prevScrollState.trackYVisible !== scrollState.trackYVisible) bitmask |= 1 << 10;
//         if (prevScrollState.trackXVisible !== scrollState.trackXVisible) bitmask |= 1 << 11;
//         if (prevScrollState.isRTL !== scrollState.isRTL) bitmask |= 1 << 12;
//         if (prevScrollState.contentScrollHeight !== scrollState.contentScrollHeight) bitmask |= 1 << 13;
//         if (prevScrollState.contentScrollWidth !== scrollState.contentScrollWidth) bitmask |= 1 << 14;
//         if (prevScrollState.zoomLevel !== scrollState.zoomLevel) bitmask |= 1 << 15; // if not forced and nothing has changed - skip this update

//         if (bitmask === 0) {
//           return prevScrollState;
//         }
//       } else {
//         bitmask = 32767;
//       }

//       if (!props.native && _this.holderElement) {
//         if (bitmask & 1 << 13 && (props.translateContentSizesToHolder || props.translateContentSizeYToHolder)) {
//           _this.holderElement.style.height = "".concat(scrollState.contentScrollHeight, "px");
//         }

//         if (bitmask & 1 << 14 && (props.translateContentSizesToHolder || props.translateContentSizeXToHolder)) {
//           _this.holderElement.style.width = "".concat(scrollState.contentScrollWidth, "px");
//         }

//         if (props.translateContentSizesToHolder || props.translateContentSizeYToHolder || props.translateContentSizeXToHolder) {
//           if (!scrollState.clientHeight && scrollState.contentScrollHeight || !scrollState.clientWidth && scrollState.contentScrollWidth) {
//             return;
//           }
//         }
//       } // if scrollbars visibility has changed


//       if (bitmask & 1 << 10 || bitmask & 1 << 11) {
//         prevScrollState.scrollYBlocked = scrollState.scrollYBlocked;
//         prevScrollState.scrollXBlocked = scrollState.scrollXBlocked;
//         prevScrollState.scrollYPossible = scrollState.scrollYPossible;
//         prevScrollState.scrollXPossible = scrollState.scrollXPossible;

//         if (_this.trackYElement && bitmask & 1 << 10) {
//           _this.trackYElement.style.display = scrollState.trackYVisible ? '' : 'none';
//         }

//         if (_this.trackXElement && bitmask & 1 << 11) {
//           _this.trackXElement.style.display = scrollState.trackXVisible ? '' : 'none';
//         }

//         _this.scrollValues = prevScrollState;

//         _this.setState({
//           trackYVisible: _this.scrollValues.trackYVisible = scrollState.trackYVisible,
//           trackXVisible: _this.scrollValues.trackXVisible = scrollState.trackXVisible
//         });

//         return;
//       }

//       (props.native ? _this.updaterNative : _this.updaterCustom)(bitmask, scrollState);
//       _this.scrollValues = scrollState;

//       if (!props.native && bitmask & 1 << 15) {
//         getScrollbarWidth(true);

//         _this.forceUpdate();
//       }

//       _this.eventEmitter.emit('update', __assign$1({}, scrollState), prevScrollState);

//       if (bitmask & 1 << 4 || bitmask & 1 << 5) _this.eventEmitter.emit('scroll', __assign$1({}, scrollState), prevScrollState);
//       return _this.scrollValues;
//     }; // eslint-disable-next-line class-methods-use-this


//     _this.updaterNative = function () {
//       // just for future
//       return true;
//     };

//     _this.updaterCustom = function (bitmask, scrollValues) {
//       var props = _this.props;

//       if (_this.trackYElement) {
//         if (_this.thumbYElement && (bitmask & Math.trunc(1) || bitmask & 1 << 2 || bitmask & 1 << 4 || bitmask & 1 << 6 || bitmask & 1 << 8)) {
//           if (scrollValues.scrollYPossible) {
//             var trackInnerSize = getInnerHeight(_this.trackYElement);
//             var thumbSize = calcThumbSize(scrollValues.scrollHeight, scrollValues.clientHeight, trackInnerSize, props.minimalThumbYSize || props.minimalThumbSize, props.maximalThumbYSize || props.maximalThumbSize);
//             var thumbOffset = calcThumbOffset(scrollValues.scrollHeight, scrollValues.clientHeight, trackInnerSize, thumbSize, scrollValues.scrollTop);
//             _this.thumbYElement.style.transform = "translateY(".concat(thumbOffset, "px)");
//             _this.thumbYElement.style.height = "".concat(thumbSize, "px");
//             _this.thumbYElement.style.display = '';
//           } else {
//             _this.thumbYElement.style.transform = '';
//             _this.thumbYElement.style.height = '0px';
//             _this.thumbYElement.style.display = 'none';
//           }
//         }
//       }

//       if (_this.trackXElement) {
//         if (_this.thumbXElement && (bitmask & 1 << 1 || bitmask & 1 << 3 || bitmask & 1 << 5 || bitmask & 1 << 7 || bitmask & 1 << 9 || bitmask & 1 << 12)) {
//           if (scrollValues.scrollXPossible) {
//             var trackInnerSize = getInnerWidth(_this.trackXElement);
//             var thumbSize = calcThumbSize(scrollValues.scrollWidth, scrollValues.clientWidth, trackInnerSize, props.minimalThumbXSize || props.minimalThumbSize, props.maximalThumbXSize || props.maximalThumbSize);
//             var thumbOffset = calcThumbOffset(scrollValues.scrollWidth, scrollValues.clientWidth, trackInnerSize, thumbSize, scrollValues.scrollLeft);

//             if (_this.state.isRTL && shouldReverseRtlScroll()) {
//               thumbOffset += trackInnerSize - thumbSize;
//             }

//             _this.thumbXElement.style.transform = "translateX(".concat(thumbOffset, "px)");
//             _this.thumbXElement.style.width = "".concat(thumbSize, "px");
//             _this.thumbXElement.style.display = '';
//           } else {
//             _this.thumbXElement.style.transform = '';
//             _this.thumbXElement.style.width = '0px';
//             _this.thumbXElement.style.display = 'none';
//           }
//         }
//       }

//       return true;
//     };

//     _this.elementRefHolder = function (ref) {
//       _this.holderElement = ref;

//       if (isFun(_this.props.elementRef)) {
//         _this.props.elementRef(ref);
//       }
//     };

//     _this.elementRefWrapper = function (ref) {
//       _this.wrapperElement = ref;

//       if (isFun(_this.props.wrapperProps.elementRef)) {
//         _this.props.wrapperProps.elementRef(ref);
//       }
//     };

//     _this.elementRefScroller = function (ref) {
//       _this.scrollerElement = ref;

//       if (isFun(_this.props.scrollerProps.elementRef)) {
//         _this.props.scrollerProps.elementRef(ref);
//       }
//     };

//     _this.elementRefContent = function (ref) {
//       _this.contentElement = ref;

//       if (isFun(_this.props.contentProps.elementRef)) {
//         _this.props.contentProps.elementRef(ref);
//       }
//     };

//     _this.elementRefTrackX = function (ref) {
//       _this.trackXElement = ref;

//       if (isFun(_this.props.trackXProps.elementRef)) {
//         _this.props.trackXProps.elementRef(ref);
//       }
//     };

//     _this.elementRefTrackY = function (ref) {
//       _this.trackYElement = ref;

//       if (isFun(_this.props.trackYProps.elementRef)) {
//         _this.props.trackYProps.elementRef(ref);
//       }
//     };

//     _this.elementRefThumbX = function (ref) {
//       _this.thumbXElement = ref;

//       if (isFun(_this.props.thumbXProps.elementRef)) {
//         _this.props.thumbXProps.elementRef(ref);
//       }
//     };

//     _this.elementRefThumbY = function (ref) {
//       _this.thumbYElement = ref;

//       if (isFun(_this.props.thumbYProps.elementRef)) {
//         _this.props.thumbYProps.elementRef(ref);
//       }
//     };

//     _this.handleTrackXClick = function (ev, values) {
//       if (_this.props.trackXProps.onClick) {
//         _this.props.trackXProps.onClick(ev, values);
//       }

//       if (!_this.scrollerElement || !_this.trackXElement || !_this.thumbXElement || !_this.scrollValues || !_this.scrollValues.scrollXPossible) {
//         return;
//       }

//       _this._scrollDetection();

//       var thumbSize = _this.thumbXElement.clientWidth;
//       var trackInnerSize = getInnerWidth(_this.trackXElement);
//       var thumbOffset = (_this.scrollValues.isRTL && shouldReverseRtlScroll() ? values.offset + thumbSize / 2 - trackInnerSize : values.offset - thumbSize / 2) - (Number.parseFloat(getComputedStyle(_this.trackXElement).paddingLeft) || 0);
//       var target = calcScrollForThumbOffset(_this.scrollValues.scrollWidth, _this.scrollValues.clientWidth, trackInnerSize, thumbSize, thumbOffset);

//       if (_this.props.trackClickBehavior === TRACK_CLICK_BEHAVIOR.STEP) {
//         target = (_this.scrollValues.isRTL ? _this.scrollValues.scrollLeft > target : _this.scrollValues.scrollLeft < target) ? _this.scrollValues.scrollLeft + _this.scrollValues.clientWidth : _this.scrollValues.scrollLeft - _this.scrollValues.clientWidth;
//       }

//       _this.scrollerElement.scrollLeft = target;
//     };

//     _this.handleTrackYClick = function (ev, values) {
//       if (_this.props.trackYProps.onClick) _this.props.trackYProps.onClick(ev, values);

//       if (!_this.scrollerElement || !_this.trackYElement || !_this.thumbYElement || !_this.scrollValues || !_this.scrollValues.scrollYPossible) {
//         return;
//       }

//       _this._scrollDetection();

//       var thumbSize = _this.thumbYElement.clientHeight;
//       var target = calcScrollForThumbOffset(_this.scrollValues.scrollHeight, _this.scrollValues.clientHeight, getInnerHeight(_this.trackYElement), thumbSize, values.offset - thumbSize / 2) - (Number.parseFloat(getComputedStyle(_this.trackYElement).paddingTop) || 0);

//       if (_this.props.trackClickBehavior === TRACK_CLICK_BEHAVIOR.JUMP) {
//         _this.scrollerElement.scrollTop = target;
//       } else {
//         _this.scrollerElement.scrollTop = _this.scrollValues.scrollTop < target ? _this.scrollValues.scrollTop + _this.scrollValues.clientHeight : _this.scrollValues.scrollTop - _this.scrollValues.clientHeight;
//       }
//     };

//     _this.handleTrackYMouseWheel = function (ev) {
//       var props = _this.props;

//       if (props.trackYProps && props.trackYProps.onWheel) {
//         props.trackYProps.onWheel(ev);
//       }

//       if (props.disableTracksMousewheelScrolling || props.disableTrackYMousewheelScrolling) {
//         return;
//       }

//       _this._scrollDetection();

//       if (!_this.scrollerElement || _this.scrollValues.scrollYBlocked) {
//         return;
//       }

//       _this.scrollTop += ev.deltaY;
//     };

//     _this.handleTrackXMouseWheel = function (ev) {
//       var props = _this.props;

//       if (props.trackXProps && props.trackXProps.onWheel) {
//         props.trackXProps.onWheel(ev);
//       }

//       if (props.disableTracksMousewheelScrolling || props.disableTrackXMousewheelScrolling) {
//         return;
//       }

//       _this._scrollDetection();

//       if (!_this.scrollerElement || _this.scrollValues.scrollXBlocked) {
//         return;
//       }

//       _this.scrollLeft += ev.deltaX;
//     };

//     _this.handleThumbXDrag = function (data) {
//       var _a;

//       if (!_this.trackXElement || !_this.thumbXElement || !_this.scrollerElement || !_this.scrollValues || !_this.scrollValues.scrollXPossible) {
//         return;
//       }

//       _this._scrollDetection();

//       var trackRect = _this.trackXElement.getBoundingClientRect();

//       var styles = getComputedStyle(_this.trackXElement);
//       var paddingLeft = Number.parseFloat(styles.paddingLeft) || 0;
//       var paddingRight = Number.parseFloat(styles.paddingRight) || 0;
//       var trackInnerSize = trackRect.width - paddingLeft - paddingRight;
//       var thumbSize = _this.thumbXElement.clientWidth;
//       var offset = _this.scrollValues.isRTL && shouldReverseRtlScroll() ? data.x + thumbSize - trackInnerSize + paddingLeft : data.lastX - paddingLeft;
//       _this.scrollerElement.scrollLeft = calcScrollForThumbOffset(_this.scrollValues.scrollWidth, _this.scrollValues.clientWidth, trackInnerSize, thumbSize, offset);

//       if ((_a = _this.props.thumbXProps) === null || _a === void 0 ? void 0 : _a.onDrag) {
//         _this.props.thumbXProps.onDrag(data);
//       }
//     };

//     _this.handleThumbXDragEnd = function (data) {
//       var _a;

//       _this.handleThumbXDrag(data);

//       if ((_a = _this.props.thumbXProps) === null || _a === void 0 ? void 0 : _a.onDragEnd) {
//         _this.props.thumbXProps.onDragEnd(data);
//       }
//     };

//     _this.handleThumbYDrag = function (data) {
//       var _a;

//       if (!_this.scrollerElement || !_this.trackYElement || !_this.thumbYElement || !_this.scrollValues || !_this.scrollValues.scrollYPossible) {
//         return;
//       }

//       _this._scrollDetection();

//       var trackRect = _this.trackYElement.getBoundingClientRect();

//       var styles = getComputedStyle(_this.trackYElement);
//       var paddingTop = Number.parseFloat(styles.paddingTop) || 0;
//       var paddingBottom = Number.parseFloat(styles.paddingBottom) || 0;
//       var trackInnerSize = trackRect.height - paddingTop - paddingBottom;
//       var thumbSize = _this.thumbYElement.clientHeight;
//       var offset = data.y - paddingTop;
//       _this.scrollerElement.scrollTop = calcScrollForThumbOffset(_this.scrollValues.scrollHeight, _this.scrollValues.clientHeight, trackInnerSize, thumbSize, offset);

//       if ((_a = _this.props.thumbYProps) === null || _a === void 0 ? void 0 : _a.onDrag) {
//         _this.props.thumbYProps.onDrag(data);
//       }
//     };

//     _this.handleThumbYDragEnd = function (data) {
//       var _a;

//       _this.handleThumbYDrag(data);

//       if ((_a = _this.props.thumbYProps) === null || _a === void 0 ? void 0 : _a.onDragEnd) {
//         _this.props.thumbYProps.onDragEnd(data);
//       }
//     };

//     _this.handleScrollerScroll = function () {
//       _this._scrollDetection();
//     };

//     _this._scrollDetection = function () {
//       if (!_this._scrollDetectionTO) {
//         _this.eventEmitter.emit('scrollStart', _this.getScrollState());
//       } else if (isBrowser$2) {
//         window.clearTimeout(_this._scrollDetectionTO);
//       }

//       _this._scrollDetectionTO = isBrowser$2 ? window.setTimeout(_this._scrollDetectionCallback, _this.props.scrollDetectionThreshold || 0) : null;
//     };

//     _this._scrollDetectionCallback = function () {
//       _this._scrollDetectionTO = null;

//       _this.eventEmitter.emit('scrollStop', _this.getScrollState());
//     };

//     _this.state = {
//       trackXVisible: false,
//       trackYVisible: false,
//       isRTL: props.rtl
//     };
//     _this.scrollValues = _this.getScrollState(true);
//     _this.eventEmitter = new Emittr(15);
//     if (props.onUpdate) _this.eventEmitter.on('update', props.onUpdate);
//     if (props.onScroll) _this.eventEmitter.on('scroll', props.onScroll);
//     if (props.onScrollStart) _this.eventEmitter.on('scrollStart', props.onScrollStart);
//     if (props.onScrollStop) _this.eventEmitter.on('scrollStop', props.onScrollStop);
//     _this.id = uuid();
//     return _this;
//   }

//   Object.defineProperty(Scrollbar.prototype, "scrollTop", {
//     // eslint-disable-next-line react/sort-comp
//     get: function get() {
//       if (this.scrollerElement) {
//         return this.scrollerElement.scrollTop;
//       }

//       return 0;
//     },
//     set: function set(top) {
//       if (this.scrollerElement) {
//         this.scrollerElement.scrollTop = top;
//         this.update();
//       }
//     },
//     enumerable: false,
//     configurable: true
//   });
//   Object.defineProperty(Scrollbar.prototype, "scrollLeft", {
//     get: function get() {
//       if (this.scrollerElement) {
//         return this.scrollerElement.scrollLeft;
//       }

//       return 0;
//     },
//     set: function set(left) {
//       if (this.scrollerElement) {
//         this.scrollerElement.scrollLeft = left;
//       }
//     },
//     enumerable: false,
//     configurable: true
//   });
//   Object.defineProperty(Scrollbar.prototype, "scrollHeight", {
//     get: function get() {
//       if (this.scrollerElement) {
//         return this.scrollerElement.scrollHeight;
//       }

//       return 0;
//     },
//     enumerable: false,
//     configurable: true
//   });
//   Object.defineProperty(Scrollbar.prototype, "scrollWidth", {
//     get: function get() {
//       if (this.scrollerElement) {
//         return this.scrollerElement.scrollWidth;
//       }

//       return 0;
//     },
//     enumerable: false,
//     configurable: true
//   });
//   Object.defineProperty(Scrollbar.prototype, "clientHeight", {
//     get: function get() {
//       if (this.scrollerElement) {
//         return this.scrollerElement.clientHeight;
//       }

//       return 0;
//     },
//     enumerable: false,
//     configurable: true
//   });
//   Object.defineProperty(Scrollbar.prototype, "clientWidth", {
//     get: function get() {
//       if (this.scrollerElement) {
//         return this.scrollerElement.clientWidth;
//       }

//       return 0;
//     },
//     enumerable: false,
//     configurable: true
//   }); // eslint-disable-next-line react/sort-comp

//   Scrollbar.calculateStyles = function (props, state, scrollValues, scrollbarWidth) {
//     var _a, _b, _c, _d;

//     var useDefaultStyles = !props.noDefaultStyles;
//     return {
//       holder: __assign$1(__assign$1(__assign$1({}, useDefaultStyles && style$2.holder), {
//         position: 'relative'
//       }), props.style),
//       wrapper: __assign$1(__assign$1(__assign$1({}, useDefaultStyles && __assign$1(__assign$1(__assign$1({}, style$2.wrapper), !props.disableTracksWidthCompensation && !props.disableTrackYWidthCompensation && (_a = {}, _a[state.isRTL ? 'left' : 'right'] = state.trackYVisible ? 10 : 0, _a)), !props.disableTracksWidthCompensation && !props.disableTrackXWidthCompensation && {
//         bottom: state.trackXVisible ? 10 : 0
//       })), props.wrapperProps.style), {
//         position: 'absolute',
//         overflow: 'hidden'
//       }),
//       content: __assign$1(__assign$1(__assign$1(__assign$1(__assign$1({}, useDefaultStyles && style$2.content), props.translateContentSizesToHolder || props.translateContentSizeYToHolder || props.translateContentSizeXToHolder ? {
//         display: 'table-cell'
//       } : {
//         padding: 0.05 // needed to disable margin collapsing without flexboxes, other possible solutions here: https://stackoverflow.com/questions/19718634/how-to-disable-margin-collapsing

//       }), useDefaultStyles && !(props.translateContentSizesToHolder || props.translateContentSizeYToHolder) && {
//         minHeight: '100%'
//       }), useDefaultStyles && !(props.translateContentSizesToHolder || props.translateContentSizeXToHolder) && {
//         minWidth: '100%'
//       }), props.contentProps.style),
//       scroller: __assign$1(__assign$1(__assign$1(__assign$1((_b = {
//         position: 'absolute',
//         top: 0,
//         left: 0,
//         bottom: 0,
//         right: 0,
//         paddingBottom: !scrollbarWidth && scrollValues.scrollXPossible ? props.fallbackScrollbarWidth : undefined
//       }, _b[state.isRTL ? 'paddingLeft' : 'paddingRight'] = !scrollbarWidth && scrollValues.scrollYPossible ? props.fallbackScrollbarWidth : undefined, _b), props.scrollerProps.style), !isUndef(props.rtl) && {
//         direction: props.rtl ? 'rtl' : 'ltr'
//       }), props.momentum && {
//         WebkitOverflowScrolling: 'touch'
//       }), (_c = {
//         overflowY: scrollValues.scrollYPossible ? 'scroll' : 'hidden',
//         overflowX: scrollValues.scrollXPossible ? 'scroll' : 'hidden',
//         marginBottom: scrollValues.scrollXPossible ? -(scrollbarWidth || props.fallbackScrollbarWidth) - Number(scrollValues.zoomLevel !== 1) : undefined
//       }, _c[state.isRTL ? 'marginLeft' : 'marginRight'] = scrollValues.scrollYPossible ? -(scrollbarWidth || props.fallbackScrollbarWidth) - Number(scrollValues.zoomLevel !== 1) : undefined, _c)),
//       trackX: __assign$1(__assign$1(__assign$1(__assign$1({}, useDefaultStyles && style$2.track.common), useDefaultStyles && style$2.track.x), props.trackXProps.style), !state.trackXVisible && {
//         display: 'none'
//       }),
//       trackY: __assign$1(__assign$1(__assign$1(__assign$1(__assign$1({}, useDefaultStyles && style$2.track.common), useDefaultStyles && style$2.track.y), useDefaultStyles && (_d = {}, _d[state.isRTL ? 'left' : 'right'] = 0, _d)), props.trackYProps.style), !state.trackYVisible && {
//         display: 'none'
//       }),
//       thumbX: __assign$1(__assign$1(__assign$1({}, useDefaultStyles && style$2.thumb.common), useDefaultStyles && style$2.thumb.x), props.thumbXProps.style),
//       thumbY: __assign$1(__assign$1(__assign$1({}, useDefaultStyles && style$2.thumb.common), useDefaultStyles && style$2.thumb.y), props.thumbYProps.style)
//     };
//   };

//   Scrollbar.prototype.componentDidMount = function () {
//     if (!this.scrollerElement) {
//       this.setState(function () {
//         throw new Error("scroller element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
//       });
//       return;
//     }

//     if (!this.contentElement) {
//       this.setState(function () {
//         throw new Error("content element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
//       });
//       return;
//     }

//     var props = this.props;

//     if (!props.native && !props.mobileNative) {
//       // ToDo: move native state to the state so it can be synchronized
//       if (!this.holderElement) {
//         this.setState(function () {
//           throw new Error("holder element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
//         });
//         return;
//       }

//       if (!this.wrapperElement) {
//         this.setState(function () {
//           throw new Error("wrapper element was not created. Possibly you haven't provided HTMLDivElement to renderer's `elementRef` function.");
//         });
//         return;
//       }
//     }

//     Loop.addTarget(this);

//     if (!isUndef(props.scrollTop)) {
//       this.scrollerElement.scrollTop = props.scrollTop;
//     }

//     if (!isUndef(props.scrollLeft)) {
//       this.scrollerElement.scrollLeft = props.scrollLeft;
//     }

//     this.update(true);
//   };

//   Scrollbar.prototype.componentWillUnmount = function () {
//     Loop.removeTarget(this);
//   };

//   Scrollbar.prototype.componentDidUpdate = function (prevProps, prevState) {
//     if (!this.scrollerElement) {
//       return;
//     }

//     var props = this.props;

//     if (props.rtl !== prevProps.rtl && props.rtl !== this.state.isRTL) {
//       this.setState({
//         isRTL: props.rtl
//       });
//     }

//     if (this.state.isRTL !== prevState.isRTL) {
//       this.update();
//     }

//     if (!isUndef(props.scrollTop) && props.scrollTop !== this.scrollerElement.scrollTop) {
//       this.scrollerElement.scrollTop = props.scrollTop;
//     }

//     if (!isUndef(props.scrollLeft) && props.scrollLeft !== this.scrollerElement.scrollLeft) {
//       this.scrollerElement.scrollLeft = props.scrollLeft;
//     }

//     if (prevProps.onUpdate !== props.onUpdate) {
//       if (prevProps.onUpdate) this.eventEmitter.off('update', prevProps.onUpdate);
//       if (props.onUpdate) this.eventEmitter.on('update', props.onUpdate);
//     }

//     if (prevProps.onScroll !== props.onScroll) {
//       if (prevProps.onScroll) this.eventEmitter.off('scroll', prevProps.onScroll);
//       if (props.onScroll) this.eventEmitter.on('scroll', props.onScroll);
//     }

//     if (prevProps.onScrollStart !== props.onScrollStart) {
//       if (prevProps.onScrollStart) this.eventEmitter.off('scrollStart', prevProps.onScrollStart);
//       if (props.onScrollStart) this.eventEmitter.on('scrollStart', props.onScrollStart);
//     }

//     if (prevProps.onScrollStop !== props.onScrollStop) {
//       if (prevProps.onScrollStop) this.eventEmitter.off('scrollStop', prevProps.onScrollStop);
//       if (props.onScrollStop) this.eventEmitter.on('scrollStop', props.onScrollStop);
//     }
//   }; // eslint-disable-next-line react/sort-comp


//   Scrollbar.prototype.render = function () {
//     var _a = this.props,
//         createContext = _a.createContext,
//         rtl = _a.rtl,
//         native = _a.native,
//         mobileNative = _a.mobileNative,
//         momentum = _a.momentum;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.noDefaultStyles;
//         var disableTracksMousewheelScrolling = _a.disableTracksMousewheelScrolling,
//         disableTrackXMousewheelScrolling = _a.disableTrackXMousewheelScrolling,
//         disableTrackYMousewheelScrolling = _a.disableTrackYMousewheelScrolling;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.disableTracksWidthCompensation;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.disableTrackXWidthCompensation;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.disableTrackYWidthCompensation;
//         var noScrollX = _a.noScrollX,
//         noScrollY = _a.noScrollY,
//         noScroll = _a.noScroll,
//         permanentTrackX = _a.permanentTrackX,
//         permanentTrackY = _a.permanentTrackY,
//         permanentTracks = _a.permanentTracks,
//         removeTracksWhenNotUsed = _a.removeTracksWhenNotUsed,
//         removeTrackYWhenNotUsed = _a.removeTrackYWhenNotUsed,
//         removeTrackXWhenNotUsed = _a.removeTrackXWhenNotUsed;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.minimalThumbSize;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.maximalThumbSize;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.minimalThumbXSize;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.maximalThumbXSize;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.minimalThumbYSize;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.maximalThumbYSize;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.fallbackScrollbarWidth;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.scrollTop;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.scrollLeft;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.trackClickBehavior;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.scrollDetectionThreshold;
//         var propsWrapperProps = _a.wrapperProps,
//         propsScrollerProps = _a.scrollerProps,
//         propsContentProps = _a.contentProps,
//         propsTrackXProps = _a.trackXProps,
//         propsTrackYProps = _a.trackYProps,
//         propsThumbXProps = _a.thumbXProps,
//         propsThumbYProps = _a.thumbYProps,
//         propsScrollbarWidth = _a.scrollbarWidth;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.elementRef;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onUpdate;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onScroll;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onScrollStart;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.onScrollStop;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.translateContentSizesToHolder;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.translateContentSizeYToHolder;
//         // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     _a.translateContentSizeXToHolder;
//         var children = _a.children,
//         propsHolderProps = __rest$1(_a, ["createContext", "rtl", "native", "mobileNative", "momentum", "noDefaultStyles", "disableTracksMousewheelScrolling", "disableTrackXMousewheelScrolling", "disableTrackYMousewheelScrolling", "disableTracksWidthCompensation", "disableTrackXWidthCompensation", "disableTrackYWidthCompensation", "noScrollX", "noScrollY", "noScroll", "permanentTrackX", "permanentTrackY", "permanentTracks", "removeTracksWhenNotUsed", "removeTrackYWhenNotUsed", "removeTrackXWhenNotUsed", "minimalThumbSize", "maximalThumbSize", "minimalThumbXSize", "maximalThumbXSize", "minimalThumbYSize", "maximalThumbYSize", "fallbackScrollbarWidth", "scrollTop", "scrollLeft", "trackClickBehavior", "scrollDetectionThreshold", "wrapperProps", "scrollerProps", "contentProps", "trackXProps", "trackYProps", "thumbXProps", "thumbYProps", "scrollbarWidth", "elementRef", "onUpdate", "onScroll", "onScrollStart", "onScrollStop", "translateContentSizesToHolder", "translateContentSizeYToHolder", "translateContentSizeXToHolder", "children"]);

//     var scrollbarWidth = !isUndef(propsScrollbarWidth) ? propsScrollbarWidth : getScrollbarWidth() || 0;

//     if (native || !scrollbarWidth && mobileNative) {
//       this.elementRefHolder(null);
//       this.elementRefWrapper(null);
//       this.elementRefTrackX(null);
//       this.elementRefTrackY(null);
//       this.elementRefThumbX(null);
//       this.elementRefThumbY(null);

//       var contentProps_1 = __assign$1(__assign$1({}, propsContentProps), {
//         key: 'ScrollbarsCustom-Content',
//         className: cnb('ScrollbarsCustom-Content', propsContentProps.className),
//         children: children
//       });

//       var scrollerProps_1 = __assign$1(__assign$1({}, propsHolderProps), {
//         className: cnb('ScrollbarsCustom native', this.state.trackYVisible && 'trackYVisible', this.state.trackXVisible && 'trackXVisible', this.state.isRTL && 'rtl', propsHolderProps.className),
//         style: __assign$1(__assign$1(__assign$1(__assign$1({}, propsHolderProps.style), !isUndef(rtl) && {
//           direction: rtl ? 'rtl' : 'ltr'
//         }), momentum && {
//           WebkitOverflowScrolling: 'touch'
//         }), {
//           overflowX: noScroll || noScrollX ? 'hidden' : permanentTracks || permanentTrackX ? 'scroll' : 'auto',
//           overflowY: noScroll || noScrollY ? 'hidden' : permanentTracks || permanentTrackY ? 'scroll' : 'auto'
//         }),
//         onScroll: this.handleScrollerScroll,
//         children: renderDivWithRenderer(contentProps_1, this.elementRefContent),
//         renderer: propsScrollerProps.renderer,
//         elementRef: propsScrollerProps.elementRef
//       });

//       return renderDivWithRenderer(scrollerProps_1, this.elementRefScroller);
//     }

//     var styles = Scrollbar.calculateStyles(this.props, this.state, this.scrollValues, scrollbarWidth);
//     var holderChildren = [];

//     var contentProps = __assign$1(__assign$1({}, propsContentProps), {
//       key: 'ScrollbarsCustom-Content',
//       className: cnb('ScrollbarsCustom-Content', propsContentProps.className),
//       style: styles.content,
//       children: createContext ? // eslint-disable-next-line react/jsx-no-constructed-context-values
//       React.createElement(ScrollbarContext.Provider, {
//         value: {
//           parentScrollbar: this
//         }
//       }, children) : children
//     });

//     var scrollerProps = __assign$1(__assign$1({}, propsScrollerProps), {
//       key: 'ScrollbarsCustom-Scroller',
//       className: cnb('ScrollbarsCustom-Scroller', propsScrollerProps.className),
//       style: styles.scroller,
//       children: renderDivWithRenderer(contentProps, this.elementRefContent),
//       onScroll: this.handleScrollerScroll
//     });

//     var wrapperProps = __assign$1(__assign$1({}, propsWrapperProps), {
//       key: 'ScrollbarsCustom-Wrapper',
//       className: cnb('ScrollbarsCustom-Wrapper', propsWrapperProps.className),
//       style: styles.wrapper,
//       children: renderDivWithRenderer(scrollerProps, this.elementRefScroller)
//     });

//     holderChildren.push(renderDivWithRenderer(wrapperProps, this.elementRefWrapper));

//     if (this.state.trackYVisible || !removeTracksWhenNotUsed && !removeTrackYWhenNotUsed) {
//       var thumbYProps = __assign$1(__assign$1({}, propsThumbYProps), {
//         key: 'ScrollbarsCustom-ThumbY',
//         style: styles.thumbY,
//         elementRef: this.elementRefThumbY,
//         onDrag: this.handleThumbYDrag,
//         onDragEnd: this.handleThumbYDragEnd,
//         axis: AXIS_DIRECTION.Y
//       });

//       var trackYProps = __assign$1(__assign$1(__assign$1(__assign$1({}, propsTrackYProps), {
//         key: 'ScrollbarsCustom-TrackY',
//         style: styles.trackY,
//         elementRef: this.elementRefTrackY,
//         onClick: this.handleTrackYClick
//       }), (disableTracksMousewheelScrolling || disableTrackYMousewheelScrolling) && {
//         onWheel: this.handleTrackYMouseWheel
//       }), {
//         axis: AXIS_DIRECTION.Y
//       });

//       trackYProps.children = React.createElement(ScrollbarThumb, __assign$1({}, thumbYProps));
//       holderChildren.push(React.createElement(ScrollbarTrack, __assign$1({}, trackYProps)));
//     } else {
//       this.elementRefTrackY(null);
//       this.elementRefThumbY(null);
//     }

//     if (this.state.trackXVisible || !removeTracksWhenNotUsed && !removeTrackXWhenNotUsed) {
//       var thumbXProps = __assign$1(__assign$1({}, propsThumbXProps), {
//         key: 'ScrollbarsCustom-ThumbX',
//         style: styles.thumbX,
//         elementRef: this.elementRefThumbX,
//         onDrag: this.handleThumbXDrag,
//         onDragEnd: this.handleThumbXDragEnd,
//         axis: AXIS_DIRECTION.X
//       });

//       var trackXProps = __assign$1(__assign$1(__assign$1(__assign$1({}, propsTrackXProps), {
//         key: 'ScrollbarsCustom-TrackX',
//         style: styles.trackX,
//         elementRef: this.elementRefTrackX,
//         onClick: this.handleTrackXClick
//       }), (disableTracksMousewheelScrolling || disableTrackXMousewheelScrolling) && {
//         onWheel: this.handleTrackXMouseWheel
//       }), {
//         axis: AXIS_DIRECTION.X
//       });

//       trackXProps.children = React.createElement(ScrollbarThumb, __assign$1({}, thumbXProps));
//       holderChildren.push(React.createElement(ScrollbarTrack, __assign$1({}, trackXProps)));
//     } else {
//       this.elementRefTrackX(null);
//       this.elementRefThumbX(null);
//     }

//     var holderProps = __assign$1(__assign$1({}, propsHolderProps), {
//       className: cnb('ScrollbarsCustom', this.state.trackYVisible && 'trackYVisible', this.state.trackXVisible && 'trackXVisible', this.state.isRTL && 'rtl', propsHolderProps.className),
//       style: styles.holder,
//       children: holderChildren
//     });

//     return renderDivWithRenderer(holderProps, this.elementRefHolder);
//   }; // eslint-disable-next-line react/static-property-placement


//   Scrollbar.contextType = ScrollbarContext; // eslint-disable-next-line react/static-property-placement

//   Scrollbar.defaultProps = {
//     momentum: true,
//     minimalThumbSize: 30,
//     fallbackScrollbarWidth: 20,
//     trackClickBehavior: TRACK_CLICK_BEHAVIOR.JUMP,
//     scrollDetectionThreshold: 100,
//     wrapperProps: {},
//     scrollerProps: {},
//     contentProps: {},
//     trackXProps: {},
//     trackYProps: {},
//     thumbXProps: {},
//     thumbYProps: {}
//   };
//   return Scrollbar;
// }(React.Component);

// function _extends$u() {
//   _extends$u = Object.assign ? Object.assign.bind() : function (target) {
//     for (var i = 1; i < arguments.length; i++) {
//       var source = arguments[i];
//       for (var key in source) {
//         if (Object.prototype.hasOwnProperty.call(source, key)) {
//           target[key] = source[key];
//         }
//       }
//     }
//     return target;
//   };
//   return _extends$u.apply(this, arguments);
// }

// function _assertThisInitialized$c(self) {
//   if (self === void 0) {
//     throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
//   }
//   return self;
// }

// function _setPrototypeOf$d(o, p) {
//   _setPrototypeOf$d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
//     o.__proto__ = p;
//     return o;
//   };
//   return _setPrototypeOf$d(o, p);
// }

// function _inheritsLoose$1(subClass, superClass) {
//   subClass.prototype = Object.create(superClass.prototype);
//   subClass.prototype.constructor = subClass;
//   _setPrototypeOf$d(subClass, superClass);
// }

// function _getPrototypeOf$c(o) {
//   _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
//     return o.__proto__ || Object.getPrototypeOf(o);
//   };
//   return _getPrototypeOf$c(o);
// }

// function _isNativeFunction(fn) {
//   try {
//     return Function.toString.call(fn).indexOf("[native code]") !== -1;
//   } catch (e) {
//     return typeof fn === "function";
//   }
// }

// function _isNativeReflectConstruct$d() {
//   if (typeof Reflect === "undefined" || !Reflect.construct) return false;
//   if (Reflect.construct.sham) return false;
//   if (typeof Proxy === "function") return true;
//   try {
//     Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
//     return true;
//   } catch (e) {
//     return false;
//   }
// }

// function _construct$1(Parent, args, Class) {
//   if (_isNativeReflectConstruct$d()) {
//     _construct$1 = Reflect.construct.bind();
//   } else {
//     _construct$1 = function _construct(Parent, args, Class) {
//       var a = [null];
//       a.push.apply(a, args);
//       var Constructor = Function.bind.apply(Parent, a);
//       var instance = new Constructor();
//       if (Class) _setPrototypeOf$d(instance, Class.prototype);
//       return instance;
//     };
//   }
//   return _construct$1.apply(null, arguments);
// }

// function _wrapNativeSuper(Class) {
//   var _cache = typeof Map === "function" ? new Map() : undefined;
//   _wrapNativeSuper = function _wrapNativeSuper(Class) {
//     if (Class === null || !_isNativeFunction(Class)) return Class;
//     if (typeof Class !== "function") {
//       throw new TypeError("Super expression must either be null or a function");
//     }
//     if (typeof _cache !== "undefined") {
//       if (_cache.has(Class)) return _cache.get(Class);
//       _cache.set(Class, Wrapper);
//     }
//     function Wrapper() {
//       return _construct$1(Class, arguments, _getPrototypeOf$c(this).constructor);
//     }
//     Wrapper.prototype = Object.create(Class.prototype, {
//       constructor: {
//         value: Wrapper,
//         enumerable: false,
//         writable: true,
//         configurable: true
//       }
//     });
//     return _setPrototypeOf$d(Wrapper, Class);
//   };
//   return _wrapNativeSuper(Class);
// }

// // based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js

// /**
//  * Parse errors.md and turn it into a simple hash of code: message
//  * @private
//  */
// var ERRORS = {
//   "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
//   "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
//   "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
//   "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
//   "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
//   "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
//   "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
//   "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
//   "9": "Please provide a number of steps to the modularScale helper.\n\n",
//   "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
//   "11": "Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\n\n",
//   "12": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\n\n",
//   "13": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\n\n",
//   "14": "Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
//   "15": "Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
//   "16": "You must provide a template to this method.\n\n",
//   "17": "You passed an unsupported selector state to this method.\n\n",
//   "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
//   "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
//   "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
//   "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
//   "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
//   "23": "fontFace expects a name of a font-family.\n\n",
//   "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
//   "25": "fontFace expects localFonts to be an array.\n\n",
//   "26": "fontFace expects fileFormats to be an array.\n\n",
//   "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
//   "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
//   "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
//   "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
//   "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
//   "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
//   "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
//   "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
//   "35": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
//   "36": "Property must be a string value.\n\n",
//   "37": "Syntax Error at %s.\n\n",
//   "38": "Formula contains a function that needs parentheses at %s.\n\n",
//   "39": "Formula is missing closing parenthesis at %s.\n\n",
//   "40": "Formula has too many closing parentheses at %s.\n\n",
//   "41": "All values in a formula must have the same unit or be unitless.\n\n",
//   "42": "Please provide a number of steps to the modularScale helper.\n\n",
//   "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
//   "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
//   "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
//   "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
//   "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
//   "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
//   "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
//   "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
//   "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
//   "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
//   "53": "fontFace expects localFonts to be an array.\n\n",
//   "54": "fontFace expects fileFormats to be an array.\n\n",
//   "55": "fontFace expects a name of a font-family.\n\n",
//   "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
//   "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
//   "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
//   "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
//   "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
//   "61": "Property must be a string value.\n\n",
//   "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
//   "63": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
//   "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
//   "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
//   "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
//   "67": "You must provide a template to this method.\n\n",
//   "68": "You passed an unsupported selector state to this method.\n\n",
//   "69": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\n\n",
//   "70": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\n\n",
//   "71": "Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
//   "72": "Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
//   "73": "Please provide a valid CSS variable.\n\n",
//   "74": "CSS variable not found and no default was provided.\n\n",
//   "75": "important requires a valid style object, got a %s instead.\n\n",
//   "76": "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
//   "77": "remToPx expects a value in \"rem\" but you provided it in \"%s\".\n\n",
//   "78": "base must be set in \"px\" or \"%\" but you set it in \"%s\".\n"
// };
// /**
//  * super basic version of sprintf
//  * @private
//  */

// function format$1() {
//   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//     args[_key] = arguments[_key];
//   }

//   var a = args[0];
//   var b = [];
//   var c;

//   for (c = 1; c < args.length; c += 1) {
//     b.push(args[c]);
//   }

//   b.forEach(function (d) {
//     a = a.replace(/%[a-z]/, d);
//   });
//   return a;
// }
// /**
//  * Create an error file out of errors.md for development and a simple web link to the full errors
//  * in production mode.
//  * @private
//  */


// var PolishedError = /*#__PURE__*/function (_Error) {
//   _inheritsLoose$1(PolishedError, _Error);

//   function PolishedError(code) {
//     var _this;

//     if (process.env.NODE_ENV === 'production') {
//       _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
//     } else {
//       for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
//         args[_key2 - 1] = arguments[_key2];
//       }

//       _this = _Error.call(this, format$1.apply(void 0, [ERRORS[code]].concat(args))) || this;
//     }

//     return _assertThisInitialized$c(_this);
//   }

//   return PolishedError;
// }( /*#__PURE__*/_wrapNativeSuper(Error));

// function colorToInt(color) {
//   return Math.round(color * 255);
// }

// function convertToInt(red, green, blue) {
//   return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
// }

// function hslToRgb(hue, saturation, lightness, convert) {
//   if (convert === void 0) {
//     convert = convertToInt;
//   }

//   if (saturation === 0) {
//     // achromatic
//     return convert(lightness, lightness, lightness);
//   } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV


//   var huePrime = (hue % 360 + 360) % 360 / 60;
//   var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
//   var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
//   var red = 0;
//   var green = 0;
//   var blue = 0;

//   if (huePrime >= 0 && huePrime < 1) {
//     red = chroma;
//     green = secondComponent;
//   } else if (huePrime >= 1 && huePrime < 2) {
//     red = secondComponent;
//     green = chroma;
//   } else if (huePrime >= 2 && huePrime < 3) {
//     green = chroma;
//     blue = secondComponent;
//   } else if (huePrime >= 3 && huePrime < 4) {
//     green = secondComponent;
//     blue = chroma;
//   } else if (huePrime >= 4 && huePrime < 5) {
//     red = secondComponent;
//     blue = chroma;
//   } else if (huePrime >= 5 && huePrime < 6) {
//     red = chroma;
//     blue = secondComponent;
//   }

//   var lightnessModification = lightness - chroma / 2;
//   var finalRed = red + lightnessModification;
//   var finalGreen = green + lightnessModification;
//   var finalBlue = blue + lightnessModification;
//   return convert(finalRed, finalGreen, finalBlue);
// }

// var namedColorMap = {
//   aliceblue: 'f0f8ff',
//   antiquewhite: 'faebd7',
//   aqua: '00ffff',
//   aquamarine: '7fffd4',
//   azure: 'f0ffff',
//   beige: 'f5f5dc',
//   bisque: 'ffe4c4',
//   black: '000',
//   blanchedalmond: 'ffebcd',
//   blue: '0000ff',
//   blueviolet: '8a2be2',
//   brown: 'a52a2a',
//   burlywood: 'deb887',
//   cadetblue: '5f9ea0',
//   chartreuse: '7fff00',
//   chocolate: 'd2691e',
//   coral: 'ff7f50',
//   cornflowerblue: '6495ed',
//   cornsilk: 'fff8dc',
//   crimson: 'dc143c',
//   cyan: '00ffff',
//   darkblue: '00008b',
//   darkcyan: '008b8b',
//   darkgoldenrod: 'b8860b',
//   darkgray: 'a9a9a9',
//   darkgreen: '006400',
//   darkgrey: 'a9a9a9',
//   darkkhaki: 'bdb76b',
//   darkmagenta: '8b008b',
//   darkolivegreen: '556b2f',
//   darkorange: 'ff8c00',
//   darkorchid: '9932cc',
//   darkred: '8b0000',
//   darksalmon: 'e9967a',
//   darkseagreen: '8fbc8f',
//   darkslateblue: '483d8b',
//   darkslategray: '2f4f4f',
//   darkslategrey: '2f4f4f',
//   darkturquoise: '00ced1',
//   darkviolet: '9400d3',
//   deeppink: 'ff1493',
//   deepskyblue: '00bfff',
//   dimgray: '696969',
//   dimgrey: '696969',
//   dodgerblue: '1e90ff',
//   firebrick: 'b22222',
//   floralwhite: 'fffaf0',
//   forestgreen: '228b22',
//   fuchsia: 'ff00ff',
//   gainsboro: 'dcdcdc',
//   ghostwhite: 'f8f8ff',
//   gold: 'ffd700',
//   goldenrod: 'daa520',
//   gray: '808080',
//   green: '008000',
//   greenyellow: 'adff2f',
//   grey: '808080',
//   honeydew: 'f0fff0',
//   hotpink: 'ff69b4',
//   indianred: 'cd5c5c',
//   indigo: '4b0082',
//   ivory: 'fffff0',
//   khaki: 'f0e68c',
//   lavender: 'e6e6fa',
//   lavenderblush: 'fff0f5',
//   lawngreen: '7cfc00',
//   lemonchiffon: 'fffacd',
//   lightblue: 'add8e6',
//   lightcoral: 'f08080',
//   lightcyan: 'e0ffff',
//   lightgoldenrodyellow: 'fafad2',
//   lightgray: 'd3d3d3',
//   lightgreen: '90ee90',
//   lightgrey: 'd3d3d3',
//   lightpink: 'ffb6c1',
//   lightsalmon: 'ffa07a',
//   lightseagreen: '20b2aa',
//   lightskyblue: '87cefa',
//   lightslategray: '789',
//   lightslategrey: '789',
//   lightsteelblue: 'b0c4de',
//   lightyellow: 'ffffe0',
//   lime: '0f0',
//   limegreen: '32cd32',
//   linen: 'faf0e6',
//   magenta: 'f0f',
//   maroon: '800000',
//   mediumaquamarine: '66cdaa',
//   mediumblue: '0000cd',
//   mediumorchid: 'ba55d3',
//   mediumpurple: '9370db',
//   mediumseagreen: '3cb371',
//   mediumslateblue: '7b68ee',
//   mediumspringgreen: '00fa9a',
//   mediumturquoise: '48d1cc',
//   mediumvioletred: 'c71585',
//   midnightblue: '191970',
//   mintcream: 'f5fffa',
//   mistyrose: 'ffe4e1',
//   moccasin: 'ffe4b5',
//   navajowhite: 'ffdead',
//   navy: '000080',
//   oldlace: 'fdf5e6',
//   olive: '808000',
//   olivedrab: '6b8e23',
//   orange: 'ffa500',
//   orangered: 'ff4500',
//   orchid: 'da70d6',
//   palegoldenrod: 'eee8aa',
//   palegreen: '98fb98',
//   paleturquoise: 'afeeee',
//   palevioletred: 'db7093',
//   papayawhip: 'ffefd5',
//   peachpuff: 'ffdab9',
//   peru: 'cd853f',
//   pink: 'ffc0cb',
//   plum: 'dda0dd',
//   powderblue: 'b0e0e6',
//   purple: '800080',
//   rebeccapurple: '639',
//   red: 'f00',
//   rosybrown: 'bc8f8f',
//   royalblue: '4169e1',
//   saddlebrown: '8b4513',
//   salmon: 'fa8072',
//   sandybrown: 'f4a460',
//   seagreen: '2e8b57',
//   seashell: 'fff5ee',
//   sienna: 'a0522d',
//   silver: 'c0c0c0',
//   skyblue: '87ceeb',
//   slateblue: '6a5acd',
//   slategray: '708090',
//   slategrey: '708090',
//   snow: 'fffafa',
//   springgreen: '00ff7f',
//   steelblue: '4682b4',
//   tan: 'd2b48c',
//   teal: '008080',
//   thistle: 'd8bfd8',
//   tomato: 'ff6347',
//   turquoise: '40e0d0',
//   violet: 'ee82ee',
//   wheat: 'f5deb3',
//   white: 'fff',
//   whitesmoke: 'f5f5f5',
//   yellow: 'ff0',
//   yellowgreen: '9acd32'
// };
// /**
//  * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
//  * @private
//  */

// function nameToHex(color) {
//   if (typeof color !== 'string') return color;
//   var normalizedColorName = color.toLowerCase();
//   return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
// }

// var hexRegex = /^#[a-fA-F0-9]{6}$/;
// var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
// var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
// var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
// var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
// var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
// var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
// var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
// /**
//  * Returns an RgbColor or RgbaColor object. This utility function is only useful
//  * if want to extract a color component. With the color util `toColorString` you
//  * can convert a RgbColor or RgbaColor object back to a string.
//  *
//  * @example
//  * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
//  * const color1 = parseToRgb('rgb(255, 0, 0)');
//  * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
//  * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
//  */

// function parseToRgb(color) {
//   if (typeof color !== 'string') {
//     throw new PolishedError(3);
//   }

//   var normalizedColor = nameToHex(color);

//   if (normalizedColor.match(hexRegex)) {
//     return {
//       red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
//       green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
//       blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
//     };
//   }

//   if (normalizedColor.match(hexRgbaRegex)) {
//     var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
//     return {
//       red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
//       green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
//       blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
//       alpha: alpha
//     };
//   }

//   if (normalizedColor.match(reducedHexRegex)) {
//     return {
//       red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
//       green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
//       blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
//     };
//   }

//   if (normalizedColor.match(reducedRgbaHexRegex)) {
//     var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));

//     return {
//       red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
//       green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
//       blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
//       alpha: _alpha
//     };
//   }

//   var rgbMatched = rgbRegex.exec(normalizedColor);

//   if (rgbMatched) {
//     return {
//       red: parseInt("" + rgbMatched[1], 10),
//       green: parseInt("" + rgbMatched[2], 10),
//       blue: parseInt("" + rgbMatched[3], 10)
//     };
//   }

//   var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));

//   if (rgbaMatched) {
//     return {
//       red: parseInt("" + rgbaMatched[1], 10),
//       green: parseInt("" + rgbaMatched[2], 10),
//       blue: parseInt("" + rgbaMatched[3], 10),
//       alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
//     };
//   }

//   var hslMatched = hslRegex.exec(normalizedColor);

//   if (hslMatched) {
//     var hue = parseInt("" + hslMatched[1], 10);
//     var saturation = parseInt("" + hslMatched[2], 10) / 100;
//     var lightness = parseInt("" + hslMatched[3], 10) / 100;
//     var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
//     var hslRgbMatched = rgbRegex.exec(rgbColorString);

//     if (!hslRgbMatched) {
//       throw new PolishedError(4, normalizedColor, rgbColorString);
//     }

//     return {
//       red: parseInt("" + hslRgbMatched[1], 10),
//       green: parseInt("" + hslRgbMatched[2], 10),
//       blue: parseInt("" + hslRgbMatched[3], 10)
//     };
//   }

//   var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));

//   if (hslaMatched) {
//     var _hue = parseInt("" + hslaMatched[1], 10);

//     var _saturation = parseInt("" + hslaMatched[2], 10) / 100;

//     var _lightness = parseInt("" + hslaMatched[3], 10) / 100;

//     var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";

//     var _hslRgbMatched = rgbRegex.exec(_rgbColorString);

//     if (!_hslRgbMatched) {
//       throw new PolishedError(4, normalizedColor, _rgbColorString);
//     }

//     return {
//       red: parseInt("" + _hslRgbMatched[1], 10),
//       green: parseInt("" + _hslRgbMatched[2], 10),
//       blue: parseInt("" + _hslRgbMatched[3], 10),
//       alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
//     };
//   }

//   throw new PolishedError(5);
// }

// function rgbToHsl(color) {
//   // make sure rgb are contained in a set of [0, 255]
//   var red = color.red / 255;
//   var green = color.green / 255;
//   var blue = color.blue / 255;
//   var max = Math.max(red, green, blue);
//   var min = Math.min(red, green, blue);
//   var lightness = (max + min) / 2;

//   if (max === min) {
//     // achromatic
//     if (color.alpha !== undefined) {
//       return {
//         hue: 0,
//         saturation: 0,
//         lightness: lightness,
//         alpha: color.alpha
//       };
//     } else {
//       return {
//         hue: 0,
//         saturation: 0,
//         lightness: lightness
//       };
//     }
//   }

//   var hue;
//   var delta = max - min;
//   var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);

//   switch (max) {
//     case red:
//       hue = (green - blue) / delta + (green < blue ? 6 : 0);
//       break;

//     case green:
//       hue = (blue - red) / delta + 2;
//       break;

//     default:
//       // blue case
//       hue = (red - green) / delta + 4;
//       break;
//   }

//   hue *= 60;

//   if (color.alpha !== undefined) {
//     return {
//       hue: hue,
//       saturation: saturation,
//       lightness: lightness,
//       alpha: color.alpha
//     };
//   }

//   return {
//     hue: hue,
//     saturation: saturation,
//     lightness: lightness
//   };
// }

// /**
//  * Returns an HslColor or HslaColor object. This utility function is only useful
//  * if want to extract a color component. With the color util `toColorString` you
//  * can convert a HslColor or HslaColor object back to a string.
//  *
//  * @example
//  * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1
//  * const color1 = parseToHsl('rgb(255, 0, 0)');
//  * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2
//  * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');
//  */
// function parseToHsl(color) {
//   // Note: At a later stage we can optimize this function as right now a hsl
//   // color would be parsed converted to rgb values and converted back to hsl.
//   return rgbToHsl(parseToRgb(color));
// }

// /**
//  * Reduces hex values if possible e.g. #ff8866 to #f86
//  * @private
//  */
// var reduceHexValue = function reduceHexValue(value) {
//   if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
//     return "#" + value[1] + value[3] + value[5];
//   }

//   return value;
// };

// var reduceHexValue$1 = reduceHexValue;

// function numberToHex(value) {
//   var hex = value.toString(16);
//   return hex.length === 1 ? "0" + hex : hex;
// }

// function colorToHex(color) {
//   return numberToHex(Math.round(color * 255));
// }

// function convertToHex(red, green, blue) {
//   return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
// }

// function hslToHex(hue, saturation, lightness) {
//   return hslToRgb(hue, saturation, lightness, convertToHex);
// }

// /**
//  * Returns a string value for the color. The returned result is the smallest possible hex notation.
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: hsl(359, 0.75, 0.4),
//  *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${hsl(359, 0.75, 0.4)};
//  *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};
//  * `
//  *
//  * // CSS in JS Output
//  *
//  * element {
//  *   background: "#b3191c";
//  *   background: "#b3191c";
//  * }
//  */
// function hsl(value, saturation, lightness) {
//   if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {
//     return hslToHex(value, saturation, lightness);
//   } else if (typeof value === 'object' && saturation === undefined && lightness === undefined) {
//     return hslToHex(value.hue, value.saturation, value.lightness);
//   }

//   throw new PolishedError(1);
// }

// /**
//  * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: hsla(359, 0.75, 0.4, 0.7),
//  *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),
//  *   background: hsla(359, 0.75, 0.4, 1),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${hsla(359, 0.75, 0.4, 0.7)};
//  *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};
//  *   background: ${hsla(359, 0.75, 0.4, 1)};
//  * `
//  *
//  * // CSS in JS Output
//  *
//  * element {
//  *   background: "rgba(179,25,28,0.7)";
//  *   background: "rgba(179,25,28,0.7)";
//  *   background: "#b3191c";
//  * }
//  */
// function hsla(value, saturation, lightness, alpha) {
//   if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {
//     return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
//   } else if (typeof value === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {
//     return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
//   }

//   throw new PolishedError(2);
// }

// /**
//  * Returns a string value for the color. The returned result is the smallest possible hex notation.
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: rgb(255, 205, 100),
//  *   background: rgb({ red: 255, green: 205, blue: 100 }),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${rgb(255, 205, 100)};
//  *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
//  * `
//  *
//  * // CSS in JS Output
//  *
//  * element {
//  *   background: "#ffcd64";
//  *   background: "#ffcd64";
//  * }
//  */
// function rgb(value, green, blue) {
//   if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
//     return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
//   } else if (typeof value === 'object' && green === undefined && blue === undefined) {
//     return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
//   }

//   throw new PolishedError(6);
// }

// /**
//  * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
//  *
//  * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: rgba(255, 205, 100, 0.7),
//  *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
//  *   background: rgba(255, 205, 100, 1),
//  *   background: rgba('#ffffff', 0.4),
//  *   background: rgba('black', 0.7),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${rgba(255, 205, 100, 0.7)};
//  *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
//  *   background: ${rgba(255, 205, 100, 1)};
//  *   background: ${rgba('#ffffff', 0.4)};
//  *   background: ${rgba('black', 0.7)};
//  * `
//  *
//  * // CSS in JS Output
//  *
//  * element {
//  *   background: "rgba(255,205,100,0.7)";
//  *   background: "rgba(255,205,100,0.7)";
//  *   background: "#ffcd64";
//  *   background: "rgba(255,255,255,0.4)";
//  *   background: "rgba(0,0,0,0.7)";
//  * }
//  */
// function rgba(firstValue, secondValue, thirdValue, fourthValue) {
//   if (typeof firstValue === 'string' && typeof secondValue === 'number') {
//     var rgbValue = parseToRgb(firstValue);
//     return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
//   } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
//     return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
//   } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
//     return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
//   }

//   throw new PolishedError(7);
// }

// var isRgb = function isRgb(color) {
//   return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
// };

// var isRgba = function isRgba(color) {
//   return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';
// };

// var isHsl = function isHsl(color) {
//   return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
// };

// var isHsla = function isHsla(color) {
//   return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';
// };
// /**
//  * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.
//  * This util is useful in case you only know on runtime which color object is
//  * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: toColorString({ red: 255, green: 205, blue: 100 }),
//  *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
//  *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
//  *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};
//  *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
//  *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
//  *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
//  * `
//  *
//  * // CSS in JS Output
//  * element {
//  *   background: "#ffcd64";
//  *   background: "rgba(255,205,100,0.72)";
//  *   background: "#00f";
//  *   background: "rgba(179,25,25,0.72)";
//  * }
//  */


// function toColorString(color) {
//   if (typeof color !== 'object') throw new PolishedError(8);
//   if (isRgba(color)) return rgba(color);
//   if (isRgb(color)) return rgb(color);
//   if (isHsla(color)) return hsla(color);
//   if (isHsl(color)) return hsl(color);
//   throw new PolishedError(8);
// }

// // Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
// // eslint-disable-next-line no-unused-vars
// // eslint-disable-next-line no-unused-vars
// // eslint-disable-next-line no-redeclare
// function curried(f, length, acc) {
//   return function fn() {
//     // eslint-disable-next-line prefer-rest-params
//     var combined = acc.concat(Array.prototype.slice.call(arguments));
//     return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
//   };
// } // eslint-disable-next-line no-redeclare


// function curry$1(f) {
//   // eslint-disable-line no-redeclare
//   return curried(f, f.length, []);
// }

// function guard(lowerBoundary, upperBoundary, value) {
//   return Math.max(lowerBoundary, Math.min(upperBoundary, value));
// }

// /**
//  * Returns a string value for the darkened color.
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: darken(0.2, '#FFCD64'),
//  *   background: darken('0.2', 'rgba(255,205,100,0.7)'),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${darken(0.2, '#FFCD64')};
//  *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};
//  * `
//  *
//  * // CSS in JS Output
//  *
//  * element {
//  *   background: "#ffbd31";
//  *   background: "rgba(255,189,49,0.7)";
//  * }
//  */

// function darken(amount, color) {
//   if (color === 'transparent') return color;
//   var hslColor = parseToHsl(color);
//   return toColorString(_extends$u({}, hslColor, {
//     lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
//   }));
// } // prettier-ignore


// var curriedDarken = /*#__PURE__*/curry$1
// /* ::<number | string, string, string> */
// (darken);
// var curriedDarken$1 = curriedDarken;

// /**
//  * Returns a string value for the lightened color.
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: lighten(0.2, '#CCCD64'),
//  *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${lighten(0.2, '#FFCD64')};
//  *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};
//  * `
//  *
//  * // CSS in JS Output
//  *
//  * element {
//  *   background: "#e5e6b1";
//  *   background: "rgba(229,230,177,0.7)";
//  * }
//  */

// function lighten(amount, color) {
//   if (color === 'transparent') return color;
//   var hslColor = parseToHsl(color);
//   return toColorString(_extends$u({}, hslColor, {
//     lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
//   }));
// } // prettier-ignore


// var curriedLighten = /*#__PURE__*/curry$1
// /* ::<number | string, string, string> */
// (lighten);
// var curriedLighten$1 = curriedLighten;

// /**
//  * Decreases the opacity of a color. Its range for the amount is between 0 to 1.
//  *
//  *
//  * @example
//  * // Styles as object usage
//  * const styles = {
//  *   background: transparentize(0.1, '#fff'),
//  *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),
//  *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),
//  * }
//  *
//  * // styled-components usage
//  * const div = styled.div`
//  *   background: ${transparentize(0.1, '#fff')};
//  *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')};
//  *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')};
//  * `
//  *
//  * // CSS in JS Output
//  *
//  * element {
//  *   background: "rgba(255,255,255,0.9)";
//  *   background: "rgba(255,255,255,0.8)";
//  *   background: "rgba(255,0,0,0.3)";
//  * }
//  */

// function transparentize(amount, color) {
//   if (color === 'transparent') return color;
//   var parsedColor = parseToRgb(color);
//   var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;

//   var colorWithAlpha = _extends$u({}, parsedColor, {
//     alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
//   });

//   return rgba(colorWithAlpha);
// } // prettier-ignore


// var curriedTransparentize = /*#__PURE__*/curry$1
// /* ::<number | string, string, string> */
// (transparentize);
// var curriedTransparentize$1 = curriedTransparentize;

// var useColorSwitcher = function useColorSwitcher(initialColor, amount) {
//   // This code is referenced from - https://awik.io/determine-color-bright-dark-using-javascript/

//   // Variables for red, green, blue values
//   var r;
//   var g;
//   var b;
//   var color = initialColor;

//   // Check the format of the color, HEX or RGB?
//   if (color.match(/^rgb/)) {
//     // If RGB --> store the red, green, blue values in separate variables
//     color = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
//     var _color = color;
//     var _color2 = _slicedToArray$b(_color, 4);
//     r = _color2[1];
//     g = _color2[2];
//     b = _color2[3];
//   } else {
//     // If hex --> Convert it to RGB: http://gist.github.com/983661
//     color = +"0x".concat(color.slice(1).replace(color.length < 5 && /./g, '$&$&'));
//     r = color >> 16;
//     g = color >> 8 & 255;
//     b = color & 255;
//   }

//   // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
//   var hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));

//   // Using the HSP value, determine whether the color is light or dark
//   if (hsp > 127.5) {
//     return curriedDarken$1(amount, initialColor);
//   }
//   return curriedLighten$1(amount, initialColor);
// };

// var _templateObject$1w, _templateObject2$S, _templateObject3$v, _templateObject4$i, _templateObject5$c, _templateObject6$9, _templateObject7$9;
// var StyledTrack = styled.div(_templateObject$1w || (_templateObject$1w = _taggedTemplateLiteral$1(["\n  &[style] {\n    background-color: ", " !important;\n    width: 0.1875rem !important;\n  }\n  &:hover {\n    width: 0.5rem !important;\n    > div {\n      width: 0.5rem !important;\n    }\n  }\n"])), function (props) {
//   return props.switchColor ? props.theme.variables.leftNavParentColor : useColorSwitcher(props.theme.variables.leftNavParentColor, 0.5);
// });
// var StyledTrackX = styled.div(_templateObject2$S || (_templateObject2$S = _taggedTemplateLiteral$1(["\n  &[style] {\n    background-color: ", " !important;\n    height: 0.1875rem !important;\n  }\n  &:hover {\n    height: 0.5rem !important;\n    > div {\n      height: 0.5rem !important;\n    }\n  }\n"])), function (props) {
//   return props.switchColor ? props.theme.variables.leftNavParentColor : useColorSwitcher(props.theme.variables.leftNavParentColor, 0.5);
// });
// var StyledThumbY = styled.div(_templateObject3$v || (_templateObject3$v = _taggedTemplateLiteral$1(["\n  &[style] {\n    background-color: ", " !important;\n    width: 0.1875rem !important;\n  }\n"])), function (props) {
//   return props.switchColor ? useColorSwitcher(props.theme.variables.leftNavParentColor, 0.5) : props.theme.variables.leftNavParentColor;
// });
// var StyledThumbX = styled.div(_templateObject4$i || (_templateObject4$i = _taggedTemplateLiteral$1(["\n  &[style] {\n    background-color: ", " !important;\n  }\n"])), function (props) {
//   return props.switchColor ? useColorSwitcher(props.theme.variables.leftNavParentColor, 0.5) : props.theme.variables.leftNavParentColor;
// });
// var ScrollRender = styled.div(_templateObject5$c || (_templateObject5$c = _taggedTemplateLiteral$1(["\n  &[style] {\n    position: static !important;\n    height: ", ";\n    width: ", ";\n  }\n"])), function (props) {
//   return props.height ? "".concat(props.height, "px !important") : 'auto';
// }, function (props) {
//   return props.width ? "".concat(props.width, "px !important") : 'auto';
// });
// var StyledContent = styled.div(_templateObject6$9 || (_templateObject6$9 = _taggedTemplateLiteral$1(["\n  &[style] {\n    display: block !important;\n    padding: 0 0.625rem 0.75rem 0.375rem !important;\n  }\n"])));
// var StyledWrapper = styled.div(_templateObject7$9 || (_templateObject7$9 = _taggedTemplateLiteral$1(["\n  &[style] {\n    right: 0rem !important;\n  }\n"])));

// var _excluded$U = ["elementRef"],
//   _excluded2$7 = ["elementRef"],
//   _excluded3$2 = ["elementRef"],
//   _excluded4 = ["elementRef"],
//   _excluded5 = ["elementRef"],
//   _excluded6 = ["elementRef"],
//   _excluded7 = ["elementRef"];

// /**
//  * The CustomScrollbar component is used to display scrollbar.
//  */

// function CustomScrollbar(_ref) {
//   var translateContentSizeYToHolder = _ref.translateContentSizeYToHolder,
//     translateContentSizeXToHolder = _ref.translateContentSizeXToHolder,
//     children = _ref.children,
//     height = _ref.height,
//     width = _ref.width,
//     className = _ref.className,
//     switchColor = _ref.switchColor;
//   return /*#__PURE__*/React__default.createElement(Scrollbar, {
//     translateContentSizeYToHolder: translateContentSizeYToHolder,
//     translateContentSizeXToHolder: translateContentSizeXToHolder,
//     switchColor: switchColor,
//     className: className,
//     renderer: function renderer(props) {
//       // eslint-disable-next-line react/prop-types
//       var elementRef = props.elementRef,
//         restProps = _objectWithoutProperties$j(props, _excluded$U);
//       return /*#__PURE__*/React__default.createElement(ScrollRender, _extends$v({}, restProps, {
//         ref: elementRef,
//         height: translateContentSizeYToHolder ? height : undefined,
//         width: translateContentSizeXToHolder ? width : undefined
//       }));
//     },
//     trackYProps: {
//       renderer: function renderer(props) {
//         // eslint-disable-next-line react/prop-types
//         var elementRef = props.elementRef,
//           restProps = _objectWithoutProperties$j(props, _excluded2$7);
//         restProps.switchColor = switchColor;
//         return /*#__PURE__*/React__default.createElement(StyledTrack, _extends$v({}, restProps, {
//           ref: elementRef,
//           role: "scrollbar",
//           "aria-orientation": "vertical",
//           "aria-valuemin": "0",
//           "aria-valuemax": "100"
//         }));
//       }
//     },
//     trackXProps: {
//       renderer: function renderer(props) {
//         // eslint-disable-next-line react/prop-types
//         var elementRef = props.elementRef,
//           restProps = _objectWithoutProperties$j(props, _excluded3$2);
//         restProps.switchColor = switchColor;
//         return /*#__PURE__*/React__default.createElement(StyledTrackX, _extends$v({}, restProps, {
//           ref: elementRef,
//           role: "scrollbar",
//           "aria-orientation": "horizontal",
//           "aria-valuemin": "0",
//           "aria-valuemax": "100"
//         }));
//       }
//     },
//     contentProps: {
//       renderer: function renderer(props) {
//         // eslint-disable-next-line react/prop-types
//         var elementRef = props.elementRef,
//           restProps = _objectWithoutProperties$j(props, _excluded4);
//         return /*#__PURE__*/React__default.createElement(StyledContent, _extends$v({}, restProps, {
//           ref: elementRef
//         }));
//       }
//     },
//     wrapperProps: {
//       renderer: function renderer(props) {
//         // eslint-disable-next-line react/prop-types
//         var elementRef = props.elementRef,
//           restProps = _objectWithoutProperties$j(props, _excluded5);
//         return /*#__PURE__*/React__default.createElement(StyledWrapper, _extends$v({}, restProps, {
//           ref: elementRef
//         }));
//       }
//     },
//     thumbYProps: {
//       renderer: function renderer(props) {
//         // eslint-disable-next-line react/prop-types
//         var elementRef = props.elementRef,
//           restProps = _objectWithoutProperties$j(props, _excluded6);
//         restProps.switchColor = switchColor;
//         return /*#__PURE__*/React__default.createElement(StyledThumbY, _extends$v({}, restProps, {
//           ref: elementRef
//         }));
//       }
//     },
//     thumbXProps: {
//       renderer: function renderer(props) {
//         // eslint-disable-next-line react/prop-types
//         var elementRef = props.elementRef,
//           restProps = _objectWithoutProperties$j(props, _excluded7);
//         restProps.switchColor = switchColor;
//         return /*#__PURE__*/React__default.createElement(StyledThumbX, _extends$v({}, restProps, {
//           ref: elementRef
//         }));
//       }
//     }
//   }, children);
// }
// // PropType check
// CustomScrollbar.propTypes = {
//   /**
//    * Child elements for the component
//    */

//   children: PropTypes__default.node,
//   /**
//    * translateContentSizeYToHolder for the component
//    */
//   translateContentSizeYToHolder: PropTypes__default.bool,
//   /**
//    * translateContentSizeXToHolder for the component
//    */
//   translateContentSizeXToHolder: PropTypes__default.bool,
//   /**
//    * scroll bar container height in px
//    * (custom height used when translateContentSizeYToHolder prop is applied)
//    */
//   height: PropTypes__default.number,
//   /**
//    * scroll bar container width in px
//    * (custom width used when translateContentSizeXToHolder prop is applied)
//    */
//   width: PropTypes__default.number,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * switchColor property to swap the scroll thumb and track colors.
//    */
//   switchColor: PropTypes__default.bool
// };
// CustomScrollbar.defaultProps = {
//   /**
//    * Child elements for the component
//    */

//   children: undefined,
//   translateContentSizeYToHolder: false,
//   translateContentSizeXToHolder: false,
//   height: undefined,
//   width: undefined,
//   className: '',
//   switchColor: false
// };

// function toInteger(dirtyNumber) {
//   if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
//     return NaN;
//   }
//   var number = Number(dirtyNumber);
//   if (isNaN(number)) {
//     return number;
//   }
//   return number < 0 ? Math.ceil(number) : Math.floor(number);
// }

// function _typeof$F(o) {
//   "@babel/helpers - typeof";

//   return _typeof$F = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
//     return typeof o;
//   } : function (o) {
//     return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
//   }, _typeof$F(o);
// }

// function requiredArgs(required, args) {
//   if (args.length < required) {
//     throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
//   }
// }

// /**
//  * @name toDate
//  * @category Common Helpers
//  * @summary Convert the given argument to an instance of Date.
//  *
//  * @description
//  * Convert the given argument to an instance of Date.
//  *
//  * If the argument is an instance of Date, the function returns its clone.
//  *
//  * If the argument is a number, it is treated as a timestamp.
//  *
//  * If the argument is none of the above, the function returns Invalid Date.
//  *
//  * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
//  *
//  * @param {Date|Number} argument - the value to convert
//  * @returns {Date} the parsed date in the local time zone
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Clone the date:
//  * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
//  * //=> Tue Feb 11 2014 11:30:30
//  *
//  * @example
//  * // Convert the timestamp to date:
//  * const result = toDate(1392098430000)
//  * //=> Tue Feb 11 2014 11:30:30
//  */
// function toDate$1(argument) {
//   requiredArgs(1, arguments);
//   var argStr = Object.prototype.toString.call(argument);

//   // Clone the date
//   if (argument instanceof Date || _typeof$F(argument) === 'object' && argStr === '[object Date]') {
//     // Prevent the date to lose the milliseconds when passed to new Date() in IE10
//     return new Date(argument.getTime());
//   } else if (typeof argument === 'number' || argStr === '[object Number]') {
//     return new Date(argument);
//   } else {
//     if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
//       // eslint-disable-next-line no-console
//       console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
//       // eslint-disable-next-line no-console
//       console.warn(new Error().stack);
//     }
//     return new Date(NaN);
//   }
// }

// /**
//  * @name addDays
//  * @category Day Helpers
//  * @summary Add the specified number of days to the given date.
//  *
//  * @description
//  * Add the specified number of days to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} - the new date with the days added
//  * @throws {TypeError} - 2 arguments required
//  *
//  * @example
//  * // Add 10 days to 1 September 2014:
//  * const result = addDays(new Date(2014, 8, 1), 10)
//  * //=> Thu Sep 11 2014 00:00:00
//  */
// function addDays(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var amount = toInteger(dirtyAmount);
//   if (isNaN(amount)) {
//     return new Date(NaN);
//   }
//   if (!amount) {
//     // If 0 days, no-op to avoid changing times in the hour before end of DST
//     return date;
//   }
//   date.setDate(date.getDate() + amount);
//   return date;
// }

// /**
//  * @name addMilliseconds
//  * @category Millisecond Helpers
//  * @summary Add the specified number of milliseconds to the given date.
//  *
//  * @description
//  * Add the specified number of milliseconds to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the milliseconds added
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
//  * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
//  * //=> Thu Jul 10 2014 12:45:30.750
//  */
// function addMilliseconds(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var timestamp = toDate$1(dirtyDate).getTime();
//   var amount = toInteger(dirtyAmount);
//   return new Date(timestamp + amount);
// }

// /**
//  * @name addSeconds
//  * @category Second Helpers
//  * @summary Add the specified number of seconds to the given date.
//  *
//  * @description
//  * Add the specified number of seconds to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the seconds added
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Add 30 seconds to 10 July 2014 12:45:00:
//  * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
//  * //=> Thu Jul 10 2014 12:45:30
//  */
// function addSeconds(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var amount = toInteger(dirtyAmount);
//   return addMilliseconds(dirtyDate, amount * 1000);
// }

// var MILLISECONDS_IN_MINUTE$2 = 60000;

// /**
//  * @name addMinutes
//  * @category Minute Helpers
//  * @summary Add the specified number of minutes to the given date.
//  *
//  * @description
//  * Add the specified number of minutes to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of minutes to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the minutes added
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Add 30 minutes to 10 July 2014 12:00:00:
//  * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
//  * //=> Thu Jul 10 2014 12:30:00
//  */
// function addMinutes(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var amount = toInteger(dirtyAmount);
//   return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$2);
// }

// var MILLISECONDS_IN_HOUR$2 = 3600000;

// /**
//  * @name addHours
//  * @category Hour Helpers
//  * @summary Add the specified number of hours to the given date.
//  *
//  * @description
//  * Add the specified number of hours to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of hours to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the hours added
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Add 2 hours to 10 July 2014 23:00:00:
//  * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)
//  * //=> Fri Jul 11 2014 01:00:00
//  */
// function addHours(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var amount = toInteger(dirtyAmount);
//   return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR$2);
// }

// /**
//  * @name addWeeks
//  * @category Week Helpers
//  * @summary Add the specified number of weeks to the given date.
//  *
//  * @description
//  * Add the specified number of week to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the weeks added
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Add 4 weeks to 1 September 2014:
//  * const result = addWeeks(new Date(2014, 8, 1), 4)
//  * //=> Mon Sep 29 2014 00:00:00
//  */
// function addWeeks(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var amount = toInteger(dirtyAmount);
//   var days = amount * 7;
//   return addDays(dirtyDate, days);
// }

// /**
//  * @name addMonths
//  * @category Month Helpers
//  * @summary Add the specified number of months to the given date.
//  *
//  * @description
//  * Add the specified number of months to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the months added
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Add 5 months to 1 September 2014:
//  * const result = addMonths(new Date(2014, 8, 1), 5)
//  * //=> Sun Feb 01 2015 00:00:00
//  */
// function addMonths(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var amount = toInteger(dirtyAmount);
//   if (isNaN(amount)) {
//     return new Date(NaN);
//   }
//   if (!amount) {
//     // If 0 months, no-op to avoid changing times in the hour before end of DST
//     return date;
//   }
//   var dayOfMonth = date.getDate();

//   // The JS Date object supports date math by accepting out-of-bounds values for
//   // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
//   // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
//   // want except that dates will wrap around the end of a month, meaning that
//   // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
//   // we'll default to the end of the desired month by adding 1 to the desired
//   // month and using a date of 0 to back up one day to the end of the desired
//   // month.
//   var endOfDesiredMonth = new Date(date.getTime());
//   endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
//   var daysInMonth = endOfDesiredMonth.getDate();
//   if (dayOfMonth >= daysInMonth) {
//     // If we're already at the end of the month, then this is the correct date
//     // and we're done.
//     return endOfDesiredMonth;
//   } else {
//     // Otherwise, we now know that setting the original day-of-month value won't
//     // cause an overflow, so set the desired day-of-month. Note that we can't
//     // just set the date of `endOfDesiredMonth` because that object may have had
//     // its time changed in the unusual case where where a DST transition was on
//     // the last day of the month and its local time was in the hour skipped or
//     // repeated next to a DST transition.  So we use `date` instead which is
//     // guaranteed to still have the original time.
//     date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
//     return date;
//   }
// }

// /**
//  * @name addYears
//  * @category Year Helpers
//  * @summary Add the specified number of years to the given date.
//  *
//  * @description
//  * Add the specified number of years to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the years added
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Add 5 years to 1 September 2014:
//  * const result = addYears(new Date(2014, 8, 1), 5)
//  * //=> Sun Sep 01 2019 00:00:00
//  */
// function addYears(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var amount = toInteger(dirtyAmount);
//   return addMonths(dirtyDate, amount * 12);
// }

// /**
//  * @name differenceInCalendarYears
//  * @category Year Helpers
//  * @summary Get the number of calendar years between the given dates.
//  *
//  * @description
//  * Get the number of calendar years between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @returns {Number} the number of calendar years
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many calendar years are between 31 December 2013 and 11 February 2015?
//  * const result = differenceInCalendarYears(
//  *   new Date(2015, 1, 11),
//  *   new Date(2013, 11, 31)
//  * )
//  * //=> 2
//  */
// function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   return dateLeft.getFullYear() - dateRight.getFullYear();
// }

// /**
//  * @name compareAsc
//  * @category Common Helpers
//  * @summary Compare the two dates and return -1, 0 or 1.
//  *
//  * @description
//  * Compare the two dates and return 1 if the first date is after the second,
//  * -1 if the first date is before the second or 0 if dates are equal.
//  *
//  * @param {Date|Number} dateLeft - the first date to compare
//  * @param {Date|Number} dateRight - the second date to compare
//  * @returns {Number} the result of the comparison
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Compare 11 February 1987 and 10 July 1989:
//  * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
//  * //=> -1
//  *
//  * @example
//  * // Sort the array of dates:
//  * const result = [
//  *   new Date(1995, 6, 2),
//  *   new Date(1987, 1, 11),
//  *   new Date(1989, 6, 10)
//  * ].sort(compareAsc)
//  * //=> [
//  * //   Wed Feb 11 1987 00:00:00,
//  * //   Mon Jul 10 1989 00:00:00,
//  * //   Sun Jul 02 1995 00:00:00
//  * // ]
//  */
// function compareAsc(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   var diff = dateLeft.getTime() - dateRight.getTime();
//   if (diff < 0) {
//     return -1;
//   } else if (diff > 0) {
//     return 1;
//     // Return 0 if diff is 0; return NaN if diff is NaN
//   } else {
//     return diff;
//   }
// }

// /**
//  * @name differenceInYears
//  * @category Year Helpers
//  * @summary Get the number of full years between the given dates.
//  *
//  * @description
//  * Get the number of full years between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @returns {Number} the number of full years
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many full years are between 31 December 2013 and 11 February 2015?
//  * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
//  * //=> 1
//  */
// function differenceInYears(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   var sign = compareAsc(dateLeft, dateRight);
//   var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));

//   // Set both dates to a valid leap year for accurate comparison when dealing
//   // with leap days
//   dateLeft.setFullYear(1584);
//   dateRight.setFullYear(1584);

//   // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
//   // If so, result must be decreased by 1 in absolute value
//   var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign;
//   var result = sign * (difference - Number(isLastYearNotFull));
//   // Prevent negative zero
//   return result === 0 ? 0 : result;
// }

// /**
//  * @name differenceInCalendarMonths
//  * @category Month Helpers
//  * @summary Get the number of calendar months between the given dates.
//  *
//  * @description
//  * Get the number of calendar months between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @returns {Number} the number of calendar months
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many calendar months are between 31 January 2014 and 1 September 2014?
//  * const result = differenceInCalendarMonths(
//  *   new Date(2014, 8, 1),
//  *   new Date(2014, 0, 31)
//  * )
//  * //=> 8
//  */
// function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
//   var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
//   return yearDiff * 12 + monthDiff;
// }

// /**
//  * @name endOfDay
//  * @category Day Helpers
//  * @summary Return the end of a day for the given date.
//  *
//  * @description
//  * Return the end of a day for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @returns {Date} the end of a day
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // The end of a day for 2 September 2014 11:55:00:
//  * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
//  * //=> Tue Sep 02 2014 23:59:59.999
//  */
// function endOfDay(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   date.setHours(23, 59, 59, 999);
//   return date;
// }

// /**
//  * @name endOfMonth
//  * @category Month Helpers
//  * @summary Return the end of a month for the given date.
//  *
//  * @description
//  * Return the end of a month for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @returns {Date} the end of a month
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // The end of a month for 2 September 2014 11:55:00:
//  * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
//  * //=> Tue Sep 30 2014 23:59:59.999
//  */
// function endOfMonth(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var month = date.getMonth();
//   date.setFullYear(date.getFullYear(), month + 1, 0);
//   date.setHours(23, 59, 59, 999);
//   return date;
// }

// /**
//  * @name isLastDayOfMonth
//  * @category Month Helpers
//  * @summary Is the given date the last day of a month?
//  *
//  * @description
//  * Is the given date the last day of a month?
//  *
//  * @param {Date|Number} date - the date to check
//  * @returns {Boolean} the date is the last day of a month
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Is 28 February 2014 the last day of a month?
//  * const result = isLastDayOfMonth(new Date(2014, 1, 28))
//  * //=> true
//  */
// function isLastDayOfMonth(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   return endOfDay(date).getTime() === endOfMonth(date).getTime();
// }

// /**
//  * @name differenceInMonths
//  * @category Month Helpers
//  * @summary Get the number of full months between the given dates.
//  *
//  * @description
//  * Get the number of full months between the given dates using trunc as a default rounding method.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @returns {Number} the number of full months
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many full months are between 31 January 2014 and 1 September 2014?
//  * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
//  * //=> 7
//  */
// function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   var sign = compareAsc(dateLeft, dateRight);
//   var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
//   var result;

//   // Check for the difference of less than month
//   if (difference < 1) {
//     result = 0;
//   } else {
//     if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
//       // This will check if the date is end of Feb and assign a higher end of month date
//       // to compare it with Jan
//       dateLeft.setDate(30);
//     }
//     dateLeft.setMonth(dateLeft.getMonth() - sign * difference);

//     // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
//     // If so, result must be decreased by 1 in absolute value
//     var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;

//     // Check for cases of one full calendar month
//     if (isLastDayOfMonth(toDate$1(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
//       isLastMonthNotFull = false;
//     }
//     result = sign * (difference - Number(isLastMonthNotFull));
//   }

//   // Prevent negative zero
//   return result === 0 ? 0 : result;
// }

// var roundingMap = {
//   ceil: Math.ceil,
//   round: Math.round,
//   floor: Math.floor,
//   trunc: function trunc(value) {
//     return value < 0 ? Math.ceil(value) : Math.floor(value);
//   } // Math.trunc is not supported by IE
// };

// var defaultRoundingMethod = 'trunc';
// function getRoundingMethod(method) {
//   return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
// }

// /**
//  * @name differenceInQuarters
//  * @category Quarter Helpers
//  * @summary Get the number of quarters between the given dates.
//  *
//  * @description
//  * Get the number of quarters between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @param {Object} [options] - an object with options.
//  * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
//  * @returns {Number} the number of full quarters
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many full quarters are between 31 December 2013 and 2 July 2014?
//  * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
//  * //=> 2
//  */
// function differenceInQuarters(dateLeft, dateRight, options) {
//   requiredArgs(2, arguments);
//   var diff = differenceInMonths(dateLeft, dateRight) / 3;
//   return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
// }

// /**
//  * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
//  * They usually appear for dates that denote time before the timezones were introduced
//  * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
//  * and GMT+01:00:00 after that date)
//  *
//  * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
//  * which would lead to incorrect calculations.
//  *
//  * This function returns the timezone offset in milliseconds that takes seconds in account.
//  */
// function getTimezoneOffsetInMilliseconds(date) {
//   var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
//   utcDate.setUTCFullYear(date.getFullYear());
//   return date.getTime() - utcDate.getTime();
// }

// /**
//  * @name startOfDay
//  * @category Day Helpers
//  * @summary Return the start of a day for the given date.
//  *
//  * @description
//  * Return the start of a day for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @returns {Date} the start of a day
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // The start of a day for 2 September 2014 11:55:00:
//  * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
//  * //=> Tue Sep 02 2014 00:00:00
//  */
// function startOfDay(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   date.setHours(0, 0, 0, 0);
//   return date;
// }

// var MILLISECONDS_IN_DAY$1 = 86400000;

// /**
//  * @name differenceInCalendarDays
//  * @category Day Helpers
//  * @summary Get the number of calendar days between the given dates.
//  *
//  * @description
//  * Get the number of calendar days between the given dates. This means that the times are removed
//  * from the dates and then the difference in days is calculated.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @returns {Number} the number of calendar days
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many calendar days are between
//  * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
//  * const result = differenceInCalendarDays(
//  *   new Date(2012, 6, 2, 0, 0),
//  *   new Date(2011, 6, 2, 23, 0)
//  * )
//  * //=> 366
//  * // How many calendar days are between
//  * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
//  * const result = differenceInCalendarDays(
//  *   new Date(2011, 6, 3, 0, 1),
//  *   new Date(2011, 6, 2, 23, 59)
//  * )
//  * //=> 1
//  */
// function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var startOfDayLeft = startOfDay(dirtyDateLeft);
//   var startOfDayRight = startOfDay(dirtyDateRight);
//   var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
//   var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);

//   // Round the number of days to the nearest integer
//   // because the number of milliseconds in a day is not constant
//   // (e.g. it's different in the day of the daylight saving time clock shift)
//   return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
// }

// // for accurate equality comparisons of UTC timestamps that end up
// // having the same representation in local time, e.g. one hour before
// // DST ends vs. the instant that DST ends.
// function compareLocalAsc(dateLeft, dateRight) {
//   var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
//   if (diff < 0) {
//     return -1;
//   } else if (diff > 0) {
//     return 1;
//     // Return 0 if diff is 0; return NaN if diff is NaN
//   } else {
//     return diff;
//   }
// }

// /**
//  * @name differenceInDays
//  * @category Day Helpers
//  * @summary Get the number of full days between the given dates.
//  *
//  * @description
//  * Get the number of full day periods between two dates. Fractional days are
//  * truncated towards zero.
//  *
//  * One "full day" is the distance between a local time in one day to the same
//  * local time on the next or previous day. A full day can sometimes be less than
//  * or more than 24 hours if a daylight savings change happens between two dates.
//  *
//  * To ignore DST and only measure exact 24-hour periods, use this instead:
//  * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
//  *
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @returns {Number} the number of full days according to the local timezone
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many full days are between
//  * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
//  * const result = differenceInDays(
//  *   new Date(2012, 6, 2, 0, 0),
//  *   new Date(2011, 6, 2, 23, 0)
//  * )
//  * //=> 365
//  * // How many full days are between
//  * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
//  * const result = differenceInDays(
//  *   new Date(2011, 6, 3, 0, 1),
//  *   new Date(2011, 6, 2, 23, 59)
//  * )
//  * //=> 0
//  * // How many full days are between
//  * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
//  * // Note: because local time is used, the
//  * // result will always be 92 days, even in
//  * // time zones where DST starts and the
//  * // period has only 92*24-1 hours.
//  * const result = differenceInDays(
//  *   new Date(2020, 5, 1),
//  *   new Date(2020, 2, 1)
//  * )
// //=> 92
//  */
// function differenceInDays(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   var sign = compareLocalAsc(dateLeft, dateRight);
//   var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
//   dateLeft.setDate(dateLeft.getDate() - sign * difference);

//   // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
//   // If so, result must be decreased by 1 in absolute value
//   var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
//   var result = sign * (difference - isLastDayNotFull);
//   // Prevent negative zero
//   return result === 0 ? 0 : result;
// }

// /**
//  * @name differenceInWeeks
//  * @category Week Helpers
//  * @summary Get the number of full weeks between the given dates.
//  *
//  * @description
//  * Get the number of full weeks between two dates. Fractional weeks are
//  * truncated towards zero by default.
//  *
//  * One "full week" is the distance between a local time in one day to the same
//  * local time 7 days earlier or later. A full week can sometimes be less than
//  * or more than 7*24 hours if a daylight savings change happens between two dates.
//  *
//  * To ignore DST and only measure exact 7*24-hour periods, use this instead:
//  * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
//  *
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @param {Object} [options] - an object with options.
//  * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
//  * @returns {Number} the number of full weeks
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many full weeks are between 5 July 2014 and 20 July 2014?
//  * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
//  * //=> 2
//  *
//  * // How many full weeks are between
//  * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
//  * // Note: because local time is used, the
//  * // result will always be 8 weeks (54 days),
//  * // even if DST starts and the period has
//  * // only 54*24-1 hours.
//  * const result = differenceInWeeks(
//  *   new Date(2020, 5, 1),
//  *   new Date(2020, 2, 6)
//  * )
//  * //=> 8
//  */
// function differenceInWeeks(dateLeft, dateRight, options) {
//   requiredArgs(2, arguments);
//   var diff = differenceInDays(dateLeft, dateRight) / 7;
//   return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
// }

// /**
//  * Days in 1 week.
//  *
//  * @name daysInWeek
//  * @constant
//  * @type {number}
//  * @default
//  */

// /**
//  * Milliseconds in 1 minute
//  *
//  * @name millisecondsInMinute
//  * @constant
//  * @type {number}
//  * @default
//  */
// var millisecondsInMinute = 60000;

// /**
//  * Milliseconds in 1 hour
//  *
//  * @name millisecondsInHour
//  * @constant
//  * @type {number}
//  * @default
//  */
// var millisecondsInHour = 3600000;

// /**
//  * Milliseconds in 1 second
//  *
//  * @name millisecondsInSecond
//  * @constant
//  * @type {number}
//  * @default
//  */
// var millisecondsInSecond = 1000;

// /**
//  * @name differenceInMilliseconds
//  * @category Millisecond Helpers
//  * @summary Get the number of milliseconds between the given dates.
//  *
//  * @description
//  * Get the number of milliseconds between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @returns {Number} the number of milliseconds
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many milliseconds are between
//  * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
//  * const result = differenceInMilliseconds(
//  *   new Date(2014, 6, 2, 12, 30, 21, 700),
//  *   new Date(2014, 6, 2, 12, 30, 20, 600)
//  * )
//  * //=> 1100
//  */
// function differenceInMilliseconds(dateLeft, dateRight) {
//   requiredArgs(2, arguments);
//   return toDate$1(dateLeft).getTime() - toDate$1(dateRight).getTime();
// }

// /**
//  * @name differenceInHours
//  * @category Hour Helpers
//  * @summary Get the number of hours between the given dates.
//  *
//  * @description
//  * Get the number of hours between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @param {Object} [options] - an object with options.
//  * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
//  * @returns {Number} the number of hours
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
//  * const result = differenceInHours(
//  *   new Date(2014, 6, 2, 19, 0),
//  *   new Date(2014, 6, 2, 6, 50)
//  * )
//  * //=> 12
//  */
// function differenceInHours(dateLeft, dateRight, options) {
//   requiredArgs(2, arguments);
//   var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
//   return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
// }

// /**
//  * @name differenceInMinutes
//  * @category Minute Helpers
//  * @summary Get the number of minutes between the given dates.
//  *
//  * @description
//  * Get the signed number of full (rounded towards 0) minutes between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @param {Object} [options] - an object with options.
//  * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
//  * @returns {Number} the number of minutes
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
//  * const result = differenceInMinutes(
//  *   new Date(2014, 6, 2, 12, 20, 0),
//  *   new Date(2014, 6, 2, 12, 7, 59)
//  * )
//  * //=> 12
//  *
//  * @example
//  * // How many minutes are between 10:01:59 and 10:00:00
//  * const result = differenceInMinutes(
//  *   new Date(2000, 0, 1, 10, 0, 0),
//  *   new Date(2000, 0, 1, 10, 1, 59)
//  * )
//  * //=> -1
//  */
// function differenceInMinutes(dateLeft, dateRight, options) {
//   requiredArgs(2, arguments);
//   var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
//   return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
// }

// /**
//  * @name differenceInSeconds
//  * @category Second Helpers
//  * @summary Get the number of seconds between the given dates.
//  *
//  * @description
//  * Get the number of seconds between the given dates.
//  *
//  * @param {Date|Number} dateLeft - the later date
//  * @param {Date|Number} dateRight - the earlier date
//  * @param {Object} [options] - an object with options.
//  * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
//  * @returns {Number} the number of seconds
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // How many seconds are between
//  * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
//  * const result = differenceInSeconds(
//  *   new Date(2014, 6, 2, 12, 30, 20, 0),
//  *   new Date(2014, 6, 2, 12, 30, 7, 999)
//  * )
//  * //=> 12
//  */
// function differenceInSeconds(dateLeft, dateRight, options) {
//   requiredArgs(2, arguments);
//   var diff = differenceInMilliseconds(dateLeft, dateRight) / 1000;
//   return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
// }

// /**
//  * @name eachDayOfInterval
//  * @category Interval Helpers
//  * @summary Return the array of dates within the specified time interval.
//  *
//  * @description
//  * Return the array of dates within the specified time interval.
//  *
//  * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
//  * @param {Object} [options] - an object with options.
//  * @param {Number} [options.step=1] - the step to increment by. The value should be more than 1.
//  * @returns {Date[]} the array with starts of days from the day of the interval start to the day of the interval end
//  * @throws {TypeError} 1 argument required
//  * @throws {RangeError} `options.step` must be a number greater than 1
//  * @throws {RangeError} The start of an interval cannot be after its end
//  * @throws {RangeError} Date in interval cannot be `Invalid Date`
//  *
//  * @example
//  * // Each day between 6 October 2014 and 10 October 2014:
//  * const result = eachDayOfInterval({
//  *   start: new Date(2014, 9, 6),
//  *   end: new Date(2014, 9, 10)
//  * })
//  * //=> [
//  * //   Mon Oct 06 2014 00:00:00,
//  * //   Tue Oct 07 2014 00:00:00,
//  * //   Wed Oct 08 2014 00:00:00,
//  * //   Thu Oct 09 2014 00:00:00,
//  * //   Fri Oct 10 2014 00:00:00
//  * // ]
//  */
// function eachDayOfInterval(dirtyInterval, options) {
//   var _options$step;
//   requiredArgs(1, arguments);
//   var interval = dirtyInterval || {};
//   var startDate = toDate$1(interval.start);
//   var endDate = toDate$1(interval.end);
//   var endTime = endDate.getTime();

//   // Throw an exception if start date is after end date or if any date is `Invalid Date`
//   if (!(startDate.getTime() <= endTime)) {
//     throw new RangeError('Invalid interval');
//   }
//   var dates = [];
//   var currentDate = startDate;
//   currentDate.setHours(0, 0, 0, 0);
//   var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
//   if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');
//   while (currentDate.getTime() <= endTime) {
//     dates.push(toDate$1(currentDate));
//     currentDate.setDate(currentDate.getDate() + step);
//     currentDate.setHours(0, 0, 0, 0);
//   }
//   return dates;
// }

// var defaultOptions = {};
// function getDefaultOptions() {
//   return defaultOptions;
// }

// /**
//  * @name endOfWeek
//  * @category Week Helpers
//  * @summary Return the end of a week for the given date.
//  *
//  * @description
//  * Return the end of a week for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @param {Object} [options] - an object with options.
//  * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
//  * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
//  * @returns {Date} the end of a week
//  * @throws {TypeError} 1 argument required
//  * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
//  *
//  * @example
//  * // The end of a week for 2 September 2014 11:55:00:
//  * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
//  * //=> Sat Sep 06 2014 23:59:59.999
//  *
//  * @example
//  * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
//  * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
//  * //=> Sun Sep 07 2014 23:59:59.999
//  */
// function endOfWeek(dirtyDate, options) {
//   var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
//   requiredArgs(1, arguments);
//   var defaultOptions = getDefaultOptions();
//   var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

//   // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
//   if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
//     throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
//   }
//   var date = toDate$1(dirtyDate);
//   var day = date.getDay();
//   var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
//   date.setDate(date.getDate() + diff);
//   date.setHours(23, 59, 59, 999);
//   return date;
// }

// /**
//  * @name endOfYear
//  * @category Year Helpers
//  * @summary Return the end of a year for the given date.
//  *
//  * @description
//  * Return the end of a year for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @returns {Date} the end of a year
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // The end of a year for 2 September 2014 11:55:00:
//  * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
//  * //=> Wed Dec 31 2014 23:59:59.999
//  */
// function endOfYear(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var year = date.getFullYear();
//   date.setFullYear(year + 1, 0, 0);
//   date.setHours(23, 59, 59, 999);
//   return date;
// }

// /**
//  * @name isDate
//  * @category Common Helpers
//  * @summary Is the given value a date?
//  *
//  * @description
//  * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
//  *
//  * @param {*} value - the value to check
//  * @returns {boolean} true if the given value is a date
//  * @throws {TypeError} 1 arguments required
//  *
//  * @example
//  * // For a valid date:
//  * const result = isDate(new Date())
//  * //=> true
//  *
//  * @example
//  * // For an invalid date:
//  * const result = isDate(new Date(NaN))
//  * //=> true
//  *
//  * @example
//  * // For some value:
//  * const result = isDate('2014-02-31')
//  * //=> false
//  *
//  * @example
//  * // For an object:
//  * const result = isDate({})
//  * //=> false
//  */
// function isDate(value) {
//   requiredArgs(1, arguments);
//   return value instanceof Date || _typeof$F(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
// }

// /**
//  * @name isValid
//  * @category Common Helpers
//  * @summary Is the given date valid?
//  *
//  * @description
//  * Returns false if argument is Invalid Date and true otherwise.
//  * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
//  * Invalid Date is a Date, whose time value is NaN.
//  *
//  * Time value of Date: http://es5.github.io/#x15.9.1.1
//  *
//  * @param {*} date - the date to check
//  * @returns {Boolean} the date is valid
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // For the valid date:
//  * const result = isValid(new Date(2014, 1, 31))
//  * //=> true
//  *
//  * @example
//  * // For the value, convertable into a date:
//  * const result = isValid(1393804800000)
//  * //=> true
//  *
//  * @example
//  * // For the invalid date:
//  * const result = isValid(new Date(''))
//  * //=> false
//  */
// function isValid(dirtyDate) {
//   requiredArgs(1, arguments);
//   if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
//     return false;
//   }
//   var date = toDate$1(dirtyDate);
//   return !isNaN(Number(date));
// }

// /**
//  * @name subMilliseconds
//  * @category Millisecond Helpers
//  * @summary Subtract the specified number of milliseconds from the given date.
//  *
//  * @description
//  * Subtract the specified number of milliseconds from the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
//  * @returns {Date} the new date with the milliseconds subtracted
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
//  * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
//  * //=> Thu Jul 10 2014 12:45:29.250
//  */
// function subMilliseconds(dirtyDate, dirtyAmount) {
//   requiredArgs(2, arguments);
//   var amount = toInteger(dirtyAmount);
//   return addMilliseconds(dirtyDate, -amount);
// }

// var MILLISECONDS_IN_DAY = 86400000;
// function getUTCDayOfYear(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var timestamp = date.getTime();
//   date.setUTCMonth(0, 1);
//   date.setUTCHours(0, 0, 0, 0);
//   var startOfYearTimestamp = date.getTime();
//   var difference = timestamp - startOfYearTimestamp;
//   return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
// }

// function startOfUTCISOWeek(dirtyDate) {
//   requiredArgs(1, arguments);
//   var weekStartsOn = 1;
//   var date = toDate$1(dirtyDate);
//   var day = date.getUTCDay();
//   var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
//   date.setUTCDate(date.getUTCDate() - diff);
//   date.setUTCHours(0, 0, 0, 0);
//   return date;
// }

// function getUTCISOWeekYear(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var year = date.getUTCFullYear();
//   var fourthOfJanuaryOfNextYear = new Date(0);
//   fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
//   fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
//   var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
//   var fourthOfJanuaryOfThisYear = new Date(0);
//   fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
//   fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
//   var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
//   if (date.getTime() >= startOfNextYear.getTime()) {
//     return year + 1;
//   } else if (date.getTime() >= startOfThisYear.getTime()) {
//     return year;
//   } else {
//     return year - 1;
//   }
// }

// function startOfUTCISOWeekYear(dirtyDate) {
//   requiredArgs(1, arguments);
//   var year = getUTCISOWeekYear(dirtyDate);
//   var fourthOfJanuary = new Date(0);
//   fourthOfJanuary.setUTCFullYear(year, 0, 4);
//   fourthOfJanuary.setUTCHours(0, 0, 0, 0);
//   var date = startOfUTCISOWeek(fourthOfJanuary);
//   return date;
// }

// var MILLISECONDS_IN_WEEK$1 = 604800000;
// function getUTCISOWeek(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();

//   // Round the number of days to the nearest integer
//   // because the number of milliseconds in a week is not constant
//   // (e.g. it's different in the week of the daylight saving time clock shift)
//   return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
// }

// function startOfUTCWeek(dirtyDate, options) {
//   var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
//   requiredArgs(1, arguments);
//   var defaultOptions = getDefaultOptions();
//   var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

//   // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
//   if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
//     throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
//   }
//   var date = toDate$1(dirtyDate);
//   var day = date.getUTCDay();
//   var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
//   date.setUTCDate(date.getUTCDate() - diff);
//   date.setUTCHours(0, 0, 0, 0);
//   return date;
// }

// function getUTCWeekYear(dirtyDate, options) {
//   var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var year = date.getUTCFullYear();
//   var defaultOptions = getDefaultOptions();
//   var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

//   // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
//   if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
//     throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
//   }
//   var firstWeekOfNextYear = new Date(0);
//   firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
//   firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
//   var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
//   var firstWeekOfThisYear = new Date(0);
//   firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
//   firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
//   var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
//   if (date.getTime() >= startOfNextYear.getTime()) {
//     return year + 1;
//   } else if (date.getTime() >= startOfThisYear.getTime()) {
//     return year;
//   } else {
//     return year - 1;
//   }
// }

// function startOfUTCWeekYear(dirtyDate, options) {
//   var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
//   requiredArgs(1, arguments);
//   var defaultOptions = getDefaultOptions();
//   var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
//   var year = getUTCWeekYear(dirtyDate, options);
//   var firstWeek = new Date(0);
//   firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
//   firstWeek.setUTCHours(0, 0, 0, 0);
//   var date = startOfUTCWeek(firstWeek, options);
//   return date;
// }

// var MILLISECONDS_IN_WEEK = 604800000;
// function getUTCWeek(dirtyDate, options) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();

//   // Round the number of days to the nearest integer
//   // because the number of milliseconds in a week is not constant
//   // (e.g. it's different in the week of the daylight saving time clock shift)
//   return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
// }

// function addLeadingZeros(number, targetLength) {
//   var sign = number < 0 ? '-' : '';
//   var output = Math.abs(number).toString();
//   while (output.length < targetLength) {
//     output = '0' + output;
//   }
//   return sign + output;
// }

// /*
//  * |     | Unit                           |     | Unit                           |
//  * |-----|--------------------------------|-----|--------------------------------|
//  * |  a  | AM, PM                         |  A* |                                |
//  * |  d  | Day of month                   |  D  |                                |
//  * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
//  * |  m  | Minute                         |  M  | Month                          |
//  * |  s  | Second                         |  S  | Fraction of second             |
//  * |  y  | Year (abs)                     |  Y  |                                |
//  *
//  * Letters marked by * are not implemented but reserved by Unicode standard.
//  */
// var formatters$1 = {
//   // Year
//   y: function y(date, token) {
//     // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
//     // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
//     // |----------|-------|----|-------|-------|-------|
//     // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
//     // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
//     // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
//     // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
//     // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

//     var signedYear = date.getUTCFullYear();
//     // Returns 1 for 1 BC (which is year 0 in JavaScript)
//     var year = signedYear > 0 ? signedYear : 1 - signedYear;
//     return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
//   },
//   // Month
//   M: function M(date, token) {
//     var month = date.getUTCMonth();
//     return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
//   },
//   // Day of the month
//   d: function d(date, token) {
//     return addLeadingZeros(date.getUTCDate(), token.length);
//   },
//   // AM or PM
//   a: function a(date, token) {
//     var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
//     switch (token) {
//       case 'a':
//       case 'aa':
//         return dayPeriodEnumValue.toUpperCase();
//       case 'aaa':
//         return dayPeriodEnumValue;
//       case 'aaaaa':
//         return dayPeriodEnumValue[0];
//       case 'aaaa':
//       default:
//         return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
//     }
//   },
//   // Hour [1-12]
//   h: function h(date, token) {
//     return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
//   },
//   // Hour [0-23]
//   H: function H(date, token) {
//     return addLeadingZeros(date.getUTCHours(), token.length);
//   },
//   // Minute
//   m: function m(date, token) {
//     return addLeadingZeros(date.getUTCMinutes(), token.length);
//   },
//   // Second
//   s: function s(date, token) {
//     return addLeadingZeros(date.getUTCSeconds(), token.length);
//   },
//   // Fraction of second
//   S: function S(date, token) {
//     var numberOfDigits = token.length;
//     var milliseconds = date.getUTCMilliseconds();
//     var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
//     return addLeadingZeros(fractionalSeconds, token.length);
//   }
// };

// var dayPeriodEnum = {
//   am: 'am',
//   pm: 'pm',
//   midnight: 'midnight',
//   noon: 'noon',
//   morning: 'morning',
//   afternoon: 'afternoon',
//   evening: 'evening',
//   night: 'night'
// };
// /*
//  * |     | Unit                           |     | Unit                           |
//  * |-----|--------------------------------|-----|--------------------------------|
//  * |  a  | AM, PM                         |  A* | Milliseconds in day            |
//  * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
//  * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
//  * |  d  | Day of month                   |  D  | Day of year                    |
//  * |  e  | Local day of week              |  E  | Day of week                    |
//  * |  f  |                                |  F* | Day of week in month           |
//  * |  g* | Modified Julian day            |  G  | Era                            |
//  * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
//  * |  i! | ISO day of week                |  I! | ISO week of year               |
//  * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
//  * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
//  * |  l* | (deprecated)                   |  L  | Stand-alone month              |
//  * |  m  | Minute                         |  M  | Month                          |
//  * |  n  |                                |  N  |                                |
//  * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
//  * |  p! | Long localized time            |  P! | Long localized date            |
//  * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
//  * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
//  * |  s  | Second                         |  S  | Fraction of second             |
//  * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
//  * |  u  | Extended year                  |  U* | Cyclic year                    |
//  * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
//  * |  w  | Local week of year             |  W* | Week of month                  |
//  * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
//  * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
//  * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
//  *
//  * Letters marked by * are not implemented but reserved by Unicode standard.
//  *
//  * Letters marked by ! are non-standard, but implemented by date-fns:
//  * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
//  * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
//  *   i.e. 7 for Sunday, 1 for Monday, etc.
//  * - `I` is ISO week of year, as opposed to `w` which is local week of year.
//  * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
//  *   `R` is supposed to be used in conjunction with `I` and `i`
//  *   for universal ISO week-numbering date, whereas
//  *   `Y` is supposed to be used in conjunction with `w` and `e`
//  *   for week-numbering date specific to the locale.
//  * - `P` is long localized date format
//  * - `p` is long localized time format
//  */

// var formatters = {
//   // Era
//   G: function G(date, token, localize) {
//     var era = date.getUTCFullYear() > 0 ? 1 : 0;
//     switch (token) {
//       // AD, BC
//       case 'G':
//       case 'GG':
//       case 'GGG':
//         return localize.era(era, {
//           width: 'abbreviated'
//         });
//       // A, B
//       case 'GGGGG':
//         return localize.era(era, {
//           width: 'narrow'
//         });
//       // Anno Domini, Before Christ
//       case 'GGGG':
//       default:
//         return localize.era(era, {
//           width: 'wide'
//         });
//     }
//   },
//   // Year
//   y: function y(date, token, localize) {
//     // Ordinal number
//     if (token === 'yo') {
//       var signedYear = date.getUTCFullYear();
//       // Returns 1 for 1 BC (which is year 0 in JavaScript)
//       var year = signedYear > 0 ? signedYear : 1 - signedYear;
//       return localize.ordinalNumber(year, {
//         unit: 'year'
//       });
//     }
//     return formatters$1.y(date, token);
//   },
//   // Local week-numbering year
//   Y: function Y(date, token, localize, options) {
//     var signedWeekYear = getUTCWeekYear(date, options);
//     // Returns 1 for 1 BC (which is year 0 in JavaScript)
//     var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

//     // Two digit year
//     if (token === 'YY') {
//       var twoDigitYear = weekYear % 100;
//       return addLeadingZeros(twoDigitYear, 2);
//     }

//     // Ordinal number
//     if (token === 'Yo') {
//       return localize.ordinalNumber(weekYear, {
//         unit: 'year'
//       });
//     }

//     // Padding
//     return addLeadingZeros(weekYear, token.length);
//   },
//   // ISO week-numbering year
//   R: function R(date, token) {
//     var isoWeekYear = getUTCISOWeekYear(date);

//     // Padding
//     return addLeadingZeros(isoWeekYear, token.length);
//   },
//   // Extended year. This is a single number designating the year of this calendar system.
//   // The main difference between `y` and `u` localizers are B.C. years:
//   // | Year | `y` | `u` |
//   // |------|-----|-----|
//   // | AC 1 |   1 |   1 |
//   // | BC 1 |   1 |   0 |
//   // | BC 2 |   2 |  -1 |
//   // Also `yy` always returns the last two digits of a year,
//   // while `uu` pads single digit years to 2 characters and returns other years unchanged.
//   u: function u(date, token) {
//     var year = date.getUTCFullYear();
//     return addLeadingZeros(year, token.length);
//   },
//   // Quarter
//   Q: function Q(date, token, localize) {
//     var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
//     switch (token) {
//       // 1, 2, 3, 4
//       case 'Q':
//         return String(quarter);
//       // 01, 02, 03, 04
//       case 'QQ':
//         return addLeadingZeros(quarter, 2);
//       // 1st, 2nd, 3rd, 4th
//       case 'Qo':
//         return localize.ordinalNumber(quarter, {
//           unit: 'quarter'
//         });
//       // Q1, Q2, Q3, Q4
//       case 'QQQ':
//         return localize.quarter(quarter, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       // 1, 2, 3, 4 (narrow quarter; could be not numerical)
//       case 'QQQQQ':
//         return localize.quarter(quarter, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       // 1st quarter, 2nd quarter, ...
//       case 'QQQQ':
//       default:
//         return localize.quarter(quarter, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // Stand-alone quarter
//   q: function q(date, token, localize) {
//     var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
//     switch (token) {
//       // 1, 2, 3, 4
//       case 'q':
//         return String(quarter);
//       // 01, 02, 03, 04
//       case 'qq':
//         return addLeadingZeros(quarter, 2);
//       // 1st, 2nd, 3rd, 4th
//       case 'qo':
//         return localize.ordinalNumber(quarter, {
//           unit: 'quarter'
//         });
//       // Q1, Q2, Q3, Q4
//       case 'qqq':
//         return localize.quarter(quarter, {
//           width: 'abbreviated',
//           context: 'standalone'
//         });
//       // 1, 2, 3, 4 (narrow quarter; could be not numerical)
//       case 'qqqqq':
//         return localize.quarter(quarter, {
//           width: 'narrow',
//           context: 'standalone'
//         });
//       // 1st quarter, 2nd quarter, ...
//       case 'qqqq':
//       default:
//         return localize.quarter(quarter, {
//           width: 'wide',
//           context: 'standalone'
//         });
//     }
//   },
//   // Month
//   M: function M(date, token, localize) {
//     var month = date.getUTCMonth();
//     switch (token) {
//       case 'M':
//       case 'MM':
//         return formatters$1.M(date, token);
//       // 1st, 2nd, ..., 12th
//       case 'Mo':
//         return localize.ordinalNumber(month + 1, {
//           unit: 'month'
//         });
//       // Jan, Feb, ..., Dec
//       case 'MMM':
//         return localize.month(month, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       // J, F, ..., D
//       case 'MMMMM':
//         return localize.month(month, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       // January, February, ..., December
//       case 'MMMM':
//       default:
//         return localize.month(month, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // Stand-alone month
//   L: function L(date, token, localize) {
//     var month = date.getUTCMonth();
//     switch (token) {
//       // 1, 2, ..., 12
//       case 'L':
//         return String(month + 1);
//       // 01, 02, ..., 12
//       case 'LL':
//         return addLeadingZeros(month + 1, 2);
//       // 1st, 2nd, ..., 12th
//       case 'Lo':
//         return localize.ordinalNumber(month + 1, {
//           unit: 'month'
//         });
//       // Jan, Feb, ..., Dec
//       case 'LLL':
//         return localize.month(month, {
//           width: 'abbreviated',
//           context: 'standalone'
//         });
//       // J, F, ..., D
//       case 'LLLLL':
//         return localize.month(month, {
//           width: 'narrow',
//           context: 'standalone'
//         });
//       // January, February, ..., December
//       case 'LLLL':
//       default:
//         return localize.month(month, {
//           width: 'wide',
//           context: 'standalone'
//         });
//     }
//   },
//   // Local week of year
//   w: function w(date, token, localize, options) {
//     var week = getUTCWeek(date, options);
//     if (token === 'wo') {
//       return localize.ordinalNumber(week, {
//         unit: 'week'
//       });
//     }
//     return addLeadingZeros(week, token.length);
//   },
//   // ISO week of year
//   I: function I(date, token, localize) {
//     var isoWeek = getUTCISOWeek(date);
//     if (token === 'Io') {
//       return localize.ordinalNumber(isoWeek, {
//         unit: 'week'
//       });
//     }
//     return addLeadingZeros(isoWeek, token.length);
//   },
//   // Day of the month
//   d: function d(date, token, localize) {
//     if (token === 'do') {
//       return localize.ordinalNumber(date.getUTCDate(), {
//         unit: 'date'
//       });
//     }
//     return formatters$1.d(date, token);
//   },
//   // Day of year
//   D: function D(date, token, localize) {
//     var dayOfYear = getUTCDayOfYear(date);
//     if (token === 'Do') {
//       return localize.ordinalNumber(dayOfYear, {
//         unit: 'dayOfYear'
//       });
//     }
//     return addLeadingZeros(dayOfYear, token.length);
//   },
//   // Day of week
//   E: function E(date, token, localize) {
//     var dayOfWeek = date.getUTCDay();
//     switch (token) {
//       // Tue
//       case 'E':
//       case 'EE':
//       case 'EEE':
//         return localize.day(dayOfWeek, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       // T
//       case 'EEEEE':
//         return localize.day(dayOfWeek, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       // Tu
//       case 'EEEEEE':
//         return localize.day(dayOfWeek, {
//           width: 'short',
//           context: 'formatting'
//         });
//       // Tuesday
//       case 'EEEE':
//       default:
//         return localize.day(dayOfWeek, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // Local day of week
//   e: function e(date, token, localize, options) {
//     var dayOfWeek = date.getUTCDay();
//     var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
//     switch (token) {
//       // Numerical value (Nth day of week with current locale or weekStartsOn)
//       case 'e':
//         return String(localDayOfWeek);
//       // Padded numerical value
//       case 'ee':
//         return addLeadingZeros(localDayOfWeek, 2);
//       // 1st, 2nd, ..., 7th
//       case 'eo':
//         return localize.ordinalNumber(localDayOfWeek, {
//           unit: 'day'
//         });
//       case 'eee':
//         return localize.day(dayOfWeek, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       // T
//       case 'eeeee':
//         return localize.day(dayOfWeek, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       // Tu
//       case 'eeeeee':
//         return localize.day(dayOfWeek, {
//           width: 'short',
//           context: 'formatting'
//         });
//       // Tuesday
//       case 'eeee':
//       default:
//         return localize.day(dayOfWeek, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // Stand-alone local day of week
//   c: function c(date, token, localize, options) {
//     var dayOfWeek = date.getUTCDay();
//     var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
//     switch (token) {
//       // Numerical value (same as in `e`)
//       case 'c':
//         return String(localDayOfWeek);
//       // Padded numerical value
//       case 'cc':
//         return addLeadingZeros(localDayOfWeek, token.length);
//       // 1st, 2nd, ..., 7th
//       case 'co':
//         return localize.ordinalNumber(localDayOfWeek, {
//           unit: 'day'
//         });
//       case 'ccc':
//         return localize.day(dayOfWeek, {
//           width: 'abbreviated',
//           context: 'standalone'
//         });
//       // T
//       case 'ccccc':
//         return localize.day(dayOfWeek, {
//           width: 'narrow',
//           context: 'standalone'
//         });
//       // Tu
//       case 'cccccc':
//         return localize.day(dayOfWeek, {
//           width: 'short',
//           context: 'standalone'
//         });
//       // Tuesday
//       case 'cccc':
//       default:
//         return localize.day(dayOfWeek, {
//           width: 'wide',
//           context: 'standalone'
//         });
//     }
//   },
//   // ISO day of week
//   i: function i(date, token, localize) {
//     var dayOfWeek = date.getUTCDay();
//     var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
//     switch (token) {
//       // 2
//       case 'i':
//         return String(isoDayOfWeek);
//       // 02
//       case 'ii':
//         return addLeadingZeros(isoDayOfWeek, token.length);
//       // 2nd
//       case 'io':
//         return localize.ordinalNumber(isoDayOfWeek, {
//           unit: 'day'
//         });
//       // Tue
//       case 'iii':
//         return localize.day(dayOfWeek, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       // T
//       case 'iiiii':
//         return localize.day(dayOfWeek, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       // Tu
//       case 'iiiiii':
//         return localize.day(dayOfWeek, {
//           width: 'short',
//           context: 'formatting'
//         });
//       // Tuesday
//       case 'iiii':
//       default:
//         return localize.day(dayOfWeek, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // AM or PM
//   a: function a(date, token, localize) {
//     var hours = date.getUTCHours();
//     var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
//     switch (token) {
//       case 'a':
//       case 'aa':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       case 'aaa':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'abbreviated',
//           context: 'formatting'
//         }).toLowerCase();
//       case 'aaaaa':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       case 'aaaa':
//       default:
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // AM, PM, midnight, noon
//   b: function b(date, token, localize) {
//     var hours = date.getUTCHours();
//     var dayPeriodEnumValue;
//     if (hours === 12) {
//       dayPeriodEnumValue = dayPeriodEnum.noon;
//     } else if (hours === 0) {
//       dayPeriodEnumValue = dayPeriodEnum.midnight;
//     } else {
//       dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
//     }
//     switch (token) {
//       case 'b':
//       case 'bb':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       case 'bbb':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'abbreviated',
//           context: 'formatting'
//         }).toLowerCase();
//       case 'bbbbb':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       case 'bbbb':
//       default:
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // in the morning, in the afternoon, in the evening, at night
//   B: function B(date, token, localize) {
//     var hours = date.getUTCHours();
//     var dayPeriodEnumValue;
//     if (hours >= 17) {
//       dayPeriodEnumValue = dayPeriodEnum.evening;
//     } else if (hours >= 12) {
//       dayPeriodEnumValue = dayPeriodEnum.afternoon;
//     } else if (hours >= 4) {
//       dayPeriodEnumValue = dayPeriodEnum.morning;
//     } else {
//       dayPeriodEnumValue = dayPeriodEnum.night;
//     }
//     switch (token) {
//       case 'B':
//       case 'BB':
//       case 'BBB':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'abbreviated',
//           context: 'formatting'
//         });
//       case 'BBBBB':
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'narrow',
//           context: 'formatting'
//         });
//       case 'BBBB':
//       default:
//         return localize.dayPeriod(dayPeriodEnumValue, {
//           width: 'wide',
//           context: 'formatting'
//         });
//     }
//   },
//   // Hour [1-12]
//   h: function h(date, token, localize) {
//     if (token === 'ho') {
//       var hours = date.getUTCHours() % 12;
//       if (hours === 0) hours = 12;
//       return localize.ordinalNumber(hours, {
//         unit: 'hour'
//       });
//     }
//     return formatters$1.h(date, token);
//   },
//   // Hour [0-23]
//   H: function H(date, token, localize) {
//     if (token === 'Ho') {
//       return localize.ordinalNumber(date.getUTCHours(), {
//         unit: 'hour'
//       });
//     }
//     return formatters$1.H(date, token);
//   },
//   // Hour [0-11]
//   K: function K(date, token, localize) {
//     var hours = date.getUTCHours() % 12;
//     if (token === 'Ko') {
//       return localize.ordinalNumber(hours, {
//         unit: 'hour'
//       });
//     }
//     return addLeadingZeros(hours, token.length);
//   },
//   // Hour [1-24]
//   k: function k(date, token, localize) {
//     var hours = date.getUTCHours();
//     if (hours === 0) hours = 24;
//     if (token === 'ko') {
//       return localize.ordinalNumber(hours, {
//         unit: 'hour'
//       });
//     }
//     return addLeadingZeros(hours, token.length);
//   },
//   // Minute
//   m: function m(date, token, localize) {
//     if (token === 'mo') {
//       return localize.ordinalNumber(date.getUTCMinutes(), {
//         unit: 'minute'
//       });
//     }
//     return formatters$1.m(date, token);
//   },
//   // Second
//   s: function s(date, token, localize) {
//     if (token === 'so') {
//       return localize.ordinalNumber(date.getUTCSeconds(), {
//         unit: 'second'
//       });
//     }
//     return formatters$1.s(date, token);
//   },
//   // Fraction of second
//   S: function S(date, token) {
//     return formatters$1.S(date, token);
//   },
//   // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
//   X: function X(date, token, _localize, options) {
//     var originalDate = options._originalDate || date;
//     var timezoneOffset = originalDate.getTimezoneOffset();
//     if (timezoneOffset === 0) {
//       return 'Z';
//     }
//     switch (token) {
//       // Hours and optional minutes
//       case 'X':
//         return formatTimezoneWithOptionalMinutes(timezoneOffset);

//       // Hours, minutes and optional seconds without `:` delimiter
//       // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
//       // so this token always has the same output as `XX`
//       case 'XXXX':
//       case 'XX':
//         // Hours and minutes without `:` delimiter
//         return formatTimezone(timezoneOffset);

//       // Hours, minutes and optional seconds with `:` delimiter
//       // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
//       // so this token always has the same output as `XXX`
//       case 'XXXXX':
//       case 'XXX': // Hours and minutes with `:` delimiter
//       default:
//         return formatTimezone(timezoneOffset, ':');
//     }
//   },
//   // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
//   x: function x(date, token, _localize, options) {
//     var originalDate = options._originalDate || date;
//     var timezoneOffset = originalDate.getTimezoneOffset();
//     switch (token) {
//       // Hours and optional minutes
//       case 'x':
//         return formatTimezoneWithOptionalMinutes(timezoneOffset);

//       // Hours, minutes and optional seconds without `:` delimiter
//       // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
//       // so this token always has the same output as `xx`
//       case 'xxxx':
//       case 'xx':
//         // Hours and minutes without `:` delimiter
//         return formatTimezone(timezoneOffset);

//       // Hours, minutes and optional seconds with `:` delimiter
//       // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
//       // so this token always has the same output as `xxx`
//       case 'xxxxx':
//       case 'xxx': // Hours and minutes with `:` delimiter
//       default:
//         return formatTimezone(timezoneOffset, ':');
//     }
//   },
//   // Timezone (GMT)
//   O: function O(date, token, _localize, options) {
//     var originalDate = options._originalDate || date;
//     var timezoneOffset = originalDate.getTimezoneOffset();
//     switch (token) {
//       // Short
//       case 'O':
//       case 'OO':
//       case 'OOO':
//         return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
//       // Long
//       case 'OOOO':
//       default:
//         return 'GMT' + formatTimezone(timezoneOffset, ':');
//     }
//   },
//   // Timezone (specific non-location)
//   z: function z(date, token, _localize, options) {
//     var originalDate = options._originalDate || date;
//     var timezoneOffset = originalDate.getTimezoneOffset();
//     switch (token) {
//       // Short
//       case 'z':
//       case 'zz':
//       case 'zzz':
//         return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
//       // Long
//       case 'zzzz':
//       default:
//         return 'GMT' + formatTimezone(timezoneOffset, ':');
//     }
//   },
//   // Seconds timestamp
//   t: function t(date, token, _localize, options) {
//     var originalDate = options._originalDate || date;
//     var timestamp = Math.floor(originalDate.getTime() / 1000);
//     return addLeadingZeros(timestamp, token.length);
//   },
//   // Milliseconds timestamp
//   T: function T(date, token, _localize, options) {
//     var originalDate = options._originalDate || date;
//     var timestamp = originalDate.getTime();
//     return addLeadingZeros(timestamp, token.length);
//   }
// };
// function formatTimezoneShort(offset, dirtyDelimiter) {
//   var sign = offset > 0 ? '-' : '+';
//   var absOffset = Math.abs(offset);
//   var hours = Math.floor(absOffset / 60);
//   var minutes = absOffset % 60;
//   if (minutes === 0) {
//     return sign + String(hours);
//   }
//   var delimiter = dirtyDelimiter || '';
//   return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
// }
// function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
//   if (offset % 60 === 0) {
//     var sign = offset > 0 ? '-' : '+';
//     return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
//   }
//   return formatTimezone(offset, dirtyDelimiter);
// }
// function formatTimezone(offset, dirtyDelimiter) {
//   var delimiter = dirtyDelimiter || '';
//   var sign = offset > 0 ? '-' : '+';
//   var absOffset = Math.abs(offset);
//   var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
//   var minutes = addLeadingZeros(absOffset % 60, 2);
//   return sign + hours + delimiter + minutes;
// }

// var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
//   switch (pattern) {
//     case 'P':
//       return formatLong.date({
//         width: 'short'
//       });
//     case 'PP':
//       return formatLong.date({
//         width: 'medium'
//       });
//     case 'PPP':
//       return formatLong.date({
//         width: 'long'
//       });
//     case 'PPPP':
//     default:
//       return formatLong.date({
//         width: 'full'
//       });
//   }
// };
// var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
//   switch (pattern) {
//     case 'p':
//       return formatLong.time({
//         width: 'short'
//       });
//     case 'pp':
//       return formatLong.time({
//         width: 'medium'
//       });
//     case 'ppp':
//       return formatLong.time({
//         width: 'long'
//       });
//     case 'pppp':
//     default:
//       return formatLong.time({
//         width: 'full'
//       });
//   }
// };
// var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
//   var matchResult = pattern.match(/(P+)(p+)?/) || [];
//   var datePattern = matchResult[1];
//   var timePattern = matchResult[2];
//   if (!timePattern) {
//     return dateLongFormatter(pattern, formatLong);
//   }
//   var dateTimeFormat;
//   switch (datePattern) {
//     case 'P':
//       dateTimeFormat = formatLong.dateTime({
//         width: 'short'
//       });
//       break;
//     case 'PP':
//       dateTimeFormat = formatLong.dateTime({
//         width: 'medium'
//       });
//       break;
//     case 'PPP':
//       dateTimeFormat = formatLong.dateTime({
//         width: 'long'
//       });
//       break;
//     case 'PPPP':
//     default:
//       dateTimeFormat = formatLong.dateTime({
//         width: 'full'
//       });
//       break;
//   }
//   return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
// };
// var longFormatters = {
//   p: timeLongFormatter,
//   P: dateTimeLongFormatter
// };

// var protectedDayOfYearTokens = ['D', 'DD'];
// var protectedWeekYearTokens = ['YY', 'YYYY'];
// function isProtectedDayOfYearToken(token) {
//   return protectedDayOfYearTokens.indexOf(token) !== -1;
// }
// function isProtectedWeekYearToken(token) {
//   return protectedWeekYearTokens.indexOf(token) !== -1;
// }
// function throwProtectedError(token, format, input) {
//   if (token === 'YYYY') {
//     throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
//   } else if (token === 'YY') {
//     throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
//   } else if (token === 'D') {
//     throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
//   } else if (token === 'DD') {
//     throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
//   }
// }

// var formatDistanceLocale = {
//   lessThanXSeconds: {
//     one: 'less than a second',
//     other: 'less than {{count}} seconds'
//   },
//   xSeconds: {
//     one: '1 second',
//     other: '{{count}} seconds'
//   },
//   halfAMinute: 'half a minute',
//   lessThanXMinutes: {
//     one: 'less than a minute',
//     other: 'less than {{count}} minutes'
//   },
//   xMinutes: {
//     one: '1 minute',
//     other: '{{count}} minutes'
//   },
//   aboutXHours: {
//     one: 'about 1 hour',
//     other: 'about {{count}} hours'
//   },
//   xHours: {
//     one: '1 hour',
//     other: '{{count}} hours'
//   },
//   xDays: {
//     one: '1 day',
//     other: '{{count}} days'
//   },
//   aboutXWeeks: {
//     one: 'about 1 week',
//     other: 'about {{count}} weeks'
//   },
//   xWeeks: {
//     one: '1 week',
//     other: '{{count}} weeks'
//   },
//   aboutXMonths: {
//     one: 'about 1 month',
//     other: 'about {{count}} months'
//   },
//   xMonths: {
//     one: '1 month',
//     other: '{{count}} months'
//   },
//   aboutXYears: {
//     one: 'about 1 year',
//     other: 'about {{count}} years'
//   },
//   xYears: {
//     one: '1 year',
//     other: '{{count}} years'
//   },
//   overXYears: {
//     one: 'over 1 year',
//     other: 'over {{count}} years'
//   },
//   almostXYears: {
//     one: 'almost 1 year',
//     other: 'almost {{count}} years'
//   }
// };
// var formatDistance = function formatDistance(token, count, options) {
//   var result;
//   var tokenValue = formatDistanceLocale[token];
//   if (typeof tokenValue === 'string') {
//     result = tokenValue;
//   } else if (count === 1) {
//     result = tokenValue.one;
//   } else {
//     result = tokenValue.other.replace('{{count}}', count.toString());
//   }
//   if (options !== null && options !== void 0 && options.addSuffix) {
//     if (options.comparison && options.comparison > 0) {
//       return 'in ' + result;
//     } else {
//       return result + ' ago';
//     }
//   }
//   return result;
// };

// function buildFormatLongFn(args) {
//   return function () {
//     var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
//     // TODO: Remove String()
//     var width = options.width ? String(options.width) : args.defaultWidth;
//     var format = args.formats[width] || args.formats[args.defaultWidth];
//     return format;
//   };
// }

// var dateFormats = {
//   full: 'EEEE, MMMM do, y',
//   long: 'MMMM do, y',
//   medium: 'MMM d, y',
//   short: 'MM/dd/yyyy'
// };
// var timeFormats = {
//   full: 'h:mm:ss a zzzz',
//   long: 'h:mm:ss a z',
//   medium: 'h:mm:ss a',
//   short: 'h:mm a'
// };
// var dateTimeFormats = {
//   full: "{{date}} 'at' {{time}}",
//   long: "{{date}} 'at' {{time}}",
//   medium: '{{date}}, {{time}}',
//   short: '{{date}}, {{time}}'
// };
// var formatLong = {
//   date: buildFormatLongFn({
//     formats: dateFormats,
//     defaultWidth: 'full'
//   }),
//   time: buildFormatLongFn({
//     formats: timeFormats,
//     defaultWidth: 'full'
//   }),
//   dateTime: buildFormatLongFn({
//     formats: dateTimeFormats,
//     defaultWidth: 'full'
//   })
// };

// var formatRelativeLocale = {
//   lastWeek: "'last' eeee 'at' p",
//   yesterday: "'yesterday at' p",
//   today: "'today at' p",
//   tomorrow: "'tomorrow at' p",
//   nextWeek: "eeee 'at' p",
//   other: 'P'
// };
// var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
//   return formatRelativeLocale[token];
// };

// function buildLocalizeFn(args) {
//   return function (dirtyIndex, options) {
//     var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
//     var valuesArray;
//     if (context === 'formatting' && args.formattingValues) {
//       var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
//       var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
//       valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
//     } else {
//       var _defaultWidth = args.defaultWidth;
//       var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
//       valuesArray = args.values[_width] || args.values[_defaultWidth];
//     }
//     var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
//     // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
//     return valuesArray[index];
//   };
// }

// var eraValues = {
//   narrow: ['B', 'A'],
//   abbreviated: ['BC', 'AD'],
//   wide: ['Before Christ', 'Anno Domini']
// };
// var quarterValues = {
//   narrow: ['1', '2', '3', '4'],
//   abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
//   wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
// };

// // Note: in English, the names of days of the week and months are capitalized.
// // If you are making a new locale based on this one, check if the same is true for the language you're working on.
// // Generally, formatted dates should look like they are in the middle of a sentence,
// // e.g. in Spanish language the weekdays and months should be in the lowercase.
// var monthValues = {
//   narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
//   abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
//   wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
// };
// var dayValues = {
//   narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
//   short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
//   abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
//   wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
// };
// var dayPeriodValues = {
//   narrow: {
//     am: 'a',
//     pm: 'p',
//     midnight: 'mi',
//     noon: 'n',
//     morning: 'morning',
//     afternoon: 'afternoon',
//     evening: 'evening',
//     night: 'night'
//   },
//   abbreviated: {
//     am: 'AM',
//     pm: 'PM',
//     midnight: 'midnight',
//     noon: 'noon',
//     morning: 'morning',
//     afternoon: 'afternoon',
//     evening: 'evening',
//     night: 'night'
//   },
//   wide: {
//     am: 'a.m.',
//     pm: 'p.m.',
//     midnight: 'midnight',
//     noon: 'noon',
//     morning: 'morning',
//     afternoon: 'afternoon',
//     evening: 'evening',
//     night: 'night'
//   }
// };
// var formattingDayPeriodValues = {
//   narrow: {
//     am: 'a',
//     pm: 'p',
//     midnight: 'mi',
//     noon: 'n',
//     morning: 'in the morning',
//     afternoon: 'in the afternoon',
//     evening: 'in the evening',
//     night: 'at night'
//   },
//   abbreviated: {
//     am: 'AM',
//     pm: 'PM',
//     midnight: 'midnight',
//     noon: 'noon',
//     morning: 'in the morning',
//     afternoon: 'in the afternoon',
//     evening: 'in the evening',
//     night: 'at night'
//   },
//   wide: {
//     am: 'a.m.',
//     pm: 'p.m.',
//     midnight: 'midnight',
//     noon: 'noon',
//     morning: 'in the morning',
//     afternoon: 'in the afternoon',
//     evening: 'in the evening',
//     night: 'at night'
//   }
// };
// var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
//   var number = Number(dirtyNumber);

//   // If ordinal numbers depend on context, for example,
//   // if they are different for different grammatical genders,
//   // use `options.unit`.
//   //
//   // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
//   // 'day', 'hour', 'minute', 'second'.

//   var rem100 = number % 100;
//   if (rem100 > 20 || rem100 < 10) {
//     switch (rem100 % 10) {
//       case 1:
//         return number + 'st';
//       case 2:
//         return number + 'nd';
//       case 3:
//         return number + 'rd';
//     }
//   }
//   return number + 'th';
// };
// var localize = {
//   ordinalNumber: ordinalNumber,
//   era: buildLocalizeFn({
//     values: eraValues,
//     defaultWidth: 'wide'
//   }),
//   quarter: buildLocalizeFn({
//     values: quarterValues,
//     defaultWidth: 'wide',
//     argumentCallback: function argumentCallback(quarter) {
//       return quarter - 1;
//     }
//   }),
//   month: buildLocalizeFn({
//     values: monthValues,
//     defaultWidth: 'wide'
//   }),
//   day: buildLocalizeFn({
//     values: dayValues,
//     defaultWidth: 'wide'
//   }),
//   dayPeriod: buildLocalizeFn({
//     values: dayPeriodValues,
//     defaultWidth: 'wide',
//     formattingValues: formattingDayPeriodValues,
//     defaultFormattingWidth: 'wide'
//   })
// };

// function buildMatchFn(args) {
//   return function (string) {
//     var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
//     var width = options.width;
//     var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
//     var matchResult = string.match(matchPattern);
//     if (!matchResult) {
//       return null;
//     }
//     var matchedString = matchResult[0];
//     var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
//     var key = Array.isArray(parsePatterns) ? findIndex$1(parsePatterns, function (pattern) {
//       return pattern.test(matchedString);
//     }) : findKey(parsePatterns, function (pattern) {
//       return pattern.test(matchedString);
//     });
//     var value;
//     value = args.valueCallback ? args.valueCallback(key) : key;
//     value = options.valueCallback ? options.valueCallback(value) : value;
//     var rest = string.slice(matchedString.length);
//     return {
//       value: value,
//       rest: rest
//     };
//   };
// }
// function findKey(object, predicate) {
//   for (var key in object) {
//     if (object.hasOwnProperty(key) && predicate(object[key])) {
//       return key;
//     }
//   }
//   return undefined;
// }
// function findIndex$1(array, predicate) {
//   for (var key = 0; key < array.length; key++) {
//     if (predicate(array[key])) {
//       return key;
//     }
//   }
//   return undefined;
// }

// function buildMatchPatternFn(args) {
//   return function (string) {
//     var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
//     var matchResult = string.match(args.matchPattern);
//     if (!matchResult) return null;
//     var matchedString = matchResult[0];
//     var parseResult = string.match(args.parsePattern);
//     if (!parseResult) return null;
//     var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
//     value = options.valueCallback ? options.valueCallback(value) : value;
//     var rest = string.slice(matchedString.length);
//     return {
//       value: value,
//       rest: rest
//     };
//   };
// }

// var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
// var parseOrdinalNumberPattern = /\d+/i;
// var matchEraPatterns = {
//   narrow: /^(b|a)/i,
//   abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
//   wide: /^(before christ|before common era|anno domini|common era)/i
// };
// var parseEraPatterns = {
//   any: [/^b/i, /^(a|c)/i]
// };
// var matchQuarterPatterns = {
//   narrow: /^[1234]/i,
//   abbreviated: /^q[1234]/i,
//   wide: /^[1234](th|st|nd|rd)? quarter/i
// };
// var parseQuarterPatterns = {
//   any: [/1/i, /2/i, /3/i, /4/i]
// };
// var matchMonthPatterns = {
//   narrow: /^[jfmasond]/i,
//   abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
//   wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
// };
// var parseMonthPatterns = {
//   narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
//   any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
// };
// var matchDayPatterns = {
//   narrow: /^[smtwf]/i,
//   short: /^(su|mo|tu|we|th|fr|sa)/i,
//   abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
//   wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
// };
// var parseDayPatterns = {
//   narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
//   any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
// };
// var matchDayPeriodPatterns = {
//   narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
//   any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
// };
// var parseDayPeriodPatterns = {
//   any: {
//     am: /^a/i,
//     pm: /^p/i,
//     midnight: /^mi/i,
//     noon: /^no/i,
//     morning: /morning/i,
//     afternoon: /afternoon/i,
//     evening: /evening/i,
//     night: /night/i
//   }
// };
// var match = {
//   ordinalNumber: buildMatchPatternFn({
//     matchPattern: matchOrdinalNumberPattern,
//     parsePattern: parseOrdinalNumberPattern,
//     valueCallback: function valueCallback(value) {
//       return parseInt(value, 10);
//     }
//   }),
//   era: buildMatchFn({
//     matchPatterns: matchEraPatterns,
//     defaultMatchWidth: 'wide',
//     parsePatterns: parseEraPatterns,
//     defaultParseWidth: 'any'
//   }),
//   quarter: buildMatchFn({
//     matchPatterns: matchQuarterPatterns,
//     defaultMatchWidth: 'wide',
//     parsePatterns: parseQuarterPatterns,
//     defaultParseWidth: 'any',
//     valueCallback: function valueCallback(index) {
//       return index + 1;
//     }
//   }),
//   month: buildMatchFn({
//     matchPatterns: matchMonthPatterns,
//     defaultMatchWidth: 'wide',
//     parsePatterns: parseMonthPatterns,
//     defaultParseWidth: 'any'
//   }),
//   day: buildMatchFn({
//     matchPatterns: matchDayPatterns,
//     defaultMatchWidth: 'wide',
//     parsePatterns: parseDayPatterns,
//     defaultParseWidth: 'any'
//   }),
//   dayPeriod: buildMatchFn({
//     matchPatterns: matchDayPeriodPatterns,
//     defaultMatchWidth: 'any',
//     parsePatterns: parseDayPeriodPatterns,
//     defaultParseWidth: 'any'
//   })
// };

// /**
//  * @type {Locale}
//  * @category Locales
//  * @summary English locale (United States).
//  * @language English
//  * @iso-639-2 eng
//  * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
//  * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
//  */
// var locale = {
//   code: 'en-US',
//   formatDistance: formatDistance,
//   formatLong: formatLong,
//   formatRelative: formatRelative,
//   localize: localize,
//   match: match,
//   options: {
//     weekStartsOn: 0 /* Sunday */,
//     firstWeekContainsDate: 1
//   }
// };

// // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
// //   (one of the certain letters followed by `o`)
// // - (\w)\1* matches any sequences of the same letter
// // - '' matches two quote characters in a row
// // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
// //   except a single quote symbol, which ends the sequence.
// //   Two quote characters do not end the sequence.
// //   If there is no matching single quote
// //   then the sequence will continue until the end of the string.
// // - . matches any single character unmatched by previous parts of the RegExps
// var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// // This RegExp catches symbols escaped by quotes, and also
// // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
// var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
// var escapedStringRegExp$1 = /^'([^]*?)'?$/;
// var doubleQuoteRegExp$1 = /''/g;
// var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;

// /**
//  * @name format
//  * @category Common Helpers
//  * @summary Format the date.
//  *
//  * @description
//  * Return the formatted date string in the given format. The result may vary by locale.
//  *
//  * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
//  * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  *
//  * The characters wrapped between two single quotes characters (') are escaped.
//  * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
//  * (see the last example)
//  *
//  * Format of the string is based on Unicode Technical Standard #35:
//  * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
//  * with a few additions (see note 7 below the table).
//  *
//  * Accepted patterns:
//  * | Unit                            | Pattern | Result examples                   | Notes |
//  * |---------------------------------|---------|-----------------------------------|-------|
//  * | Era                             | G..GGG  | AD, BC                            |       |
//  * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
//  * |                                 | GGGGG   | A, B                              |       |
//  * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
//  * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
//  * |                                 | yy      | 44, 01, 00, 17                    | 5     |
//  * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
//  * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
//  * |                                 | yyyyy   | ...                               | 3,5   |
//  * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
//  * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
//  * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
//  * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
//  * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
//  * |                                 | YYYYY   | ...                               | 3,5   |
//  * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
//  * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
//  * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
//  * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
//  * |                                 | RRRRR   | ...                               | 3,5,7 |
//  * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
//  * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
//  * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
//  * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
//  * |                                 | uuuuu   | ...                               | 3,5   |
//  * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
//  * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
//  * |                                 | QQ      | 01, 02, 03, 04                    |       |
//  * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
//  * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
//  * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
//  * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
//  * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
//  * |                                 | qq      | 01, 02, 03, 04                    |       |
//  * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
//  * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
//  * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
//  * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
//  * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
//  * |                                 | MM      | 01, 02, ..., 12                   |       |
//  * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
//  * |                                 | MMMM    | January, February, ..., December  | 2     |
//  * |                                 | MMMMM   | J, F, ..., D                      |       |
//  * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
//  * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
//  * |                                 | LL      | 01, 02, ..., 12                   |       |
//  * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
//  * |                                 | LLLL    | January, February, ..., December  | 2     |
//  * |                                 | LLLLL   | J, F, ..., D                      |       |
//  * | Local week of year              | w       | 1, 2, ..., 53                     |       |
//  * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
//  * |                                 | ww      | 01, 02, ..., 53                   |       |
//  * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
//  * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
//  * |                                 | II      | 01, 02, ..., 53                   | 7     |
//  * | Day of month                    | d       | 1, 2, ..., 31                     |       |
//  * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
//  * |                                 | dd      | 01, 02, ..., 31                   |       |
//  * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
//  * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
//  * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
//  * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
//  * |                                 | DDDD    | ...                               | 3     |
//  * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
//  * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
//  * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
//  * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
//  * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
//  * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
//  * |                                 | ii      | 01, 02, ..., 07                   | 7     |
//  * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
//  * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
//  * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
//  * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
//  * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
//  * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
//  * |                                 | ee      | 02, 03, ..., 01                   |       |
//  * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
//  * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
//  * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
//  * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
//  * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
//  * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
//  * |                                 | cc      | 02, 03, ..., 01                   |       |
//  * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
//  * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
//  * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
//  * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
//  * | AM, PM                          | a..aa   | AM, PM                            |       |
//  * |                                 | aaa     | am, pm                            |       |
//  * |                                 | aaaa    | a.m., p.m.                        | 2     |
//  * |                                 | aaaaa   | a, p                              |       |
//  * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
//  * |                                 | bbb     | am, pm, noon, midnight            |       |
//  * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
//  * |                                 | bbbbb   | a, p, n, mi                       |       |
//  * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
//  * |                                 | BBBB    | at night, in the morning, ...     | 2     |
//  * |                                 | BBBBB   | at night, in the morning, ...     |       |
//  * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
//  * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
//  * |                                 | hh      | 01, 02, ..., 11, 12               |       |
//  * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
//  * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
//  * |                                 | HH      | 00, 01, 02, ..., 23               |       |
//  * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
//  * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
//  * |                                 | KK      | 01, 02, ..., 11, 00               |       |
//  * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
//  * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
//  * |                                 | kk      | 24, 01, 02, ..., 23               |       |
//  * | Minute                          | m       | 0, 1, ..., 59                     |       |
//  * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
//  * |                                 | mm      | 00, 01, ..., 59                   |       |
//  * | Second                          | s       | 0, 1, ..., 59                     |       |
//  * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
//  * |                                 | ss      | 00, 01, ..., 59                   |       |
//  * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
//  * |                                 | SS      | 00, 01, ..., 99                   |       |
//  * |                                 | SSS     | 000, 001, ..., 999                |       |
//  * |                                 | SSSS    | ...                               | 3     |
//  * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
//  * |                                 | XX      | -0800, +0530, Z                   |       |
//  * |                                 | XXX     | -08:00, +05:30, Z                 |       |
//  * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
//  * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
//  * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
//  * |                                 | xx      | -0800, +0530, +0000               |       |
//  * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
//  * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
//  * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
//  * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
//  * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
//  * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
//  * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
//  * | Seconds timestamp               | t       | 512969520                         | 7     |
//  * |                                 | tt      | ...                               | 3,7   |
//  * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
//  * |                                 | TT      | ...                               | 3,7   |
//  * | Long localized date             | P       | 04/29/1453                        | 7     |
//  * |                                 | PP      | Apr 29, 1453                      | 7     |
//  * |                                 | PPP     | April 29th, 1453                  | 7     |
//  * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
//  * | Long localized time             | p       | 12:00 AM                          | 7     |
//  * |                                 | pp      | 12:00:00 AM                       | 7     |
//  * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
//  * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
//  * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
//  * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
//  * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
//  * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
//  * Notes:
//  * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
//  *    are the same as "stand-alone" units, but are different in some languages.
//  *    "Formatting" units are declined according to the rules of the language
//  *    in the context of a date. "Stand-alone" units are always nominative singular:
//  *
//  *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
//  *
//  *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
//  *
//  * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
//  *    the single quote characters (see below).
//  *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
//  *    the output will be the same as default pattern for this unit, usually
//  *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
//  *    are marked with "2" in the last column of the table.
//  *
//  *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
//  *
//  *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
//  *
//  *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
//  *
//  *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
//  *
//  *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
//  *
//  * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
//  *    The output will be padded with zeros to match the length of the pattern.
//  *
//  *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
//  *
//  * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
//  *    These tokens represent the shortest form of the quarter.
//  *
//  * 5. The main difference between `y` and `u` patterns are B.C. years:
//  *
//  *    | Year | `y` | `u` |
//  *    |------|-----|-----|
//  *    | AC 1 |   1 |   1 |
//  *    | BC 1 |   1 |   0 |
//  *    | BC 2 |   2 |  -1 |
//  *
//  *    Also `yy` always returns the last two digits of a year,
//  *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
//  *
//  *    | Year | `yy` | `uu` |
//  *    |------|------|------|
//  *    | 1    |   01 |   01 |
//  *    | 14   |   14 |   14 |
//  *    | 376  |   76 |  376 |
//  *    | 1453 |   53 | 1453 |
//  *
//  *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
//  *    except local week-numbering years are dependent on `options.weekStartsOn`
//  *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
//  *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
//  *
//  * 6. Specific non-location timezones are currently unavailable in `date-fns`,
//  *    so right now these tokens fall back to GMT timezones.
//  *
//  * 7. These patterns are not in the Unicode Technical Standard #35:
//  *    - `i`: ISO day of week
//  *    - `I`: ISO week of year
//  *    - `R`: ISO week-numbering year
//  *    - `t`: seconds timestamp
//  *    - `T`: milliseconds timestamp
//  *    - `o`: ordinal number modifier
//  *    - `P`: long localized date
//  *    - `p`: long localized time
//  *
//  * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
//  *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  *
//  * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
//  *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  *
//  * @param {Date|Number} date - the original date
//  * @param {String} format - the string of tokens
//  * @param {Object} [options] - an object with options.
//  * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
//  * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
//  * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
//  * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
//  *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
//  *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @returns {String} the formatted date string
//  * @throws {TypeError} 2 arguments required
//  * @throws {RangeError} `date` must not be Invalid Date
//  * @throws {RangeError} `options.locale` must contain `localize` property
//  * @throws {RangeError} `options.locale` must contain `formatLong` property
//  * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
//  * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
//  * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} format string contains an unescaped latin alphabet character
//  *
//  * @example
//  * // Represent 11 February 2014 in middle-endian format:
//  * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
//  * //=> '02/11/2014'
//  *
//  * @example
//  * // Represent 2 July 2014 in Esperanto:
//  * import { eoLocale } from 'date-fns/locale/eo'
//  * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
//  *   locale: eoLocale
//  * })
//  * //=> '2-a de julio 2014'
//  *
//  * @example
//  * // Escape string by single quote characters:
//  * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
//  * //=> "3 o'clock"
//  */

// function format(dirtyDate, dirtyFormatStr, options) {
//   var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
//   requiredArgs(2, arguments);
//   var formatStr = String(dirtyFormatStr);
//   var defaultOptions = getDefaultOptions();
//   var locale$1 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale;
//   var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

//   // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
//   if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
//     throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
//   }
//   var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

//   // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
//   if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
//     throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
//   }
//   if (!locale$1.localize) {
//     throw new RangeError('locale must contain localize property');
//   }
//   if (!locale$1.formatLong) {
//     throw new RangeError('locale must contain formatLong property');
//   }
//   var originalDate = toDate$1(dirtyDate);
//   if (!isValid(originalDate)) {
//     throw new RangeError('Invalid time value');
//   }

//   // Convert the date in system timezone to the same date in UTC+00:00 timezone.
//   // This ensures that when UTC functions will be implemented, locales will be compatible with them.
//   // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
//   var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
//   var utcDate = subMilliseconds(originalDate, timezoneOffset);
//   var formatterOptions = {
//     firstWeekContainsDate: firstWeekContainsDate,
//     weekStartsOn: weekStartsOn,
//     locale: locale$1,
//     _originalDate: originalDate
//   };
//   var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
//     var firstCharacter = substring[0];
//     if (firstCharacter === 'p' || firstCharacter === 'P') {
//       var longFormatter = longFormatters[firstCharacter];
//       return longFormatter(substring, locale$1.formatLong);
//     }
//     return substring;
//   }).join('').match(formattingTokensRegExp$1).map(function (substring) {
//     // Replace two single quote characters with one single quote character
//     if (substring === "''") {
//       return "'";
//     }
//     var firstCharacter = substring[0];
//     if (firstCharacter === "'") {
//       return cleanEscapedString$1(substring);
//     }
//     var formatter = formatters[firstCharacter];
//     if (formatter) {
//       if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
//         throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
//       }
//       if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
//         throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
//       }
//       return formatter(utcDate, substring, locale$1.localize, formatterOptions);
//     }
//     if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
//       throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
//     }
//     return substring;
//   }).join('');
//   return result;
// }
// function cleanEscapedString$1(input) {
//   var matched = input.match(escapedStringRegExp$1);
//   if (!matched) {
//     return input;
//   }
//   return matched[1].replace(doubleQuoteRegExp$1, "'");
// }

// /**
//  * @name getDate
//  * @category Day Helpers
//  * @summary Get the day of the month of the given date.
//  *
//  * @description
//  * Get the day of the month of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {Number} the day of month
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Which day of the month is 29 February 2012?
//  * const result = getDate(new Date(2012, 1, 29))
//  * //=> 29
//  */
// function getDate(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var dayOfMonth = date.getDate();
//   return dayOfMonth;
// }

// /**
//  * @name getDay
//  * @category Weekday Helpers
//  * @summary Get the day of the week of the given date.
//  *
//  * @description
//  * Get the day of the week of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Which day of the week is 29 February 2012?
//  * const result = getDay(new Date(2012, 1, 29))
//  * //=> 3
//  */
// function getDay(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var day = date.getDay();
//   return day;
// }

// /**
//  * @name getDaysInMonth
//  * @category Month Helpers
//  * @summary Get the number of days in a month of the given date.
//  *
//  * @description
//  * Get the number of days in a month of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {Number} the number of days in a month
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // How many days are in February 2000?
//  * const result = getDaysInMonth(new Date(2000, 1))
//  * //=> 29
//  */
// function getDaysInMonth(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var year = date.getFullYear();
//   var monthIndex = date.getMonth();
//   var lastDayOfMonth = new Date(0);
//   lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
//   lastDayOfMonth.setHours(0, 0, 0, 0);
//   return lastDayOfMonth.getDate();
// }

// /**
//  * @name getHours
//  * @category Hour Helpers
//  * @summary Get the hours of the given date.
//  *
//  * @description
//  * Get the hours of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {Number} the hours
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Get the hours of 29 February 2012 11:45:00:
//  * const result = getHours(new Date(2012, 1, 29, 11, 45))
//  * //=> 11
//  */
// function getHours$1(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var hours = date.getHours();
//   return hours;
// }

// /**
//  * @name getMinutes
//  * @category Minute Helpers
//  * @summary Get the minutes of the given date.
//  *
//  * @description
//  * Get the minutes of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {Number} the minutes
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Get the minutes of 29 February 2012 11:45:05:
//  * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
//  * //=> 45
//  */
// function getMinutes$1(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var minutes = date.getMinutes();
//   return minutes;
// }

// /**
//  * @name getMonth
//  * @category Month Helpers
//  * @summary Get the month of the given date.
//  *
//  * @description
//  * Get the month of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {Number} the month
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Which month is 29 February 2012?
//  * const result = getMonth(new Date(2012, 1, 29))
//  * //=> 1
//  */
// function getMonth(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var month = date.getMonth();
//   return month;
// }

// /**
//  * @name getSeconds
//  * @category Second Helpers
//  * @summary Get the seconds of the given date.
//  *
//  * @description
//  * Get the seconds of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {Number} the seconds
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Get the seconds of 29 February 2012 11:45:05.123:
//  * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
//  * //=> 5
//  */
// function getSeconds(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   var seconds = date.getSeconds();
//   return seconds;
// }

// /**
//  * @name getYear
//  * @category Year Helpers
//  * @summary Get the year of the given date.
//  *
//  * @description
//  * Get the year of the given date.
//  *
//  * @param {Date|Number} date - the given date
//  * @returns {Number} the year
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // Which year is 2 July 2014?
//  * const result = getYear(new Date(2014, 6, 2))
//  * //=> 2014
//  */
// function getYear(dirtyDate) {
//   requiredArgs(1, arguments);
//   return toDate$1(dirtyDate).getFullYear();
// }

// /**
//  * @name isAfter
//  * @category Common Helpers
//  * @summary Is the first date after the second one?
//  *
//  * @description
//  * Is the first date after the second one?
//  *
//  * @param {Date|Number} date - the date that should be after the other one to return true
//  * @param {Date|Number} dateToCompare - the date to compare with
//  * @returns {Boolean} the first date is after the second date
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Is 10 July 1989 after 11 February 1987?
//  * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
//  * //=> true
//  */
// function isAfter(dirtyDate, dirtyDateToCompare) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var dateToCompare = toDate$1(dirtyDateToCompare);
//   return date.getTime() > dateToCompare.getTime();
// }

// /**
//  * @name isBefore
//  * @category Common Helpers
//  * @summary Is the first date before the second one?
//  *
//  * @description
//  * Is the first date before the second one?
//  *
//  * @param {Date|Number} date - the date that should be before the other one to return true
//  * @param {Date|Number} dateToCompare - the date to compare with
//  * @returns {Boolean} the first date is before the second date
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Is 10 July 1989 before 11 February 1987?
//  * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
//  * //=> false
//  */
// function isBefore(dirtyDate, dirtyDateToCompare) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var dateToCompare = toDate$1(dirtyDateToCompare);
//   return date.getTime() < dateToCompare.getTime();
// }

// /**
//  * @name isEqual
//  * @category Common Helpers
//  * @summary Are the given dates equal?
//  *
//  * @description
//  * Are the given dates equal?
//  *
//  * @param {Date|Number} dateLeft - the first date to compare
//  * @param {Date|Number} dateRight - the second date to compare
//  * @returns {Boolean} the dates are equal
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
//  * const result = isEqual(
//  *   new Date(2014, 6, 2, 6, 30, 45, 0),
//  *   new Date(2014, 6, 2, 6, 30, 45, 500)
//  * )
//  * //=> false
//  */
// function isEqual(dirtyLeftDate, dirtyRightDate) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyLeftDate);
//   var dateRight = toDate$1(dirtyRightDate);
//   return dateLeft.getTime() === dateRight.getTime();
// }

// /**
//  * @name isSameDay
//  * @category Day Helpers
//  * @summary Are the given dates in the same day (and year and month)?
//  *
//  * @description
//  * Are the given dates in the same day (and year and month)?
//  *
//  * @param {Date|Number} dateLeft - the first date to check
//  * @param {Date|Number} dateRight - the second date to check
//  * @returns {Boolean} the dates are in the same day (and year and month)
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
//  * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
//  * //=> true
//  *
//  * @example
//  * // Are 4 September and 4 October in the same day?
//  * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
//  * //=> false
//  *
//  * @example
//  * // Are 4 September, 2014 and 4 September, 2015 in the same day?
//  * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
//  * //=> false
//  */
// function isSameDay(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
//   var dateRightStartOfDay = startOfDay(dirtyDateRight);
//   return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
// }

// /**
//  * @name isSameYear
//  * @category Year Helpers
//  * @summary Are the given dates in the same year?
//  *
//  * @description
//  * Are the given dates in the same year?
//  *
//  * @param {Date|Number} dateLeft - the first date to check
//  * @param {Date|Number} dateRight - the second date to check
//  * @returns {Boolean} the dates are in the same year
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Are 2 September 2014 and 25 September 2014 in the same year?
//  * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
//  * //=> true
//  */
// function isSameYear(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   return dateLeft.getFullYear() === dateRight.getFullYear();
// }

// /**
//  * @name isSameMonth
//  * @category Month Helpers
//  * @summary Are the given dates in the same month (and year)?
//  *
//  * @description
//  * Are the given dates in the same month (and year)?
//  *
//  * @param {Date|Number} dateLeft - the first date to check
//  * @param {Date|Number} dateRight - the second date to check
//  * @returns {Boolean} the dates are in the same month (and year)
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Are 2 September 2014 and 25 September 2014 in the same month?
//  * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
//  * //=> true
//  *
//  * @example
//  * // Are 2 September 2014 and 25 September 2015 in the same month?
//  * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
//  * //=> false
//  */
// function isSameMonth(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeft = toDate$1(dirtyDateLeft);
//   var dateRight = toDate$1(dirtyDateRight);
//   return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
// }

// /**
//  * @name startOfHour
//  * @category Hour Helpers
//  * @summary Return the start of an hour for the given date.
//  *
//  * @description
//  * Return the start of an hour for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @returns {Date} the start of an hour
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // The start of an hour for 2 September 2014 11:55:00:
//  * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
//  * //=> Tue Sep 02 2014 11:00:00
//  */
// function startOfHour(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   date.setMinutes(0, 0, 0);
//   return date;
// }

// /**
//  * @name isSameHour
//  * @category Hour Helpers
//  * @summary Are the given dates in the same hour (and same day)?
//  *
//  * @description
//  * Are the given dates in the same hour (and same day)?
//  *
//  * @param {Date|Number} dateLeft - the first date to check
//  * @param {Date|Number} dateRight - the second date to check
//  * @returns {Boolean} the dates are in the same hour (and same day)
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
//  * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
//  * //=> true
//  *
//  * @example
//  * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
//  * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
//  * //=> false
//  */
// function isSameHour(dirtyDateLeft, dirtyDateRight) {
//   requiredArgs(2, arguments);
//   var dateLeftStartOfHour = startOfHour(dirtyDateLeft);
//   var dateRightStartOfHour = startOfHour(dirtyDateRight);
//   return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
// }

// function _arrayLikeToArray$l(arr, len) {
//   if (len == null || len > arr.length) len = arr.length;
//   for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
//   return arr2;
// }

// function _unsupportedIterableToArray$l(o, minLen) {
//   if (!o) return;
//   if (typeof o === "string") return _arrayLikeToArray$l(o, minLen);
//   var n = Object.prototype.toString.call(o).slice(8, -1);
//   if (n === "Object" && o.constructor) n = o.constructor.name;
//   if (n === "Map" || n === "Set") return Array.from(o);
//   if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$l(o, minLen);
// }

// function _createForOfIteratorHelper$1(o, allowArrayLike) {
//   var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
//   if (!it) {
//     if (Array.isArray(o) || (it = _unsupportedIterableToArray$l(o)) || allowArrayLike && o && typeof o.length === "number") {
//       if (it) o = it;
//       var i = 0;
//       var F = function F() {};
//       return {
//         s: F,
//         n: function n() {
//           if (i >= o.length) return {
//             done: true
//           };
//           return {
//             done: false,
//             value: o[i++]
//           };
//         },
//         e: function e(_e) {
//           throw _e;
//         },
//         f: F
//       };
//     }
//     throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
//   }
//   var normalCompletion = true,
//     didErr = false,
//     err;
//   return {
//     s: function s() {
//       it = it.call(o);
//     },
//     n: function n() {
//       var step = it.next();
//       normalCompletion = step.done;
//       return step;
//     },
//     e: function e(_e2) {
//       didErr = true;
//       err = _e2;
//     },
//     f: function f() {
//       try {
//         if (!normalCompletion && it["return"] != null) it["return"]();
//       } finally {
//         if (didErr) throw err;
//       }
//     }
//   };
// }

// function assign$1(target, object) {
//   if (target == null) {
//     throw new TypeError('assign requires that input parameter not be null or undefined');
//   }
//   for (var property in object) {
//     if (Object.prototype.hasOwnProperty.call(object, property)) {
//       target[property] = object[property];
//     }
//   }
//   return target;
// }

// function _inherits$c(subClass, superClass) {
//   if (typeof superClass !== "function" && superClass !== null) {
//     throw new TypeError("Super expression must either be null or a function");
//   }
//   subClass.prototype = Object.create(superClass && superClass.prototype, {
//     constructor: {
//       value: subClass,
//       writable: true,
//       configurable: true
//     }
//   });
//   Object.defineProperty(subClass, "prototype", {
//     writable: false
//   });
//   if (superClass) _setPrototypeOf$d(subClass, superClass);
// }

// function _possibleConstructorReturn$c(self, call) {
//   if (call && (_typeof$F(call) === "object" || typeof call === "function")) {
//     return call;
//   } else if (call !== void 0) {
//     throw new TypeError("Derived constructors may only return object or undefined");
//   }
//   return _assertThisInitialized$c(self);
// }

// function _createSuper$c(Derived) {
//   var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
//   return function _createSuperInternal() {
//     var Super = _getPrototypeOf$c(Derived),
//       result;
//     if (hasNativeReflectConstruct) {
//       var NewTarget = _getPrototypeOf$c(this).constructor;
//       result = Reflect.construct(Super, arguments, NewTarget);
//     } else {
//       result = Super.apply(this, arguments);
//     }
//     return _possibleConstructorReturn$c(this, result);
//   };
// }

// function _classCallCheck$f(instance, Constructor) {
//   if (!(instance instanceof Constructor)) {
//     throw new TypeError("Cannot call a class as a function");
//   }
// }

// function toPrimitive(t, r) {
//   if ("object" != _typeof$F(t) || !t) return t;
//   var e = t[Symbol.toPrimitive];
//   if (void 0 !== e) {
//     var i = e.call(t, r || "default");
//     if ("object" != _typeof$F(i)) return i;
//     throw new TypeError("@@toPrimitive must return a primitive value.");
//   }
//   return ("string" === r ? String : Number)(t);
// }

// function toPropertyKey(t) {
//   var i = toPrimitive(t, "string");
//   return "symbol" == _typeof$F(i) ? i : String(i);
// }

// function _defineProperties$f(target, props) {
//   for (var i = 0; i < props.length; i++) {
//     var descriptor = props[i];
//     descriptor.enumerable = descriptor.enumerable || false;
//     descriptor.configurable = true;
//     if ("value" in descriptor) descriptor.writable = true;
//     Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
//   }
// }
// function _createClass$f(Constructor, protoProps, staticProps) {
//   if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
//   if (staticProps) _defineProperties$f(Constructor, staticProps);
//   Object.defineProperty(Constructor, "prototype", {
//     writable: false
//   });
//   return Constructor;
// }

// function _defineProperty$B(obj, key, value) {
//   key = toPropertyKey(key);
//   if (key in obj) {
//     Object.defineProperty(obj, key, {
//       value: value,
//       enumerable: true,
//       configurable: true,
//       writable: true
//     });
//   } else {
//     obj[key] = value;
//   }
//   return obj;
// }

// var TIMEZONE_UNIT_PRIORITY = 10;
// var Setter = /*#__PURE__*/function () {
//   function Setter() {
//     _classCallCheck$f(this, Setter);
//     _defineProperty$B(this, "priority", void 0);
//     _defineProperty$B(this, "subPriority", 0);
//   }
//   _createClass$f(Setter, [{
//     key: "validate",
//     value: function validate(_utcDate, _options) {
//       return true;
//     }
//   }]);
//   return Setter;
// }();
// var ValueSetter = /*#__PURE__*/function (_Setter) {
//   _inherits$c(ValueSetter, _Setter);
//   var _super = _createSuper$c(ValueSetter);
//   function ValueSetter(value, validateValue, setValue, priority, subPriority) {
//     var _this;
//     _classCallCheck$f(this, ValueSetter);
//     _this = _super.call(this);
//     _this.value = value;
//     _this.validateValue = validateValue;
//     _this.setValue = setValue;
//     _this.priority = priority;
//     if (subPriority) {
//       _this.subPriority = subPriority;
//     }
//     return _this;
//   }
//   _createClass$f(ValueSetter, [{
//     key: "validate",
//     value: function validate(utcDate, options) {
//       return this.validateValue(utcDate, this.value, options);
//     }
//   }, {
//     key: "set",
//     value: function set(utcDate, flags, options) {
//       return this.setValue(utcDate, flags, this.value, options);
//     }
//   }]);
//   return ValueSetter;
// }(Setter);
// var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
//   _inherits$c(DateToSystemTimezoneSetter, _Setter2);
//   var _super2 = _createSuper$c(DateToSystemTimezoneSetter);
//   function DateToSystemTimezoneSetter() {
//     var _this2;
//     _classCallCheck$f(this, DateToSystemTimezoneSetter);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this2 = _super2.call.apply(_super2, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
//     _defineProperty$B(_assertThisInitialized$c(_this2), "subPriority", -1);
//     return _this2;
//   }
//   _createClass$f(DateToSystemTimezoneSetter, [{
//     key: "set",
//     value: function set(date, flags) {
//       if (flags.timestampIsSet) {
//         return date;
//       }
//       var convertedDate = new Date(0);
//       convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
//       convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
//       return convertedDate;
//     }
//   }]);
//   return DateToSystemTimezoneSetter;
// }(Setter);

// var Parser = /*#__PURE__*/function () {
//   function Parser() {
//     _classCallCheck$f(this, Parser);
//     _defineProperty$B(this, "incompatibleTokens", void 0);
//     _defineProperty$B(this, "priority", void 0);
//     _defineProperty$B(this, "subPriority", void 0);
//   }
//   _createClass$f(Parser, [{
//     key: "run",
//     value: function run(dateString, token, match, options) {
//       var result = this.parse(dateString, token, match, options);
//       if (!result) {
//         return null;
//       }
//       return {
//         setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
//         rest: result.rest
//       };
//     }
//   }, {
//     key: "validate",
//     value: function validate(_utcDate, _value, _options) {
//       return true;
//     }
//   }]);
//   return Parser;
// }();

// var EraParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(EraParser, _Parser);
//   var _super = _createSuper$c(EraParser);
//   function EraParser() {
//     var _this;
//     _classCallCheck$f(this, EraParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 140);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(EraParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         // AD, BC
//         case 'G':
//         case 'GG':
//         case 'GGG':
//           return match.era(dateString, {
//             width: 'abbreviated'
//           }) || match.era(dateString, {
//             width: 'narrow'
//           });
//         // A, B
//         case 'GGGGG':
//           return match.era(dateString, {
//             width: 'narrow'
//           });
//         // Anno Domini, Before Christ
//         case 'GGGG':
//         default:
//           return match.era(dateString, {
//             width: 'wide'
//           }) || match.era(dateString, {
//             width: 'abbreviated'
//           }) || match.era(dateString, {
//             width: 'narrow'
//           });
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, flags, value) {
//       flags.era = value;
//       date.setUTCFullYear(value, 0, 1);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return EraParser;
// }(Parser);

// var numericPatterns = {
//   month: /^(1[0-2]|0?\d)/,
//   // 0 to 12
//   date: /^(3[0-1]|[0-2]?\d)/,
//   // 0 to 31
//   dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
//   // 0 to 366
//   week: /^(5[0-3]|[0-4]?\d)/,
//   // 0 to 53
//   hour23h: /^(2[0-3]|[0-1]?\d)/,
//   // 0 to 23
//   hour24h: /^(2[0-4]|[0-1]?\d)/,
//   // 0 to 24
//   hour11h: /^(1[0-1]|0?\d)/,
//   // 0 to 11
//   hour12h: /^(1[0-2]|0?\d)/,
//   // 0 to 12
//   minute: /^[0-5]?\d/,
//   // 0 to 59
//   second: /^[0-5]?\d/,
//   // 0 to 59

//   singleDigit: /^\d/,
//   // 0 to 9
//   twoDigits: /^\d{1,2}/,
//   // 0 to 99
//   threeDigits: /^\d{1,3}/,
//   // 0 to 999
//   fourDigits: /^\d{1,4}/,
//   // 0 to 9999

//   anyDigitsSigned: /^-?\d+/,
//   singleDigitSigned: /^-?\d/,
//   // 0 to 9, -0 to -9
//   twoDigitsSigned: /^-?\d{1,2}/,
//   // 0 to 99, -0 to -99
//   threeDigitsSigned: /^-?\d{1,3}/,
//   // 0 to 999, -0 to -999
//   fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
// };

// var timezonePatterns = {
//   basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
//   basic: /^([+-])(\d{2})(\d{2})|Z/,
//   basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
//   extended: /^([+-])(\d{2}):(\d{2})|Z/,
//   extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
// };

// function mapValue(parseFnResult, mapFn) {
//   if (!parseFnResult) {
//     return parseFnResult;
//   }
//   return {
//     value: mapFn(parseFnResult.value),
//     rest: parseFnResult.rest
//   };
// }
// function parseNumericPattern(pattern, dateString) {
//   var matchResult = dateString.match(pattern);
//   if (!matchResult) {
//     return null;
//   }
//   return {
//     value: parseInt(matchResult[0], 10),
//     rest: dateString.slice(matchResult[0].length)
//   };
// }
// function parseTimezonePattern(pattern, dateString) {
//   var matchResult = dateString.match(pattern);
//   if (!matchResult) {
//     return null;
//   }

//   // Input is 'Z'
//   if (matchResult[0] === 'Z') {
//     return {
//       value: 0,
//       rest: dateString.slice(1)
//     };
//   }
//   var sign = matchResult[1] === '+' ? 1 : -1;
//   var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
//   var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
//   var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
//   return {
//     value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
//     rest: dateString.slice(matchResult[0].length)
//   };
// }
// function parseAnyDigitsSigned(dateString) {
//   return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
// }
// function parseNDigits(n, dateString) {
//   switch (n) {
//     case 1:
//       return parseNumericPattern(numericPatterns.singleDigit, dateString);
//     case 2:
//       return parseNumericPattern(numericPatterns.twoDigits, dateString);
//     case 3:
//       return parseNumericPattern(numericPatterns.threeDigits, dateString);
//     case 4:
//       return parseNumericPattern(numericPatterns.fourDigits, dateString);
//     default:
//       return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
//   }
// }
// function parseNDigitsSigned(n, dateString) {
//   switch (n) {
//     case 1:
//       return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
//     case 2:
//       return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
//     case 3:
//       return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
//     case 4:
//       return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
//     default:
//       return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
//   }
// }
// function dayPeriodEnumToHours(dayPeriod) {
//   switch (dayPeriod) {
//     case 'morning':
//       return 4;
//     case 'evening':
//       return 17;
//     case 'pm':
//     case 'noon':
//     case 'afternoon':
//       return 12;
//     case 'am':
//     case 'midnight':
//     case 'night':
//     default:
//       return 0;
//   }
// }
// function normalizeTwoDigitYear(twoDigitYear, currentYear) {
//   var isCommonEra = currentYear > 0;
//   // Absolute number of the current year:
//   // 1 -> 1 AC
//   // 0 -> 1 BC
//   // -1 -> 2 BC
//   var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
//   var result;
//   if (absCurrentYear <= 50) {
//     result = twoDigitYear || 100;
//   } else {
//     var rangeEnd = absCurrentYear + 50;
//     var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
//     var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
//     result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
//   }
//   return isCommonEra ? result : 1 - result;
// }
// function isLeapYearIndex$2(year) {
//   return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
// }

// // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// // |----------|-------|----|-------|-------|-------|
// // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
// var YearParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(YearParser, _Parser);
//   var _super = _createSuper$c(YearParser);
//   function YearParser() {
//     var _this;
//     _classCallCheck$f(this, YearParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 130);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(YearParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       var valueCallback = function valueCallback(year) {
//         return {
//           year: year,
//           isTwoDigitYear: token === 'yy'
//         };
//       };
//       switch (token) {
//         case 'y':
//           return mapValue(parseNDigits(4, dateString), valueCallback);
//         case 'yo':
//           return mapValue(match.ordinalNumber(dateString, {
//             unit: 'year'
//           }), valueCallback);
//         default:
//           return mapValue(parseNDigits(token.length, dateString), valueCallback);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value.isTwoDigitYear || value.year > 0;
//     }
//   }, {
//     key: "set",
//     value: function set(date, flags, value) {
//       var currentYear = date.getUTCFullYear();
//       if (value.isTwoDigitYear) {
//         var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
//         date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
//         date.setUTCHours(0, 0, 0, 0);
//         return date;
//       }
//       var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
//       date.setUTCFullYear(year, 0, 1);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return YearParser;
// }(Parser);

// // Local week-numbering year
// var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(LocalWeekYearParser, _Parser);
//   var _super = _createSuper$c(LocalWeekYearParser);
//   function LocalWeekYearParser() {
//     var _this;
//     _classCallCheck$f(this, LocalWeekYearParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 130);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(LocalWeekYearParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       var valueCallback = function valueCallback(year) {
//         return {
//           year: year,
//           isTwoDigitYear: token === 'YY'
//         };
//       };
//       switch (token) {
//         case 'Y':
//           return mapValue(parseNDigits(4, dateString), valueCallback);
//         case 'Yo':
//           return mapValue(match.ordinalNumber(dateString, {
//             unit: 'year'
//           }), valueCallback);
//         default:
//           return mapValue(parseNDigits(token.length, dateString), valueCallback);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value.isTwoDigitYear || value.year > 0;
//     }
//   }, {
//     key: "set",
//     value: function set(date, flags, value, options) {
//       var currentYear = getUTCWeekYear(date, options);
//       if (value.isTwoDigitYear) {
//         var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
//         date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
//         date.setUTCHours(0, 0, 0, 0);
//         return startOfUTCWeek(date, options);
//       }
//       var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
//       date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
//       date.setUTCHours(0, 0, 0, 0);
//       return startOfUTCWeek(date, options);
//     }
//   }]);
//   return LocalWeekYearParser;
// }(Parser);

// var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(ISOWeekYearParser, _Parser);
//   var _super = _createSuper$c(ISOWeekYearParser);
//   function ISOWeekYearParser() {
//     var _this;
//     _classCallCheck$f(this, ISOWeekYearParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 130);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(ISOWeekYearParser, [{
//     key: "parse",
//     value: function parse(dateString, token) {
//       if (token === 'R') {
//         return parseNDigitsSigned(4, dateString);
//       }
//       return parseNDigitsSigned(token.length, dateString);
//     }
//   }, {
//     key: "set",
//     value: function set(_date, _flags, value) {
//       var firstWeekOfYear = new Date(0);
//       firstWeekOfYear.setUTCFullYear(value, 0, 4);
//       firstWeekOfYear.setUTCHours(0, 0, 0, 0);
//       return startOfUTCISOWeek(firstWeekOfYear);
//     }
//   }]);
//   return ISOWeekYearParser;
// }(Parser);

// var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(ExtendedYearParser, _Parser);
//   var _super = _createSuper$c(ExtendedYearParser);
//   function ExtendedYearParser() {
//     var _this;
//     _classCallCheck$f(this, ExtendedYearParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 130);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(ExtendedYearParser, [{
//     key: "parse",
//     value: function parse(dateString, token) {
//       if (token === 'u') {
//         return parseNDigitsSigned(4, dateString);
//       }
//       return parseNDigitsSigned(token.length, dateString);
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCFullYear(value, 0, 1);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return ExtendedYearParser;
// }(Parser);

// var QuarterParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(QuarterParser, _Parser);
//   var _super = _createSuper$c(QuarterParser);
//   function QuarterParser() {
//     var _this;
//     _classCallCheck$f(this, QuarterParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 120);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(QuarterParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         // 1, 2, 3, 4
//         case 'Q':
//         case 'QQ':
//           // 01, 02, 03, 04
//           return parseNDigits(token.length, dateString);
//         // 1st, 2nd, 3rd, 4th
//         case 'Qo':
//           return match.ordinalNumber(dateString, {
//             unit: 'quarter'
//           });
//         // Q1, Q2, Q3, Q4
//         case 'QQQ':
//           return match.quarter(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.quarter(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // 1, 2, 3, 4 (narrow quarter; could be not numerical)
//         case 'QQQQQ':
//           return match.quarter(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // 1st quarter, 2nd quarter, ...
//         case 'QQQQ':
//         default:
//           return match.quarter(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.quarter(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.quarter(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 1 && value <= 4;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCMonth((value - 1) * 3, 1);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return QuarterParser;
// }(Parser);

// var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(StandAloneQuarterParser, _Parser);
//   var _super = _createSuper$c(StandAloneQuarterParser);
//   function StandAloneQuarterParser() {
//     var _this;
//     _classCallCheck$f(this, StandAloneQuarterParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 120);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(StandAloneQuarterParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         // 1, 2, 3, 4
//         case 'q':
//         case 'qq':
//           // 01, 02, 03, 04
//           return parseNDigits(token.length, dateString);
//         // 1st, 2nd, 3rd, 4th
//         case 'qo':
//           return match.ordinalNumber(dateString, {
//             unit: 'quarter'
//           });
//         // Q1, Q2, Q3, Q4
//         case 'qqq':
//           return match.quarter(dateString, {
//             width: 'abbreviated',
//             context: 'standalone'
//           }) || match.quarter(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//         // 1, 2, 3, 4 (narrow quarter; could be not numerical)
//         case 'qqqqq':
//           return match.quarter(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//         // 1st quarter, 2nd quarter, ...
//         case 'qqqq':
//         default:
//           return match.quarter(dateString, {
//             width: 'wide',
//             context: 'standalone'
//           }) || match.quarter(dateString, {
//             width: 'abbreviated',
//             context: 'standalone'
//           }) || match.quarter(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 1 && value <= 4;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCMonth((value - 1) * 3, 1);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return StandAloneQuarterParser;
// }(Parser);

// var MonthParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(MonthParser, _Parser);
//   var _super = _createSuper$c(MonthParser);
//   function MonthParser() {
//     var _this;
//     _classCallCheck$f(this, MonthParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 110);
//     return _this;
//   }
//   _createClass$f(MonthParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       var valueCallback = function valueCallback(value) {
//         return value - 1;
//       };
//       switch (token) {
//         // 1, 2, ..., 12
//         case 'M':
//           return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
//         // 01, 02, ..., 12
//         case 'MM':
//           return mapValue(parseNDigits(2, dateString), valueCallback);
//         // 1st, 2nd, ..., 12th
//         case 'Mo':
//           return mapValue(match.ordinalNumber(dateString, {
//             unit: 'month'
//           }), valueCallback);
//         // Jan, Feb, ..., Dec
//         case 'MMM':
//           return match.month(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.month(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // J, F, ..., D
//         case 'MMMMM':
//           return match.month(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // January, February, ..., December
//         case 'MMMM':
//         default:
//           return match.month(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.month(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.month(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 11;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCMonth(value, 1);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return MonthParser;
// }(Parser);

// var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(StandAloneMonthParser, _Parser);
//   var _super = _createSuper$c(StandAloneMonthParser);
//   function StandAloneMonthParser() {
//     var _this;
//     _classCallCheck$f(this, StandAloneMonthParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 110);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(StandAloneMonthParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       var valueCallback = function valueCallback(value) {
//         return value - 1;
//       };
//       switch (token) {
//         // 1, 2, ..., 12
//         case 'L':
//           return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
//         // 01, 02, ..., 12
//         case 'LL':
//           return mapValue(parseNDigits(2, dateString), valueCallback);
//         // 1st, 2nd, ..., 12th
//         case 'Lo':
//           return mapValue(match.ordinalNumber(dateString, {
//             unit: 'month'
//           }), valueCallback);
//         // Jan, Feb, ..., Dec
//         case 'LLL':
//           return match.month(dateString, {
//             width: 'abbreviated',
//             context: 'standalone'
//           }) || match.month(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//         // J, F, ..., D
//         case 'LLLLL':
//           return match.month(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//         // January, February, ..., December
//         case 'LLLL':
//         default:
//           return match.month(dateString, {
//             width: 'wide',
//             context: 'standalone'
//           }) || match.month(dateString, {
//             width: 'abbreviated',
//             context: 'standalone'
//           }) || match.month(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 11;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCMonth(value, 1);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return StandAloneMonthParser;
// }(Parser);

// function setUTCWeek(dirtyDate, dirtyWeek, options) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var week = toInteger(dirtyWeek);
//   var diff = getUTCWeek(date, options) - week;
//   date.setUTCDate(date.getUTCDate() - diff * 7);
//   return date;
// }

// var LocalWeekParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(LocalWeekParser, _Parser);
//   var _super = _createSuper$c(LocalWeekParser);
//   function LocalWeekParser() {
//     var _this;
//     _classCallCheck$f(this, LocalWeekParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 100);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(LocalWeekParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'w':
//           return parseNumericPattern(numericPatterns.week, dateString);
//         case 'wo':
//           return match.ordinalNumber(dateString, {
//             unit: 'week'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 1 && value <= 53;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value, options) {
//       return startOfUTCWeek(setUTCWeek(date, value, options), options);
//     }
//   }]);
//   return LocalWeekParser;
// }(Parser);

// function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var isoWeek = toInteger(dirtyISOWeek);
//   var diff = getUTCISOWeek(date) - isoWeek;
//   date.setUTCDate(date.getUTCDate() - diff * 7);
//   return date;
// }

// var ISOWeekParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(ISOWeekParser, _Parser);
//   var _super = _createSuper$c(ISOWeekParser);
//   function ISOWeekParser() {
//     var _this;
//     _classCallCheck$f(this, ISOWeekParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 100);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(ISOWeekParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'I':
//           return parseNumericPattern(numericPatterns.week, dateString);
//         case 'Io':
//           return match.ordinalNumber(dateString, {
//             unit: 'week'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 1 && value <= 53;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       return startOfUTCISOWeek(setUTCISOWeek(date, value));
//     }
//   }]);
//   return ISOWeekParser;
// }(Parser);

// var DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
// var DAYS_IN_MONTH_LEAP_YEAR$1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// // Day of the month
// var DateParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(DateParser, _Parser);
//   var _super = _createSuper$c(DateParser);
//   function DateParser() {
//     var _this;
//     _classCallCheck$f(this, DateParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 90);
//     _defineProperty$B(_assertThisInitialized$c(_this), "subPriority", 1);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(DateParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'd':
//           return parseNumericPattern(numericPatterns.date, dateString);
//         case 'do':
//           return match.ordinalNumber(dateString, {
//             unit: 'date'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(date, value) {
//       var year = date.getUTCFullYear();
//       var isLeapYear = isLeapYearIndex$2(year);
//       var month = date.getUTCMonth();
//       if (isLeapYear) {
//         return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
//       } else {
//         return value >= 1 && value <= DAYS_IN_MONTH$1[month];
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCDate(value);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return DateParser;
// }(Parser);

// var DayOfYearParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(DayOfYearParser, _Parser);
//   var _super = _createSuper$c(DayOfYearParser);
//   function DayOfYearParser() {
//     var _this;
//     _classCallCheck$f(this, DayOfYearParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 90);
//     _defineProperty$B(_assertThisInitialized$c(_this), "subpriority", 1);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(DayOfYearParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'D':
//         case 'DD':
//           return parseNumericPattern(numericPatterns.dayOfYear, dateString);
//         case 'Do':
//           return match.ordinalNumber(dateString, {
//             unit: 'date'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(date, value) {
//       var year = date.getUTCFullYear();
//       var isLeapYear = isLeapYearIndex$2(year);
//       if (isLeapYear) {
//         return value >= 1 && value <= 366;
//       } else {
//         return value >= 1 && value <= 365;
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCMonth(0, value);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return DayOfYearParser;
// }(Parser);

// function setUTCDay(dirtyDate, dirtyDay, options) {
//   var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
//   requiredArgs(2, arguments);
//   var defaultOptions = getDefaultOptions();
//   var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

//   // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
//   if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
//     throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
//   }
//   var date = toDate$1(dirtyDate);
//   var day = toInteger(dirtyDay);
//   var currentDay = date.getUTCDay();
//   var remainder = day % 7;
//   var dayIndex = (remainder + 7) % 7;
//   var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
//   date.setUTCDate(date.getUTCDate() + diff);
//   return date;
// }

// var DayParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(DayParser, _Parser);
//   var _super = _createSuper$c(DayParser);
//   function DayParser() {
//     var _this;
//     _classCallCheck$f(this, DayParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 90);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(DayParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         // Tue
//         case 'E':
//         case 'EE':
//         case 'EEE':
//           return match.day(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // T
//         case 'EEEEE':
//           return match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // Tu
//         case 'EEEEEE':
//           return match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // Tuesday
//         case 'EEEE':
//         default:
//           return match.day(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 6;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value, options) {
//       date = setUTCDay(date, value, options);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return DayParser;
// }(Parser);

// var LocalDayParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(LocalDayParser, _Parser);
//   var _super = _createSuper$c(LocalDayParser);
//   function LocalDayParser() {
//     var _this;
//     _classCallCheck$f(this, LocalDayParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 90);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(LocalDayParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match, options) {
//       var valueCallback = function valueCallback(value) {
//         var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
//         return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
//       };
//       switch (token) {
//         // 3
//         case 'e':
//         case 'ee':
//           // 03
//           return mapValue(parseNDigits(token.length, dateString), valueCallback);
//         // 3rd
//         case 'eo':
//           return mapValue(match.ordinalNumber(dateString, {
//             unit: 'day'
//           }), valueCallback);
//         // Tue
//         case 'eee':
//           return match.day(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // T
//         case 'eeeee':
//           return match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // Tu
//         case 'eeeeee':
//           return match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         // Tuesday
//         case 'eeee':
//         default:
//           return match.day(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 6;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value, options) {
//       date = setUTCDay(date, value, options);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return LocalDayParser;
// }(Parser);

// var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(StandAloneLocalDayParser, _Parser);
//   var _super = _createSuper$c(StandAloneLocalDayParser);
//   function StandAloneLocalDayParser() {
//     var _this;
//     _classCallCheck$f(this, StandAloneLocalDayParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 90);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(StandAloneLocalDayParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match, options) {
//       var valueCallback = function valueCallback(value) {
//         var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
//         return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
//       };
//       switch (token) {
//         // 3
//         case 'c':
//         case 'cc':
//           // 03
//           return mapValue(parseNDigits(token.length, dateString), valueCallback);
//         // 3rd
//         case 'co':
//           return mapValue(match.ordinalNumber(dateString, {
//             unit: 'day'
//           }), valueCallback);
//         // Tue
//         case 'ccc':
//           return match.day(dateString, {
//             width: 'abbreviated',
//             context: 'standalone'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'standalone'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//         // T
//         case 'ccccc':
//           return match.day(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//         // Tu
//         case 'cccccc':
//           return match.day(dateString, {
//             width: 'short',
//             context: 'standalone'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//         // Tuesday
//         case 'cccc':
//         default:
//           return match.day(dateString, {
//             width: 'wide',
//             context: 'standalone'
//           }) || match.day(dateString, {
//             width: 'abbreviated',
//             context: 'standalone'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'standalone'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'standalone'
//           });
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 6;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value, options) {
//       date = setUTCDay(date, value, options);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return StandAloneLocalDayParser;
// }(Parser);

// function setUTCISODay(dirtyDate, dirtyDay) {
//   requiredArgs(2, arguments);
//   var day = toInteger(dirtyDay);
//   if (day % 7 === 0) {
//     day = day - 7;
//   }
//   var weekStartsOn = 1;
//   var date = toDate$1(dirtyDate);
//   var currentDay = date.getUTCDay();
//   var remainder = day % 7;
//   var dayIndex = (remainder + 7) % 7;
//   var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
//   date.setUTCDate(date.getUTCDate() + diff);
//   return date;
// }

// var ISODayParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(ISODayParser, _Parser);
//   var _super = _createSuper$c(ISODayParser);
//   function ISODayParser() {
//     var _this;
//     _classCallCheck$f(this, ISODayParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 90);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(ISODayParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       var valueCallback = function valueCallback(value) {
//         if (value === 0) {
//           return 7;
//         }
//         return value;
//       };
//       switch (token) {
//         // 2
//         case 'i':
//         case 'ii':
//           // 02
//           return parseNDigits(token.length, dateString);
//         // 2nd
//         case 'io':
//           return match.ordinalNumber(dateString, {
//             unit: 'day'
//           });
//         // Tue
//         case 'iii':
//           return mapValue(match.day(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           }), valueCallback);
//         // T
//         case 'iiiii':
//           return mapValue(match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           }), valueCallback);
//         // Tu
//         case 'iiiiii':
//           return mapValue(match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           }), valueCallback);
//         // Tuesday
//         case 'iiii':
//         default:
//           return mapValue(match.day(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'short',
//             context: 'formatting'
//           }) || match.day(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           }), valueCallback);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 1 && value <= 7;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date = setUTCISODay(date, value);
//       date.setUTCHours(0, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return ISODayParser;
// }(Parser);

// var AMPMParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(AMPMParser, _Parser);
//   var _super = _createSuper$c(AMPMParser);
//   function AMPMParser() {
//     var _this;
//     _classCallCheck$f(this, AMPMParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 80);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(AMPMParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'a':
//         case 'aa':
//         case 'aaa':
//           return match.dayPeriod(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         case 'aaaaa':
//           return match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         case 'aaaa':
//         default:
//           return match.dayPeriod(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
//       return date;
//     }
//   }]);
//   return AMPMParser;
// }(Parser);

// var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(AMPMMidnightParser, _Parser);
//   var _super = _createSuper$c(AMPMMidnightParser);
//   function AMPMMidnightParser() {
//     var _this;
//     _classCallCheck$f(this, AMPMMidnightParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 80);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(AMPMMidnightParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'b':
//         case 'bb':
//         case 'bbb':
//           return match.dayPeriod(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         case 'bbbbb':
//           return match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         case 'bbbb':
//         default:
//           return match.dayPeriod(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
//       return date;
//     }
//   }]);
//   return AMPMMidnightParser;
// }(Parser);

// var DayPeriodParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(DayPeriodParser, _Parser);
//   var _super = _createSuper$c(DayPeriodParser);
//   function DayPeriodParser() {
//     var _this;
//     _classCallCheck$f(this, DayPeriodParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 80);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(DayPeriodParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'B':
//         case 'BB':
//         case 'BBB':
//           return match.dayPeriod(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         case 'BBBBB':
//           return match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//         case 'BBBB':
//         default:
//           return match.dayPeriod(dateString, {
//             width: 'wide',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'abbreviated',
//             context: 'formatting'
//           }) || match.dayPeriod(dateString, {
//             width: 'narrow',
//             context: 'formatting'
//           });
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
//       return date;
//     }
//   }]);
//   return DayPeriodParser;
// }(Parser);

// var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(Hour1to12Parser, _Parser);
//   var _super = _createSuper$c(Hour1to12Parser);
//   function Hour1to12Parser() {
//     var _this;
//     _classCallCheck$f(this, Hour1to12Parser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 70);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(Hour1to12Parser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'h':
//           return parseNumericPattern(numericPatterns.hour12h, dateString);
//         case 'ho':
//           return match.ordinalNumber(dateString, {
//             unit: 'hour'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 1 && value <= 12;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       var isPM = date.getUTCHours() >= 12;
//       if (isPM && value < 12) {
//         date.setUTCHours(value + 12, 0, 0, 0);
//       } else if (!isPM && value === 12) {
//         date.setUTCHours(0, 0, 0, 0);
//       } else {
//         date.setUTCHours(value, 0, 0, 0);
//       }
//       return date;
//     }
//   }]);
//   return Hour1to12Parser;
// }(Parser);

// var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(Hour0to23Parser, _Parser);
//   var _super = _createSuper$c(Hour0to23Parser);
//   function Hour0to23Parser() {
//     var _this;
//     _classCallCheck$f(this, Hour0to23Parser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 70);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(Hour0to23Parser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'H':
//           return parseNumericPattern(numericPatterns.hour23h, dateString);
//         case 'Ho':
//           return match.ordinalNumber(dateString, {
//             unit: 'hour'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 23;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCHours(value, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return Hour0to23Parser;
// }(Parser);

// var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(Hour0To11Parser, _Parser);
//   var _super = _createSuper$c(Hour0To11Parser);
//   function Hour0To11Parser() {
//     var _this;
//     _classCallCheck$f(this, Hour0To11Parser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 70);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(Hour0To11Parser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'K':
//           return parseNumericPattern(numericPatterns.hour11h, dateString);
//         case 'Ko':
//           return match.ordinalNumber(dateString, {
//             unit: 'hour'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 11;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       var isPM = date.getUTCHours() >= 12;
//       if (isPM && value < 12) {
//         date.setUTCHours(value + 12, 0, 0, 0);
//       } else {
//         date.setUTCHours(value, 0, 0, 0);
//       }
//       return date;
//     }
//   }]);
//   return Hour0To11Parser;
// }(Parser);

// var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(Hour1To24Parser, _Parser);
//   var _super = _createSuper$c(Hour1To24Parser);
//   function Hour1To24Parser() {
//     var _this;
//     _classCallCheck$f(this, Hour1To24Parser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 70);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
//     return _this;
//   }
//   _createClass$f(Hour1To24Parser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'k':
//           return parseNumericPattern(numericPatterns.hour24h, dateString);
//         case 'ko':
//           return match.ordinalNumber(dateString, {
//             unit: 'hour'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 1 && value <= 24;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       var hours = value <= 24 ? value % 24 : value;
//       date.setUTCHours(hours, 0, 0, 0);
//       return date;
//     }
//   }]);
//   return Hour1To24Parser;
// }(Parser);

// var MinuteParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(MinuteParser, _Parser);
//   var _super = _createSuper$c(MinuteParser);
//   function MinuteParser() {
//     var _this;
//     _classCallCheck$f(this, MinuteParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 60);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['t', 'T']);
//     return _this;
//   }
//   _createClass$f(MinuteParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 'm':
//           return parseNumericPattern(numericPatterns.minute, dateString);
//         case 'mo':
//           return match.ordinalNumber(dateString, {
//             unit: 'minute'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 59;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCMinutes(value, 0, 0);
//       return date;
//     }
//   }]);
//   return MinuteParser;
// }(Parser);

// var SecondParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(SecondParser, _Parser);
//   var _super = _createSuper$c(SecondParser);
//   function SecondParser() {
//     var _this;
//     _classCallCheck$f(this, SecondParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 50);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['t', 'T']);
//     return _this;
//   }
//   _createClass$f(SecondParser, [{
//     key: "parse",
//     value: function parse(dateString, token, match) {
//       switch (token) {
//         case 's':
//           return parseNumericPattern(numericPatterns.second, dateString);
//         case 'so':
//           return match.ordinalNumber(dateString, {
//             unit: 'second'
//           });
//         default:
//           return parseNDigits(token.length, dateString);
//       }
//     }
//   }, {
//     key: "validate",
//     value: function validate(_date, value) {
//       return value >= 0 && value <= 59;
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCSeconds(value, 0);
//       return date;
//     }
//   }]);
//   return SecondParser;
// }(Parser);

// var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(FractionOfSecondParser, _Parser);
//   var _super = _createSuper$c(FractionOfSecondParser);
//   function FractionOfSecondParser() {
//     var _this;
//     _classCallCheck$f(this, FractionOfSecondParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 30);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['t', 'T']);
//     return _this;
//   }
//   _createClass$f(FractionOfSecondParser, [{
//     key: "parse",
//     value: function parse(dateString, token) {
//       var valueCallback = function valueCallback(value) {
//         return Math.floor(value * Math.pow(10, -token.length + 3));
//       };
//       return mapValue(parseNDigits(token.length, dateString), valueCallback);
//     }
//   }, {
//     key: "set",
//     value: function set(date, _flags, value) {
//       date.setUTCMilliseconds(value);
//       return date;
//     }
//   }]);
//   return FractionOfSecondParser;
// }(Parser);

// var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(ISOTimezoneWithZParser, _Parser);
//   var _super = _createSuper$c(ISOTimezoneWithZParser);
//   function ISOTimezoneWithZParser() {
//     var _this;
//     _classCallCheck$f(this, ISOTimezoneWithZParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 10);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['t', 'T', 'x']);
//     return _this;
//   }
//   _createClass$f(ISOTimezoneWithZParser, [{
//     key: "parse",
//     value: function parse(dateString, token) {
//       switch (token) {
//         case 'X':
//           return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
//         case 'XX':
//           return parseTimezonePattern(timezonePatterns.basic, dateString);
//         case 'XXXX':
//           return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
//         case 'XXXXX':
//           return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
//         case 'XXX':
//         default:
//           return parseTimezonePattern(timezonePatterns.extended, dateString);
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, flags, value) {
//       if (flags.timestampIsSet) {
//         return date;
//       }
//       return new Date(date.getTime() - value);
//     }
//   }]);
//   return ISOTimezoneWithZParser;
// }(Parser);

// var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(ISOTimezoneParser, _Parser);
//   var _super = _createSuper$c(ISOTimezoneParser);
//   function ISOTimezoneParser() {
//     var _this;
//     _classCallCheck$f(this, ISOTimezoneParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 10);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", ['t', 'T', 'X']);
//     return _this;
//   }
//   _createClass$f(ISOTimezoneParser, [{
//     key: "parse",
//     value: function parse(dateString, token) {
//       switch (token) {
//         case 'x':
//           return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
//         case 'xx':
//           return parseTimezonePattern(timezonePatterns.basic, dateString);
//         case 'xxxx':
//           return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
//         case 'xxxxx':
//           return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
//         case 'xxx':
//         default:
//           return parseTimezonePattern(timezonePatterns.extended, dateString);
//       }
//     }
//   }, {
//     key: "set",
//     value: function set(date, flags, value) {
//       if (flags.timestampIsSet) {
//         return date;
//       }
//       return new Date(date.getTime() - value);
//     }
//   }]);
//   return ISOTimezoneParser;
// }(Parser);

// var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(TimestampSecondsParser, _Parser);
//   var _super = _createSuper$c(TimestampSecondsParser);
//   function TimestampSecondsParser() {
//     var _this;
//     _classCallCheck$f(this, TimestampSecondsParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 40);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", '*');
//     return _this;
//   }
//   _createClass$f(TimestampSecondsParser, [{
//     key: "parse",
//     value: function parse(dateString) {
//       return parseAnyDigitsSigned(dateString);
//     }
//   }, {
//     key: "set",
//     value: function set(_date, _flags, value) {
//       return [new Date(value * 1000), {
//         timestampIsSet: true
//       }];
//     }
//   }]);
//   return TimestampSecondsParser;
// }(Parser);

// var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
//   _inherits$c(TimestampMillisecondsParser, _Parser);
//   var _super = _createSuper$c(TimestampMillisecondsParser);
//   function TimestampMillisecondsParser() {
//     var _this;
//     _classCallCheck$f(this, TimestampMillisecondsParser);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$B(_assertThisInitialized$c(_this), "priority", 20);
//     _defineProperty$B(_assertThisInitialized$c(_this), "incompatibleTokens", '*');
//     return _this;
//   }
//   _createClass$f(TimestampMillisecondsParser, [{
//     key: "parse",
//     value: function parse(dateString) {
//       return parseAnyDigitsSigned(dateString);
//     }
//   }, {
//     key: "set",
//     value: function set(_date, _flags, value) {
//       return [new Date(value), {
//         timestampIsSet: true
//       }];
//     }
//   }]);
//   return TimestampMillisecondsParser;
// }(Parser);

// /*
//  * |     | Unit                           |     | Unit                           |
//  * |-----|--------------------------------|-----|--------------------------------|
//  * |  a  | AM, PM                         |  A* | Milliseconds in day            |
//  * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
//  * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
//  * |  d  | Day of month                   |  D  | Day of year                    |
//  * |  e  | Local day of week              |  E  | Day of week                    |
//  * |  f  |                                |  F* | Day of week in month           |
//  * |  g* | Modified Julian day            |  G  | Era                            |
//  * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
//  * |  i! | ISO day of week                |  I! | ISO week of year               |
//  * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
//  * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
//  * |  l* | (deprecated)                   |  L  | Stand-alone month              |
//  * |  m  | Minute                         |  M  | Month                          |
//  * |  n  |                                |  N  |                                |
//  * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
//  * |  p  |                                |  P  |                                |
//  * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
//  * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
//  * |  s  | Second                         |  S  | Fraction of second             |
//  * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
//  * |  u  | Extended year                  |  U* | Cyclic year                    |
//  * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
//  * |  w  | Local week of year             |  W* | Week of month                  |
//  * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
//  * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
//  * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
//  *
//  * Letters marked by * are not implemented but reserved by Unicode standard.
//  *
//  * Letters marked by ! are non-standard, but implemented by date-fns:
//  * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
//  * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
//  *   i.e. 7 for Sunday, 1 for Monday, etc.
//  * - `I` is ISO week of year, as opposed to `w` which is local week of year.
//  * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
//  *   `R` is supposed to be used in conjunction with `I` and `i`
//  *   for universal ISO week-numbering date, whereas
//  *   `Y` is supposed to be used in conjunction with `w` and `e`
//  *   for week-numbering date specific to the locale.
//  */
// var parsers = {
//   G: new EraParser(),
//   y: new YearParser(),
//   Y: new LocalWeekYearParser(),
//   R: new ISOWeekYearParser(),
//   u: new ExtendedYearParser(),
//   Q: new QuarterParser(),
//   q: new StandAloneQuarterParser(),
//   M: new MonthParser(),
//   L: new StandAloneMonthParser(),
//   w: new LocalWeekParser(),
//   I: new ISOWeekParser(),
//   d: new DateParser(),
//   D: new DayOfYearParser(),
//   E: new DayParser(),
//   e: new LocalDayParser(),
//   c: new StandAloneLocalDayParser(),
//   i: new ISODayParser(),
//   a: new AMPMParser(),
//   b: new AMPMMidnightParser(),
//   B: new DayPeriodParser(),
//   h: new Hour1to12Parser(),
//   H: new Hour0to23Parser(),
//   K: new Hour0To11Parser(),
//   k: new Hour1To24Parser(),
//   m: new MinuteParser(),
//   s: new SecondParser(),
//   S: new FractionOfSecondParser(),
//   X: new ISOTimezoneWithZParser(),
//   x: new ISOTimezoneParser(),
//   t: new TimestampSecondsParser(),
//   T: new TimestampMillisecondsParser()
// };

// // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
// //   (one of the certain letters followed by `o`)
// // - (\w)\1* matches any sequences of the same letter
// // - '' matches two quote characters in a row
// // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
// //   except a single quote symbol, which ends the sequence.
// //   Two quote characters do not end the sequence.
// //   If there is no matching single quote
// //   then the sequence will continue until the end of the string.
// // - . matches any single character unmatched by previous parts of the RegExps
// var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// // This RegExp catches symbols escaped by quotes, and also
// // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
// var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
// var escapedStringRegExp = /^'([^]*?)'?$/;
// var doubleQuoteRegExp = /''/g;
// var notWhitespaceRegExp = /\S/;
// var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

// /**
//  * @name parse
//  * @category Common Helpers
//  * @summary Parse the date.
//  *
//  * @description
//  * Return the date parsed from string using the given format string.
//  *
//  * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
//  * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  *
//  * The characters in the format string wrapped between two single quotes characters (') are escaped.
//  * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
//  *
//  * Format of the format string is based on Unicode Technical Standard #35:
//  * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
//  * with a few additions (see note 5 below the table).
//  *
//  * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
//  * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
//  *
//  * ```javascript
//  * parse('23 AM', 'HH a', new Date())
//  * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
//  * ```
//  *
//  * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
//  *
//  * Accepted format string patterns:
//  * | Unit                            |Prior| Pattern | Result examples                   | Notes |
//  * |---------------------------------|-----|---------|-----------------------------------|-------|
//  * | Era                             | 140 | G..GGG  | AD, BC                            |       |
//  * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
//  * |                                 |     | GGGGG   | A, B                              |       |
//  * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
//  * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
//  * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
//  * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
//  * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
//  * |                                 |     | yyyyy   | ...                               | 2,4   |
//  * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
//  * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
//  * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
//  * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
//  * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
//  * |                                 |     | YYYYY   | ...                               | 2,4   |
//  * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
//  * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
//  * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
//  * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
//  * |                                 |     | RRRRR   | ...                               | 2,4,5 |
//  * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
//  * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
//  * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
//  * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
//  * |                                 |     | uuuuu   | ...                               | 2,4   |
//  * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
//  * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
//  * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
//  * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
//  * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
//  * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
//  * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
//  * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
//  * |                                 |     | qq      | 01, 02, 03, 04                    |       |
//  * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
//  * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
//  * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
//  * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
//  * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
//  * |                                 |     | MM      | 01, 02, ..., 12                   |       |
//  * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
//  * |                                 |     | MMMM    | January, February, ..., December  | 2     |
//  * |                                 |     | MMMMM   | J, F, ..., D                      |       |
//  * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
//  * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
//  * |                                 |     | LL      | 01, 02, ..., 12                   |       |
//  * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
//  * |                                 |     | LLLL    | January, February, ..., December  | 2     |
//  * |                                 |     | LLLLL   | J, F, ..., D                      |       |
//  * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
//  * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
//  * |                                 |     | ww      | 01, 02, ..., 53                   |       |
//  * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
//  * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
//  * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
//  * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
//  * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
//  * |                                 |     | dd      | 01, 02, ..., 31                   |       |
//  * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
//  * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
//  * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
//  * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
//  * |                                 |     | DDDD    | ...                               | 2     |
//  * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
//  * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
//  * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
//  * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
//  * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
//  * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
//  * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
//  * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
//  * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
//  * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
//  * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
//  * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
//  * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
//  * |                                 |     | ee      | 02, 03, ..., 01                   |       |
//  * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
//  * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
//  * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
//  * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
//  * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
//  * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
//  * |                                 |     | cc      | 02, 03, ..., 01                   |       |
//  * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
//  * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
//  * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
//  * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
//  * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
//  * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
//  * |                                 |     | aaaaa   | a, p                              |       |
//  * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
//  * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
//  * |                                 |     | bbbbb   | a, p, n, mi                       |       |
//  * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
//  * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
//  * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
//  * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
//  * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
//  * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
//  * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
//  * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
//  * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
//  * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
//  * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
//  * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
//  * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
//  * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
//  * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
//  * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
//  * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
//  * |                                 |     | mm      | 00, 01, ..., 59                   |       |
//  * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
//  * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
//  * |                                 |     | ss      | 00, 01, ..., 59                   |       |
//  * | Seconds timestamp               |  40 | t       | 512969520                         |       |
//  * |                                 |     | tt      | ...                               | 2     |
//  * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
//  * |                                 |     | SS      | 00, 01, ..., 99                   |       |
//  * |                                 |     | SSS     | 000, 001, ..., 999                |       |
//  * |                                 |     | SSSS    | ...                               | 2     |
//  * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
//  * |                                 |     | TT      | ...                               | 2     |
//  * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
//  * |                                 |     | XX      | -0800, +0530, Z                   |       |
//  * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
//  * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
//  * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
//  * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
//  * |                                 |     | xx      | -0800, +0530, +0000               |       |
//  * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
//  * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
//  * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
//  * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
//  * |                                 |     | PP      | May 29, 1453                      |       |
//  * |                                 |     | PPP     | May 29th, 1453                    |       |
//  * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
//  * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
//  * |                                 |     | pp      | 12:00:00 AM                       |       |
//  * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
//  * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
//  * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
//  * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
//  * Notes:
//  * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
//  *    are the same as "stand-alone" units, but are different in some languages.
//  *    "Formatting" units are declined according to the rules of the language
//  *    in the context of a date. "Stand-alone" units are always nominative singular.
//  *    In `format` function, they will produce different result:
//  *
//  *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
//  *
//  *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
//  *
//  *    `parse` will try to match both formatting and stand-alone units interchangably.
//  *
//  * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
//  *    the single quote characters (see below).
//  *    If the sequence is longer than listed in table:
//  *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
//  *      as wide as the sequence
//  *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
//  *      These variations are marked with "2" in the last column of the table.
//  *
//  * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
//  *    These tokens represent the shortest form of the quarter.
//  *
//  * 4. The main difference between `y` and `u` patterns are B.C. years:
//  *
//  *    | Year | `y` | `u` |
//  *    |------|-----|-----|
//  *    | AC 1 |   1 |   1 |
//  *    | BC 1 |   1 |   0 |
//  *    | BC 2 |   2 |  -1 |
//  *
//  *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
//  *
//  *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
//  *
//  *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
//  *
//  *    while `uu` will just assign the year as is:
//  *
//  *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
//  *
//  *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
//  *
//  *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
//  *    except local week-numbering years are dependent on `options.weekStartsOn`
//  *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
//  *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
//  *
//  * 5. These patterns are not in the Unicode Technical Standard #35:
//  *    - `i`: ISO day of week
//  *    - `I`: ISO week of year
//  *    - `R`: ISO week-numbering year
//  *    - `o`: ordinal number modifier
//  *    - `P`: long localized date
//  *    - `p`: long localized time
//  *
//  * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
//  *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  *
//  * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
//  *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  *
//  * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
//  *    on the given locale.
//  *
//  *    using `en-US` locale: `P` => `MM/dd/yyyy`
//  *    using `en-US` locale: `p` => `hh:mm a`
//  *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
//  *    using `pt-BR` locale: `p` => `HH:mm`
//  *
//  * Values will be assigned to the date in the descending order of its unit's priority.
//  * Units of an equal priority overwrite each other in the order of appearance.
//  *
//  * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
//  * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
//  *
//  * `referenceDate` must be passed for correct work of the function.
//  * If you're not sure which `referenceDate` to supply, create a new instance of Date:
//  * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
//  * In this case parsing will be done in the context of the current date.
//  * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
//  * then `Invalid Date` will be returned.
//  *
//  * The result may vary by locale.
//  *
//  * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
//  *
//  * If parsing failed, `Invalid Date` will be returned.
//  * Invalid Date is a Date, whose time value is NaN.
//  * Time value of Date: http://es5.github.io/#x15.9.1.1
//  *
//  * @param {String} dateString - the string to parse
//  * @param {String} formatString - the string of tokens
//  * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
//  * @param {Object} [options] - an object with options.
//  * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
//  * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
//  * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
//  * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
//  *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
//  *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @returns {Date} the parsed date
//  * @throws {TypeError} 3 arguments required
//  * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
//  * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
//  * @throws {RangeError} `options.locale` must contain `match` property
//  * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
//  * @throws {RangeError} format string contains an unescaped latin alphabet character
//  *
//  * @example
//  * // Parse 11 February 2014 from middle-endian format:
//  * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
//  * //=> Tue Feb 11 2014 00:00:00
//  *
//  * @example
//  * // Parse 28th of February in Esperanto locale in the context of 2010 year:
//  * import eo from 'date-fns/locale/eo'
//  * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
//  *   locale: eo
//  * })
//  * //=> Sun Feb 28 2010 00:00:00
//  */
// function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
//   var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
//   requiredArgs(3, arguments);
//   var dateString = String(dirtyDateString);
//   var formatString = String(dirtyFormatString);
//   var defaultOptions = getDefaultOptions();
//   var locale$1 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale;
//   if (!locale$1.match) {
//     throw new RangeError('locale must contain match property');
//   }
//   var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

//   // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
//   if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
//     throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
//   }
//   var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

//   // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
//   if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
//     throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
//   }
//   if (formatString === '') {
//     if (dateString === '') {
//       return toDate$1(dirtyReferenceDate);
//     } else {
//       return new Date(NaN);
//     }
//   }
//   var subFnOptions = {
//     firstWeekContainsDate: firstWeekContainsDate,
//     weekStartsOn: weekStartsOn,
//     locale: locale$1
//   };

//   // If timezone isn't specified, it will be set to the system timezone
//   var setters = [new DateToSystemTimezoneSetter()];
//   var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
//     var firstCharacter = substring[0];
//     if (firstCharacter in longFormatters) {
//       var longFormatter = longFormatters[firstCharacter];
//       return longFormatter(substring, locale$1.formatLong);
//     }
//     return substring;
//   }).join('').match(formattingTokensRegExp);
//   var usedTokens = [];
//   var _iterator = _createForOfIteratorHelper$1(tokens),
//     _step;
//   try {
//     var _loop = function _loop() {
//       var token = _step.value;
//       if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
//         throwProtectedError(token, formatString, dirtyDateString);
//       }
//       if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
//         throwProtectedError(token, formatString, dirtyDateString);
//       }
//       var firstCharacter = token[0];
//       var parser = parsers[firstCharacter];
//       if (parser) {
//         var incompatibleTokens = parser.incompatibleTokens;
//         if (Array.isArray(incompatibleTokens)) {
//           var incompatibleToken = usedTokens.find(function (usedToken) {
//             return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
//           });
//           if (incompatibleToken) {
//             throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
//           }
//         } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
//           throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
//         }
//         usedTokens.push({
//           token: firstCharacter,
//           fullToken: token
//         });
//         var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);
//         if (!parseResult) {
//           return {
//             v: new Date(NaN)
//           };
//         }
//         setters.push(parseResult.setter);
//         dateString = parseResult.rest;
//       } else {
//         if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
//           throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
//         }

//         // Replace two single quote characters with one single quote character
//         if (token === "''") {
//           token = "'";
//         } else if (firstCharacter === "'") {
//           token = cleanEscapedString(token);
//         }

//         // Cut token from string, or, if string doesn't match the token, return Invalid Date
//         if (dateString.indexOf(token) === 0) {
//           dateString = dateString.slice(token.length);
//         } else {
//           return {
//             v: new Date(NaN)
//           };
//         }
//       }
//     };
//     for (_iterator.s(); !(_step = _iterator.n()).done;) {
//       var _ret = _loop();
//       if (_typeof$F(_ret) === "object") return _ret.v;
//     }

//     // Check if the remaining input contains something other than whitespace
//   } catch (err) {
//     _iterator.e(err);
//   } finally {
//     _iterator.f();
//   }
//   if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
//     return new Date(NaN);
//   }
//   var uniquePrioritySetters = setters.map(function (setter) {
//     return setter.priority;
//   }).sort(function (a, b) {
//     return b - a;
//   }).filter(function (priority, index, array) {
//     return array.indexOf(priority) === index;
//   }).map(function (priority) {
//     return setters.filter(function (setter) {
//       return setter.priority === priority;
//     }).sort(function (a, b) {
//       return b.subPriority - a.subPriority;
//     });
//   }).map(function (setterArray) {
//     return setterArray[0];
//   });
//   var date = toDate$1(dirtyReferenceDate);
//   if (isNaN(date.getTime())) {
//     return new Date(NaN);
//   }

//   // Convert the date in system timezone to the same date in UTC+00:00 timezone.
//   var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
//   var flags = {};
//   var _iterator2 = _createForOfIteratorHelper$1(uniquePrioritySetters),
//     _step2;
//   try {
//     for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
//       var setter = _step2.value;
//       if (!setter.validate(utcDate, subFnOptions)) {
//         return new Date(NaN);
//       }
//       var result = setter.set(utcDate, flags, subFnOptions);
//       // Result is tuple (date, flags)
//       if (Array.isArray(result)) {
//         utcDate = result[0];
//         assign$1(flags, result[1]);
//         // Result is date
//       } else {
//         utcDate = result;
//       }
//     }
//   } catch (err) {
//     _iterator2.e(err);
//   } finally {
//     _iterator2.f();
//   }
//   return utcDate;
// }
// function cleanEscapedString(input) {
//   return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
// }

// /**
//  * @name setDate
//  * @category Day Helpers
//  * @summary Set the day of the month to the given date.
//  *
//  * @description
//  * Set the day of the month to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} dayOfMonth - the day of the month of the new date
//  * @returns {Date} the new date with the day of the month set
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Set the 30th day of the month to 1 September 2014:
//  * const result = setDate(new Date(2014, 8, 1), 30)
//  * //=> Tue Sep 30 2014 00:00:00
//  */
// function setDate(dirtyDate, dirtyDayOfMonth) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var dayOfMonth = toInteger(dirtyDayOfMonth);
//   date.setDate(dayOfMonth);
//   return date;
// }

// /**
//  * @name setHours
//  * @category Hour Helpers
//  * @summary Set the hours to the given date.
//  *
//  * @description
//  * Set the hours to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} hours - the hours of the new date
//  * @returns {Date} the new date with the hours set
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Set 4 hours to 1 September 2014 11:30:00:
//  * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
//  * //=> Mon Sep 01 2014 04:30:00
//  */
// function setHours(dirtyDate, dirtyHours) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var hours = toInteger(dirtyHours);
//   date.setHours(hours);
//   return date;
// }

// /**
//  * @name setMinutes
//  * @category Minute Helpers
//  * @summary Set the minutes to the given date.
//  *
//  * @description
//  * Set the minutes to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} minutes - the minutes of the new date
//  * @returns {Date} the new date with the minutes set
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Set 45 minutes to 1 September 2014 11:30:40:
//  * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
//  * //=> Mon Sep 01 2014 11:45:40
//  */
// function setMinutes(dirtyDate, dirtyMinutes) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var minutes = toInteger(dirtyMinutes);
//   date.setMinutes(minutes);
//   return date;
// }

// /**
//  * @name setMonth
//  * @category Month Helpers
//  * @summary Set the month to the given date.
//  *
//  * @description
//  * Set the month to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} month - the month of the new date
//  * @returns {Date} the new date with the month set
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Set February to 1 September 2014:
//  * const result = setMonth(new Date(2014, 8, 1), 1)
//  * //=> Sat Feb 01 2014 00:00:00
//  */
// function setMonth(dirtyDate, dirtyMonth) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var month = toInteger(dirtyMonth);
//   var year = date.getFullYear();
//   var day = date.getDate();
//   var dateWithDesiredMonth = new Date(0);
//   dateWithDesiredMonth.setFullYear(year, month, 15);
//   dateWithDesiredMonth.setHours(0, 0, 0, 0);
//   var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
//   // Set the last day of the new month
//   // if the original date was the last day of the longer month
//   date.setMonth(month, Math.min(day, daysInMonth));
//   return date;
// }

// /**
//  * @name setSeconds
//  * @category Second Helpers
//  * @summary Set the seconds to the given date.
//  *
//  * @description
//  * Set the seconds to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} seconds - the seconds of the new date
//  * @returns {Date} the new date with the seconds set
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Set 45 seconds to 1 September 2014 11:30:40:
//  * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
//  * //=> Mon Sep 01 2014 11:30:45
//  */
// function setSeconds(dirtyDate, dirtySeconds) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var seconds = toInteger(dirtySeconds);
//   date.setSeconds(seconds);
//   return date;
// }

// /**
//  * @name setYear
//  * @category Year Helpers
//  * @summary Set the year to the given date.
//  *
//  * @description
//  * Set the year to the given date.
//  *
//  * @param {Date|Number} date - the date to be changed
//  * @param {Number} year - the year of the new date
//  * @returns {Date} the new date with the year set
//  * @throws {TypeError} 2 arguments required
//  *
//  * @example
//  * // Set year 2013 to 1 September 2014:
//  * const result = setYear(new Date(2014, 8, 1), 2013)
//  * //=> Sun Sep 01 2013 00:00:00
//  */
// function setYear(dirtyDate, dirtyYear) {
//   requiredArgs(2, arguments);
//   var date = toDate$1(dirtyDate);
//   var year = toInteger(dirtyYear);

//   // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
//   if (isNaN(date.getTime())) {
//     return new Date(NaN);
//   }
//   date.setFullYear(year);
//   return date;
// }

// /**
//  * @name startOfMonth
//  * @category Month Helpers
//  * @summary Return the start of a month for the given date.
//  *
//  * @description
//  * Return the start of a month for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @returns {Date} the start of a month
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // The start of a month for 2 September 2014 11:55:00:
//  * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
//  * //=> Mon Sep 01 2014 00:00:00
//  */
// function startOfMonth(dirtyDate) {
//   requiredArgs(1, arguments);
//   var date = toDate$1(dirtyDate);
//   date.setDate(1);
//   date.setHours(0, 0, 0, 0);
//   return date;
// }

// /**
//  * @name startOfWeek
//  * @category Week Helpers
//  * @summary Return the start of a week for the given date.
//  *
//  * @description
//  * Return the start of a week for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @param {Object} [options] - an object with options.
//  * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
//  * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
//  * @returns {Date} the start of a week
//  * @throws {TypeError} 1 argument required
//  * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
//  *
//  * @example
//  * // The start of a week for 2 September 2014 11:55:00:
//  * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
//  * //=> Sun Aug 31 2014 00:00:00
//  *
//  * @example
//  * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
//  * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
//  * //=> Mon Sep 01 2014 00:00:00
//  */
// function startOfWeek(dirtyDate, options) {
//   var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
//   requiredArgs(1, arguments);
//   var defaultOptions = getDefaultOptions();
//   var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

//   // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
//   if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
//     throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
//   }
//   var date = toDate$1(dirtyDate);
//   var day = date.getDay();
//   var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
//   date.setDate(date.getDate() - diff);
//   date.setHours(0, 0, 0, 0);
//   return date;
// }

// /**
//  * @name startOfYear
//  * @category Year Helpers
//  * @summary Return the start of a year for the given date.
//  *
//  * @description
//  * Return the start of a year for the given date.
//  * The result will be in the local timezone.
//  *
//  * @param {Date|Number} date - the original date
//  * @returns {Date} the start of a year
//  * @throws {TypeError} 1 argument required
//  *
//  * @example
//  * // The start of a year for 2 September 2014 11:55:00:
//  * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
//  * //=> Wed Jan 01 2014 00:00:00
//  */
// function startOfYear(dirtyDate) {
//   requiredArgs(1, arguments);
//   var cleanDate = toDate$1(dirtyDate);
//   var date = new Date(0);
//   date.setFullYear(cleanDate.getFullYear(), 0, 1);
//   date.setHours(0, 0, 0, 0);
//   return date;
// }

// /**
//  * @name parseISO
//  * @category Common Helpers
//  * @summary Parse ISO string
//  *
//  * @description
//  * Parse the given string in ISO 8601 format and return an instance of Date.
//  *
//  * Function accepts complete ISO 8601 formats as well as partial implementations.
//  * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
//  *
//  * If the argument isn't a string, the function cannot parse the string or
//  * the values are invalid, it returns Invalid Date.
//  *
//  * @param {String} argument - the value to convert
//  * @param {Object} [options] - an object with options.
//  * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
//  * @returns {Date} the parsed date in the local time zone
//  * @throws {TypeError} 1 argument required
//  * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
//  *
//  * @example
//  * // Convert string '2014-02-11T11:30:30' to date:
//  * const result = parseISO('2014-02-11T11:30:30')
//  * //=> Tue Feb 11 2014 11:30:30
//  *
//  * @example
//  * // Convert string '+02014101' to date,
//  * // if the additional number of digits in the extended year format is 1:
//  * const result = parseISO('+02014101', { additionalDigits: 1 })
//  * //=> Fri Apr 11 2014 00:00:00
//  */
// function parseISO(argument, options) {
//   var _options$additionalDi;
//   requiredArgs(1, arguments);
//   var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
//   if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
//     throw new RangeError('additionalDigits must be 0, 1 or 2');
//   }
//   if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
//     return new Date(NaN);
//   }
//   var dateStrings = splitDateString$1(argument);
//   var date;
//   if (dateStrings.date) {
//     var parseYearResult = parseYear$1(dateStrings.date, additionalDigits);
//     date = parseDate$1(parseYearResult.restDateString, parseYearResult.year);
//   }
//   if (!date || isNaN(date.getTime())) {
//     return new Date(NaN);
//   }
//   var timestamp = date.getTime();
//   var time = 0;
//   var offset;
//   if (dateStrings.time) {
//     time = parseTime$1(dateStrings.time);
//     if (isNaN(time)) {
//       return new Date(NaN);
//     }
//   }
//   if (dateStrings.timezone) {
//     offset = parseTimezone(dateStrings.timezone);
//     if (isNaN(offset)) {
//       return new Date(NaN);
//     }
//   } else {
//     var dirtyDate = new Date(timestamp + time);
//     // js parsed string assuming it's in UTC timezone
//     // but we need it to be parsed in our timezone
//     // so we use utc values to build date in our timezone.
//     // Year values from 0 to 99 map to the years 1900 to 1999
//     // so set year explicitly with setFullYear.
//     var result = new Date(0);
//     result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
//     result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
//     return result;
//   }
//   return new Date(timestamp + time + offset);
// }
// var patterns$2 = {
//   dateTimeDelimiter: /[T ]/,
//   timeZoneDelimiter: /[Z ]/i,
//   timezone: /([Z+-].*)$/
// };
// var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
// var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
// var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
// function splitDateString$1(dateString) {
//   var dateStrings = {};
//   var array = dateString.split(patterns$2.dateTimeDelimiter);
//   var timeString;

//   // The regex match should only return at maximum two array elements.
//   // [date], [time], or [date, time].
//   if (array.length > 2) {
//     return dateStrings;
//   }
//   if (/:/.test(array[0])) {
//     timeString = array[0];
//   } else {
//     dateStrings.date = array[0];
//     timeString = array[1];
//     if (patterns$2.timeZoneDelimiter.test(dateStrings.date)) {
//       dateStrings.date = dateString.split(patterns$2.timeZoneDelimiter)[0];
//       timeString = dateString.substr(dateStrings.date.length, dateString.length);
//     }
//   }
//   if (timeString) {
//     var token = patterns$2.timezone.exec(timeString);
//     if (token) {
//       dateStrings.time = timeString.replace(token[1], '');
//       dateStrings.timezone = token[1];
//     } else {
//       dateStrings.time = timeString;
//     }
//   }
//   return dateStrings;
// }
// function parseYear$1(dateString, additionalDigits) {
//   var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
//   var captures = dateString.match(regex);
//   // Invalid ISO-formatted year
//   if (!captures) return {
//     year: NaN,
//     restDateString: ''
//   };
//   var year = captures[1] ? parseInt(captures[1]) : null;
//   var century = captures[2] ? parseInt(captures[2]) : null;

//   // either year or century is null, not both
//   return {
//     year: century === null ? year : century * 100,
//     restDateString: dateString.slice((captures[1] || captures[2]).length)
//   };
// }
// function parseDate$1(dateString, year) {
//   // Invalid ISO-formatted year
//   if (year === null) return new Date(NaN);
//   var captures = dateString.match(dateRegex);
//   // Invalid ISO-formatted string
//   if (!captures) return new Date(NaN);
//   var isWeekDate = !!captures[4];
//   var dayOfYear = parseDateUnit(captures[1]);
//   var month = parseDateUnit(captures[2]) - 1;
//   var day = parseDateUnit(captures[3]);
//   var week = parseDateUnit(captures[4]);
//   var dayOfWeek = parseDateUnit(captures[5]) - 1;
//   if (isWeekDate) {
//     if (!validateWeekDate$1(year, week, dayOfWeek)) {
//       return new Date(NaN);
//     }
//     return dayOfISOWeekYear$1(year, week, dayOfWeek);
//   } else {
//     var date = new Date(0);
//     if (!validateDate$2(year, month, day) || !validateDayOfYearDate$1(year, dayOfYear)) {
//       return new Date(NaN);
//     }
//     date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
//     return date;
//   }
// }
// function parseDateUnit(value) {
//   return value ? parseInt(value) : 1;
// }
// function parseTime$1(timeString) {
//   var captures = timeString.match(timeRegex);
//   if (!captures) return NaN; // Invalid ISO-formatted time

//   var hours = parseTimeUnit(captures[1]);
//   var minutes = parseTimeUnit(captures[2]);
//   var seconds = parseTimeUnit(captures[3]);
//   if (!validateTime$2(hours, minutes, seconds)) {
//     return NaN;
//   }
//   return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000;
// }
// function parseTimeUnit(value) {
//   return value && parseFloat(value.replace(',', '.')) || 0;
// }
// function parseTimezone(timezoneString) {
//   if (timezoneString === 'Z') return 0;
//   var captures = timezoneString.match(timezoneRegex);
//   if (!captures) return 0;
//   var sign = captures[1] === '+' ? -1 : 1;
//   var hours = parseInt(captures[2]);
//   var minutes = captures[3] && parseInt(captures[3]) || 0;
//   if (!validateTimezone$1(hours, minutes)) {
//     return NaN;
//   }
//   return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
// }
// function dayOfISOWeekYear$1(isoWeekYear, week, day) {
//   var date = new Date(0);
//   date.setUTCFullYear(isoWeekYear, 0, 4);
//   var fourthOfJanuaryDay = date.getUTCDay() || 7;
//   var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
//   date.setUTCDate(date.getUTCDate() + diff);
//   return date;
// }

// // Validation functions

// // February is null to handle the leap year (using ||)
// var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
// function isLeapYearIndex$1(year) {
//   return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
// }
// function validateDate$2(year, month, date) {
//   return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex$1(year) ? 29 : 28));
// }
// function validateDayOfYearDate$1(year, dayOfYear) {
//   return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex$1(year) ? 366 : 365);
// }
// function validateWeekDate$1(_year, week, day) {
//   return week >= 1 && week <= 53 && day >= 0 && day <= 6;
// }
// function validateTime$2(hours, minutes, seconds) {
//   if (hours === 24) {
//     return minutes === 0 && seconds === 0;
//   }
//   return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
// }
// function validateTimezone$1(_hours, minutes) {
//   return minutes >= 0 && minutes <= 59;
// }

// /**
//  * @name formatISO
//  * @category Common Helpers
//  * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
//  *
//  * @description
//  * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
//  *
//  * @param {Date|Number} date - the original date
//  * @param {Object} [options] - an object with options.
//  * @param {'extended'|'basic'} [options.format='extended'] - if 'basic', hide delimiters between date and time values.
//  * @param {'complete'|'date'|'time'} [options.representation='complete'] - format date, time with local time zone, or both.
//  * @returns {String} the formatted date string (in local time zone)
//  * @throws {TypeError} 1 argument required
//  * @throws {RangeError} `date` must not be Invalid Date
//  * @throws {RangeError} `options.format` must be 'extended' or 'basic'
//  * @throws {RangeError} `options.representation` must be 'date', 'time' or 'complete'
//  *
//  * @example
//  * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
//  * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
//  * //=> '2019-09-18T19:00:52Z'
//  *
//  * @example
//  * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
//  * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
//  * //=> '20190918T190052'
//  *
//  * @example
//  * // Represent 18 September 2019 in ISO 8601 format, date only:
//  * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
//  * //=> '2019-09-18'
//  *
//  * @example
//  * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
//  * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
//  * //=> '19:00:52Z'
//  */
// function formatISO(date, options) {
//   var _options$format, _options$representati;
//   requiredArgs(1, arguments);
//   var originalDate = toDate$1(date);
//   if (isNaN(originalDate.getTime())) {
//     throw new RangeError('Invalid time value');
//   }
//   var format = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : 'extended');
//   var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : 'complete');
//   if (format !== 'extended' && format !== 'basic') {
//     throw new RangeError("format must be 'extended' or 'basic'");
//   }
//   if (representation !== 'date' && representation !== 'time' && representation !== 'complete') {
//     throw new RangeError("representation must be 'date', 'time', or 'complete'");
//   }
//   var result = '';
//   var tzOffset = '';
//   var dateDelimiter = format === 'extended' ? '-' : '';
//   var timeDelimiter = format === 'extended' ? ':' : '';

//   // Representation is either 'date' or 'complete'
//   if (representation !== 'time') {
//     var day = addLeadingZeros(originalDate.getDate(), 2);
//     var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
//     var year = addLeadingZeros(originalDate.getFullYear(), 4);

//     // yyyyMMdd or yyyy-MM-dd.
//     result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
//   }

//   // Representation is either 'time' or 'complete'
//   if (representation !== 'date') {
//     // Add the timezone.
//     var offset = originalDate.getTimezoneOffset();
//     if (offset !== 0) {
//       var absoluteOffset = Math.abs(offset);
//       var hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2);
//       var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
//       // If less than 0, the sign is +, because it is ahead of time.
//       var sign = offset < 0 ? '+' : '-';
//       tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
//     } else {
//       tzOffset = 'Z';
//     }
//     var hour = addLeadingZeros(originalDate.getHours(), 2);
//     var minute = addLeadingZeros(originalDate.getMinutes(), 2);
//     var second = addLeadingZeros(originalDate.getSeconds(), 2);

//     // If there's also date, separate it with time with 'T'
//     var separator = result === '' ? '' : 'T';

//     // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.
//     var time = [hour, minute, second].join(timeDelimiter);

//     // HHmmss or HH:mm:ss.
//     result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
//   }
//   return result;
// }

// /**
//  * @name isWithinInterval
//  * @category Interval Helpers
//  * @summary Is the given date within the interval?
//  *
//  * @description
//  * Is the given date within the interval? (Including start and end.)
//  *
//  * @param {Date|Number} date - the date to check
//  * @param {Interval} interval - the interval to check
//  * @returns {Boolean} the date is within the interval
//  * @throws {TypeError} 2 arguments required
//  * @throws {RangeError} The start of an interval cannot be after its end
//  * @throws {RangeError} Date in interval cannot be `Invalid Date`
//  *
//  * @example
//  * // For the date within the interval:
//  * isWithinInterval(new Date(2014, 0, 3), {
//  *   start: new Date(2014, 0, 1),
//  *   end: new Date(2014, 0, 7)
//  * })
//  * //=> true
//  *
//  * @example
//  * // For the date outside of the interval:
//  * isWithinInterval(new Date(2014, 0, 10), {
//  *   start: new Date(2014, 0, 1),
//  *   end: new Date(2014, 0, 7)
//  * })
//  * //=> false
//  *
//  * @example
//  * // For date equal to interval start:
//  * isWithinInterval(date, { start, end: date }) // => true
//  *
//  * @example
//  * // For date equal to interval end:
//  * isWithinInterval(date, { start: date, end }) // => true
//  */
// function isWithinInterval(dirtyDate, interval) {
//   requiredArgs(2, arguments);
//   var time = toDate$1(dirtyDate).getTime();
//   var startTime = toDate$1(interval.start).getTime();
//   var endTime = toDate$1(interval.end).getTime();

//   // Throw an exception if start date is after end date or if any date is `Invalid Date`
//   if (!(startTime <= endTime)) {
//     throw new RangeError('Invalid interval');
//   }
//   return time >= startTime && time <= endTime;
// }

// const defaultFormats = {
//     dayOfMonth: "d",
//     fullDate: "PP",
//     fullDateWithWeekday: "PPPP",
//     fullDateTime: "PP p",
//     fullDateTime12h: "PP hh:mm aaa",
//     fullDateTime24h: "PP HH:mm",
//     fullTime: "p",
//     fullTime12h: "hh:mm aaa",
//     fullTime24h: "HH:mm",
//     hours12h: "hh",
//     hours24h: "HH",
//     keyboardDate: "P",
//     keyboardDateTime: "P p",
//     keyboardDateTime12h: "P hh:mm aaa",
//     keyboardDateTime24h: "P HH:mm",
//     minutes: "mm",
//     month: "LLLL",
//     monthAndDate: "MMMM d",
//     monthAndYear: "LLLL yyyy",
//     monthShort: "MMM",
//     weekday: "EEEE",
//     weekdayShort: "EEE",
//     normalDate: "d MMMM",
//     normalDateWithWeekday: "EEE, MMM d",
//     seconds: "ss",
//     shortDate: "MMM d",
//     year: "yyyy",
// };
// class DateFnsUtils {
//     constructor({ locale: locale$1, formats, } = {}) {
//         this.lib = "date-fns";
//         // Note: date-fns input types are more lenient than this adapter, so we need to expose our more
//         // strict signature and delegate to the more lenient signature. Otherwise, we have downstream type errors upon usage.
//         this.is12HourCycleInCurrentLocale = () => {
//             var _a;
//             if (this.locale) {
//                 return /a/.test((_a = this.locale.formatLong) === null || _a === void 0 ? void 0 : _a.time());
//             }
//             // By default date-fns is using en-US locale with am/pm enabled
//             return true;
//         };
//         this.getFormatHelperText = (format) => {
//             var _a, _b;
//             // @see https://github.com/date-fns/date-fns/blob/master/src/format/index.js#L31
//             const longFormatRegexp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
//             const locale$1 = this.locale || locale;
//             return ((_b = (_a = format
//                 .match(longFormatRegexp)) === null || _a === void 0 ? void 0 : _a.map((token) => {
//                 const firstCharacter = token[0];
//                 if (firstCharacter === "p" || firstCharacter === "P") {
//                     const longFormatter = longFormatters$1[firstCharacter];
//                     return longFormatter(token, locale$1.formatLong, {});
//                 }
//                 return token;
//             }).join("").replace(/(aaa|aa|a)/g, "(a|p)m").toLocaleLowerCase()) !== null && _b !== void 0 ? _b : format);
//         };
//         this.parseISO = (isoString) => {
//             return parseISO(isoString);
//         };
//         this.toISO = (value) => {
//             return formatISO(value, { format: "extended" });
//         };
//         this.getCurrentLocaleCode = () => {
//             var _a;
//             return ((_a = this.locale) === null || _a === void 0 ? void 0 : _a.code) || "en-US";
//         };
//         this.addSeconds = (value, count) => {
//             return addSeconds(value, count);
//         };
//         this.addMinutes = (value, count) => {
//             return addMinutes(value, count);
//         };
//         this.addHours = (value, count) => {
//             return addHours(value, count);
//         };
//         this.addDays = (value, count) => {
//             return addDays(value, count);
//         };
//         this.addWeeks = (value, count) => {
//             return addWeeks(value, count);
//         };
//         this.addMonths = (value, count) => {
//             return addMonths(value, count);
//         };
//         this.addYears = (value, count) => {
//             return addYears(value, count);
//         };
//         this.isValid = (value) => {
//             return isValid(this.date(value));
//         };
//         this.getDiff = (value, comparing, unit) => {
//             var _a;
//             // we output 0 if the compare date is string and parsing is not valid
//             const dateToCompare = (_a = this.date(comparing)) !== null && _a !== void 0 ? _a : value;
//             if (!this.isValid(dateToCompare)) {
//                 return 0;
//             }
//             switch (unit) {
//                 case "years":
//                     return differenceInYears(value, dateToCompare);
//                 case "quarters":
//                     return differenceInQuarters(value, dateToCompare);
//                 case "months":
//                     return differenceInMonths(value, dateToCompare);
//                 case "weeks":
//                     return differenceInWeeks(value, dateToCompare);
//                 case "days":
//                     return differenceInDays(value, dateToCompare);
//                 case "hours":
//                     return differenceInHours(value, dateToCompare);
//                 case "minutes":
//                     return differenceInMinutes(value, dateToCompare);
//                 case "seconds":
//                     return differenceInSeconds(value, dateToCompare);
//                 default: {
//                     return differenceInMilliseconds(value, dateToCompare);
//                 }
//             }
//         };
//         this.isAfter = (value, comparing) => {
//             return isAfter(value, comparing);
//         };
//         this.isBefore = (value, comparing) => {
//             return isBefore(value, comparing);
//         };
//         this.startOfDay = (value) => {
//             return startOfDay(value);
//         };
//         this.endOfDay = (value) => {
//             return endOfDay(value);
//         };
//         this.getHours = (value) => {
//             return getHours$1(value);
//         };
//         this.setHours = (value, count) => {
//             return setHours(value, count);
//         };
//         this.setMinutes = (value, count) => {
//             return setMinutes(value, count);
//         };
//         this.getSeconds = (value) => {
//             return getSeconds(value);
//         };
//         this.setSeconds = (value, count) => {
//             return setSeconds(value, count);
//         };
//         this.isSameDay = (value, comparing) => {
//             return isSameDay(value, comparing);
//         };
//         this.isSameMonth = (value, comparing) => {
//             return isSameMonth(value, comparing);
//         };
//         this.isSameYear = (value, comparing) => {
//             return isSameYear(value, comparing);
//         };
//         this.isSameHour = (value, comparing) => {
//             return isSameHour(value, comparing);
//         };
//         this.startOfYear = (value) => {
//             return startOfYear(value);
//         };
//         this.endOfYear = (value) => {
//             return endOfYear(value);
//         };
//         this.startOfMonth = (value) => {
//             return startOfMonth(value);
//         };
//         this.endOfMonth = (value) => {
//             return endOfMonth(value);
//         };
//         this.startOfWeek = (value) => {
//             return startOfWeek(value, { locale: this.locale });
//         };
//         this.endOfWeek = (value) => {
//             return endOfWeek(value, { locale: this.locale });
//         };
//         this.getYear = (value) => {
//             return getYear(value);
//         };
//         this.setYear = (value, count) => {
//             return setYear(value, count);
//         };
//         this.date = (value) => {
//             if (typeof value === "undefined") {
//                 return new Date();
//             }
//             if (value === null) {
//                 return null;
//             }
//             return new Date(value);
//         };
//         this.toJsDate = (value) => {
//             return value;
//         };
//         this.parse = (value, formatString) => {
//             if (value === "") {
//                 return null;
//             }
//             return parse(value, formatString, new Date(), { locale: this.locale });
//         };
//         this.format = (date, formatKey) => {
//             return this.formatByString(date, this.formats[formatKey]);
//         };
//         this.formatByString = (date, formatString) => {
//             return format(date, formatString, { locale: this.locale });
//         };
//         this.isEqual = (date, comparing) => {
//             if (date === null && comparing === null) {
//                 return true;
//             }
//             return isEqual(date, comparing);
//         };
//         this.isNull = (date) => {
//             return date === null;
//         };
//         this.isAfterDay = (date, value) => {
//             return isAfter(date, endOfDay(value));
//         };
//         this.isBeforeDay = (date, value) => {
//             return isBefore(date, startOfDay(value));
//         };
//         this.isBeforeYear = (date, value) => {
//             return isBefore(date, startOfYear(value));
//         };
//         this.isAfterYear = (date, value) => {
//             return isAfter(date, endOfYear(value));
//         };
//         this.isWithinRange = (date, [start, end]) => {
//             return isWithinInterval(date, { start, end });
//         };
//         this.formatNumber = (numberToFormat) => {
//             return numberToFormat;
//         };
//         this.getMinutes = (date) => {
//             return getMinutes$1(date);
//         };
//         this.getDate = (date) => {
//             return getDate(date);
//         };
//         this.setDate = (date, count) => {
//             return setDate(date, count);
//         };
//         this.getMonth = (date) => {
//             return getMonth(date);
//         };
//         this.getDaysInMonth = (date) => {
//             return getDaysInMonth(date);
//         };
//         this.setMonth = (date, count) => {
//             return setMonth(date, count);
//         };
//         this.getMeridiemText = (ampm) => {
//             return ampm === "am" ? "AM" : "PM";
//         };
//         this.getNextMonth = (date) => {
//             return addMonths(date, 1);
//         };
//         this.getPreviousMonth = (date) => {
//             return addMonths(date, -1);
//         };
//         this.getMonthArray = (date) => {
//             const firstMonth = startOfYear(date);
//             const monthArray = [firstMonth];
//             while (monthArray.length < 12) {
//                 const prevMonth = monthArray[monthArray.length - 1];
//                 monthArray.push(this.getNextMonth(prevMonth));
//             }
//             return monthArray;
//         };
//         this.mergeDateAndTime = (date, time) => {
//             return this.setSeconds(this.setMinutes(this.setHours(date, this.getHours(time)), this.getMinutes(time)), this.getSeconds(time));
//         };
//         this.getWeekdays = () => {
//             const now = new Date();
//             return eachDayOfInterval({
//                 start: startOfWeek(now, { locale: this.locale }),
//                 end: endOfWeek(now, { locale: this.locale }),
//             }).map((day) => this.formatByString(day, "EEEEEE"));
//         };
//         this.getWeekArray = (date) => {
//             const start = startOfWeek(startOfMonth(date), { locale: this.locale });
//             const end = endOfWeek(endOfMonth(date), { locale: this.locale });
//             let count = 0;
//             let current = start;
//             const nestedWeeks = [];
//             let lastDay = null;
//             while (isBefore(current, end)) {
//                 const weekNumber = Math.floor(count / 7);
//                 nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
//                 const day = getDay(current);
//                 if (lastDay !== day) {
//                     lastDay = day;
//                     nestedWeeks[weekNumber].push(current);
//                     count += 1;
//                 }
//                 current = addDays(current, 1);
//             }
//             return nestedWeeks;
//         };
//         this.getYearRange = (start, end) => {
//             const startDate = startOfYear(start);
//             const endDate = endOfYear(end);
//             const years = [];
//             let current = startDate;
//             while (isBefore(current, endDate)) {
//                 years.push(current);
//                 current = addYears(current, 1);
//             }
//             return years;
//         };
//         this.locale = locale$1;
//         this.formats = Object.assign({}, defaultFormats, formats);
//     }
//     isBeforeMonth(value, comparing) {
//         return isBefore(value, startOfMonth(comparing));
//     }
//     isAfterMonth(value, comparing) {
//         return isAfter(value, startOfMonth(comparing));
//     }
// }

// const formatTokenMap = {
//   y: 'year',
//   yy: 'year',
//   yyy: 'year',
//   yyyy: 'year',
//   MMMM: 'month',
//   MM: 'month',
//   DD: 'day',
//   d: 'day',
//   dd: 'day',
//   H: 'hour',
//   HH: 'hour',
//   h: 'hour',
//   hh: 'hour',
//   mm: 'minute',
//   ss: 'second',
//   a: 'am-pm',
//   aa: 'am-pm',
//   aaa: 'am-pm'
// };
// class AdapterDateFns extends DateFnsUtils {
//   constructor(...args) {
//     super(...args);
//     this.formatTokenMap = formatTokenMap;

//     this.expandFormat = format => {
//       const longFormatRegexp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g; // @see https://github.com/date-fns/date-fns/blob/master/src/format/index.js#L31

//       return format.match(longFormatRegexp).map(token => {
//         const firstCharacter = token[0];

//         if (firstCharacter === 'p' || firstCharacter === 'P') {
//           const longFormatter = longFormatters$1[firstCharacter];
//           const locale$1 = this.locale || locale;
//           return longFormatter(token, locale$1.formatLong, {});
//         }

//         return token;
//       }).join('');
//     };

//     this.getFormatHelperText = format => {
//       return this.expandFormat(format).replace(/(aaa|aa|a)/g, '(a|p)m').toLocaleLowerCase();
//     };
//   }

// }

// const getPickersLocalization = pickersTranslations => {
//   return {
//     components: {
//       MuiLocalizationProvider: {
//         defaultProps: {
//           localeText: _extends$u({}, pickersTranslations)
//         }
//       }
//     }
//   };
// };

// const enUSPickers = {
//   // Calendar navigation
//   previousMonth: 'Previous month',
//   nextMonth: 'Next month',
//   // View navigation
//   openPreviousView: 'open previous view',
//   openNextView: 'open next view',
//   calendarViewSwitchingButtonAriaLabel: view => view === 'year' ? 'year view is open, switch to calendar view' : 'calendar view is open, switch to year view',
//   inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
//   // DateRange placeholders
//   start: 'Start',
//   end: 'End',
//   // Action bar
//   cancelButtonLabel: 'Cancel',
//   clearButtonLabel: 'Clear',
//   okButtonLabel: 'OK',
//   todayButtonLabel: 'Today',
//   // Toolbar titles
//   datePickerDefaultToolbarTitle: 'Select date',
//   dateTimePickerDefaultToolbarTitle: 'Select date & time',
//   timePickerDefaultToolbarTitle: 'Select time',
//   dateRangePickerDefaultToolbarTitle: 'Select date range',
//   // Clock labels
//   clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? 'No time selected' : `Selected time is ${adapter.format(time, 'fullTime')}`}`,
//   hoursClockNumberText: hours => `${hours} hours`,
//   minutesClockNumberText: minutes => `${minutes} minutes`,
//   secondsClockNumberText: seconds => `${seconds} seconds`,
//   // Open picker labels
//   openDatePickerDialogue: (rawValue, utils) => rawValue && utils.isValid(utils.date(rawValue)) ? `Choose date, selected date is ${utils.format(utils.date(rawValue), 'fullDate')}` : 'Choose date',
//   openTimePickerDialogue: (rawValue, utils) => rawValue && utils.isValid(utils.date(rawValue)) ? `Choose time, selected time is ${utils.format(utils.date(rawValue), 'fullTime')}` : 'Choose time',
//   // Table labels
//   timeTableLabel: 'pick time',
//   dateTableLabel: 'pick date'
// };
// const DEFAULT_LOCALE = enUSPickers;
// getPickersLocalization(enUSPickers);

// const MuiPickersAdapterContext = /*#__PURE__*/React.createContext(null);

// if (process.env.NODE_ENV !== 'production') {
//   MuiPickersAdapterContext.displayName = 'MuiPickersAdapterContext';
// }

// let warnedOnce = false;
// /**
//  * @ignore - do not document.
//  */

// function LocalizationProvider(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiLocalizationProvider'
//   });
//   const {
//     children,
//     dateAdapter: Utils,
//     dateFormats,
//     dateLibInstance,
//     locale,
//     adapterLocale,
//     localeText
//   } = props;

//   if (process.env.NODE_ENV !== 'production') {
//     if (!warnedOnce && locale !== undefined) {
//       warnedOnce = true;
//       console.warn("LocalizationProvider's prop `locale` is deprecated and replaced by `adapterLocale`");
//     }
//   }

//   const utils = React.useMemo(() => new Utils({
//     locale: adapterLocale != null ? adapterLocale : locale,
//     formats: dateFormats,
//     instance: dateLibInstance
//   }), [Utils, locale, adapterLocale, dateFormats, dateLibInstance]);
//   const defaultDates = React.useMemo(() => {
//     return {
//       minDate: utils.date('1900-01-01T00:00:00.000'),
//       maxDate: utils.date('2099-12-31T00:00:00.000')
//     };
//   }, [utils]);
//   const contextValue = React.useMemo(() => {
//     return {
//       utils,
//       defaultDates,
//       localeText: _extends$u({}, DEFAULT_LOCALE, localeText != null ? localeText : {})
//     };
//   }, [defaultDates, utils, localeText]);
//   return /*#__PURE__*/jsx(MuiPickersAdapterContext.Provider, {
//     value: contextValue,
//     children: children
//   });
// }
// process.env.NODE_ENV !== "production" ? LocalizationProvider.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------

//   /**
//    * Locale for the date library you are using
//    */
//   adapterLocale: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.string]),
//   children: PropTypes__default.node,

//   /**
//    * DateIO adapter class function
//    */
//   dateAdapter: PropTypes__default.func.isRequired,

//   /**
//    * Formats that are used for any child pickers
//    */
//   dateFormats: PropTypes__default.shape({
//     dayOfMonth: PropTypes__default.string,
//     fullDate: PropTypes__default.string,
//     fullDateTime: PropTypes__default.string,
//     fullDateTime12h: PropTypes__default.string,
//     fullDateTime24h: PropTypes__default.string,
//     fullDateWithWeekday: PropTypes__default.string,
//     fullTime: PropTypes__default.string,
//     fullTime12h: PropTypes__default.string,
//     fullTime24h: PropTypes__default.string,
//     hours12h: PropTypes__default.string,
//     hours24h: PropTypes__default.string,
//     keyboardDate: PropTypes__default.string,
//     keyboardDateTime: PropTypes__default.string,
//     keyboardDateTime12h: PropTypes__default.string,
//     keyboardDateTime24h: PropTypes__default.string,
//     minutes: PropTypes__default.string,
//     month: PropTypes__default.string,
//     monthAndDate: PropTypes__default.string,
//     monthAndYear: PropTypes__default.string,
//     monthShort: PropTypes__default.string,
//     normalDate: PropTypes__default.string,
//     normalDateWithWeekday: PropTypes__default.string,
//     seconds: PropTypes__default.string,
//     shortDate: PropTypes__default.string,
//     weekday: PropTypes__default.string,
//     weekdayShort: PropTypes__default.string,
//     year: PropTypes__default.string
//   }),

//   /**
//    * Date library instance you are using, if it has some global overrides
//    * ```jsx
//    * dateLibInstance={momentTimeZone}
//    * ```
//    */
//   dateLibInstance: PropTypes__default.any,

//   /**
//    * Locale for the date library you are using
//    * @deprecated Use `adapterLocale` instead
//    */
//   locale: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.string]),

//   /**
//    * Locale for components texts
//    */
//   localeText: PropTypes__default.object
// } : void 0;

// function _objectWithoutPropertiesLoose$k(source, excluded) {
//   if (source == null) return {};
//   var target = {};
//   var sourceKeys = Object.keys(source);
//   var key, i;
//   for (i = 0; i < sourceKeys.length; i++) {
//     key = sourceKeys[i];
//     if (excluded.indexOf(key) >= 0) continue;
//     target[key] = source[key];
//   }
//   return target;
// }

// function r$1(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r$1(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx$1(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r$1(e))&&(n&&(n+=" "),n+=t);return n}

// /**
//  * WARNING: Don't import this directly.
//  * Use `MuiError` from `@mui-internal/babel-macros/MuiError.macro` instead.
//  * @param {number} code
//  */
// function formatMuiErrorMessage(code) {
//   // Apply babel-plugin-transform-template-literals in loose mode
//   // loose mode is safe if we're concatenating primitives
//   // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose
//   /* eslint-disable prefer-template */
//   let url = 'https://mui.com/production-error/?code=' + code;
//   for (let i = 1; i < arguments.length; i += 1) {
//     // rest params over-transpile for this case
//     // eslint-disable-next-line prefer-rest-params
//     url += '&args[]=' + encodeURIComponent(arguments[i]);
//   }
//   return 'Minified MUI error #' + code + '; visit ' + url + ' for the full message.';
//   /* eslint-enable prefer-template */
// }

// function isPlainObject(item) {
//   return item !== null && typeof item === 'object' && item.constructor === Object;
// }
// function deepClone(source) {
//   if (!isPlainObject(source)) {
//     return source;
//   }
//   const output = {};
//   Object.keys(source).forEach(key => {
//     output[key] = deepClone(source[key]);
//   });
//   return output;
// }
// function deepmerge(target, source, options = {
//   clone: true
// }) {
//   const output = options.clone ? _extends$u({}, target) : target;
//   if (isPlainObject(target) && isPlainObject(source)) {
//     Object.keys(source).forEach(key => {
//       // Avoid prototype pollution
//       if (key === '__proto__') {
//         return;
//       }
//       if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
//         // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
//         output[key] = deepmerge(target[key], source[key], options);
//       } else if (options.clone) {
//         output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
//       } else {
//         output[key] = source[key];
//       }
//     });
//   }
//   return output;
// }

// // It should to be noted that this function isn't equivalent to `text-transform: capitalize`.
// //
// // A strict capitalization should uppercase the first letter of each word in the sentence.
// // We only handle the first word.
// function capitalize(string) {
//   if (typeof string !== 'string') {
//     throw new Error(process.env.NODE_ENV !== "production" ? `MUI: \`capitalize(string)\` expects a string argument.` : formatMuiErrorMessage(7));
//   }
//   return string.charAt(0).toUpperCase() + string.slice(1);
// }

// function ownerDocument(node) {
//   return node && node.ownerDocument || document;
// }

// /**
//  * TODO v5: consider making it private
//  *
//  * passes {value} to {ref}
//  *
//  * WARNING: Be sure to only call this inside a callback that is passed as a ref.
//  * Otherwise, make sure to cleanup the previous {ref} if it changes. See
//  * https://github.com/mui/material-ui/issues/13539
//  *
//  * Useful if you want to expose the ref of an inner component to the public API
//  * while still using it inside the component.
//  * @param ref A ref callback or ref object. If anything falsy, this is a no-op.
//  */
// function setRef(ref, value) {
//   if (typeof ref === 'function') {
//     ref(value);
//   } else if (ref) {
//     ref.current = value;
//   }
// }

// /**
//  * A version of `React.useLayoutEffect` that does not show a warning when server-side rendering.
//  * This is useful for effects that are only needed for client-side rendering but not for SSR.
//  *
//  * Before you use this hook, make sure to read https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
//  * and confirm it doesn't apply to your use-case.
//  */
// const useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

// function useControlled({
//   controlled,
//   default: defaultProp,
//   name,
//   state = 'value'
// }) {
//   // isControlled is ignored in the hook dependency lists as it should never change.
//   const {
//     current: isControlled
//   } = React.useRef(controlled !== undefined);
//   const [valueState, setValue] = React.useState(defaultProp);
//   const value = isControlled ? controlled : valueState;
//   if (process.env.NODE_ENV !== 'production') {
//     React.useEffect(() => {
//       if (isControlled !== (controlled !== undefined)) {
//         console.error([`MUI: A component is changing the ${isControlled ? '' : 'un'}controlled ${state} state of ${name} to be ${isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${name} ` + 'element for the lifetime of the component.', "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
//       }
//     }, [state, name, controlled]);
//     const {
//       current: defaultValue
//     } = React.useRef(defaultProp);
//     React.useEffect(() => {
//       if (!isControlled && defaultValue !== defaultProp) {
//         console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`].join('\n'));
//       }
//     }, [JSON.stringify(defaultProp)]);
//   }
//   const setValueIfUncontrolled = React.useCallback(newValue => {
//     if (!isControlled) {
//       setValue(newValue);
//     }
//   }, []);
//   return [value, setValueIfUncontrolled];
// }

// /**
//  * Inspired by https://github.com/facebook/react/issues/14099#issuecomment-440013892
//  * See RFC in https://github.com/reactjs/rfcs/pull/220
//  */

// function useEventCallback(fn) {
//   const ref = React.useRef(fn);
//   useEnhancedEffect(() => {
//     ref.current = fn;
//   });
//   return React.useRef((...args) =>
//   // @ts-expect-error hide `this`
//   (0, ref.current)(...args)).current;
// }

// function useForkRef(...refs) {
//   /**
//    * This will create a new function if the refs passed to this hook change and are all defined.
//    * This means react will call the old forkRef with `null` and the new forkRef
//    * with the ref. Cleanup naturally emerges from this behavior.
//    */
//   return React.useMemo(() => {
//     if (refs.every(ref => ref == null)) {
//       return null;
//     }
//     return instance => {
//       refs.forEach(ref => {
//         setRef(ref, instance);
//       });
//     };
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, refs);
// }

// function composeClasses(slots, getUtilityClass, classes = undefined) {
//   const output = {};
//   Object.keys(slots).forEach(
//   // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
//   // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
//   slot => {
//     output[slot] = slots[slot].reduce((acc, key) => {
//       if (key) {
//         const utilityClass = getUtilityClass(key);
//         if (utilityClass !== '') {
//           acc.push(utilityClass);
//         }
//         if (classes && classes[key]) {
//           acc.push(classes[key]);
//         }
//       }
//       return acc;
//     }, []).join(' ');
//   });
//   return output;
// }

// const defaultGenerator = componentName => componentName;
// const createClassNameGenerator = () => {
//   let generate = defaultGenerator;
//   return {
//     configure(generator) {
//       generate = generator;
//     },
//     generate(componentName) {
//       return generate(componentName);
//     },
//     reset() {
//       generate = defaultGenerator;
//     }
//   };
// };
// const ClassNameGenerator = createClassNameGenerator();

// // If GlobalStateSlot is changed, GLOBAL_STATE_CLASSES in
// // \packages\api-docs-builder\utils\parseSlotsAndClasses.ts must be updated accordingly.

// const globalStateClassesMapping = {
//   active: 'active',
//   checked: 'checked',
//   completed: 'completed',
//   disabled: 'disabled',
//   error: 'error',
//   expanded: 'expanded',
//   focused: 'focused',
//   focusVisible: 'focusVisible',
//   open: 'open',
//   readOnly: 'readOnly',
//   required: 'required',
//   selected: 'selected'
// };
// function generateUtilityClass(componentName, slot, globalStatePrefix = 'Mui') {
//   const globalStateClass = globalStateClassesMapping[slot];
//   return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
// }

// function generateUtilityClasses(componentName, slots, globalStatePrefix = 'Mui') {
//   const result = {};
//   slots.forEach(slot => {
//     result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
//   });
//   return result;
// }

// const _excluded$T = ["values", "unit", "step"];
// const sortBreakpointsValues = values => {
//   const breakpointsAsArray = Object.keys(values).map(key => ({
//     key,
//     val: values[key]
//   })) || [];
//   // Sort in ascending order
//   breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
//   return breakpointsAsArray.reduce((acc, obj) => {
//     return _extends$u({}, acc, {
//       [obj.key]: obj.val
//     });
//   }, {});
// };

// // Keep in mind that @media is inclusive by the CSS specification.
// function createBreakpoints(breakpoints) {
//   const {
//       // The breakpoint **start** at this value.
//       // For instance with the first breakpoint xs: [xs, sm).
//       values = {
//         xs: 0,
//         // phone
//         sm: 600,
//         // tablet
//         md: 900,
//         // small laptop
//         lg: 1200,
//         // desktop
//         xl: 1536 // large screen
//       },
//       unit = 'px',
//       step = 5
//     } = breakpoints,
//     other = _objectWithoutPropertiesLoose$k(breakpoints, _excluded$T);
//   const sortedValues = sortBreakpointsValues(values);
//   const keys = Object.keys(sortedValues);
//   function up(key) {
//     const value = typeof values[key] === 'number' ? values[key] : key;
//     return `@media (min-width:${value}${unit})`;
//   }
//   function down(key) {
//     const value = typeof values[key] === 'number' ? values[key] : key;
//     return `@media (max-width:${value - step / 100}${unit})`;
//   }
//   function between(start, end) {
//     const endIndex = keys.indexOf(end);
//     return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
//   }
//   function only(key) {
//     if (keys.indexOf(key) + 1 < keys.length) {
//       return between(key, keys[keys.indexOf(key) + 1]);
//     }
//     return up(key);
//   }
//   function not(key) {
//     // handle first and last key separately, for better readability
//     const keyIndex = keys.indexOf(key);
//     if (keyIndex === 0) {
//       return up(keys[1]);
//     }
//     if (keyIndex === keys.length - 1) {
//       return down(keys[keyIndex]);
//     }
//     return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
//   }
//   return _extends$u({
//     keys,
//     values: sortedValues,
//     up,
//     down,
//     between,
//     only,
//     not,
//     unit
//   }, other);
// }

// const shape = {
//   borderRadius: 4
// };

// const responsivePropType = process.env.NODE_ENV !== 'production' ? PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string, PropTypes__default.object, PropTypes__default.array]) : {};

// function merge(acc, item) {
//   if (!item) {
//     return acc;
//   }
//   return deepmerge(acc, item, {
//     clone: false // No need to clone deep, it's way faster.
//   });
// }

// // The breakpoint **start** at this value.
// // For instance with the first breakpoint xs: [xs, sm[.
// const values$1 = {
//   xs: 0,
//   // phone
//   sm: 600,
//   // tablet
//   md: 900,
//   // small laptop
//   lg: 1200,
//   // desktop
//   xl: 1536 // large screen
// };
// const defaultBreakpoints = {
//   // Sorted ASC by size. That's important.
//   // It can't be configured as it's used statically for propTypes.
//   keys: ['xs', 'sm', 'md', 'lg', 'xl'],
//   up: key => `@media (min-width:${values$1[key]}px)`
// };
// function handleBreakpoints(props, propValue, styleFromPropValue) {
//   const theme = props.theme || {};
//   if (Array.isArray(propValue)) {
//     const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
//     return propValue.reduce((acc, item, index) => {
//       acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
//       return acc;
//     }, {});
//   }
//   if (typeof propValue === 'object') {
//     const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
//     return Object.keys(propValue).reduce((acc, breakpoint) => {
//       // key is breakpoint
//       if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
//         const mediaKey = themeBreakpoints.up(breakpoint);
//         acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
//       } else {
//         const cssKey = breakpoint;
//         acc[cssKey] = propValue[cssKey];
//       }
//       return acc;
//     }, {});
//   }
//   const output = styleFromPropValue(propValue);
//   return output;
// }
// function createEmptyBreakpointObject(breakpointsInput = {}) {
//   var _breakpointsInput$key;
//   const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
//     const breakpointStyleKey = breakpointsInput.up(key);
//     acc[breakpointStyleKey] = {};
//     return acc;
//   }, {});
//   return breakpointsInOrder || {};
// }
// function removeUnusedBreakpoints(breakpointKeys, style) {
//   return breakpointKeys.reduce((acc, key) => {
//     const breakpointOutput = acc[key];
//     const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
//     if (isBreakpointUnused) {
//       delete acc[key];
//     }
//     return acc;
//   }, style);
// }

// function getPath$2(obj, path, checkVars = true) {
//   if (!path || typeof path !== 'string') {
//     return null;
//   }

//   // Check if CSS variables are used
//   if (obj && obj.vars && checkVars) {
//     const val = `vars.${path}`.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
//     if (val != null) {
//       return val;
//     }
//   }
//   return path.split('.').reduce((acc, item) => {
//     if (acc && acc[item] != null) {
//       return acc[item];
//     }
//     return null;
//   }, obj);
// }
// function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
//   let value;
//   if (typeof themeMapping === 'function') {
//     value = themeMapping(propValueFinal);
//   } else if (Array.isArray(themeMapping)) {
//     value = themeMapping[propValueFinal] || userValue;
//   } else {
//     value = getPath$2(themeMapping, propValueFinal) || userValue;
//   }
//   if (transform) {
//     value = transform(value, userValue, themeMapping);
//   }
//   return value;
// }
// function style$1(options) {
//   const {
//     prop,
//     cssProperty = options.prop,
//     themeKey,
//     transform
//   } = options;

//   // false positive
//   // eslint-disable-next-line react/function-component-definition
//   const fn = props => {
//     if (props[prop] == null) {
//       return null;
//     }
//     const propValue = props[prop];
//     const theme = props.theme;
//     const themeMapping = getPath$2(theme, themeKey) || {};
//     const styleFromPropValue = propValueFinal => {
//       let value = getStyleValue(themeMapping, transform, propValueFinal);
//       if (propValueFinal === value && typeof propValueFinal === 'string') {
//         // Haven't found value
//         value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
//       }
//       if (cssProperty === false) {
//         return value;
//       }
//       return {
//         [cssProperty]: value
//       };
//     };
//     return handleBreakpoints(props, propValue, styleFromPropValue);
//   };
//   fn.propTypes = process.env.NODE_ENV !== 'production' ? {
//     [prop]: responsivePropType
//   } : {};
//   fn.filterProps = [prop];
//   return fn;
// }

// function memoize$1(fn) {
//   const cache = {};
//   return arg => {
//     if (cache[arg] === undefined) {
//       cache[arg] = fn(arg);
//     }
//     return cache[arg];
//   };
// }

// const properties = {
//   m: 'margin',
//   p: 'padding'
// };
// const directions = {
//   t: 'Top',
//   r: 'Right',
//   b: 'Bottom',
//   l: 'Left',
//   x: ['Left', 'Right'],
//   y: ['Top', 'Bottom']
// };
// const aliases = {
//   marginX: 'mx',
//   marginY: 'my',
//   paddingX: 'px',
//   paddingY: 'py'
// };

// // memoize() impact:
// // From 300,000 ops/sec
// // To 350,000 ops/sec
// const getCssProperties = memoize$1(prop => {
//   // It's not a shorthand notation.
//   if (prop.length > 2) {
//     if (aliases[prop]) {
//       prop = aliases[prop];
//     } else {
//       return [prop];
//     }
//   }
//   const [a, b] = prop.split('');
//   const property = properties[a];
//   const direction = directions[b] || '';
//   return Array.isArray(direction) ? direction.map(dir => property + dir) : [property + direction];
// });
// const marginKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'];
// const paddingKeys = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd'];
// const spacingKeys = [...marginKeys, ...paddingKeys];
// function createUnaryUnit(theme, themeKey, defaultValue, propName) {
//   var _getPath;
//   const themeSpacing = (_getPath = getPath$2(theme, themeKey, false)) != null ? _getPath : defaultValue;
//   if (typeof themeSpacing === 'number') {
//     return abs => {
//       if (typeof abs === 'string') {
//         return abs;
//       }
//       if (process.env.NODE_ENV !== 'production') {
//         if (typeof abs !== 'number') {
//           console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${abs}.`);
//         }
//       }
//       return themeSpacing * abs;
//     };
//   }
//   if (Array.isArray(themeSpacing)) {
//     return abs => {
//       if (typeof abs === 'string') {
//         return abs;
//       }
//       if (process.env.NODE_ENV !== 'production') {
//         if (!Number.isInteger(abs)) {
//           console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.` + `You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join('\n'));
//         } else if (abs > themeSpacing.length - 1) {
//           console.error([`MUI: The value provided (${abs}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`].join('\n'));
//         }
//       }
//       return themeSpacing[abs];
//     };
//   }
//   if (typeof themeSpacing === 'function') {
//     return themeSpacing;
//   }
//   if (process.env.NODE_ENV !== 'production') {
//     console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, 'It should be a number, an array or a function.'].join('\n'));
//   }
//   return () => undefined;
// }
// function createUnarySpacing(theme) {
//   return createUnaryUnit(theme, 'spacing', 8, 'spacing');
// }
// function getValue(transformer, propValue) {
//   if (typeof propValue === 'string' || propValue == null) {
//     return propValue;
//   }
//   const abs = Math.abs(propValue);
//   const transformed = transformer(abs);
//   if (propValue >= 0) {
//     return transformed;
//   }
//   if (typeof transformed === 'number') {
//     return -transformed;
//   }
//   return `-${transformed}`;
// }
// function getStyleFromPropValue(cssProperties, transformer) {
//   return propValue => cssProperties.reduce((acc, cssProperty) => {
//     acc[cssProperty] = getValue(transformer, propValue);
//     return acc;
//   }, {});
// }
// function resolveCssProperty(props, keys, prop, transformer) {
//   // Using a hash computation over an array iteration could be faster, but with only 28 items,
//   // it's doesn't worth the bundle size.
//   if (keys.indexOf(prop) === -1) {
//     return null;
//   }
//   const cssProperties = getCssProperties(prop);
//   const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
//   const propValue = props[prop];
//   return handleBreakpoints(props, propValue, styleFromPropValue);
// }
// function style(props, keys) {
//   const transformer = createUnarySpacing(props.theme);
//   return Object.keys(props).map(prop => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
// }
// function margin(props) {
//   return style(props, marginKeys);
// }
// margin.propTypes = process.env.NODE_ENV !== 'production' ? marginKeys.reduce((obj, key) => {
//   obj[key] = responsivePropType;
//   return obj;
// }, {}) : {};
// margin.filterProps = marginKeys;
// function padding(props) {
//   return style(props, paddingKeys);
// }
// padding.propTypes = process.env.NODE_ENV !== 'production' ? paddingKeys.reduce((obj, key) => {
//   obj[key] = responsivePropType;
//   return obj;
// }, {}) : {};
// padding.filterProps = paddingKeys;
// process.env.NODE_ENV !== 'production' ? spacingKeys.reduce((obj, key) => {
//   obj[key] = responsivePropType;
//   return obj;
// }, {}) : {};

// // The different signatures imply different meaning for their arguments that can't be expressed structurally.
// // We express the difference with variable names.

// function createSpacing(spacingInput = 8) {
//   // Already transformed.
//   if (spacingInput.mui) {
//     return spacingInput;
//   }

//   // Material Design layouts are visually balanced. Most measurements align to an 8dp grid, which aligns both spacing and the overall layout.
//   // Smaller components, such as icons, can align to a 4dp grid.
//   // https://m2.material.io/design/layout/understanding-layout.html
//   const transform = createUnarySpacing({
//     spacing: spacingInput
//   });
//   const spacing = (...argsInput) => {
//     if (process.env.NODE_ENV !== 'production') {
//       if (!(argsInput.length <= 4)) {
//         console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
//       }
//     }
//     const args = argsInput.length === 0 ? [1] : argsInput;
//     return args.map(argument => {
//       const output = transform(argument);
//       return typeof output === 'number' ? `${output}px` : output;
//     }).join(' ');
//   };
//   spacing.mui = true;
//   return spacing;
// }

// function compose$1(...styles) {
//   const handlers = styles.reduce((acc, style) => {
//     style.filterProps.forEach(prop => {
//       acc[prop] = style;
//     });
//     return acc;
//   }, {});

//   // false positive
//   // eslint-disable-next-line react/function-component-definition
//   const fn = props => {
//     return Object.keys(props).reduce((acc, prop) => {
//       if (handlers[prop]) {
//         return merge(acc, handlers[prop](props));
//       }
//       return acc;
//     }, {});
//   };
//   fn.propTypes = process.env.NODE_ENV !== 'production' ? styles.reduce((acc, style) => Object.assign(acc, style.propTypes), {}) : {};
//   fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
//   return fn;
// }

// function borderTransform(value) {
//   if (typeof value !== 'number') {
//     return value;
//   }
//   return `${value}px solid`;
// }
// function createBorderStyle(prop, transform) {
//   return style$1({
//     prop,
//     themeKey: 'borders',
//     transform
//   });
// }
// const border = createBorderStyle('border', borderTransform);
// const borderTop = createBorderStyle('borderTop', borderTransform);
// const borderRight = createBorderStyle('borderRight', borderTransform);
// const borderBottom = createBorderStyle('borderBottom', borderTransform);
// const borderLeft = createBorderStyle('borderLeft', borderTransform);
// const borderColor = createBorderStyle('borderColor');
// const borderTopColor = createBorderStyle('borderTopColor');
// const borderRightColor = createBorderStyle('borderRightColor');
// const borderBottomColor = createBorderStyle('borderBottomColor');
// const borderLeftColor = createBorderStyle('borderLeftColor');
// const outline = createBorderStyle('outline', borderTransform);
// const outlineColor = createBorderStyle('outlineColor');

// // false positive
// // eslint-disable-next-line react/function-component-definition
// const borderRadius = props => {
//   if (props.borderRadius !== undefined && props.borderRadius !== null) {
//     const transformer = createUnaryUnit(props.theme, 'shape.borderRadius', 4, 'borderRadius');
//     const styleFromPropValue = propValue => ({
//       borderRadius: getValue(transformer, propValue)
//     });
//     return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
//   }
//   return null;
// };
// borderRadius.propTypes = process.env.NODE_ENV !== 'production' ? {
//   borderRadius: responsivePropType
// } : {};
// borderRadius.filterProps = ['borderRadius'];
// compose$1(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);

// // false positive
// // eslint-disable-next-line react/function-component-definition
// const gap = props => {
//   if (props.gap !== undefined && props.gap !== null) {
//     const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'gap');
//     const styleFromPropValue = propValue => ({
//       gap: getValue(transformer, propValue)
//     });
//     return handleBreakpoints(props, props.gap, styleFromPropValue);
//   }
//   return null;
// };
// gap.propTypes = process.env.NODE_ENV !== 'production' ? {
//   gap: responsivePropType
// } : {};
// gap.filterProps = ['gap'];

// // false positive
// // eslint-disable-next-line react/function-component-definition
// const columnGap = props => {
//   if (props.columnGap !== undefined && props.columnGap !== null) {
//     const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'columnGap');
//     const styleFromPropValue = propValue => ({
//       columnGap: getValue(transformer, propValue)
//     });
//     return handleBreakpoints(props, props.columnGap, styleFromPropValue);
//   }
//   return null;
// };
// columnGap.propTypes = process.env.NODE_ENV !== 'production' ? {
//   columnGap: responsivePropType
// } : {};
// columnGap.filterProps = ['columnGap'];

// // false positive
// // eslint-disable-next-line react/function-component-definition
// const rowGap = props => {
//   if (props.rowGap !== undefined && props.rowGap !== null) {
//     const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'rowGap');
//     const styleFromPropValue = propValue => ({
//       rowGap: getValue(transformer, propValue)
//     });
//     return handleBreakpoints(props, props.rowGap, styleFromPropValue);
//   }
//   return null;
// };
// rowGap.propTypes = process.env.NODE_ENV !== 'production' ? {
//   rowGap: responsivePropType
// } : {};
// rowGap.filterProps = ['rowGap'];
// const gridColumn = style$1({
//   prop: 'gridColumn'
// });
// const gridRow = style$1({
//   prop: 'gridRow'
// });
// const gridAutoFlow = style$1({
//   prop: 'gridAutoFlow'
// });
// const gridAutoColumns = style$1({
//   prop: 'gridAutoColumns'
// });
// const gridAutoRows = style$1({
//   prop: 'gridAutoRows'
// });
// const gridTemplateColumns = style$1({
//   prop: 'gridTemplateColumns'
// });
// const gridTemplateRows = style$1({
//   prop: 'gridTemplateRows'
// });
// const gridTemplateAreas = style$1({
//   prop: 'gridTemplateAreas'
// });
// const gridArea = style$1({
//   prop: 'gridArea'
// });
// compose$1(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

// function paletteTransform(value, userValue) {
//   if (userValue === 'grey') {
//     return userValue;
//   }
//   return value;
// }
// const color = style$1({
//   prop: 'color',
//   themeKey: 'palette',
//   transform: paletteTransform
// });
// const bgcolor = style$1({
//   prop: 'bgcolor',
//   cssProperty: 'backgroundColor',
//   themeKey: 'palette',
//   transform: paletteTransform
// });
// const backgroundColor = style$1({
//   prop: 'backgroundColor',
//   themeKey: 'palette',
//   transform: paletteTransform
// });
// compose$1(color, bgcolor, backgroundColor);

// function sizingTransform(value) {
//   return value <= 1 && value !== 0 ? `${value * 100}%` : value;
// }
// const width = style$1({
//   prop: 'width',
//   transform: sizingTransform
// });
// const maxWidth = props => {
//   if (props.maxWidth !== undefined && props.maxWidth !== null) {
//     const styleFromPropValue = propValue => {
//       var _props$theme, _props$theme2;
//       const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
//       if (!breakpoint) {
//         return {
//           maxWidth: sizingTransform(propValue)
//         };
//       }
//       if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== 'px') {
//         return {
//           maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
//         };
//       }
//       return {
//         maxWidth: breakpoint
//       };
//     };
//     return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
//   }
//   return null;
// };
// maxWidth.filterProps = ['maxWidth'];
// const minWidth = style$1({
//   prop: 'minWidth',
//   transform: sizingTransform
// });
// const height$1 = style$1({
//   prop: 'height',
//   transform: sizingTransform
// });
// const maxHeight = style$1({
//   prop: 'maxHeight',
//   transform: sizingTransform
// });
// const minHeight = style$1({
//   prop: 'minHeight',
//   transform: sizingTransform
// });
// style$1({
//   prop: 'size',
//   cssProperty: 'width',
//   transform: sizingTransform
// });
// style$1({
//   prop: 'size',
//   cssProperty: 'height',
//   transform: sizingTransform
// });
// const boxSizing = style$1({
//   prop: 'boxSizing'
// });
// compose$1(width, maxWidth, minWidth, height$1, maxHeight, minHeight, boxSizing);

// const defaultSxConfig = {
//   // borders
//   border: {
//     themeKey: 'borders',
//     transform: borderTransform
//   },
//   borderTop: {
//     themeKey: 'borders',
//     transform: borderTransform
//   },
//   borderRight: {
//     themeKey: 'borders',
//     transform: borderTransform
//   },
//   borderBottom: {
//     themeKey: 'borders',
//     transform: borderTransform
//   },
//   borderLeft: {
//     themeKey: 'borders',
//     transform: borderTransform
//   },
//   borderColor: {
//     themeKey: 'palette'
//   },
//   borderTopColor: {
//     themeKey: 'palette'
//   },
//   borderRightColor: {
//     themeKey: 'palette'
//   },
//   borderBottomColor: {
//     themeKey: 'palette'
//   },
//   borderLeftColor: {
//     themeKey: 'palette'
//   },
//   outline: {
//     themeKey: 'borders',
//     transform: borderTransform
//   },
//   outlineColor: {
//     themeKey: 'palette'
//   },
//   borderRadius: {
//     themeKey: 'shape.borderRadius',
//     style: borderRadius
//   },
//   // palette
//   color: {
//     themeKey: 'palette',
//     transform: paletteTransform
//   },
//   bgcolor: {
//     themeKey: 'palette',
//     cssProperty: 'backgroundColor',
//     transform: paletteTransform
//   },
//   backgroundColor: {
//     themeKey: 'palette',
//     transform: paletteTransform
//   },
//   // spacing
//   p: {
//     style: padding
//   },
//   pt: {
//     style: padding
//   },
//   pr: {
//     style: padding
//   },
//   pb: {
//     style: padding
//   },
//   pl: {
//     style: padding
//   },
//   px: {
//     style: padding
//   },
//   py: {
//     style: padding
//   },
//   padding: {
//     style: padding
//   },
//   paddingTop: {
//     style: padding
//   },
//   paddingRight: {
//     style: padding
//   },
//   paddingBottom: {
//     style: padding
//   },
//   paddingLeft: {
//     style: padding
//   },
//   paddingX: {
//     style: padding
//   },
//   paddingY: {
//     style: padding
//   },
//   paddingInline: {
//     style: padding
//   },
//   paddingInlineStart: {
//     style: padding
//   },
//   paddingInlineEnd: {
//     style: padding
//   },
//   paddingBlock: {
//     style: padding
//   },
//   paddingBlockStart: {
//     style: padding
//   },
//   paddingBlockEnd: {
//     style: padding
//   },
//   m: {
//     style: margin
//   },
//   mt: {
//     style: margin
//   },
//   mr: {
//     style: margin
//   },
//   mb: {
//     style: margin
//   },
//   ml: {
//     style: margin
//   },
//   mx: {
//     style: margin
//   },
//   my: {
//     style: margin
//   },
//   margin: {
//     style: margin
//   },
//   marginTop: {
//     style: margin
//   },
//   marginRight: {
//     style: margin
//   },
//   marginBottom: {
//     style: margin
//   },
//   marginLeft: {
//     style: margin
//   },
//   marginX: {
//     style: margin
//   },
//   marginY: {
//     style: margin
//   },
//   marginInline: {
//     style: margin
//   },
//   marginInlineStart: {
//     style: margin
//   },
//   marginInlineEnd: {
//     style: margin
//   },
//   marginBlock: {
//     style: margin
//   },
//   marginBlockStart: {
//     style: margin
//   },
//   marginBlockEnd: {
//     style: margin
//   },
//   // display
//   displayPrint: {
//     cssProperty: false,
//     transform: value => ({
//       '@media print': {
//         display: value
//       }
//     })
//   },
//   display: {},
//   overflow: {},
//   textOverflow: {},
//   visibility: {},
//   whiteSpace: {},
//   // flexbox
//   flexBasis: {},
//   flexDirection: {},
//   flexWrap: {},
//   justifyContent: {},
//   alignItems: {},
//   alignContent: {},
//   order: {},
//   flex: {},
//   flexGrow: {},
//   flexShrink: {},
//   alignSelf: {},
//   justifyItems: {},
//   justifySelf: {},
//   // grid
//   gap: {
//     style: gap
//   },
//   rowGap: {
//     style: rowGap
//   },
//   columnGap: {
//     style: columnGap
//   },
//   gridColumn: {},
//   gridRow: {},
//   gridAutoFlow: {},
//   gridAutoColumns: {},
//   gridAutoRows: {},
//   gridTemplateColumns: {},
//   gridTemplateRows: {},
//   gridTemplateAreas: {},
//   gridArea: {},
//   // positions
//   position: {},
//   zIndex: {
//     themeKey: 'zIndex'
//   },
//   top: {},
//   right: {},
//   bottom: {},
//   left: {},
//   // shadows
//   boxShadow: {
//     themeKey: 'shadows'
//   },
//   // sizing
//   width: {
//     transform: sizingTransform
//   },
//   maxWidth: {
//     style: maxWidth
//   },
//   minWidth: {
//     transform: sizingTransform
//   },
//   height: {
//     transform: sizingTransform
//   },
//   maxHeight: {
//     transform: sizingTransform
//   },
//   minHeight: {
//     transform: sizingTransform
//   },
//   boxSizing: {},
//   // typography
//   fontFamily: {
//     themeKey: 'typography'
//   },
//   fontSize: {
//     themeKey: 'typography'
//   },
//   fontStyle: {
//     themeKey: 'typography'
//   },
//   fontWeight: {
//     themeKey: 'typography'
//   },
//   letterSpacing: {},
//   textTransform: {},
//   lineHeight: {},
//   textAlign: {},
//   typography: {
//     cssProperty: false,
//     themeKey: 'typography'
//   }
// };

// function objectsHaveSameKeys(...objects) {
//   const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
//   const union = new Set(allKeys);
//   return objects.every(object => union.size === Object.keys(object).length);
// }
// function callIfFn(maybeFn, arg) {
//   return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
// }

// // eslint-disable-next-line @typescript-eslint/naming-convention
// function unstable_createStyleFunctionSx() {
//   function getThemeValue(prop, val, theme, config) {
//     const props = {
//       [prop]: val,
//       theme
//     };
//     const options = config[prop];
//     if (!options) {
//       return {
//         [prop]: val
//       };
//     }
//     const {
//       cssProperty = prop,
//       themeKey,
//       transform,
//       style
//     } = options;
//     if (val == null) {
//       return null;
//     }

//     // TODO v6: remove, see https://github.com/mui/material-ui/pull/38123
//     if (themeKey === 'typography' && val === 'inherit') {
//       return {
//         [prop]: val
//       };
//     }
//     const themeMapping = getPath$2(theme, themeKey) || {};
//     if (style) {
//       return style(props);
//     }
//     const styleFromPropValue = propValueFinal => {
//       let value = getStyleValue(themeMapping, transform, propValueFinal);
//       if (propValueFinal === value && typeof propValueFinal === 'string') {
//         // Haven't found value
//         value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
//       }
//       if (cssProperty === false) {
//         return value;
//       }
//       return {
//         [cssProperty]: value
//       };
//     };
//     return handleBreakpoints(props, val, styleFromPropValue);
//   }
//   function styleFunctionSx(props) {
//     var _theme$unstable_sxCon;
//     const {
//       sx,
//       theme = {}
//     } = props || {};
//     if (!sx) {
//       return null; // Emotion & styled-components will neglect null
//     }
//     const config = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig;

//     /*
//      * Receive `sxInput` as object or callback
//      * and then recursively check keys & values to create media query object styles.
//      * (the result will be used in `styled`)
//      */
//     function traverse(sxInput) {
//       let sxObject = sxInput;
//       if (typeof sxInput === 'function') {
//         sxObject = sxInput(theme);
//       } else if (typeof sxInput !== 'object') {
//         // value
//         return sxInput;
//       }
//       if (!sxObject) {
//         return null;
//       }
//       const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
//       const breakpointsKeys = Object.keys(emptyBreakpoints);
//       let css = emptyBreakpoints;
//       Object.keys(sxObject).forEach(styleKey => {
//         const value = callIfFn(sxObject[styleKey], theme);
//         if (value !== null && value !== undefined) {
//           if (typeof value === 'object') {
//             if (config[styleKey]) {
//               css = merge(css, getThemeValue(styleKey, value, theme, config));
//             } else {
//               const breakpointsValues = handleBreakpoints({
//                 theme
//               }, value, x => ({
//                 [styleKey]: x
//               }));
//               if (objectsHaveSameKeys(breakpointsValues, value)) {
//                 css[styleKey] = styleFunctionSx({
//                   sx: value,
//                   theme
//                 });
//               } else {
//                 css = merge(css, breakpointsValues);
//               }
//             }
//           } else {
//             css = merge(css, getThemeValue(styleKey, value, theme, config));
//           }
//         }
//       });
//       return removeUnusedBreakpoints(breakpointsKeys, css);
//     }
//     return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
//   }
//   return styleFunctionSx;
// }
// const styleFunctionSx = unstable_createStyleFunctionSx();
// styleFunctionSx.filterProps = ['sx'];

// const _excluded$S = ["breakpoints", "palette", "spacing", "shape"];
// function createTheme(options = {}, ...args) {
//   const {
//       breakpoints: breakpointsInput = {},
//       palette: paletteInput = {},
//       spacing: spacingInput,
//       shape: shapeInput = {}
//     } = options,
//     other = _objectWithoutPropertiesLoose$k(options, _excluded$S);
//   const breakpoints = createBreakpoints(breakpointsInput);
//   const spacing = createSpacing(spacingInput);
//   let muiTheme = deepmerge({
//     breakpoints,
//     direction: 'ltr',
//     components: {},
//     // Inject component definitions.
//     palette: _extends$u({
//       mode: 'light'
//     }, paletteInput),
//     spacing,
//     shape: _extends$u({}, shape, shapeInput)
//   }, other);
//   muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
//   muiTheme.unstable_sxConfig = _extends$u({}, defaultSxConfig, other == null ? void 0 : other.unstable_sxConfig);
//   muiTheme.unstable_sx = function sx(props) {
//     return styleFunctionSx({
//       sx: props,
//       theme: this
//     });
//   };
//   return muiTheme;
// }

// function isObjectEmpty(obj) {
//   return Object.keys(obj).length === 0;
// }
// function useTheme$1(defaultTheme = null) {
//   const contextTheme = React.useContext(ThemeContext);
//   return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme : contextTheme;
// }

// const systemDefaultTheme = createTheme();
// function useTheme(defaultTheme = systemDefaultTheme) {
//   return useTheme$1(defaultTheme);
// }

// function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

// /* Use it instead of .includes method for IE support */
// function arrayIncludes(array, itemOrItems) {
//   if (Array.isArray(itemOrItems)) {
//     return itemOrItems.every(item => array.indexOf(item) !== -1);
//   }

//   return array.indexOf(itemOrItems) !== -1;
// }
// const onSpaceOrEnter = (innerFn, onFocus) => event => {
//   if (event.key === 'Enter' || event.key === ' ') {
//     innerFn(event); // prevent any side effects

//     event.preventDefault();
//     event.stopPropagation();
//   }

//   if (onFocus) {
//     onFocus(event);
//   }
// };

// const getActiveElement = (root = document) => {
//   const activeEl = root.activeElement;

//   if (!activeEl) {
//     return null;
//   }

//   if (activeEl.shadowRoot) {
//     return getActiveElement(activeEl.shadowRoot);
//   }

//   return activeEl;
// };

// function getPickersMonthUtilityClass(slot) {
//   // TODO v6 Rename 'PrivatePickersMonth' to 'MuiPickersMonth' to follow convention
//   return generateUtilityClass$1('PrivatePickersMonth', slot);
// }
// const pickersMonthClasses = generateUtilityClasses$1( // TODO v6 Rename 'PrivatePickersMonth' to 'MuiPickersMonth' to follow convention
// 'PrivatePickersMonth', ['root', 'selected']);

// const _excluded$R = ["disabled", "onSelect", "selected", "value", "tabIndex", "hasFocus", "onFocus", "onBlur"];

// const useUtilityClasses$o = ownerState => {
//   const {
//     classes,
//     selected
//   } = ownerState;
//   const slots = {
//     root: ['root', selected && 'selected']
//   };
//   return unstable_composeClasses(slots, getPickersMonthUtilityClass, classes);
// };

// const PickersMonthRoot = styled$1(Typography, {
//   name: 'PrivatePickersMonth',
//   slot: 'Root',
//   overridesResolver: (_, styles) => [styles.root, {
//     [`&.${pickersMonthClasses.selected}`]: styles.selected
//   }]
// })(({
//   theme
// }) => _extends$u({
//   flex: '1 0 33.33%',
//   display: 'flex',
//   alignItems: 'center',
//   justifyContent: 'center',
//   color: 'unset',
//   backgroundColor: 'transparent',
//   border: 0,
//   outline: 0
// }, theme.typography.subtitle1, {
//   margin: '8px 0',
//   height: 36,
//   borderRadius: 18,
//   cursor: 'pointer',
//   '&:focus, &:hover': {
//     backgroundColor: alpha$1(theme.palette.action.active, theme.palette.action.hoverOpacity)
//   },
//   '&:disabled': {
//     pointerEvents: 'none',
//     color: theme.palette.text.secondary
//   },
//   [`&.${pickersMonthClasses.selected}`]: {
//     color: theme.palette.primary.contrastText,
//     backgroundColor: theme.palette.primary.main,
//     '&:focus, &:hover': {
//       backgroundColor: theme.palette.primary.dark
//     }
//   }
// }));

// const noop$6 = () => {};
// /**
//  * @ignore - do not document.
//  */


// const PickersMonth = props => {
//   // TODO v6 add 'useThemeProps' once the component class names are aligned
//   const {
//     disabled,
//     onSelect,
//     selected,
//     value,
//     tabIndex,
//     hasFocus,
//     onFocus = noop$6,
//     onBlur = noop$6
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$R);

//   const classes = useUtilityClasses$o(props);

//   const handleSelection = () => {
//     onSelect(value);
//   };

//   const ref = React.useRef(null);
//   unstable_useEnhancedEffect(() => {
//     if (hasFocus) {
//       var _ref$current;

//       (_ref$current = ref.current) == null ? void 0 : _ref$current.focus();
//     }
//   }, [hasFocus]);
//   return /*#__PURE__*/jsx(PickersMonthRoot, _extends$u({
//     ref: ref,
//     component: "button",
//     type: "button",
//     className: classes.root,
//     tabIndex: tabIndex,
//     onClick: handleSelection,
//     onKeyDown: onSpaceOrEnter(handleSelection),
//     color: selected ? 'primary' : undefined,
//     variant: selected ? 'h5' : 'subtitle1',
//     disabled: disabled,
//     onFocus: event => onFocus(event, value),
//     onBlur: event => onBlur(event, value)
//   }, other));
// };

// const useLocalizationContext = () => {
//   const localization = React.useContext(MuiPickersAdapterContext);

//   if (localization === null) {
//     throw new Error('MUI: Can not find utils in context. It looks like you forgot to wrap your component in LocalizationProvider, or pass dateAdapter prop directly.');
//   }

//   return localization;
// };
// const useUtils = () => useLocalizationContext().utils;
// const useDefaultDates = () => useLocalizationContext().defaultDates;
// const useLocaleText = () => useLocalizationContext().localeText;
// const useNow = () => {
//   const utils = useUtils();
//   const now = React.useRef(utils.date());
//   return now.current;
// };

// function getMonthPickerUtilityClass(slot) {
//   return generateUtilityClass$1('MuiMonthPicker', slot);
// }
// generateUtilityClasses$1('MuiMonthPicker', ['root']);

// const findClosestEnabledDate = ({
//   date,
//   disableFuture,
//   disablePast,
//   maxDate,
//   minDate,
//   isDateDisabled,
//   utils
// }) => {
//   const today = utils.startOfDay(utils.date());

//   if (disablePast && utils.isBefore(minDate, today)) {
//     minDate = today;
//   }

//   if (disableFuture && utils.isAfter(maxDate, today)) {
//     maxDate = today;
//   }

//   let forward = date;
//   let backward = date;

//   if (utils.isBefore(date, minDate)) {
//     forward = utils.date(minDate);
//     backward = null;
//   }

//   if (utils.isAfter(date, maxDate)) {
//     if (backward) {
//       backward = utils.date(maxDate);
//     }

//     forward = null;
//   }

//   while (forward || backward) {
//     if (forward && utils.isAfter(forward, maxDate)) {
//       forward = null;
//     }

//     if (backward && utils.isBefore(backward, minDate)) {
//       backward = null;
//     }

//     if (forward) {
//       if (!isDateDisabled(forward)) {
//         return forward;
//       }

//       forward = utils.addDays(forward, 1);
//     }

//     if (backward) {
//       if (!isDateDisabled(backward)) {
//         return backward;
//       }

//       backward = utils.addDays(backward, -1);
//     }
//   }

//   return null;
// };
// const parsePickerInputValue = (utils, value) => {
//   const parsedValue = utils.date(value);
//   return utils.isValid(parsedValue) ? parsedValue : null;
// };
// const parseNonNullablePickerDate = (utils, value, defaultValue) => {
//   if (value == null) {
//     return defaultValue;
//   }

//   const parsedValue = utils.date(value);
//   const isDateValid = utils.isValid(parsedValue);

//   if (isDateValid) {
//     return parsedValue;
//   }

//   return defaultValue;
// };

// const _excluded$Q = ["className", "date", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange"];

// const useUtilityClasses$n = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root']
//   };
//   return unstable_composeClasses(slots, getMonthPickerUtilityClass, classes);
// };

// function useMonthPickerDefaultizedProps(props, name) {
//   const utils = useUtils();
//   const defaultDates = useDefaultDates();
//   const themeProps = useThemeProps({
//     props,
//     name
//   });
//   return _extends$u({
//     disableFuture: false,
//     disablePast: false
//   }, themeProps, {
//     minDate: parseNonNullablePickerDate(utils, themeProps.minDate, defaultDates.minDate),
//     maxDate: parseNonNullablePickerDate(utils, themeProps.maxDate, defaultDates.maxDate)
//   });
// }
// const MonthPickerRoot = styled$1('div', {
//   name: 'MuiMonthPicker',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })({
//   width: 310,
//   display: 'flex',
//   flexWrap: 'wrap',
//   alignContent: 'stretch',
//   margin: '0 4px'
// });
// const MonthPicker = /*#__PURE__*/React.forwardRef(function MonthPicker(inProps, ref) {
//   const utils = useUtils();
//   const now = useNow();
//   const props = useMonthPickerDefaultizedProps(inProps, 'MuiMonthPicker');

//   const {
//     className,
//     date,
//     disabled,
//     disableFuture,
//     disablePast,
//     maxDate,
//     minDate,
//     onChange,
//     shouldDisableMonth,
//     readOnly,
//     disableHighlightToday,
//     autoFocus = false,
//     onMonthFocus,
//     hasFocus,
//     onFocusedViewChange
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$Q);

//   const ownerState = props;
//   const classes = useUtilityClasses$n(ownerState);
//   const theme = useTheme();
//   const selectedDateOrStartOfMonth = React.useMemo(() => date != null ? date : utils.startOfMonth(now), [now, utils, date]);
//   const selectedMonth = React.useMemo(() => {
//     if (date != null) {
//       return utils.getMonth(date);
//     }

//     if (disableHighlightToday) {
//       return null;
//     }

//     return utils.getMonth(now);
//   }, [now, date, utils, disableHighlightToday]);
//   const [focusedMonth, setFocusedMonth] = React.useState(() => selectedMonth || utils.getMonth(now));
//   const isMonthDisabled = React.useCallback(month => {
//     const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
//     const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);

//     if (utils.isBefore(month, firstEnabledMonth)) {
//       return true;
//     }

//     if (utils.isAfter(month, lastEnabledMonth)) {
//       return true;
//     }

//     if (!shouldDisableMonth) {
//       return false;
//     }

//     return shouldDisableMonth(month);
//   }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableMonth, utils]);

//   const onMonthSelect = month => {
//     if (readOnly) {
//       return;
//     }

//     const newDate = utils.setMonth(selectedDateOrStartOfMonth, month);
//     onChange(newDate, 'finish');
//   };

//   const [internalHasFocus, setInternalHasFocus] = useControlled$1({
//     name: 'MonthPicker',
//     state: 'hasFocus',
//     controlled: hasFocus,
//     default: autoFocus
//   });
//   const changeHasFocus = React.useCallback(newHasFocus => {
//     setInternalHasFocus(newHasFocus);

//     if (onFocusedViewChange) {
//       onFocusedViewChange(newHasFocus);
//     }
//   }, [setInternalHasFocus, onFocusedViewChange]);
//   const focusMonth = React.useCallback(month => {
//     if (!isMonthDisabled(utils.setMonth(selectedDateOrStartOfMonth, month))) {
//       setFocusedMonth(month);
//       changeHasFocus(true);

//       if (onMonthFocus) {
//         onMonthFocus(month);
//       }
//     }
//   }, [isMonthDisabled, utils, selectedDateOrStartOfMonth, changeHasFocus, onMonthFocus]);
//   React.useEffect(() => {
//     setFocusedMonth(prevFocusedMonth => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
//   }, [selectedMonth]);
//   const handleKeyDown = useEventCallback$1(event => {
//     const monthsInYear = 12;
//     const monthsInRow = 3;

//     switch (event.key) {
//       case 'ArrowUp':
//         focusMonth((monthsInYear + focusedMonth - monthsInRow) % monthsInYear);
//         event.preventDefault();
//         break;

//       case 'ArrowDown':
//         focusMonth((monthsInYear + focusedMonth + monthsInRow) % monthsInYear);
//         event.preventDefault();
//         break;

//       case 'ArrowLeft':
//         focusMonth((monthsInYear + focusedMonth + (theme.direction === 'ltr' ? -1 : 1)) % monthsInYear);
//         event.preventDefault();
//         break;

//       case 'ArrowRight':
//         focusMonth((monthsInYear + focusedMonth + (theme.direction === 'ltr' ? 1 : -1)) % monthsInYear);
//         event.preventDefault();
//         break;
//     }
//   });
//   const handleMonthFocus = React.useCallback((event, month) => {
//     focusMonth(month);
//   }, [focusMonth]);
//   const handleMonthBlur = React.useCallback(() => {
//     changeHasFocus(false);
//   }, [changeHasFocus]);
//   const currentMonthNumber = utils.getMonth(now);
//   return /*#__PURE__*/jsx(MonthPickerRoot, _extends$u({
//     ref: ref,
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState,
//     onKeyDown: handleKeyDown
//   }, other, {
//     children: utils.getMonthArray(selectedDateOrStartOfMonth).map(month => {
//       const monthNumber = utils.getMonth(month);
//       const monthText = utils.format(month, 'monthShort');
//       const isDisabled = disabled || isMonthDisabled(month);
//       return /*#__PURE__*/jsx(PickersMonth, {
//         value: monthNumber,
//         selected: monthNumber === selectedMonth,
//         tabIndex: monthNumber === focusedMonth && !isDisabled ? 0 : -1,
//         hasFocus: internalHasFocus && monthNumber === focusedMonth,
//         onSelect: onMonthSelect,
//         onFocus: handleMonthFocus,
//         onBlur: handleMonthBlur,
//         disabled: isDisabled,
//         "aria-current": currentMonthNumber === monthNumber ? 'date' : undefined,
//         children: monthText
//       }, monthText);
//     })
//   }));
// });
// process.env.NODE_ENV !== "production" ? MonthPicker.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------
//   autoFocus: PropTypes__default.bool,

//   /**
//    * Override or extend the styles applied to the component.
//    */
//   classes: PropTypes__default.object,

//   /**
//    * className applied to the root element.
//    */
//   className: PropTypes__default.string,

//   /**
//    * Date value for the MonthPicker
//    */
//   date: PropTypes__default.any,

//   /**
//    * If `true` picker is disabled
//    */
//   disabled: PropTypes__default.bool,

//   /**
//    * If `true` future days are disabled.
//    * @default false
//    */
//   disableFuture: PropTypes__default.bool,

//   /**
//    * If `true`, today's date is rendering without highlighting with circle.
//    * @default false
//    */
//   disableHighlightToday: PropTypes__default.bool,

//   /**
//    * If `true` past days are disabled.
//    * @default false
//    */
//   disablePast: PropTypes__default.bool,
//   hasFocus: PropTypes__default.bool,

//   /**
//    * Maximal selectable date. @DateIOType
//    */
//   maxDate: PropTypes__default.any,

//   /**
//    * Minimal selectable date. @DateIOType
//    */
//   minDate: PropTypes__default.any,

//   /**
//    * Callback fired on date change.
//    */
//   onChange: PropTypes__default.func.isRequired,
//   onFocusedViewChange: PropTypes__default.func,
//   onMonthFocus: PropTypes__default.func,

//   /**
//    * If `true` picker is readonly
//    */
//   readOnly: PropTypes__default.bool,

//   /**
//    * Disable specific months dynamically.
//    * Works like `shouldDisableDate` but for month selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} month The month to check.
//    * @returns {boolean} If `true` the month will be disabled.
//    */
//   shouldDisableMonth: PropTypes__default.func,

//   /**
//    * The system prop that allows defining system overrides as well as additional CSS styles.
//    */
//   sx: PropTypes__default.oneOfType([PropTypes__default.arrayOf(PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object, PropTypes__default.bool])), PropTypes__default.func, PropTypes__default.object])
// } : void 0;

// function useValidation(props, validate, isSameError) {
//   const {
//     value,
//     onError
//   } = props;
//   const adapter = useLocalizationContext();
//   const previousValidationErrorRef = React.useRef(null);
//   const validationError = validate({
//     adapter,
//     value,
//     props
//   });
//   React.useEffect(() => {
//     if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
//       onError(validationError, value);
//     }

//     previousValidationErrorRef.current = validationError;
//   }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
//   return validationError;
// }

// const validateDate$1 = ({
//   props,
//   value,
//   adapter
// }) => {
//   const now = adapter.utils.date();
//   const date = adapter.utils.date(value);
//   const minDate = parseNonNullablePickerDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
//   const maxDate = parseNonNullablePickerDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);

//   if (date === null) {
//     return null;
//   }

//   switch (true) {
//     case !adapter.utils.isValid(value):
//       return 'invalidDate';

//     case Boolean(props.shouldDisableDate && props.shouldDisableDate(date)):
//       return 'shouldDisableDate';

//     case Boolean(props.disableFuture && adapter.utils.isAfterDay(date, now)):
//       return 'disableFuture';

//     case Boolean(props.disablePast && adapter.utils.isBeforeDay(date, now)):
//       return 'disablePast';

//     case Boolean(minDate && adapter.utils.isBeforeDay(date, minDate)):
//       return 'minDate';

//     case Boolean(maxDate && adapter.utils.isAfterDay(date, maxDate)):
//       return 'maxDate';

//     default:
//       return null;
//   }
// };
// const useIsDayDisabled = ({
//   shouldDisableDate,
//   minDate,
//   maxDate,
//   disableFuture,
//   disablePast
// }) => {
//   const adapter = useLocalizationContext();
//   return React.useCallback(day => validateDate$1({
//     adapter,
//     value: day,
//     props: {
//       shouldDisableDate,
//       minDate,
//       maxDate,
//       disableFuture,
//       disablePast
//     }
//   }) !== null, [adapter, shouldDisableDate, minDate, maxDate, disableFuture, disablePast]);
// };
// const isSameDateError = (a, b) => a === b;
// const useDateValidation = props => useValidation(props, validateDate$1, isSameDateError);

// const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils) => (state, action) => {
//   switch (action.type) {
//     case 'changeMonth':
//       return _extends$u({}, state, {
//         slideDirection: action.direction,
//         currentMonth: action.newMonth,
//         isMonthSwitchingAnimating: !reduceAnimations
//       });

//     case 'finishMonthSwitchingAnimation':
//       return _extends$u({}, state, {
//         isMonthSwitchingAnimating: false
//       });

//     case 'changeFocusedDay':
//       {
//         if (state.focusedDay != null && action.focusedDay != null && utils.isSameDay(action.focusedDay, state.focusedDay)) {
//           return state;
//         }

//         const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils.isSameMonth(state.currentMonth, action.focusedDay);
//         return _extends$u({}, state, {
//           focusedDay: action.focusedDay,
//           isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
//           currentMonth: needMonthSwitch ? utils.startOfMonth(action.focusedDay) : state.currentMonth,
//           slideDirection: action.focusedDay != null && utils.isAfterDay(action.focusedDay, state.currentMonth) ? 'left' : 'right'
//         });
//       }

//     default:
//       throw new Error('missing support');
//   }
// };
// const useCalendarState = ({
//   date,
//   defaultCalendarMonth,
//   disableFuture,
//   disablePast,
//   disableSwitchToMonthOnDayFocus = false,
//   maxDate,
//   minDate,
//   onMonthChange,
//   reduceAnimations,
//   shouldDisableDate
// }) => {
//   var _ref;

//   const now = useNow();
//   const utils = useUtils();
//   const reducerFn = React.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils)).current;
//   const [calendarState, dispatch] = React.useReducer(reducerFn, {
//     isMonthSwitchingAnimating: false,
//     focusedDay: date || now,
//     currentMonth: utils.startOfMonth((_ref = date != null ? date : defaultCalendarMonth) != null ? _ref : now),
//     slideDirection: 'left'
//   });
//   const handleChangeMonth = React.useCallback(payload => {
//     dispatch(_extends$u({
//       type: 'changeMonth'
//     }, payload));

//     if (onMonthChange) {
//       onMonthChange(payload.newMonth);
//     }
//   }, [onMonthChange]);
//   const changeMonth = React.useCallback(newDate => {
//     const newDateRequested = newDate != null ? newDate : now;

//     if (utils.isSameMonth(newDateRequested, calendarState.currentMonth)) {
//       return;
//     }

//     handleChangeMonth({
//       newMonth: utils.startOfMonth(newDateRequested),
//       direction: utils.isAfterDay(newDateRequested, calendarState.currentMonth) ? 'left' : 'right'
//     });
//   }, [calendarState.currentMonth, handleChangeMonth, now, utils]);
//   const isDateDisabled = useIsDayDisabled({
//     shouldDisableDate,
//     minDate,
//     maxDate,
//     disableFuture,
//     disablePast
//   });
//   const onMonthSwitchingAnimationEnd = React.useCallback(() => {
//     dispatch({
//       type: 'finishMonthSwitchingAnimation'
//     });
//   }, []);
//   const changeFocusedDay = React.useCallback((newFocusedDate, withoutMonthSwitchingAnimation) => {
//     if (!isDateDisabled(newFocusedDate)) {
//       dispatch({
//         type: 'changeFocusedDay',
//         focusedDay: newFocusedDate,
//         withoutMonthSwitchingAnimation
//       });
//     }
//   }, [isDateDisabled]);
//   return {
//     calendarState,
//     changeMonth,
//     changeFocusedDay,
//     isDateDisabled,
//     onMonthSwitchingAnimationEnd,
//     handleChangeMonth
//   };
// };

// /**
//  * Checks if a given element has a CSS class.
//  * 
//  * @param element the element
//  * @param className the CSS class name
//  */
// function hasClass(element, className) {
//   if (element.classList) return !!className && element.classList.contains(className);
//   return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
// }

// /**
//  * Adds a CSS class to a given element.
//  * 
//  * @param element the element
//  * @param className the CSS class name
//  */

// function addClass(element, className) {
//   if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
// }

// function replaceClassName(origClass, classToRemove) {
//   return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
// }
// /**
//  * Removes a CSS class from a given element.
//  * 
//  * @param element the element
//  * @param className the CSS class name
//  */


// function removeClass$1(element, className) {
//   if (element.classList) {
//     element.classList.remove(className);
//   } else if (typeof element.className === 'string') {
//     element.className = replaceClassName(element.className, className);
//   } else {
//     element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
//   }
// }

// var config$1 = {
//   disabled: false
// };

// var timeoutsShape = process.env.NODE_ENV !== 'production' ? PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
//   enter: PropTypes__default.number,
//   exit: PropTypes__default.number,
//   appear: PropTypes__default.number
// }).isRequired]) : null;
// var classNamesShape = process.env.NODE_ENV !== 'production' ? PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.shape({
//   enter: PropTypes__default.string,
//   exit: PropTypes__default.string,
//   active: PropTypes__default.string
// }), PropTypes__default.shape({
//   enter: PropTypes__default.string,
//   enterDone: PropTypes__default.string,
//   enterActive: PropTypes__default.string,
//   exit: PropTypes__default.string,
//   exitDone: PropTypes__default.string,
//   exitActive: PropTypes__default.string
// })]) : null;

// var TransitionGroupContext = React__default.createContext(null);

// var forceReflow = function forceReflow(node) {
//   return node.scrollTop;
// };

// var UNMOUNTED = 'unmounted';
// var EXITED = 'exited';
// var ENTERING = 'entering';
// var ENTERED = 'entered';
// var EXITING = 'exiting';
// /**
//  * The Transition component lets you describe a transition from one component
//  * state to another _over time_ with a simple declarative API. Most commonly
//  * it's used to animate the mounting and unmounting of a component, but can also
//  * be used to describe in-place transition states as well.
//  *
//  * ---
//  *
//  * **Note**: `Transition` is a platform-agnostic base component. If you're using
//  * transitions in CSS, you'll probably want to use
//  * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
//  * instead. It inherits all the features of `Transition`, but contains
//  * additional features necessary to play nice with CSS transitions (hence the
//  * name of the component).
//  *
//  * ---
//  *
//  * By default the `Transition` component does not alter the behavior of the
//  * component it renders, it only tracks "enter" and "exit" states for the
//  * components. It's up to you to give meaning and effect to those states. For
//  * example we can add styles to a component when it enters or exits:
//  *
//  * ```jsx
//  * import { Transition } from 'react-transition-group';
//  *
//  * const duration = 300;
//  *
//  * const defaultStyle = {
//  *   transition: `opacity ${duration}ms ease-in-out`,
//  *   opacity: 0,
//  * }
//  *
//  * const transitionStyles = {
//  *   entering: { opacity: 1 },
//  *   entered:  { opacity: 1 },
//  *   exiting:  { opacity: 0 },
//  *   exited:  { opacity: 0 },
//  * };
//  *
//  * const Fade = ({ in: inProp }) => (
//  *   <Transition in={inProp} timeout={duration}>
//  *     {state => (
//  *       <div style={{
//  *         ...defaultStyle,
//  *         ...transitionStyles[state]
//  *       }}>
//  *         I'm a fade Transition!
//  *       </div>
//  *     )}
//  *   </Transition>
//  * );
//  * ```
//  *
//  * There are 4 main states a Transition can be in:
//  *  - `'entering'`
//  *  - `'entered'`
//  *  - `'exiting'`
//  *  - `'exited'`
//  *
//  * Transition state is toggled via the `in` prop. When `true` the component
//  * begins the "Enter" stage. During this stage, the component will shift from
//  * its current transition state, to `'entering'` for the duration of the
//  * transition and then to the `'entered'` stage once it's complete. Let's take
//  * the following example (we'll use the
//  * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
//  *
//  * ```jsx
//  * function App() {
//  *   const [inProp, setInProp] = useState(false);
//  *   return (
//  *     <div>
//  *       <Transition in={inProp} timeout={500}>
//  *         {state => (
//  *           // ...
//  *         )}
//  *       </Transition>
//  *       <button onClick={() => setInProp(true)}>
//  *         Click to Enter
//  *       </button>
//  *     </div>
//  *   );
//  * }
//  * ```
//  *
//  * When the button is clicked the component will shift to the `'entering'` state
//  * and stay there for 500ms (the value of `timeout`) before it finally switches
//  * to `'entered'`.
//  *
//  * When `in` is `false` the same thing happens except the state moves from
//  * `'exiting'` to `'exited'`.
//  */

// var Transition = /*#__PURE__*/function (_React$Component) {
//   _inheritsLoose$1(Transition, _React$Component);

//   function Transition(props, context) {
//     var _this;

//     _this = _React$Component.call(this, props, context) || this;
//     var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

//     var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
//     var initialStatus;
//     _this.appearStatus = null;

//     if (props.in) {
//       if (appear) {
//         initialStatus = EXITED;
//         _this.appearStatus = ENTERING;
//       } else {
//         initialStatus = ENTERED;
//       }
//     } else {
//       if (props.unmountOnExit || props.mountOnEnter) {
//         initialStatus = UNMOUNTED;
//       } else {
//         initialStatus = EXITED;
//       }
//     }

//     _this.state = {
//       status: initialStatus
//     };
//     _this.nextCallback = null;
//     return _this;
//   }

//   Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
//     var nextIn = _ref.in;

//     if (nextIn && prevState.status === UNMOUNTED) {
//       return {
//         status: EXITED
//       };
//     }

//     return null;
//   } // getSnapshotBeforeUpdate(prevProps) {
//   //   let nextStatus = null
//   //   if (prevProps !== this.props) {
//   //     const { status } = this.state
//   //     if (this.props.in) {
//   //       if (status !== ENTERING && status !== ENTERED) {
//   //         nextStatus = ENTERING
//   //       }
//   //     } else {
//   //       if (status === ENTERING || status === ENTERED) {
//   //         nextStatus = EXITING
//   //       }
//   //     }
//   //   }
//   //   return { nextStatus }
//   // }
//   ;

//   var _proto = Transition.prototype;

//   _proto.componentDidMount = function componentDidMount() {
//     this.updateStatus(true, this.appearStatus);
//   };

//   _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
//     var nextStatus = null;

//     if (prevProps !== this.props) {
//       var status = this.state.status;

//       if (this.props.in) {
//         if (status !== ENTERING && status !== ENTERED) {
//           nextStatus = ENTERING;
//         }
//       } else {
//         if (status === ENTERING || status === ENTERED) {
//           nextStatus = EXITING;
//         }
//       }
//     }

//     this.updateStatus(false, nextStatus);
//   };

//   _proto.componentWillUnmount = function componentWillUnmount() {
//     this.cancelNextCallback();
//   };

//   _proto.getTimeouts = function getTimeouts() {
//     var timeout = this.props.timeout;
//     var exit, enter, appear;
//     exit = enter = appear = timeout;

//     if (timeout != null && typeof timeout !== 'number') {
//       exit = timeout.exit;
//       enter = timeout.enter; // TODO: remove fallback for next major

//       appear = timeout.appear !== undefined ? timeout.appear : enter;
//     }

//     return {
//       exit: exit,
//       enter: enter,
//       appear: appear
//     };
//   };

//   _proto.updateStatus = function updateStatus(mounting, nextStatus) {
//     if (mounting === void 0) {
//       mounting = false;
//     }

//     if (nextStatus !== null) {
//       // nextStatus will always be ENTERING or EXITING.
//       this.cancelNextCallback();

//       if (nextStatus === ENTERING) {
//         if (this.props.unmountOnExit || this.props.mountOnEnter) {
//           var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
//           // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
//           // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

//           if (node) forceReflow(node);
//         }

//         this.performEnter(mounting);
//       } else {
//         this.performExit();
//       }
//     } else if (this.props.unmountOnExit && this.state.status === EXITED) {
//       this.setState({
//         status: UNMOUNTED
//       });
//     }
//   };

//   _proto.performEnter = function performEnter(mounting) {
//     var _this2 = this;

//     var enter = this.props.enter;
//     var appearing = this.context ? this.context.isMounting : mounting;

//     var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
//         maybeNode = _ref2[0],
//         maybeAppearing = _ref2[1];

//     var timeouts = this.getTimeouts();
//     var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
//     // if we are mounting and running this it means appear _must_ be set

//     if (!mounting && !enter || config$1.disabled) {
//       this.safeSetState({
//         status: ENTERED
//       }, function () {
//         _this2.props.onEntered(maybeNode);
//       });
//       return;
//     }

//     this.props.onEnter(maybeNode, maybeAppearing);
//     this.safeSetState({
//       status: ENTERING
//     }, function () {
//       _this2.props.onEntering(maybeNode, maybeAppearing);

//       _this2.onTransitionEnd(enterTimeout, function () {
//         _this2.safeSetState({
//           status: ENTERED
//         }, function () {
//           _this2.props.onEntered(maybeNode, maybeAppearing);
//         });
//       });
//     });
//   };

//   _proto.performExit = function performExit() {
//     var _this3 = this;

//     var exit = this.props.exit;
//     var timeouts = this.getTimeouts();
//     var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

//     if (!exit || config$1.disabled) {
//       this.safeSetState({
//         status: EXITED
//       }, function () {
//         _this3.props.onExited(maybeNode);
//       });
//       return;
//     }

//     this.props.onExit(maybeNode);
//     this.safeSetState({
//       status: EXITING
//     }, function () {
//       _this3.props.onExiting(maybeNode);

//       _this3.onTransitionEnd(timeouts.exit, function () {
//         _this3.safeSetState({
//           status: EXITED
//         }, function () {
//           _this3.props.onExited(maybeNode);
//         });
//       });
//     });
//   };

//   _proto.cancelNextCallback = function cancelNextCallback() {
//     if (this.nextCallback !== null) {
//       this.nextCallback.cancel();
//       this.nextCallback = null;
//     }
//   };

//   _proto.safeSetState = function safeSetState(nextState, callback) {
//     // This shouldn't be necessary, but there are weird race conditions with
//     // setState callbacks and unmounting in testing, so always make sure that
//     // we can cancel any pending setState callbacks after we unmount.
//     callback = this.setNextCallback(callback);
//     this.setState(nextState, callback);
//   };

//   _proto.setNextCallback = function setNextCallback(callback) {
//     var _this4 = this;

//     var active = true;

//     this.nextCallback = function (event) {
//       if (active) {
//         active = false;
//         _this4.nextCallback = null;
//         callback(event);
//       }
//     };

//     this.nextCallback.cancel = function () {
//       active = false;
//     };

//     return this.nextCallback;
//   };

//   _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
//     this.setNextCallback(handler);
//     var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
//     var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

//     if (!node || doesNotHaveTimeoutOrListener) {
//       setTimeout(this.nextCallback, 0);
//       return;
//     }

//     if (this.props.addEndListener) {
//       var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
//           maybeNode = _ref3[0],
//           maybeNextCallback = _ref3[1];

//       this.props.addEndListener(maybeNode, maybeNextCallback);
//     }

//     if (timeout != null) {
//       setTimeout(this.nextCallback, timeout);
//     }
//   };

//   _proto.render = function render() {
//     var status = this.state.status;

//     if (status === UNMOUNTED) {
//       return null;
//     }

//     var _this$props = this.props,
//         children = _this$props.children;
//         _this$props.in;
//         _this$props.mountOnEnter;
//         _this$props.unmountOnExit;
//         _this$props.appear;
//         _this$props.enter;
//         _this$props.exit;
//         _this$props.timeout;
//         _this$props.addEndListener;
//         _this$props.onEnter;
//         _this$props.onEntering;
//         _this$props.onEntered;
//         _this$props.onExit;
//         _this$props.onExiting;
//         _this$props.onExited;
//         _this$props.nodeRef;
//         var childProps = _objectWithoutPropertiesLoose$k(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

//     return (
//       /*#__PURE__*/
//       // allows for nested Transitions
//       React__default.createElement(TransitionGroupContext.Provider, {
//         value: null
//       }, typeof children === 'function' ? children(status, childProps) : React__default.cloneElement(React__default.Children.only(children), childProps))
//     );
//   };

//   return Transition;
// }(React__default.Component);

// Transition.contextType = TransitionGroupContext;
// Transition.propTypes = process.env.NODE_ENV !== "production" ? {
//   /**
//    * A React reference to DOM element that need to transition:
//    * https://stackoverflow.com/a/51127130/4671932
//    *
//    *   - When `nodeRef` prop is used, `node` is not passed to callback functions
//    *      (e.g. `onEnter`) because user already has direct access to the node.
//    *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
//    *     `nodeRef` need to be provided to `Transition` with changed `key` prop
//    *     (see
//    *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
//    */
//   nodeRef: PropTypes__default.shape({
//     current: typeof Element === 'undefined' ? PropTypes__default.any : function (propValue, key, componentName, location, propFullName, secret) {
//       var value = propValue[key];
//       return PropTypes__default.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
//     }
//   }),

//   /**
//    * A `function` child can be used instead of a React element. This function is
//    * called with the current transition status (`'entering'`, `'entered'`,
//    * `'exiting'`, `'exited'`), which can be used to apply context
//    * specific props to a component.
//    *
//    * ```jsx
//    * <Transition in={this.state.in} timeout={150}>
//    *   {state => (
//    *     <MyComponent className={`fade fade-${state}`} />
//    *   )}
//    * </Transition>
//    * ```
//    */
//   children: PropTypes__default.oneOfType([PropTypes__default.func.isRequired, PropTypes__default.element.isRequired]).isRequired,

//   /**
//    * Show the component; triggers the enter or exit states
//    */
//   in: PropTypes__default.bool,

//   /**
//    * By default the child component is mounted immediately along with
//    * the parent `Transition` component. If you want to "lazy mount" the component on the
//    * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
//    * mounted, even on "exited", unless you also specify `unmountOnExit`.
//    */
//   mountOnEnter: PropTypes__default.bool,

//   /**
//    * By default the child component stays mounted after it reaches the `'exited'` state.
//    * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
//    */
//   unmountOnExit: PropTypes__default.bool,

//   /**
//    * By default the child component does not perform the enter transition when
//    * it first mounts, regardless of the value of `in`. If you want this
//    * behavior, set both `appear` and `in` to `true`.
//    *
//    * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
//    * > only adds an additional enter transition. However, in the
//    * > `<CSSTransition>` component that first enter transition does result in
//    * > additional `.appear-*` classes, that way you can choose to style it
//    * > differently.
//    */
//   appear: PropTypes__default.bool,

//   /**
//    * Enable or disable enter transitions.
//    */
//   enter: PropTypes__default.bool,

//   /**
//    * Enable or disable exit transitions.
//    */
//   exit: PropTypes__default.bool,

//   /**
//    * The duration of the transition, in milliseconds.
//    * Required unless `addEndListener` is provided.
//    *
//    * You may specify a single timeout for all transitions:
//    *
//    * ```jsx
//    * timeout={500}
//    * ```
//    *
//    * or individually:
//    *
//    * ```jsx
//    * timeout={{
//    *  appear: 500,
//    *  enter: 300,
//    *  exit: 500,
//    * }}
//    * ```
//    *
//    * - `appear` defaults to the value of `enter`
//    * - `enter` defaults to `0`
//    * - `exit` defaults to `0`
//    *
//    * @type {number | { enter?: number, exit?: number, appear?: number }}
//    */
//   timeout: function timeout(props) {
//     var pt = timeoutsShape;
//     if (!props.addEndListener) pt = pt.isRequired;

//     for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
//       args[_key - 1] = arguments[_key];
//     }

//     return pt.apply(void 0, [props].concat(args));
//   },

//   /**
//    * Add a custom transition end trigger. Called with the transitioning
//    * DOM node and a `done` callback. Allows for more fine grained transition end
//    * logic. Timeouts are still used as a fallback if provided.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * ```jsx
//    * addEndListener={(node, done) => {
//    *   // use the css transitionend event to mark the finish of a transition
//    *   node.addEventListener('transitionend', done, false);
//    * }}
//    * ```
//    */
//   addEndListener: PropTypes__default.func,

//   /**
//    * Callback fired before the "entering" status is applied. An extra parameter
//    * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement, isAppearing: bool) -> void
//    */
//   onEnter: PropTypes__default.func,

//   /**
//    * Callback fired after the "entering" status is applied. An extra parameter
//    * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement, isAppearing: bool)
//    */
//   onEntering: PropTypes__default.func,

//   /**
//    * Callback fired after the "entered" status is applied. An extra parameter
//    * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement, isAppearing: bool) -> void
//    */
//   onEntered: PropTypes__default.func,

//   /**
//    * Callback fired before the "exiting" status is applied.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement) -> void
//    */
//   onExit: PropTypes__default.func,

//   /**
//    * Callback fired after the "exiting" status is applied.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement) -> void
//    */
//   onExiting: PropTypes__default.func,

//   /**
//    * Callback fired after the "exited" status is applied.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed
//    *
//    * @type Function(node: HtmlElement) -> void
//    */
//   onExited: PropTypes__default.func
// } : {}; // Name the function so it is clearer in the documentation

// function noop$5() {}

// Transition.defaultProps = {
//   in: false,
//   mountOnEnter: false,
//   unmountOnExit: false,
//   appear: false,
//   enter: true,
//   exit: true,
//   onEnter: noop$5,
//   onEntering: noop$5,
//   onEntered: noop$5,
//   onExit: noop$5,
//   onExiting: noop$5,
//   onExited: noop$5
// };
// Transition.UNMOUNTED = UNMOUNTED;
// Transition.EXITED = EXITED;
// Transition.ENTERING = ENTERING;
// Transition.ENTERED = ENTERED;
// Transition.EXITING = EXITING;

// var _addClass = function addClass$1(node, classes) {
//   return node && classes && classes.split(' ').forEach(function (c) {
//     return addClass(node, c);
//   });
// };

// var removeClass = function removeClass(node, classes) {
//   return node && classes && classes.split(' ').forEach(function (c) {
//     return removeClass$1(node, c);
//   });
// };
// /**
//  * A transition component inspired by the excellent
//  * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
//  * use it if you're using CSS transitions or animations. It's built upon the
//  * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
//  * component, so it inherits all of its props.
//  *
//  * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
//  * and `exit` states of the transition. The first class is applied and then a
//  * second `*-active` class in order to activate the CSS transition. After the
//  * transition, matching `*-done` class names are applied to persist the
//  * transition state.
//  *
//  * ```jsx
//  * function App() {
//  *   const [inProp, setInProp] = useState(false);
//  *   return (
//  *     <div>
//  *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
//  *         <div>
//  *           {"I'll receive my-node-* classes"}
//  *         </div>
//  *       </CSSTransition>
//  *       <button type="button" onClick={() => setInProp(true)}>
//  *         Click to Enter
//  *       </button>
//  *     </div>
//  *   );
//  * }
//  * ```
//  *
//  * When the `in` prop is set to `true`, the child component will first receive
//  * the class `example-enter`, then the `example-enter-active` will be added in
//  * the next tick. `CSSTransition` [forces a
//  * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
//  * between before adding the `example-enter-active`. This is an important trick
//  * because it allows us to transition between `example-enter` and
//  * `example-enter-active` even though they were added immediately one after
//  * another. Most notably, this is what makes it possible for us to animate
//  * _appearance_.
//  *
//  * ```css
//  * .my-node-enter {
//  *   opacity: 0;
//  * }
//  * .my-node-enter-active {
//  *   opacity: 1;
//  *   transition: opacity 200ms;
//  * }
//  * .my-node-exit {
//  *   opacity: 1;
//  * }
//  * .my-node-exit-active {
//  *   opacity: 0;
//  *   transition: opacity 200ms;
//  * }
//  * ```
//  *
//  * `*-active` classes represent which styles you want to animate **to**, so it's
//  * important to add `transition` declaration only to them, otherwise transitions
//  * might not behave as intended! This might not be obvious when the transitions
//  * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
//  * the example above (minus `transition`), but it becomes apparent in more
//  * complex transitions.
//  *
//  * **Note**: If you're using the
//  * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
//  * prop, make sure to define styles for `.appear-*` classes as well.
//  */


// var CSSTransition = /*#__PURE__*/function (_React$Component) {
//   _inheritsLoose$1(CSSTransition, _React$Component);

//   function CSSTransition() {
//     var _this;

//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }

//     _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
//     _this.appliedClasses = {
//       appear: {},
//       enter: {},
//       exit: {}
//     };

//     _this.onEnter = function (maybeNode, maybeAppearing) {
//       var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
//           node = _this$resolveArgument[0],
//           appearing = _this$resolveArgument[1];

//       _this.removeClasses(node, 'exit');

//       _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

//       if (_this.props.onEnter) {
//         _this.props.onEnter(maybeNode, maybeAppearing);
//       }
//     };

//     _this.onEntering = function (maybeNode, maybeAppearing) {
//       var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
//           node = _this$resolveArgument2[0],
//           appearing = _this$resolveArgument2[1];

//       var type = appearing ? 'appear' : 'enter';

//       _this.addClass(node, type, 'active');

//       if (_this.props.onEntering) {
//         _this.props.onEntering(maybeNode, maybeAppearing);
//       }
//     };

//     _this.onEntered = function (maybeNode, maybeAppearing) {
//       var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
//           node = _this$resolveArgument3[0],
//           appearing = _this$resolveArgument3[1];

//       var type = appearing ? 'appear' : 'enter';

//       _this.removeClasses(node, type);

//       _this.addClass(node, type, 'done');

//       if (_this.props.onEntered) {
//         _this.props.onEntered(maybeNode, maybeAppearing);
//       }
//     };

//     _this.onExit = function (maybeNode) {
//       var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
//           node = _this$resolveArgument4[0];

//       _this.removeClasses(node, 'appear');

//       _this.removeClasses(node, 'enter');

//       _this.addClass(node, 'exit', 'base');

//       if (_this.props.onExit) {
//         _this.props.onExit(maybeNode);
//       }
//     };

//     _this.onExiting = function (maybeNode) {
//       var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
//           node = _this$resolveArgument5[0];

//       _this.addClass(node, 'exit', 'active');

//       if (_this.props.onExiting) {
//         _this.props.onExiting(maybeNode);
//       }
//     };

//     _this.onExited = function (maybeNode) {
//       var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
//           node = _this$resolveArgument6[0];

//       _this.removeClasses(node, 'exit');

//       _this.addClass(node, 'exit', 'done');

//       if (_this.props.onExited) {
//         _this.props.onExited(maybeNode);
//       }
//     };

//     _this.resolveArguments = function (maybeNode, maybeAppearing) {
//       return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
//       : [maybeNode, maybeAppearing];
//     };

//     _this.getClassNames = function (type) {
//       var classNames = _this.props.classNames;
//       var isStringClassNames = typeof classNames === 'string';
//       var prefix = isStringClassNames && classNames ? classNames + "-" : '';
//       var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
//       var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
//       var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
//       return {
//         baseClassName: baseClassName,
//         activeClassName: activeClassName,
//         doneClassName: doneClassName
//       };
//     };

//     return _this;
//   }

//   var _proto = CSSTransition.prototype;

//   _proto.addClass = function addClass(node, type, phase) {
//     var className = this.getClassNames(type)[phase + "ClassName"];

//     var _this$getClassNames = this.getClassNames('enter'),
//         doneClassName = _this$getClassNames.doneClassName;

//     if (type === 'appear' && phase === 'done' && doneClassName) {
//       className += " " + doneClassName;
//     } // This is to force a repaint,
//     // which is necessary in order to transition styles when adding a class name.


//     if (phase === 'active') {
//       if (node) forceReflow(node);
//     }

//     if (className) {
//       this.appliedClasses[type][phase] = className;

//       _addClass(node, className);
//     }
//   };

//   _proto.removeClasses = function removeClasses(node, type) {
//     var _this$appliedClasses$ = this.appliedClasses[type],
//         baseClassName = _this$appliedClasses$.base,
//         activeClassName = _this$appliedClasses$.active,
//         doneClassName = _this$appliedClasses$.done;
//     this.appliedClasses[type] = {};

//     if (baseClassName) {
//       removeClass(node, baseClassName);
//     }

//     if (activeClassName) {
//       removeClass(node, activeClassName);
//     }

//     if (doneClassName) {
//       removeClass(node, doneClassName);
//     }
//   };

//   _proto.render = function render() {
//     var _this$props = this.props;
//         _this$props.classNames;
//         var props = _objectWithoutPropertiesLoose$k(_this$props, ["classNames"]);

//     return /*#__PURE__*/React__default.createElement(Transition, _extends$u({}, props, {
//       onEnter: this.onEnter,
//       onEntered: this.onEntered,
//       onEntering: this.onEntering,
//       onExit: this.onExit,
//       onExiting: this.onExiting,
//       onExited: this.onExited
//     }));
//   };

//   return CSSTransition;
// }(React__default.Component);

// CSSTransition.defaultProps = {
//   classNames: ''
// };
// CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? _extends$u({}, Transition.propTypes, {
//   /**
//    * The animation classNames applied to the component as it appears, enters,
//    * exits or has finished the transition. A single name can be provided, which
//    * will be suffixed for each stage, e.g. `classNames="fade"` applies:
//    *
//    * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
//    * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
//    * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
//    *
//    * A few details to note about how these classes are applied:
//    *
//    * 1. They are _joined_ with the ones that are already defined on the child
//    *    component, so if you want to add some base styles, you can use
//    *    `className` without worrying that it will be overridden.
//    *
//    * 2. If the transition component mounts with `in={false}`, no classes are
//    *    applied yet. You might be expecting `*-exit-done`, but if you think
//    *    about it, a component cannot finish exiting if it hasn't entered yet.
//    *
//    * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
//    *    allows you to define different behavior for when appearing is done and
//    *    when regular entering is done, using selectors like
//    *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
//    *    an epic entrance animation when element first appears in the DOM using
//    *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
//    *    simply use `fade-enter-done` for defining both cases.
//    *
//    * Each individual classNames can also be specified independently like:
//    *
//    * ```js
//    * classNames={{
//    *  appear: 'my-appear',
//    *  appearActive: 'my-active-appear',
//    *  appearDone: 'my-done-appear',
//    *  enter: 'my-enter',
//    *  enterActive: 'my-active-enter',
//    *  enterDone: 'my-done-enter',
//    *  exit: 'my-exit',
//    *  exitActive: 'my-active-exit',
//    *  exitDone: 'my-done-exit',
//    * }}
//    * ```
//    *
//    * If you want to set these classes using CSS Modules:
//    *
//    * ```js
//    * import styles from './styles.css';
//    * ```
//    *
//    * you might want to use camelCase in your CSS file, that way could simply
//    * spread them instead of listing them one by one:
//    *
//    * ```js
//    * classNames={{ ...styles }}
//    * ```
//    *
//    * @type {string | {
//    *  appear?: string,
//    *  appearActive?: string,
//    *  appearDone?: string,
//    *  enter?: string,
//    *  enterActive?: string,
//    *  enterDone?: string,
//    *  exit?: string,
//    *  exitActive?: string,
//    *  exitDone?: string,
//    * }}
//    */
//   classNames: classNamesShape,

//   /**
//    * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
//    * applied.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement, isAppearing: bool)
//    */
//   onEnter: PropTypes__default.func,

//   /**
//    * A `<Transition>` callback fired immediately after the 'enter-active' or
//    * 'appear-active' class is applied.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement, isAppearing: bool)
//    */
//   onEntering: PropTypes__default.func,

//   /**
//    * A `<Transition>` callback fired immediately after the 'enter' or
//    * 'appear' classes are **removed** and the `done` class is added to the DOM node.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed.
//    *
//    * @type Function(node: HtmlElement, isAppearing: bool)
//    */
//   onEntered: PropTypes__default.func,

//   /**
//    * A `<Transition>` callback fired immediately after the 'exit' class is
//    * applied.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed
//    *
//    * @type Function(node: HtmlElement)
//    */
//   onExit: PropTypes__default.func,

//   /**
//    * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed
//    *
//    * @type Function(node: HtmlElement)
//    */
//   onExiting: PropTypes__default.func,

//   /**
//    * A `<Transition>` callback fired immediately after the 'exit' classes
//    * are **removed** and the `exit-done` class is added to the DOM node.
//    *
//    * **Note**: when `nodeRef` prop is passed, `node` is not passed
//    *
//    * @type Function(node: HtmlElement)
//    */
//   onExited: PropTypes__default.func
// }) : {};

// /**
//  * Given `this.props.children`, return an object mapping key to child.
//  *
//  * @param {*} children `this.props.children`
//  * @return {object} Mapping of key to child
//  */

// function getChildMapping(children, mapFn) {
//   var mapper = function mapper(child) {
//     return mapFn && isValidElement(child) ? mapFn(child) : child;
//   };

//   var result = Object.create(null);
//   if (children) Children.map(children, function (c) {
//     return c;
//   }).forEach(function (child) {
//     // run the map function here instead so that the key is the computed one
//     result[child.key] = mapper(child);
//   });
//   return result;
// }
// /**
//  * When you're adding or removing children some may be added or removed in the
//  * same render pass. We want to show *both* since we want to simultaneously
//  * animate elements in and out. This function takes a previous set of keys
//  * and a new set of keys and merges them with its best guess of the correct
//  * ordering. In the future we may expose some of the utilities in
//  * ReactMultiChild to make this easy, but for now React itself does not
//  * directly have this concept of the union of prevChildren and nextChildren
//  * so we implement it here.
//  *
//  * @param {object} prev prev children as returned from
//  * `ReactTransitionChildMapping.getChildMapping()`.
//  * @param {object} next next children as returned from
//  * `ReactTransitionChildMapping.getChildMapping()`.
//  * @return {object} a key set that contains all keys in `prev` and all keys
//  * in `next` in a reasonable order.
//  */

// function mergeChildMappings(prev, next) {
//   prev = prev || {};
//   next = next || {};

//   function getValueForKey(key) {
//     return key in next ? next[key] : prev[key];
//   } // For each key of `next`, the list of keys to insert before that key in
//   // the combined list


//   var nextKeysPending = Object.create(null);
//   var pendingKeys = [];

//   for (var prevKey in prev) {
//     if (prevKey in next) {
//       if (pendingKeys.length) {
//         nextKeysPending[prevKey] = pendingKeys;
//         pendingKeys = [];
//       }
//     } else {
//       pendingKeys.push(prevKey);
//     }
//   }

//   var i;
//   var childMapping = {};

//   for (var nextKey in next) {
//     if (nextKeysPending[nextKey]) {
//       for (i = 0; i < nextKeysPending[nextKey].length; i++) {
//         var pendingNextKey = nextKeysPending[nextKey][i];
//         childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
//       }
//     }

//     childMapping[nextKey] = getValueForKey(nextKey);
//   } // Finally, add the keys which didn't appear before any key in `next`


//   for (i = 0; i < pendingKeys.length; i++) {
//     childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
//   }

//   return childMapping;
// }

// function getProp(child, prop, props) {
//   return props[prop] != null ? props[prop] : child.props[prop];
// }

// function getInitialChildMapping(props, onExited) {
//   return getChildMapping(props.children, function (child) {
//     return cloneElement(child, {
//       onExited: onExited.bind(null, child),
//       in: true,
//       appear: getProp(child, 'appear', props),
//       enter: getProp(child, 'enter', props),
//       exit: getProp(child, 'exit', props)
//     });
//   });
// }
// function getNextChildMapping(nextProps, prevChildMapping, onExited) {
//   var nextChildMapping = getChildMapping(nextProps.children);
//   var children = mergeChildMappings(prevChildMapping, nextChildMapping);
//   Object.keys(children).forEach(function (key) {
//     var child = children[key];
//     if (!isValidElement(child)) return;
//     var hasPrev = (key in prevChildMapping);
//     var hasNext = (key in nextChildMapping);
//     var prevChild = prevChildMapping[key];
//     var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

//     if (hasNext && (!hasPrev || isLeaving)) {
//       // console.log('entering', key)
//       children[key] = cloneElement(child, {
//         onExited: onExited.bind(null, child),
//         in: true,
//         exit: getProp(child, 'exit', nextProps),
//         enter: getProp(child, 'enter', nextProps)
//       });
//     } else if (!hasNext && hasPrev && !isLeaving) {
//       // item is old (exiting)
//       // console.log('leaving', key)
//       children[key] = cloneElement(child, {
//         in: false
//       });
//     } else if (hasNext && hasPrev && isValidElement(prevChild)) {
//       // item hasn't changed transition states
//       // copy over the last transition props;
//       // console.log('unchanged', key)
//       children[key] = cloneElement(child, {
//         onExited: onExited.bind(null, child),
//         in: prevChild.props.in,
//         exit: getProp(child, 'exit', nextProps),
//         enter: getProp(child, 'enter', nextProps)
//       });
//     }
//   });
//   return children;
// }

// var values = Object.values || function (obj) {
//   return Object.keys(obj).map(function (k) {
//     return obj[k];
//   });
// };

// var defaultProps$5 = {
//   component: 'div',
//   childFactory: function childFactory(child) {
//     return child;
//   }
// };
// /**
//  * The `<TransitionGroup>` component manages a set of transition components
//  * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
//  * components, `<TransitionGroup>` is a state machine for managing the mounting
//  * and unmounting of components over time.
//  *
//  * Consider the example below. As items are removed or added to the TodoList the
//  * `in` prop is toggled automatically by the `<TransitionGroup>`.
//  *
//  * Note that `<TransitionGroup>`  does not define any animation behavior!
//  * Exactly _how_ a list item animates is up to the individual transition
//  * component. This means you can mix and match animations across different list
//  * items.
//  */

// var TransitionGroup = /*#__PURE__*/function (_React$Component) {
//   _inheritsLoose$1(TransitionGroup, _React$Component);

//   function TransitionGroup(props, context) {
//     var _this;

//     _this = _React$Component.call(this, props, context) || this;

//     var handleExited = _this.handleExited.bind(_assertThisInitialized$c(_this)); // Initial children should all be entering, dependent on appear


//     _this.state = {
//       contextValue: {
//         isMounting: true
//       },
//       handleExited: handleExited,
//       firstRender: true
//     };
//     return _this;
//   }

//   var _proto = TransitionGroup.prototype;

//   _proto.componentDidMount = function componentDidMount() {
//     this.mounted = true;
//     this.setState({
//       contextValue: {
//         isMounting: false
//       }
//     });
//   };

//   _proto.componentWillUnmount = function componentWillUnmount() {
//     this.mounted = false;
//   };

//   TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
//     var prevChildMapping = _ref.children,
//         handleExited = _ref.handleExited,
//         firstRender = _ref.firstRender;
//     return {
//       children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
//       firstRender: false
//     };
//   } // node is `undefined` when user provided `nodeRef` prop
//   ;

//   _proto.handleExited = function handleExited(child, node) {
//     var currentChildMapping = getChildMapping(this.props.children);
//     if (child.key in currentChildMapping) return;

//     if (child.props.onExited) {
//       child.props.onExited(node);
//     }

//     if (this.mounted) {
//       this.setState(function (state) {
//         var children = _extends$u({}, state.children);

//         delete children[child.key];
//         return {
//           children: children
//         };
//       });
//     }
//   };

//   _proto.render = function render() {
//     var _this$props = this.props,
//         Component = _this$props.component,
//         childFactory = _this$props.childFactory,
//         props = _objectWithoutPropertiesLoose$k(_this$props, ["component", "childFactory"]);

//     var contextValue = this.state.contextValue;
//     var children = values(this.state.children).map(childFactory);
//     delete props.appear;
//     delete props.enter;
//     delete props.exit;

//     if (Component === null) {
//       return /*#__PURE__*/React__default.createElement(TransitionGroupContext.Provider, {
//         value: contextValue
//       }, children);
//     }

//     return /*#__PURE__*/React__default.createElement(TransitionGroupContext.Provider, {
//       value: contextValue
//     }, /*#__PURE__*/React__default.createElement(Component, props, children));
//   };

//   return TransitionGroup;
// }(React__default.Component);

// TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? {
//   /**
//    * `<TransitionGroup>` renders a `<div>` by default. You can change this
//    * behavior by providing a `component` prop.
//    * If you use React v16+ and would like to avoid a wrapping `<div>` element
//    * you can pass in `component={null}`. This is useful if the wrapping div
//    * borks your css styles.
//    */
//   component: PropTypes__default.any,

//   /**
//    * A set of `<Transition>` components, that are toggled `in` and out as they
//    * leave. the `<TransitionGroup>` will inject specific transition props, so
//    * remember to spread them through if you are wrapping the `<Transition>` as
//    * with our `<Fade>` example.
//    *
//    * While this component is meant for multiple `Transition` or `CSSTransition`
//    * children, sometimes you may want to have a single transition child with
//    * content that you want to be transitioned out and in when you change it
//    * (e.g. routes, images etc.) In that case you can change the `key` prop of
//    * the transition child as you change its content, this will cause
//    * `TransitionGroup` to transition the child out and back in.
//    */
//   children: PropTypes__default.node,

//   /**
//    * A convenience prop that enables or disables appear animations
//    * for all children. Note that specifying this will override any defaults set
//    * on individual children Transitions.
//    */
//   appear: PropTypes__default.bool,

//   /**
//    * A convenience prop that enables or disables enter animations
//    * for all children. Note that specifying this will override any defaults set
//    * on individual children Transitions.
//    */
//   enter: PropTypes__default.bool,

//   /**
//    * A convenience prop that enables or disables exit animations
//    * for all children. Note that specifying this will override any defaults set
//    * on individual children Transitions.
//    */
//   exit: PropTypes__default.bool,

//   /**
//    * You may need to apply reactive updates to a child as it is exiting.
//    * This is generally done by using `cloneElement` however in the case of an exiting
//    * child the element has already been removed and not accessible to the consumer.
//    *
//    * If you do need to update a child as it leaves you can provide a `childFactory`
//    * to wrap every child, even the ones that are leaving.
//    *
//    * @type Function(child: ReactElement) -> ReactElement
//    */
//   childFactory: PropTypes__default.func
// } : {};
// TransitionGroup.defaultProps = defaultProps$5;

// const getPickersFadeTransitionGroupUtilityClass = slot => generateUtilityClass$1('MuiPickersFadeTransitionGroup', slot);
// generateUtilityClasses$1('MuiPickersFadeTransitionGroup', ['root']);

// const useUtilityClasses$m = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root']
//   };
//   return unstable_composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
// };

// const animationDuration = 500;
// const PickersFadeTransitionGroupRoot = styled$1(TransitionGroup, {
//   name: 'MuiPickersFadeTransitionGroup',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })({
//   display: 'block',
//   position: 'relative'
// });
// /**
//  * @ignore - do not document.
//  */

// function PickersFadeTransitionGroup(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiPickersFadeTransitionGroup'
//   });
//   const {
//     children,
//     className,
//     reduceAnimations,
//     transKey
//   } = props;
//   const classes = useUtilityClasses$m(props);

//   if (reduceAnimations) {
//     return children;
//   }

//   return /*#__PURE__*/jsx(PickersFadeTransitionGroupRoot, {
//     className: clsx$1(classes.root, className),
//     children: /*#__PURE__*/jsx(Fade, {
//       appear: false,
//       mountOnEnter: true,
//       unmountOnExit: true,
//       timeout: {
//         appear: animationDuration,
//         enter: animationDuration / 2,
//         exit: 0
//       },
//       children: children
//     }, transKey)
//   });
// }

// const DAY_SIZE = 36;
// const DAY_MARGIN = 2;
// const DIALOG_WIDTH = 320;
// const VIEW_HEIGHT = 358;

// function getPickersDayUtilityClass(slot) {
//   return generateUtilityClass$1('MuiPickersDay', slot);
// }
// const pickersDayClasses = generateUtilityClasses$1('MuiPickersDay', ['root', 'dayWithMargin', 'dayOutsideMonth', 'hiddenDaySpacingFiller', 'today', 'selected', 'disabled']);

// const _excluded$P = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today"];

// const useUtilityClasses$l = ownerState => {
//   const {
//     selected,
//     disableMargin,
//     disableHighlightToday,
//     today,
//     disabled,
//     outsideCurrentMonth,
//     showDaysOutsideCurrentMonth,
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root', selected && 'selected', disabled && 'disabled', !disableMargin && 'dayWithMargin', !disableHighlightToday && today && 'today', outsideCurrentMonth && showDaysOutsideCurrentMonth && 'dayOutsideMonth', outsideCurrentMonth && !showDaysOutsideCurrentMonth && 'hiddenDaySpacingFiller'],
//     hiddenDaySpacingFiller: ['hiddenDaySpacingFiller']
//   };
//   return unstable_composeClasses(slots, getPickersDayUtilityClass, classes);
// };

// const styleArg = ({
//   theme,
//   ownerState
// }) => _extends$u({}, theme.typography.caption, {
//   width: DAY_SIZE,
//   height: DAY_SIZE,
//   borderRadius: '50%',
//   padding: 0,
//   // background required here to prevent collides with the other days when animating with transition group
//   backgroundColor: theme.palette.background.paper,
//   color: theme.palette.text.primary,
//   '&:hover': {
//     backgroundColor: alpha$1(theme.palette.action.active, theme.palette.action.hoverOpacity)
//   },
//   '&:focus': {
//     backgroundColor: alpha$1(theme.palette.action.active, theme.palette.action.hoverOpacity),
//     [`&.${pickersDayClasses.selected}`]: {
//       willChange: 'background-color',
//       backgroundColor: theme.palette.primary.dark
//     }
//   },
//   [`&.${pickersDayClasses.selected}`]: {
//     color: theme.palette.primary.contrastText,
//     backgroundColor: theme.palette.primary.main,
//     fontWeight: theme.typography.fontWeightMedium,
//     transition: theme.transitions.create('background-color', {
//       duration: theme.transitions.duration.short
//     }),
//     '&:hover': {
//       willChange: 'background-color',
//       backgroundColor: theme.palette.primary.dark
//     }
//   },
//   [`&.${pickersDayClasses.disabled}`]: {
//     color: theme.palette.text.disabled
//   }
// }, !ownerState.disableMargin && {
//   margin: `0 ${DAY_MARGIN}px`
// }, ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && {
//   color: theme.palette.text.secondary
// }, !ownerState.disableHighlightToday && ownerState.today && {
//   [`&:not(.${pickersDayClasses.selected})`]: {
//     border: `1px solid ${theme.palette.text.secondary}`
//   }
// });

// const overridesResolver = (props, styles) => {
//   const {
//     ownerState
//   } = props;
//   return [styles.root, !ownerState.disableMargin && styles.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles.hiddenDaySpacingFiller];
// };

// const PickersDayRoot = styled$1(ButtonBase, {
//   name: 'MuiPickersDay',
//   slot: 'Root',
//   overridesResolver
// })(styleArg);
// const PickersDayFiller = styled$1('div', {
//   name: 'MuiPickersDay',
//   slot: 'Root',
//   overridesResolver
// })(({
//   theme,
//   ownerState
// }) => _extends$u({}, styleArg({
//   theme,
//   ownerState
// }), {
//   // visibility: 'hidden' does not work here as it hides the element from screen readers as well
//   opacity: 0,
//   pointerEvents: 'none'
// }));

// const noop$4 = () => {};

// const PickersDayRaw = /*#__PURE__*/React.forwardRef(function PickersDay(inProps, forwardedRef) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiPickersDay'
//   });

//   const {
//     autoFocus = false,
//     className,
//     day,
//     disabled = false,
//     disableHighlightToday = false,
//     disableMargin = false,
//     isAnimating,
//     onClick,
//     onDaySelect,
//     onFocus = noop$4,
//     onBlur = noop$4,
//     onKeyDown = noop$4,
//     onMouseDown,
//     outsideCurrentMonth,
//     selected = false,
//     showDaysOutsideCurrentMonth = false,
//     children,
//     today: isToday = false
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$P);

//   const ownerState = _extends$u({}, props, {
//     autoFocus,
//     disabled,
//     disableHighlightToday,
//     disableMargin,
//     selected,
//     showDaysOutsideCurrentMonth,
//     today: isToday
//   });

//   const classes = useUtilityClasses$l(ownerState);
//   const utils = useUtils();
//   const ref = React.useRef(null);
//   const handleRef = useForkRef$1(ref, forwardedRef); // Since this is rendered when a Popper is opened we can't use passive effects.
//   // Focusing in passive effects in Popper causes scroll jump.

//   useEnhancedEffect(() => {
//     if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
//       // ref.current being null would be a bug in MUI
//       ref.current.focus();
//     }
//   }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]); // For day outside of current month, move focus from mouseDown to mouseUp
//   // Goal: have the onClick ends before sliding to the new month

//   const handleMouseDown = event => {
//     if (onMouseDown) {
//       onMouseDown(event);
//     }

//     if (outsideCurrentMonth) {
//       event.preventDefault();
//     }
//   };

//   const handleClick = event => {
//     if (!disabled) {
//       onDaySelect(day, 'finish');
//     }

//     if (outsideCurrentMonth) {
//       event.currentTarget.focus();
//     }

//     if (onClick) {
//       onClick(event);
//     }
//   };

//   if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
//     return /*#__PURE__*/jsx(PickersDayFiller, {
//       className: clsx$1(classes.root, classes.hiddenDaySpacingFiller, className),
//       ownerState: ownerState,
//       role: other.role
//     });
//   }

//   return /*#__PURE__*/jsx(PickersDayRoot, _extends$u({
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState,
//     ref: handleRef,
//     centerRipple: true,
//     disabled: disabled,
//     tabIndex: selected ? 0 : -1,
//     onKeyDown: event => onKeyDown(event, day),
//     onFocus: event => onFocus(event, day),
//     onBlur: event => onBlur(event, day),
//     onClick: handleClick,
//     onMouseDown: handleMouseDown
//   }, other, {
//     children: !children ? utils.format(day, 'dayOfMonth') : children
//   }));
// });
// const areDayPropsEqual = (prevProps, nextProps) => {
//   return prevProps.autoFocus === nextProps.autoFocus && prevProps.isAnimating === nextProps.isAnimating && prevProps.today === nextProps.today && prevProps.disabled === nextProps.disabled && prevProps.selected === nextProps.selected && prevProps.disableMargin === nextProps.disableMargin && prevProps.showDaysOutsideCurrentMonth === nextProps.showDaysOutsideCurrentMonth && prevProps.disableHighlightToday === nextProps.disableHighlightToday && prevProps.className === nextProps.className && prevProps.sx === nextProps.sx && prevProps.outsideCurrentMonth === nextProps.outsideCurrentMonth && prevProps.onFocus === nextProps.onFocus && prevProps.onBlur === nextProps.onBlur && prevProps.onDaySelect === nextProps.onDaySelect;
// };
// process.env.NODE_ENV !== "production" ? PickersDayRaw.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------

//   /**
//    * Override or extend the styles applied to the component.
//    */
//   classes: PropTypes__default.object,

//   /**
//    * The date to show.
//    */
//   day: PropTypes__default.any.isRequired,

//   /**
//    * If `true`, renders as disabled.
//    * @default false
//    */
//   disabled: PropTypes__default.bool,

//   /**
//    * If `true`, today's date is rendering without highlighting with circle.
//    * @default false
//    */
//   disableHighlightToday: PropTypes__default.bool,

//   /**
//    * If `true`, days are rendering without margin. Useful for displaying linked range of days.
//    * @default false
//    */
//   disableMargin: PropTypes__default.bool,
//   isAnimating: PropTypes__default.bool,
//   onBlur: PropTypes__default.func,
//   onDaySelect: PropTypes__default.func.isRequired,
//   onFocus: PropTypes__default.func,
//   onKeyDown: PropTypes__default.func,

//   /**
//    * If `true`, day is outside of month and will be hidden.
//    */
//   outsideCurrentMonth: PropTypes__default.bool.isRequired,

//   /**
//    * If `true`, renders as selected.
//    * @default false
//    */
//   selected: PropTypes__default.bool,

//   /**
//    * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
//    * @default false
//    */
//   showDaysOutsideCurrentMonth: PropTypes__default.bool,

//   /**
//    * The system prop that allows defining system overrides as well as additional CSS styles.
//    */
//   sx: PropTypes__default.oneOfType([PropTypes__default.arrayOf(PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object, PropTypes__default.bool])), PropTypes__default.func, PropTypes__default.object]),

//   /**
//    * If `true`, renders as today date.
//    * @default false
//    */
//   today: PropTypes__default.bool
// } : void 0;
// /**
//  *
//  * Demos:
//  *
//  * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
//  *
//  * API:
//  *
//  * - [PickersDay API](https://mui.com/x/api/date-pickers/pickers-day/)
//  */

// const PickersDay = /*#__PURE__*/React.memo(PickersDayRaw, areDayPropsEqual);

// const getPickersSlideTransitionUtilityClass = slot => // TODO v6: Rename 'PrivatePickersSlideTransition' to 'MuiPickersSlideTransition' to follow convention
// generateUtilityClass$1('PrivatePickersSlideTransition', slot);
// const pickersSlideTransitionClasses = generateUtilityClasses$1( // TODO v6: Rename 'PrivatePickersSlideTransition' to 'MuiPickersSlideTransition' to follow convention
// 'PrivatePickersSlideTransition', ['root', 'slideEnter-left', 'slideEnter-right', 'slideEnterActive', 'slideExit', 'slideExitActiveLeft-left', 'slideExitActiveLeft-right']);

// const _excluded$O = ["children", "className", "reduceAnimations", "slideDirection", "transKey"];

// const useUtilityClasses$k = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root']
//   };
//   return unstable_composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
// };

// const slideAnimationDuration = 350;
// const PickersSlideTransitionRoot = styled$1(TransitionGroup, {
//   name: 'PrivatePickersSlideTransition',
//   slot: 'Root',
//   overridesResolver: (_, styles) => [styles.root, {
//     [`.${pickersSlideTransitionClasses['slideEnter-left']}`]: styles['slideEnter-left']
//   }, {
//     [`.${pickersSlideTransitionClasses['slideEnter-right']}`]: styles['slideEnter-right']
//   }, {
//     [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles.slideEnterActive
//   }, {
//     [`.${pickersSlideTransitionClasses.slideExit}`]: styles.slideExit
//   }, {
//     [`.${pickersSlideTransitionClasses['slideExitActiveLeft-left']}`]: styles['slideExitActiveLeft-left']
//   }, {
//     [`.${pickersSlideTransitionClasses['slideExitActiveLeft-right']}`]: styles['slideExitActiveLeft-right']
//   }]
// })(({
//   theme
// }) => {
//   const slideTransition = theme.transitions.create('transform', {
//     duration: slideAnimationDuration,
//     easing: 'cubic-bezier(0.35, 0.8, 0.4, 1)'
//   });
//   return {
//     display: 'block',
//     position: 'relative',
//     overflowX: 'hidden',
//     '& > *': {
//       position: 'absolute',
//       top: 0,
//       right: 0,
//       left: 0
//     },
//     [`& .${pickersSlideTransitionClasses['slideEnter-left']}`]: {
//       willChange: 'transform',
//       transform: 'translate(100%)',
//       zIndex: 1
//     },
//     [`& .${pickersSlideTransitionClasses['slideEnter-right']}`]: {
//       willChange: 'transform',
//       transform: 'translate(-100%)',
//       zIndex: 1
//     },
//     [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
//       transform: 'translate(0%)',
//       transition: slideTransition
//     },
//     [`& .${pickersSlideTransitionClasses.slideExit}`]: {
//       transform: 'translate(0%)'
//     },
//     [`& .${pickersSlideTransitionClasses['slideExitActiveLeft-left']}`]: {
//       willChange: 'transform',
//       transform: 'translate(-100%)',
//       transition: slideTransition,
//       zIndex: 0
//     },
//     [`& .${pickersSlideTransitionClasses['slideExitActiveLeft-right']}`]: {
//       willChange: 'transform',
//       transform: 'translate(100%)',
//       transition: slideTransition,
//       zIndex: 0
//     }
//   };
// });
// /**
//  * @ignore - do not document.
//  */

// const PickersSlideTransition = props => {
//   // TODO v6: add 'useThemeProps' once the component class names are aligned
//   const {
//     children,
//     className,
//     reduceAnimations,
//     slideDirection,
//     transKey
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$O);

//   const classes = useUtilityClasses$k(props);

//   if (reduceAnimations) {
//     return /*#__PURE__*/jsx("div", {
//       className: clsx$1(classes.root, className),
//       children: children
//     });
//   }

//   const transitionClasses = {
//     exit: pickersSlideTransitionClasses.slideExit,
//     enterActive: pickersSlideTransitionClasses.slideEnterActive,
//     enter: pickersSlideTransitionClasses[`slideEnter-${slideDirection}`],
//     exitActive: pickersSlideTransitionClasses[`slideExitActiveLeft-${slideDirection}`]
//   };
//   return /*#__PURE__*/jsx(PickersSlideTransitionRoot, {
//     className: clsx$1(classes.root, className),
//     childFactory: element => /*#__PURE__*/React.cloneElement(element, {
//       classNames: transitionClasses
//     }),
//     role: "presentation",
//     children: /*#__PURE__*/jsx(CSSTransition, _extends$u({
//       mountOnEnter: true,
//       unmountOnExit: true,
//       timeout: slideAnimationDuration,
//       classNames: transitionClasses
//     }, other, {
//       children: children
//     }), transKey)
//   });
// };

// const getDayPickerUtilityClass = slot => generateUtilityClass$1('MuiDayPicker', slot);
// generateUtilityClasses$1('MuiDayPicker', ['header', 'weekDayLabel', 'loadingContainer', 'slideTransition', 'monthContainer', 'weekContainer']);

// const useUtilityClasses$j = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     header: ['header'],
//     weekDayLabel: ['weekDayLabel'],
//     loadingContainer: ['loadingContainer'],
//     slideTransition: ['slideTransition'],
//     monthContainer: ['monthContainer'],
//     weekContainer: ['weekContainer']
//   };
//   return unstable_composeClasses(slots, getDayPickerUtilityClass, classes);
// };

// const defaultDayOfWeekFormatter = day => day.charAt(0).toUpperCase();

// const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
// const PickersCalendarDayHeader = styled$1('div', {
//   name: 'MuiDayPicker',
//   slot: 'Header',
//   overridesResolver: (_, styles) => styles.header
// })({
//   display: 'flex',
//   justifyContent: 'center',
//   alignItems: 'center'
// });
// const PickersCalendarWeekDayLabel = styled$1(Typography, {
//   name: 'MuiDayPicker',
//   slot: 'WeekDayLabel',
//   overridesResolver: (_, styles) => styles.weekDayLabel
// })(({
//   theme
// }) => ({
//   width: 36,
//   height: 40,
//   margin: '0 2px',
//   textAlign: 'center',
//   display: 'flex',
//   justifyContent: 'center',
//   alignItems: 'center',
//   color: theme.palette.text.secondary
// }));
// const PickersCalendarLoadingContainer = styled$1('div', {
//   name: 'MuiDayPicker',
//   slot: 'LoadingContainer',
//   overridesResolver: (_, styles) => styles.loadingContainer
// })({
//   display: 'flex',
//   justifyContent: 'center',
//   alignItems: 'center',
//   minHeight: weeksContainerHeight
// });
// const PickersCalendarSlideTransition = styled$1(PickersSlideTransition, {
//   name: 'MuiDayPicker',
//   slot: 'SlideTransition',
//   overridesResolver: (_, styles) => styles.slideTransition
// })({
//   minHeight: weeksContainerHeight
// });
// const PickersCalendarWeekContainer = styled$1('div', {
//   name: 'MuiDayPicker',
//   slot: 'MonthContainer',
//   overridesResolver: (_, styles) => styles.monthContainer
// })({
//   overflow: 'hidden'
// });
// const PickersCalendarWeek = styled$1('div', {
//   name: 'MuiDayPicker',
//   slot: 'WeekContainer',
//   overridesResolver: (_, styles) => styles.weekContainer
// })({
//   margin: `${DAY_MARGIN}px 0`,
//   display: 'flex',
//   justifyContent: 'center'
// });
// /**
//  * @ignore - do not document.
//  */

// function DayPicker(inProps) {
//   const now = useNow();
//   const utils = useUtils();
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiDayPicker'
//   });
//   const classes = useUtilityClasses$j(props);
//   const {
//     onFocusedDayChange,
//     className,
//     currentMonth,
//     selectedDays,
//     disabled,
//     disableHighlightToday,
//     focusedDay,
//     isMonthSwitchingAnimating,
//     loading,
//     onSelectedDaysChange,
//     onMonthSwitchingAnimationEnd,
//     readOnly,
//     reduceAnimations,
//     renderDay,
//     renderLoading = () => /*#__PURE__*/jsx("span", {
//       children: "..."
//     }),
//     showDaysOutsideCurrentMonth,
//     slideDirection,
//     TransitionProps,
//     disablePast,
//     disableFuture,
//     minDate,
//     maxDate,
//     shouldDisableDate,
//     dayOfWeekFormatter = defaultDayOfWeekFormatter,
//     hasFocus,
//     onFocusedViewChange,
//     gridLabelId
//   } = props;
//   const isDateDisabled = useIsDayDisabled({
//     shouldDisableDate,
//     minDate,
//     maxDate,
//     disablePast,
//     disableFuture
//   });
//   const [internalFocusedDay, setInternalFocusedDay] = React.useState(() => focusedDay || now);
//   const changeHasFocus = React.useCallback(newHasFocus => {
//     if (onFocusedViewChange) {
//       onFocusedViewChange(newHasFocus);
//     }
//   }, [onFocusedViewChange]);
//   const handleDaySelect = React.useCallback((day, isFinish = 'finish') => {
//     if (readOnly) {
//       return;
//     }

//     onSelectedDaysChange(day, isFinish);
//   }, [onSelectedDaysChange, readOnly]);
//   const focusDay = React.useCallback(day => {
//     if (!isDateDisabled(day)) {
//       onFocusedDayChange(day);
//       setInternalFocusedDay(day);
//       changeHasFocus(true);
//     }
//   }, [isDateDisabled, onFocusedDayChange, changeHasFocus]);
//   const theme = useTheme$2();

//   function handleKeyDown(event, day) {
//     switch (event.key) {
//       case 'ArrowUp':
//         focusDay(utils.addDays(day, -7));
//         event.preventDefault();
//         break;

//       case 'ArrowDown':
//         focusDay(utils.addDays(day, 7));
//         event.preventDefault();
//         break;

//       case 'ArrowLeft':
//         {
//           const newFocusedDayDefault = utils.addDays(day, theme.direction === 'ltr' ? -1 : 1);
//           const nextAvailableMonth = theme.direction === 'ltr' ? utils.getPreviousMonth(day) : utils.getNextMonth(day);
//           const closestDayToFocus = findClosestEnabledDate({
//             utils,
//             date: newFocusedDayDefault,
//             minDate: theme.direction === 'ltr' ? utils.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
//             maxDate: theme.direction === 'ltr' ? newFocusedDayDefault : utils.endOfMonth(nextAvailableMonth),
//             isDateDisabled
//           });
//           focusDay(closestDayToFocus || newFocusedDayDefault);
//           event.preventDefault();
//           break;
//         }

//       case 'ArrowRight':
//         {
//           const newFocusedDayDefault = utils.addDays(day, theme.direction === 'ltr' ? 1 : -1);
//           const nextAvailableMonth = theme.direction === 'ltr' ? utils.getNextMonth(day) : utils.getPreviousMonth(day);
//           const closestDayToFocus = findClosestEnabledDate({
//             utils,
//             date: newFocusedDayDefault,
//             minDate: theme.direction === 'ltr' ? newFocusedDayDefault : utils.startOfMonth(nextAvailableMonth),
//             maxDate: theme.direction === 'ltr' ? utils.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
//             isDateDisabled
//           });
//           focusDay(closestDayToFocus || newFocusedDayDefault);
//           event.preventDefault();
//           break;
//         }

//       case 'Home':
//         focusDay(utils.startOfWeek(day));
//         event.preventDefault();
//         break;

//       case 'End':
//         focusDay(utils.endOfWeek(day));
//         event.preventDefault();
//         break;

//       case 'PageUp':
//         focusDay(utils.getNextMonth(day));
//         event.preventDefault();
//         break;

//       case 'PageDown':
//         focusDay(utils.getPreviousMonth(day));
//         event.preventDefault();
//         break;
//     }
//   }

//   function handleFocus(event, day) {
//     focusDay(day);
//   }

//   function handleBlur(event, day) {
//     if (hasFocus && utils.isSameDay(internalFocusedDay, day)) {
//       changeHasFocus(false);
//     }
//   }

//   const currentMonthNumber = utils.getMonth(currentMonth);
//   const validSelectedDays = selectedDays.filter(day => !!day).map(day => utils.startOfDay(day)); // need a new ref whenever the `key` of the transition changes: http://reactcommunity.org/react-transition-group/transition/#Transition-prop-nodeRef.

//   const transitionKey = currentMonthNumber; // eslint-disable-next-line react-hooks/exhaustive-deps

//   const slideNodeRef = React.useMemo(() => /*#__PURE__*/React.createRef(), [transitionKey]);
//   const startOfCurrentWeek = utils.startOfWeek(now);
//   const focusableDay = React.useMemo(() => {
//     const startOfMonth = utils.startOfMonth(currentMonth);
//     const endOfMonth = utils.endOfMonth(currentMonth);

//     if (isDateDisabled(internalFocusedDay) || utils.isAfterDay(internalFocusedDay, endOfMonth) || utils.isBeforeDay(internalFocusedDay, startOfMonth)) {
//       return findClosestEnabledDate({
//         utils,
//         date: internalFocusedDay,
//         minDate: startOfMonth,
//         maxDate: endOfMonth,
//         disablePast,
//         disableFuture,
//         isDateDisabled
//       });
//     }

//     return internalFocusedDay;
//   }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils]);
//   return /*#__PURE__*/jsxs("div", {
//     role: "grid",
//     "aria-labelledby": gridLabelId,
//     children: [/*#__PURE__*/jsx(PickersCalendarDayHeader, {
//       role: "row",
//       className: classes.header,
//       children: utils.getWeekdays().map((day, i) => {
//         var _dayOfWeekFormatter;

//         return /*#__PURE__*/jsx(PickersCalendarWeekDayLabel, {
//           variant: "caption",
//           role: "columnheader",
//           "aria-label": utils.format(utils.addDays(startOfCurrentWeek, i), 'weekday'),
//           className: classes.weekDayLabel,
//           children: (_dayOfWeekFormatter = dayOfWeekFormatter == null ? void 0 : dayOfWeekFormatter(day)) != null ? _dayOfWeekFormatter : day
//         }, day + i.toString());
//       })
//     }), loading ? /*#__PURE__*/jsx(PickersCalendarLoadingContainer, {
//       className: classes.loadingContainer,
//       children: renderLoading()
//     }) : /*#__PURE__*/jsx(PickersCalendarSlideTransition, _extends$u({
//       transKey: transitionKey,
//       onExited: onMonthSwitchingAnimationEnd,
//       reduceAnimations: reduceAnimations,
//       slideDirection: slideDirection,
//       className: clsx$1(className, classes.slideTransition)
//     }, TransitionProps, {
//       nodeRef: slideNodeRef,
//       children: /*#__PURE__*/jsx(PickersCalendarWeekContainer, {
//         ref: slideNodeRef,
//         role: "rowgroup",
//         className: classes.monthContainer,
//         children: utils.getWeekArray(currentMonth).map(week => /*#__PURE__*/jsx(PickersCalendarWeek, {
//           role: "row",
//           className: classes.weekContainer,
//           children: week.map(day => {
//             const isFocusableDay = focusableDay !== null && utils.isSameDay(day, focusableDay);
//             const isSelected = validSelectedDays.some(selectedDay => utils.isSameDay(selectedDay, day));
//             const isToday = utils.isSameDay(day, now);
//             const pickersDayProps = {
//               key: day == null ? void 0 : day.toString(),
//               day,
//               isAnimating: isMonthSwitchingAnimating,
//               disabled: disabled || isDateDisabled(day),
//               autoFocus: hasFocus && isFocusableDay,
//               today: isToday,
//               outsideCurrentMonth: utils.getMonth(day) !== currentMonthNumber,
//               selected: isSelected,
//               disableHighlightToday,
//               showDaysOutsideCurrentMonth,
//               onKeyDown: handleKeyDown,
//               onFocus: handleFocus,
//               onBlur: handleBlur,
//               onDaySelect: handleDaySelect,
//               tabIndex: isFocusableDay ? 0 : -1,
//               role: 'gridcell',
//               'aria-selected': isSelected
//             };

//             if (isToday) {
//               pickersDayProps['aria-current'] = 'date';
//             }

//             return renderDay ? renderDay(day, validSelectedDays, pickersDayProps) : /*#__PURE__*/createElement(PickersDay, _extends$u({}, pickersDayProps, {
//               key: pickersDayProps.key
//             }));
//           })
//         }, `week-${week[0]}`))
//       })
//     }))]
//   });
// }

// function useViews({
//   onChange,
//   onViewChange,
//   openTo,
//   view,
//   views
// }) {
//   var _views, _views2;

//   const [openView, setOpenView] = useControlled$2({
//     name: 'Picker',
//     state: 'view',
//     controlled: view,
//     default: openTo && arrayIncludes(views, openTo) ? openTo : views[0]
//   });
//   const previousView = (_views = views[views.indexOf(openView) - 1]) != null ? _views : null;
//   const nextView = (_views2 = views[views.indexOf(openView) + 1]) != null ? _views2 : null;
//   const changeView = React.useCallback(newView => {
//     setOpenView(newView);

//     if (onViewChange) {
//       onViewChange(newView);
//     }
//   }, [setOpenView, onViewChange]);
//   const openNext = React.useCallback(() => {
//     if (nextView) {
//       changeView(nextView);
//     }
//   }, [nextView, changeView]);
//   const handleChangeAndOpenNext = React.useCallback((date, currentViewSelectionState) => {
//     const isSelectionFinishedOnCurrentView = currentViewSelectionState === 'finish';
//     const globalSelectionState = isSelectionFinishedOnCurrentView && Boolean(nextView) ? 'partial' : currentViewSelectionState;
//     onChange(date, globalSelectionState);

//     if (isSelectionFinishedOnCurrentView) {
//       openNext();
//     }
//   }, [nextView, onChange, openNext]);
//   return {
//     handleChangeAndOpenNext,
//     nextView,
//     previousView,
//     openNext,
//     openView,
//     setOpenView: changeView
//   };
// }

// const ArrowDropDown = createSvgIcon( /*#__PURE__*/jsx("path", {
//   d: "M7 10l5 5 5-5z"
// }), 'ArrowDropDown');
// /**
//  * @ignore - internal component.
//  */

// const ArrowLeft = createSvgIcon( /*#__PURE__*/jsx("path", {
//   d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
// }), 'ArrowLeft');
// /**
//  * @ignore - internal component.
//  */

// const ArrowRight = createSvgIcon( /*#__PURE__*/jsx("path", {
//   d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
// }), 'ArrowRight');
// /**
//  * @ignore - internal component.
//  */

// const Calendar = createSvgIcon( /*#__PURE__*/jsx("path", {
//   d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
// }), 'Calendar');
// /**
//  * @ignore - internal component.
//  */

// const Clock$1 = createSvgIcon( /*#__PURE__*/jsxs(React.Fragment, {
//   children: [/*#__PURE__*/jsx("path", {
//     d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
//   }), /*#__PURE__*/jsx("path", {
//     d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
//   })]
// }), 'Clock');
// /**
//  * @ignore - internal component.
//  */

// const DateRange = createSvgIcon( /*#__PURE__*/jsx("path", {
//   d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
// }), 'DateRange');
// /**
//  * @ignore - internal component.
//  */

// const Pen = createSvgIcon( /*#__PURE__*/jsx("path", {
//   d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
// }), 'Pen');
// /**
//  * @ignore - internal component.
//  */

// const Time = createSvgIcon( /*#__PURE__*/jsxs(React.Fragment, {
//   children: [/*#__PURE__*/jsx("path", {
//     d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
//   }), /*#__PURE__*/jsx("path", {
//     d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
//   })]
// }), 'Time');

// function getPickersArrowSwitcherUtilityClass(slot) {
//   return generateUtilityClass$1('MuiPickersArrowSwitcher', slot);
// }
// generateUtilityClasses$1('MuiPickersArrowSwitcher', ['root', 'spacer', 'button']);

// const _excluded$N = ["children", "className", "components", "componentsProps", "isLeftDisabled", "isLeftHidden", "isRightDisabled", "isRightHidden", "leftArrowButtonText", "onLeftClick", "onRightClick", "rightArrowButtonText"];

// const useUtilityClasses$i = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     spacer: ['spacer'],
//     button: ['button']
//   };
//   return unstable_composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
// };

// const PickersArrowSwitcherRoot = styled$1('div', {
//   name: 'MuiPickersArrowSwitcher',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })({
//   display: 'flex'
// });
// const PickersArrowSwitcherSpacer = styled$1('div', {
//   name: 'MuiPickersArrowSwitcher',
//   slot: 'Spacer',
//   overridesResolver: (props, styles) => styles.spacer
// })(({
//   theme
// }) => ({
//   width: theme.spacing(3)
// }));
// const PickersArrowSwitcherButton = styled$1(IconButton$1, {
//   name: 'MuiPickersArrowSwitcher',
//   slot: 'Button',
//   overridesResolver: (props, styles) => styles.button
// })(({
//   ownerState
// }) => _extends$u({}, ownerState.hidden && {
//   visibility: 'hidden'
// }));
// const PickersArrowSwitcher = /*#__PURE__*/React.forwardRef(function PickersArrowSwitcher(inProps, ref) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiPickersArrowSwitcher'
//   });

//   const {
//     children,
//     className,
//     components,
//     componentsProps,
//     isLeftDisabled,
//     isLeftHidden,
//     isRightDisabled,
//     isRightHidden,
//     leftArrowButtonText,
//     onLeftClick,
//     onRightClick,
//     rightArrowButtonText
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$N);

//   const theme = useTheme$2();
//   const isRtl = theme.direction === 'rtl';
//   const leftArrowButtonProps = (componentsProps == null ? void 0 : componentsProps.leftArrowButton) || {};
//   const LeftArrowIcon = (components == null ? void 0 : components.LeftArrowIcon) || ArrowLeft;
//   const rightArrowButtonProps = (componentsProps == null ? void 0 : componentsProps.rightArrowButton) || {};
//   const RightArrowIcon = (components == null ? void 0 : components.RightArrowIcon) || ArrowRight;
//   const ownerState = props;
//   const classes = useUtilityClasses$i(ownerState);
//   return /*#__PURE__*/jsxs(PickersArrowSwitcherRoot, _extends$u({
//     ref: ref,
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState
//   }, other, {
//     children: [/*#__PURE__*/jsx(PickersArrowSwitcherButton, _extends$u({
//       as: components == null ? void 0 : components.LeftArrowButton,
//       size: "small",
//       "aria-label": leftArrowButtonText,
//       title: leftArrowButtonText,
//       disabled: isLeftDisabled,
//       edge: "end",
//       onClick: onLeftClick
//     }, leftArrowButtonProps, {
//       className: clsx$1(classes.button, leftArrowButtonProps.className),
//       ownerState: _extends$u({}, ownerState, leftArrowButtonProps, {
//         hidden: isLeftHidden
//       }),
//       children: isRtl ? /*#__PURE__*/jsx(RightArrowIcon, {}) : /*#__PURE__*/jsx(LeftArrowIcon, {})
//     })), children ? /*#__PURE__*/jsx(Typography, {
//       variant: "subtitle1",
//       component: "span",
//       children: children
//     }) : /*#__PURE__*/jsx(PickersArrowSwitcherSpacer, {
//       className: classes.spacer,
//       ownerState: ownerState
//     }), /*#__PURE__*/jsx(PickersArrowSwitcherButton, _extends$u({
//       as: components == null ? void 0 : components.RightArrowButton,
//       size: "small",
//       "aria-label": rightArrowButtonText,
//       title: rightArrowButtonText,
//       edge: "start",
//       disabled: isRightDisabled,
//       onClick: onRightClick
//     }, rightArrowButtonProps, {
//       className: clsx$1(classes.button, rightArrowButtonProps.className),
//       ownerState: _extends$u({}, ownerState, rightArrowButtonProps, {
//         hidden: isRightHidden
//       }),
//       children: isRtl ? /*#__PURE__*/jsx(LeftArrowIcon, {}) : /*#__PURE__*/jsx(RightArrowIcon, {})
//     }))]
//   }));
// });

// const getMeridiem = (date, utils) => {
//   if (!date) {
//     return null;
//   }

//   return utils.getHours(date) >= 12 ? 'pm' : 'am';
// };
// const convertValueToMeridiem = (value, meridiem, ampm) => {
//   if (ampm) {
//     const currentMeridiem = value >= 12 ? 'pm' : 'am';

//     if (currentMeridiem !== meridiem) {
//       return meridiem === 'am' ? value - 12 : value + 12;
//     }
//   }

//   return value;
// };
// const convertToMeridiem = (time, meridiem, ampm, utils) => {
//   const newHoursAmount = convertValueToMeridiem(utils.getHours(time), meridiem, ampm);
//   return utils.setHours(time, newHoursAmount);
// };
// const getSecondsInDay = (date, utils) => {
//   return utils.getHours(date) * 3600 + utils.getMinutes(date) * 60 + utils.getSeconds(date);
// };
// const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation = false, utils) => (dateLeft, dateRight) => {
//   if (disableIgnoringDatePartForTimeValidation) {
//     return utils.isAfter(dateLeft, dateRight);
//   }

//   return getSecondsInDay(dateLeft, utils) > getSecondsInDay(dateRight, utils);
// };

// function useNextMonthDisabled(month, {
//   disableFuture,
//   maxDate
// }) {
//   const utils = useUtils();
//   return React.useMemo(() => {
//     const now = utils.date();
//     const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);
//     return !utils.isAfter(lastEnabledMonth, month);
//   }, [disableFuture, maxDate, month, utils]);
// }
// function usePreviousMonthDisabled(month, {
//   disablePast,
//   minDate
// }) {
//   const utils = useUtils();
//   return React.useMemo(() => {
//     const now = utils.date();
//     const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
//     return !utils.isBefore(firstEnabledMonth, month);
//   }, [disablePast, minDate, month, utils]);
// }
// function useMeridiemMode(date, ampm, onChange) {
//   const utils = useUtils();
//   const meridiemMode = getMeridiem(date, utils);
//   const handleMeridiemChange = React.useCallback(mode => {
//     const timeWithMeridiem = date == null ? null : convertToMeridiem(date, mode, Boolean(ampm), utils);
//     onChange(timeWithMeridiem, 'partial');
//   }, [ampm, date, onChange, utils]);
//   return {
//     meridiemMode,
//     handleMeridiemChange
//   };
// }

// const buildDeprecatedPropsWarning = message => {
//   let alreadyWarned = false;

//   if (process.env.NODE_ENV === 'production') {
//     return () => {};
//   }

//   const cleanMessage = Array.isArray(message) ? message.join('\n') : message;
//   return deprecatedProps => {
//     const deprecatedKeys = Object.entries(deprecatedProps).filter(([, value]) => value !== undefined).map(([key]) => `- ${key}`);

//     if (!alreadyWarned && deprecatedKeys.length > 0) {
//       alreadyWarned = true;
//       console.warn([cleanMessage, 'deprecated props observed:', ...deprecatedKeys].join('\n'));
//     }
//   };
// };

// const getPickersCalendarHeaderUtilityClass = slot => generateUtilityClass$1('MuiPickersCalendarHeader', slot);
// generateUtilityClasses$1('MuiPickersCalendarHeader', ['root', 'labelContainer', 'label', 'switchViewButton', 'switchViewIcon']);

// const useUtilityClasses$h = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     labelContainer: ['labelContainer'],
//     label: ['label'],
//     switchViewButton: ['switchViewButton'],
//     switchViewIcon: ['switchViewIcon']
//   };
//   return unstable_composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
// };

// const PickersCalendarHeaderRoot = styled$1('div', {
//   name: 'MuiPickersCalendarHeader',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })({
//   display: 'flex',
//   alignItems: 'center',
//   marginTop: 16,
//   marginBottom: 8,
//   paddingLeft: 24,
//   paddingRight: 12,
//   // prevent jumping in safari
//   maxHeight: 30,
//   minHeight: 30
// });
// const PickersCalendarHeaderLabelContainer = styled$1('div', {
//   name: 'MuiPickersCalendarHeader',
//   slot: 'LabelContainer',
//   overridesResolver: (_, styles) => styles.labelContainer
// })(({
//   theme
// }) => _extends$u({
//   display: 'flex',
//   maxHeight: 30,
//   overflow: 'hidden',
//   alignItems: 'center',
//   cursor: 'pointer',
//   marginRight: 'auto'
// }, theme.typography.body1, {
//   fontWeight: theme.typography.fontWeightMedium
// }));
// const PickersCalendarHeaderLabel = styled$1('div', {
//   name: 'MuiPickersCalendarHeader',
//   slot: 'Label',
//   overridesResolver: (_, styles) => styles.label
// })({
//   marginRight: 6
// });
// const PickersCalendarHeaderSwitchViewButton = styled$1(IconButton$1, {
//   name: 'MuiPickersCalendarHeader',
//   slot: 'SwitchViewButton',
//   overridesResolver: (_, styles) => styles.switchViewButton
// })({
//   marginRight: 'auto'
// });
// const PickersCalendarHeaderSwitchViewIcon = styled$1(ArrowDropDown, {
//   name: 'MuiPickersCalendarHeader',
//   slot: 'SwitchViewIcon',
//   overridesResolver: (_, styles) => styles.switchViewIcon
// })(({
//   theme,
//   ownerState
// }) => _extends$u({
//   willChange: 'transform',
//   transition: theme.transitions.create('transform'),
//   transform: 'rotate(0deg)'
// }, ownerState.openView === 'year' && {
//   transform: 'rotate(180deg)'
// }));
// const deprecatedPropsWarning$1 = buildDeprecatedPropsWarning('Props for translation are deprecated. See https://mui.com/x/react-date-pickers/localization for more information.');
// /**
//  * @ignore - do not document.
//  */

// function PickersCalendarHeader(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiPickersCalendarHeader'
//   });
//   const {
//     components = {},
//     componentsProps = {},
//     currentMonth: month,
//     disabled,
//     disableFuture,
//     disablePast,
//     getViewSwitchingButtonText: getViewSwitchingButtonTextProp,
//     leftArrowButtonText: leftArrowButtonTextProp,
//     maxDate,
//     minDate,
//     onMonthChange,
//     onViewChange,
//     openView: currentView,
//     reduceAnimations,
//     rightArrowButtonText: rightArrowButtonTextProp,
//     views,
//     labelId
//   } = props;
//   deprecatedPropsWarning$1({
//     leftArrowButtonText: leftArrowButtonTextProp,
//     rightArrowButtonText: rightArrowButtonTextProp,
//     getViewSwitchingButtonText: getViewSwitchingButtonTextProp
//   });
//   const localeText = useLocaleText();
//   const leftArrowButtonText = leftArrowButtonTextProp != null ? leftArrowButtonTextProp : localeText.previousMonth;
//   const rightArrowButtonText = rightArrowButtonTextProp != null ? rightArrowButtonTextProp : localeText.nextMonth;
//   const getViewSwitchingButtonText = getViewSwitchingButtonTextProp != null ? getViewSwitchingButtonTextProp : localeText.calendarViewSwitchingButtonAriaLabel;
//   const utils = useUtils();
//   const classes = useUtilityClasses$h(props);
//   const switchViewButtonProps = componentsProps.switchViewButton || {};

//   const selectNextMonth = () => onMonthChange(utils.getNextMonth(month), 'left');

//   const selectPreviousMonth = () => onMonthChange(utils.getPreviousMonth(month), 'right');

//   const isNextMonthDisabled = useNextMonthDisabled(month, {
//     disableFuture,
//     maxDate
//   });
//   const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
//     disablePast,
//     minDate
//   });

//   const handleToggleView = () => {
//     if (views.length === 1 || !onViewChange || disabled) {
//       return;
//     }

//     if (views.length === 2) {
//       onViewChange(views.find(view => view !== currentView) || views[0]);
//     } else {
//       // switching only between first 2
//       const nextIndexToOpen = views.indexOf(currentView) !== 0 ? 0 : 1;
//       onViewChange(views[nextIndexToOpen]);
//     }
//   }; // No need to display more information


//   if (views.length === 1 && views[0] === 'year') {
//     return null;
//   }

//   const ownerState = props;
//   return /*#__PURE__*/jsxs(PickersCalendarHeaderRoot, {
//     ownerState: ownerState,
//     className: classes.root,
//     children: [/*#__PURE__*/jsxs(PickersCalendarHeaderLabelContainer, {
//       role: "presentation",
//       onClick: handleToggleView,
//       ownerState: ownerState // putting this on the label item element below breaks when using transition
//       ,
//       "aria-live": "polite",
//       className: classes.labelContainer,
//       children: [/*#__PURE__*/jsx(PickersFadeTransitionGroup, {
//         reduceAnimations: reduceAnimations,
//         transKey: utils.format(month, 'monthAndYear'),
//         children: /*#__PURE__*/jsx(PickersCalendarHeaderLabel, {
//           id: labelId,
//           ownerState: ownerState,
//           className: classes.label,
//           children: utils.format(month, 'monthAndYear')
//         })
//       }), views.length > 1 && !disabled && /*#__PURE__*/jsx(PickersCalendarHeaderSwitchViewButton, _extends$u({
//         size: "small",
//         as: components.SwitchViewButton,
//         "aria-label": getViewSwitchingButtonText(currentView),
//         className: classes.switchViewButton
//       }, switchViewButtonProps, {
//         children: /*#__PURE__*/jsx(PickersCalendarHeaderSwitchViewIcon, {
//           as: components.SwitchViewIcon,
//           ownerState: ownerState,
//           className: classes.switchViewIcon
//         })
//       }))]
//     }), /*#__PURE__*/jsx(Fade, {
//       in: currentView === 'day',
//       children: /*#__PURE__*/jsx(PickersArrowSwitcher, {
//         leftArrowButtonText: leftArrowButtonText,
//         rightArrowButtonText: rightArrowButtonText,
//         components: components,
//         componentsProps: componentsProps,
//         onLeftClick: selectPreviousMonth,
//         onRightClick: selectNextMonth,
//         isLeftDisabled: isPreviousMonthDisabled,
//         isRightDisabled: isNextMonthDisabled
//       })
//     })]
//   });
// }

// /**
//  * TODO consider getting rid from wrapper variant
//  * @ignore - internal component.
//  */
// const WrapperVariantContext = /*#__PURE__*/React.createContext(null);

// function getPickersYearUtilityClass(slot) {
//   // TODO v6: Rename 'PrivatePickersYear' to 'MuiPickersYear' to follow convention
//   return generateUtilityClass$1('PrivatePickersYear', slot);
// } // TODO v6: Rename 'PrivatePickersYear' to 'MuiPickersYear' to follow convention

// const pickersYearClasses = generateUtilityClasses$1('PrivatePickersYear', ['root', 'modeDesktop', 'modeMobile', 'yearButton', 'selected', 'disabled']);

// const _excluded$M = ["autoFocus", "className", "children", "disabled", "onClick", "onKeyDown", "value", "tabIndex", "onFocus", "onBlur"];

// const useUtilityClasses$g = ownerState => {
//   const {
//     wrapperVariant,
//     disabled,
//     selected,
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root', wrapperVariant && `mode${capitalize$1(wrapperVariant)}`],
//     yearButton: ['yearButton', disabled && 'disabled', selected && 'selected']
//   };
//   return unstable_composeClasses(slots, getPickersYearUtilityClass, classes);
// };

// const PickersYearRoot = styled$1('div', {
//   name: 'PrivatePickersYear',
//   slot: 'Root',
//   overridesResolver: (_, styles) => [styles.root, {
//     [`&.${pickersYearClasses.modeDesktop}`]: styles.modeDesktop
//   }, {
//     [`&.${pickersYearClasses.modeMobile}`]: styles.modeMobile
//   }]
// })(({
//   ownerState
// }) => _extends$u({
//   flexBasis: '33.3%',
//   display: 'flex',
//   alignItems: 'center',
//   justifyContent: 'center'
// }, (ownerState == null ? void 0 : ownerState.wrapperVariant) === 'desktop' && {
//   flexBasis: '25%'
// }));
// const PickersYearButton = styled$1('button', {
//   name: 'PrivatePickersYear',
//   slot: 'Button',
//   overridesResolver: (_, styles) => [styles.button, {
//     [`&.${pickersYearClasses.disabled}`]: styles.disabled
//   }, {
//     [`&.${pickersYearClasses.selected}`]: styles.selected
//   }]
// })(({
//   theme
// }) => _extends$u({
//   color: 'unset',
//   backgroundColor: 'transparent',
//   border: 0,
//   outline: 0
// }, theme.typography.subtitle1, {
//   margin: '8px 0',
//   height: 36,
//   width: 72,
//   borderRadius: 18,
//   cursor: 'pointer',
//   '&:focus, &:hover': {
//     backgroundColor: alpha$1(theme.palette.action.active, theme.palette.action.hoverOpacity)
//   },
//   [`&.${pickersYearClasses.disabled}`]: {
//     color: theme.palette.text.secondary
//   },
//   [`&.${pickersYearClasses.selected}`]: {
//     color: theme.palette.primary.contrastText,
//     backgroundColor: theme.palette.primary.main,
//     '&:focus, &:hover': {
//       backgroundColor: theme.palette.primary.dark
//     }
//   }
// }));

// const noop$3 = () => {};
// /**
//  * @ignore - internal component.
//  */


// const PickersYear = /*#__PURE__*/React.forwardRef(function PickersYear(props, forwardedRef) {
//   // TODO v6: add 'useThemeProps' once the component class names are aligned
//   const {
//     autoFocus,
//     className,
//     children,
//     disabled,
//     onClick,
//     onKeyDown,
//     value,
//     tabIndex,
//     onFocus = noop$3,
//     onBlur = noop$3
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$M);

//   const ref = React.useRef(null);
//   const refHandle = useForkRef$1(ref, forwardedRef);
//   const wrapperVariant = React.useContext(WrapperVariantContext);

//   const ownerState = _extends$u({}, props, {
//     wrapperVariant
//   });

//   const classes = useUtilityClasses$g(ownerState); // We can't forward the `autoFocus` to the button because it is a native button, not a MUI Button

//   React.useEffect(() => {
//     if (autoFocus) {
//       // `ref.current` being `null` would be a bug in MUI.
//       ref.current.focus();
//     }
//   }, [autoFocus]);
//   return /*#__PURE__*/jsx(PickersYearRoot, {
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState,
//     children: /*#__PURE__*/jsx(PickersYearButton, _extends$u({
//       ref: refHandle,
//       disabled: disabled,
//       type: "button",
//       tabIndex: disabled ? -1 : tabIndex,
//       onClick: event => onClick(event, value),
//       onKeyDown: event => onKeyDown(event, value),
//       onFocus: event => onFocus(event, value),
//       onBlur: event => onBlur(event, value),
//       className: classes.yearButton,
//       ownerState: ownerState
//     }, other, {
//       children: children
//     }))
//   });
// });

// function getYearPickerUtilityClass(slot) {
//   return generateUtilityClass$1('MuiYearPicker', slot);
// }
// generateUtilityClasses$1('MuiYearPicker', ['root']);

// const useUtilityClasses$f = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root']
//   };
//   return unstable_composeClasses(slots, getYearPickerUtilityClass, classes);
// };

// function useYearPickerDefaultizedProps(props, name) {
//   const utils = useUtils();
//   const defaultDates = useDefaultDates();
//   const themeProps = useThemeProps({
//     props,
//     name
//   });
//   return _extends$u({
//     disablePast: false,
//     disableFuture: false
//   }, themeProps, {
//     minDate: parseNonNullablePickerDate(utils, themeProps.minDate, defaultDates.minDate),
//     maxDate: parseNonNullablePickerDate(utils, themeProps.maxDate, defaultDates.maxDate)
//   });
// }

// const YearPickerRoot = styled$1('div', {
//   name: 'MuiYearPicker',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })({
//   display: 'flex',
//   flexDirection: 'row',
//   flexWrap: 'wrap',
//   overflowY: 'auto',
//   height: '100%',
//   padding: '0 4px',
//   maxHeight: '304px'
// });
// const YearPicker = /*#__PURE__*/React.forwardRef(function YearPicker(inProps, ref) {
//   const now = useNow();
//   const theme = useTheme$2();
//   const utils = useUtils();
//   const props = useYearPickerDefaultizedProps(inProps, 'MuiYearPicker');
//   const {
//     autoFocus,
//     className,
//     date,
//     disabled,
//     disableFuture,
//     disablePast,
//     maxDate,
//     minDate,
//     onChange,
//     readOnly,
//     shouldDisableYear,
//     disableHighlightToday,
//     onYearFocus,
//     hasFocus,
//     onFocusedViewChange
//   } = props;
//   const ownerState = props;
//   const classes = useUtilityClasses$f(ownerState);
//   const selectedDateOrStartOfYear = React.useMemo(() => date != null ? date : utils.startOfYear(now), [now, utils, date]);
//   const currentYear = React.useMemo(() => {
//     if (date != null) {
//       return utils.getYear(date);
//     }

//     if (disableHighlightToday) {
//       return null;
//     }

//     return utils.getYear(now);
//   }, [now, date, utils, disableHighlightToday]);
//   const wrapperVariant = React.useContext(WrapperVariantContext);
//   const selectedYearRef = React.useRef(null);
//   const [focusedYear, setFocusedYear] = React.useState(() => currentYear || utils.getYear(now));
//   const [internalHasFocus, setInternalHasFocus] = useControlled({
//     name: 'YearPicker',
//     state: 'hasFocus',
//     controlled: hasFocus,
//     default: autoFocus
//   });
//   const changeHasFocus = React.useCallback(newHasFocus => {
//     setInternalHasFocus(newHasFocus);

//     if (onFocusedViewChange) {
//       onFocusedViewChange(newHasFocus);
//     }
//   }, [setInternalHasFocus, onFocusedViewChange]);
//   const isYearDisabled = React.useCallback(dateToValidate => {
//     if (disablePast && utils.isBeforeYear(dateToValidate, now)) {
//       return true;
//     }

//     if (disableFuture && utils.isAfterYear(dateToValidate, now)) {
//       return true;
//     }

//     if (minDate && utils.isBeforeYear(dateToValidate, minDate)) {
//       return true;
//     }

//     if (maxDate && utils.isAfterYear(dateToValidate, maxDate)) {
//       return true;
//     }

//     if (shouldDisableYear && shouldDisableYear(dateToValidate)) {
//       return true;
//     }

//     return false;
//   }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableYear, utils]);

//   const handleYearSelection = (event, year, isFinish = 'finish') => {
//     if (readOnly) {
//       return;
//     }

//     const newDate = utils.setYear(selectedDateOrStartOfYear, year);
//     onChange(newDate, isFinish);
//   };

//   const focusYear = React.useCallback(year => {
//     if (!isYearDisabled(utils.setYear(selectedDateOrStartOfYear, year))) {
//       setFocusedYear(year);
//       changeHasFocus(true);
//       onYearFocus == null ? void 0 : onYearFocus(year);
//     }
//   }, [isYearDisabled, utils, selectedDateOrStartOfYear, changeHasFocus, onYearFocus]);
//   React.useEffect(() => {
//     setFocusedYear(prevFocusedYear => currentYear !== null && prevFocusedYear !== currentYear ? currentYear : prevFocusedYear);
//   }, [currentYear]);
//   const yearsInRow = wrapperVariant === 'desktop' ? 4 : 3;
//   const handleKeyDown = React.useCallback((event, year) => {
//     switch (event.key) {
//       case 'ArrowUp':
//         focusYear(year - yearsInRow);
//         event.preventDefault();
//         break;

//       case 'ArrowDown':
//         focusYear(year + yearsInRow);
//         event.preventDefault();
//         break;

//       case 'ArrowLeft':
//         focusYear(year + (theme.direction === 'ltr' ? -1 : 1));
//         event.preventDefault();
//         break;

//       case 'ArrowRight':
//         focusYear(year + (theme.direction === 'ltr' ? 1 : -1));
//         event.preventDefault();
//         break;
//     }
//   }, [focusYear, theme.direction, yearsInRow]);
//   const handleFocus = React.useCallback((event, year) => {
//     focusYear(year);
//   }, [focusYear]);
//   const handleBlur = React.useCallback((event, year) => {
//     if (focusedYear === year) {
//       changeHasFocus(false);
//     }
//   }, [focusedYear, changeHasFocus]);
//   const nowYear = utils.getYear(now);
//   const scrollerRef = React.useRef(null);
//   const handleRef = useForkRef$1(ref, scrollerRef);
//   React.useEffect(() => {
//     if (autoFocus || scrollerRef.current === null) {
//       return;
//     }

//     const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');

//     if (!tabbableButton) {
//       return;
//     } // Taken from useScroll in x-data-grid, but vertically centered


//     const offsetHeight = tabbableButton.offsetHeight;
//     const offsetTop = tabbableButton.offsetTop;
//     const clientHeight = scrollerRef.current.clientHeight;
//     const scrollTop = scrollerRef.current.scrollTop;
//     const elementBottom = offsetTop + offsetHeight;

//     if (offsetHeight > clientHeight || offsetTop < scrollTop) {
//       // Button already visible
//       return;
//     }

//     scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
//   }, [autoFocus]);
//   return /*#__PURE__*/jsx(YearPickerRoot, {
//     ref: handleRef,
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState,
//     children: utils.getYearRange(minDate, maxDate).map(year => {
//       const yearNumber = utils.getYear(year);
//       const selected = yearNumber === currentYear;
//       return /*#__PURE__*/jsx(PickersYear, {
//         selected: selected,
//         value: yearNumber,
//         onClick: handleYearSelection,
//         onKeyDown: handleKeyDown,
//         autoFocus: internalHasFocus && yearNumber === focusedYear,
//         ref: selected ? selectedYearRef : undefined,
//         disabled: disabled || isYearDisabled(year),
//         tabIndex: yearNumber === focusedYear ? 0 : -1,
//         onFocus: handleFocus,
//         onBlur: handleBlur,
//         "aria-current": nowYear === yearNumber ? 'date' : undefined,
//         children: utils.format(year, 'year')
//       }, utils.format(year, 'year'));
//     })
//   });
// });
// process.env.NODE_ENV !== "production" ? YearPicker.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------
//   autoFocus: PropTypes__default.bool,
//   classes: PropTypes__default.object,
//   className: PropTypes__default.string,
//   date: PropTypes__default.any,
//   disabled: PropTypes__default.bool,

//   /**
//    * If `true` future days are disabled.
//    * @default false
//    */
//   disableFuture: PropTypes__default.bool,

//   /**
//    * If `true`, today's date is rendering without highlighting with circle.
//    * @default false
//    */
//   disableHighlightToday: PropTypes__default.bool,

//   /**
//    * If `true` past days are disabled.
//    * @default false
//    */
//   disablePast: PropTypes__default.bool,
//   hasFocus: PropTypes__default.bool,

//   /**
//    * Maximal selectable date. @DateIOType
//    */
//   maxDate: PropTypes__default.any,

//   /**
//    * Minimal selectable date. @DateIOType
//    */
//   minDate: PropTypes__default.any,
//   onChange: PropTypes__default.func.isRequired,
//   onFocusedDayChange: PropTypes__default.func,
//   onFocusedViewChange: PropTypes__default.func,
//   onYearFocus: PropTypes__default.func,
//   readOnly: PropTypes__default.bool,

//   /**
//    * Disable specific years dynamically.
//    * Works like `shouldDisableDate` but for year selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} year The year to test.
//    * @returns {boolean} Returns `true` if the year should be disabled.
//    */
//   shouldDisableYear: PropTypes__default.func
// } : void 0;

// const PickerViewRoot = styled$1('div')({
//   overflowX: 'hidden',
//   width: DIALOG_WIDTH,
//   maxHeight: VIEW_HEIGHT,
//   display: 'flex',
//   flexDirection: 'column',
//   margin: '0 auto'
// });

// const defaultReduceAnimations = typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent);

// const getCalendarPickerUtilityClass = slot => generateUtilityClass$1('MuiCalendarPicker', slot);
// generateUtilityClasses$1('MuiCalendarPicker', ['root', 'viewTransitionContainer']);

// const _excluded$L = ["autoFocus", "onViewChange", "date", "disableFuture", "disablePast", "defaultCalendarMonth", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "classes"];

// const useUtilityClasses$e = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     viewTransitionContainer: ['viewTransitionContainer']
//   };
//   return unstable_composeClasses(slots, getCalendarPickerUtilityClass, classes);
// };

// function useCalendarPickerDefaultizedProps(props, name) {
//   const utils = useUtils();
//   const defaultDates = useDefaultDates();
//   const themeProps = useThemeProps({
//     props,
//     name
//   });
//   return _extends$u({
//     loading: false,
//     disablePast: false,
//     disableFuture: false,
//     openTo: 'day',
//     views: ['year', 'day'],
//     reduceAnimations: defaultReduceAnimations,
//     renderLoading: () => /*#__PURE__*/jsx("span", {
//       children: "..."
//     })
//   }, themeProps, {
//     minDate: parseNonNullablePickerDate(utils, themeProps.minDate, defaultDates.minDate),
//     maxDate: parseNonNullablePickerDate(utils, themeProps.maxDate, defaultDates.maxDate)
//   });
// }

// const CalendarPickerRoot = styled$1(PickerViewRoot, {
//   name: 'MuiCalendarPicker',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })({
//   display: 'flex',
//   flexDirection: 'column'
// });
// const CalendarPickerViewTransitionContainer = styled$1(PickersFadeTransitionGroup, {
//   name: 'MuiCalendarPicker',
//   slot: 'ViewTransitionContainer',
//   overridesResolver: (props, styles) => styles.viewTransitionContainer
// })({});

// /**
//  *
//  * Demos:
//  *
//  * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
//  *
//  * API:
//  *
//  * - [CalendarPicker API](https://mui.com/x/api/date-pickers/calendar-picker/)
//  */
// const CalendarPicker = /*#__PURE__*/React.forwardRef(function CalendarPicker(inProps, ref) {
//   const utils = useUtils();
//   const id = unstable_useId();
//   const props = useCalendarPickerDefaultizedProps(inProps, 'MuiCalendarPicker');

//   const {
//     autoFocus,
//     onViewChange,
//     date,
//     disableFuture,
//     disablePast,
//     defaultCalendarMonth,
//     onChange,
//     onYearChange,
//     onMonthChange,
//     reduceAnimations,
//     shouldDisableDate,
//     shouldDisableMonth,
//     shouldDisableYear,
//     view,
//     views,
//     openTo,
//     className,
//     disabled,
//     readOnly,
//     minDate,
//     maxDate,
//     disableHighlightToday,
//     focusedView,
//     onFocusedViewChange
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$L);

//   const {
//     openView,
//     setOpenView,
//     openNext
//   } = useViews({
//     view,
//     views,
//     openTo,
//     onChange,
//     onViewChange
//   });
//   const {
//     calendarState,
//     changeFocusedDay,
//     changeMonth,
//     handleChangeMonth,
//     isDateDisabled,
//     onMonthSwitchingAnimationEnd
//   } = useCalendarState({
//     date,
//     defaultCalendarMonth,
//     reduceAnimations,
//     onMonthChange,
//     minDate,
//     maxDate,
//     shouldDisableDate,
//     disablePast,
//     disableFuture
//   });
//   const handleDateMonthChange = React.useCallback((newDate, selectionState) => {
//     const startOfMonth = utils.startOfMonth(newDate);
//     const endOfMonth = utils.endOfMonth(newDate);
//     const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
//       utils,
//       date: newDate,
//       minDate: utils.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
//       maxDate: utils.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
//       disablePast,
//       disableFuture,
//       isDateDisabled
//     }) : newDate;

//     if (closestEnabledDate) {
//       onChange(closestEnabledDate, selectionState);
//       onMonthChange == null ? void 0 : onMonthChange(startOfMonth);
//     } else {
//       openNext();
//       changeMonth(startOfMonth);
//     }

//     changeFocusedDay(closestEnabledDate, true);
//   }, [changeFocusedDay, disableFuture, disablePast, isDateDisabled, maxDate, minDate, onChange, onMonthChange, changeMonth, openNext, utils]);
//   const handleDateYearChange = React.useCallback((newDate, selectionState) => {
//     const startOfYear = utils.startOfYear(newDate);
//     const endOfYear = utils.endOfYear(newDate);
//     const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
//       utils,
//       date: newDate,
//       minDate: utils.isBefore(minDate, startOfYear) ? startOfYear : minDate,
//       maxDate: utils.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
//       disablePast,
//       disableFuture,
//       isDateDisabled
//     }) : newDate;

//     if (closestEnabledDate) {
//       onChange(closestEnabledDate, selectionState);
//       onYearChange == null ? void 0 : onYearChange(closestEnabledDate);
//     } else {
//       openNext();
//       changeMonth(startOfYear);
//     }

//     changeFocusedDay(closestEnabledDate, true);
//   }, [changeFocusedDay, disableFuture, disablePast, isDateDisabled, maxDate, minDate, onChange, onYearChange, openNext, utils, changeMonth]);
//   const onSelectedDayChange = React.useCallback((day, isFinish) => {
//     if (date && day) {
//       // If there is a date already selected, then we want to keep its time
//       return onChange(utils.mergeDateAndTime(day, date), isFinish);
//     }

//     return onChange(day, isFinish);
//   }, [utils, date, onChange]);
//   React.useEffect(() => {
//     if (date) {
//       changeMonth(date);
//     }
//   }, [date]); // eslint-disable-line

//   const ownerState = props;
//   const classes = useUtilityClasses$e(ownerState);
//   const baseDateValidationProps = {
//     disablePast,
//     disableFuture,
//     maxDate,
//     minDate
//   }; // When disabled, limit the view to the selected date

//   const minDateWithDisabled = disabled && date || minDate;
//   const maxDateWithDisabled = disabled && date || maxDate;
//   const commonViewProps = {
//     disableHighlightToday,
//     readOnly,
//     disabled
//   };
//   const gridLabelId = `${id}-grid-label`;
//   const [internalFocusedView, setInternalFocusedView] = useControlled$2({
//     name: 'DayPicker',
//     state: 'focusedView',
//     controlled: focusedView,
//     default: autoFocus ? openView : null
//   });
//   const hasFocus = internalFocusedView !== null;
//   const handleFocusedViewChange = useEventCallback$2(eventView => newHasFocus => {
//     if (onFocusedViewChange) {
//       // Use the calendar or clock logic
//       onFocusedViewChange(eventView)(newHasFocus);
//       return;
//     } // If alone, do the local modifications


//     if (newHasFocus) {
//       setInternalFocusedView(eventView);
//     } else {
//       setInternalFocusedView(prevView => prevView === eventView ? null : prevView);
//     }
//   });
//   const prevOpenViewRef = React.useRef(openView);
//   React.useEffect(() => {
//     // Set focus to the button when switching from a view to another
//     if (prevOpenViewRef.current === openView) {
//       return;
//     }

//     prevOpenViewRef.current = openView;
//     handleFocusedViewChange(openView)(true);
//   }, [openView, handleFocusedViewChange]);
//   return /*#__PURE__*/jsxs(CalendarPickerRoot, {
//     ref: ref,
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState,
//     children: [/*#__PURE__*/jsx(PickersCalendarHeader, _extends$u({}, other, {
//       views: views,
//       openView: openView,
//       currentMonth: calendarState.currentMonth,
//       onViewChange: setOpenView,
//       onMonthChange: (newMonth, direction) => handleChangeMonth({
//         newMonth,
//         direction
//       }),
//       minDate: minDateWithDisabled,
//       maxDate: maxDateWithDisabled,
//       disabled: disabled,
//       disablePast: disablePast,
//       disableFuture: disableFuture,
//       reduceAnimations: reduceAnimations,
//       labelId: gridLabelId
//     })), /*#__PURE__*/jsx(CalendarPickerViewTransitionContainer, {
//       reduceAnimations: reduceAnimations,
//       className: classes.viewTransitionContainer,
//       transKey: openView,
//       ownerState: ownerState,
//       children: /*#__PURE__*/jsxs("div", {
//         children: [openView === 'year' && /*#__PURE__*/jsx(YearPicker, _extends$u({}, other, baseDateValidationProps, commonViewProps, {
//           autoFocus: autoFocus,
//           date: date,
//           onChange: handleDateYearChange,
//           shouldDisableYear: shouldDisableYear,
//           hasFocus: hasFocus,
//           onFocusedViewChange: handleFocusedViewChange('year')
//         })), openView === 'month' && /*#__PURE__*/jsx(MonthPicker, _extends$u({}, baseDateValidationProps, commonViewProps, {
//           autoFocus: autoFocus,
//           hasFocus: hasFocus,
//           className: className,
//           date: date,
//           onChange: handleDateMonthChange,
//           shouldDisableMonth: shouldDisableMonth,
//           onFocusedViewChange: handleFocusedViewChange('month')
//         })), openView === 'day' && /*#__PURE__*/jsx(DayPicker, _extends$u({}, other, calendarState, baseDateValidationProps, commonViewProps, {
//           autoFocus: autoFocus,
//           onMonthSwitchingAnimationEnd: onMonthSwitchingAnimationEnd,
//           onFocusedDayChange: changeFocusedDay,
//           reduceAnimations: reduceAnimations,
//           selectedDays: [date],
//           onSelectedDaysChange: onSelectedDayChange,
//           shouldDisableDate: shouldDisableDate,
//           hasFocus: hasFocus,
//           onFocusedViewChange: handleFocusedViewChange('day'),
//           gridLabelId: gridLabelId
//         }))]
//       })
//     })]
//   });
// });
// process.env.NODE_ENV !== "production" ? CalendarPicker.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------
//   autoFocus: PropTypes__default.bool,
//   classes: PropTypes__default.object,
//   className: PropTypes__default.string,

//   /**
//    * Overrideable components.
//    * @default {}
//    */
//   components: PropTypes__default.object,

//   /**
//    * The props used for each component slot.
//    * @default {}
//    */
//   componentsProps: PropTypes__default.object,
//   date: PropTypes__default.any,

//   /**
//    * Formats the day of week displayed in the calendar header.
//    * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
//    * @returns {string} The name to display.
//    * @default (day) => day.charAt(0).toUpperCase()
//    */
//   dayOfWeekFormatter: PropTypes__default.func,

//   /**
//    * Default calendar month displayed when `value={null}`.
//    */
//   defaultCalendarMonth: PropTypes__default.any,

//   /**
//    * If `true`, the picker and text field are disabled.
//    * @default false
//    */
//   disabled: PropTypes__default.bool,

//   /**
//    * If `true` future days are disabled.
//    * @default false
//    */
//   disableFuture: PropTypes__default.bool,

//   /**
//    * If `true`, today's date is rendering without highlighting with circle.
//    * @default false
//    */
//   disableHighlightToday: PropTypes__default.bool,

//   /**
//    * If `true` past days are disabled.
//    * @default false
//    */
//   disablePast: PropTypes__default.bool,
//   focusedView: PropTypes__default.oneOf(['day', 'month', 'year']),

//   /**
//    * Get aria-label text for switching between views button.
//    * @param {CalendarPickerView} currentView The view from which we want to get the button text.
//    * @returns {string} The label of the view.
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   getViewSwitchingButtonText: PropTypes__default.func,

//   /**
//    * Left arrow icon aria-label text.
//    * @deprecated
//    */
//   leftArrowButtonText: PropTypes__default.string,

//   /**
//    * If `true` renders `LoadingComponent` in calendar instead of calendar view.
//    * Can be used to preload information and show it in calendar.
//    * @default false
//    */
//   loading: PropTypes__default.bool,

//   /**
//    * Maximal selectable date. @DateIOType
//    */
//   maxDate: PropTypes__default.any,

//   /**
//    * Minimal selectable date. @DateIOType
//    */
//   minDate: PropTypes__default.any,

//   /**
//    * Callback fired on date change
//    */
//   onChange: PropTypes__default.func.isRequired,
//   onFocusedViewChange: PropTypes__default.func,

//   /**
//    * Callback firing on month change @DateIOType.
//    * @template TDate
//    * @param {TDate} month The new month.
//    * @returns {void|Promise} -
//    */
//   onMonthChange: PropTypes__default.func,

//   /**
//    * Callback fired on view change.
//    * @param {CalendarPickerView} view The new view.
//    */
//   onViewChange: PropTypes__default.func,

//   /**
//    * Callback firing on year change @DateIOType.
//    * @template TDate
//    * @param {TDate} year The new year.
//    */
//   onYearChange: PropTypes__default.func,

//   /**
//    * Initially open view.
//    * @default 'day'
//    */
//   openTo: PropTypes__default.oneOf(['day', 'month', 'year']),

//   /**
//    * Make picker read only.
//    * @default false
//    */
//   readOnly: PropTypes__default.bool,

//   /**
//    * Disable heavy animations.
//    * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
//    */
//   reduceAnimations: PropTypes__default.bool,

//   /**
//    * Custom renderer for day. Check the [PickersDay](https://mui.com/x/api/date-pickers/pickers-day/) component.
//    * @template TDate
//    * @param {TDate} day The day to render.
//    * @param {Array<TDate | null>} selectedDays The days currently selected.
//    * @param {PickersDayProps<TDate>} pickersDayProps The props of the day to render.
//    * @returns {JSX.Element} The element representing the day.
//    */
//   renderDay: PropTypes__default.func,

//   /**
//    * Component displaying when passed `loading` true.
//    * @returns {React.ReactNode} The node to render when loading.
//    * @default () => <span data-mui-test="loading-progress">...</span>
//    */
//   renderLoading: PropTypes__default.func,

//   /**
//    * Right arrow icon aria-label text.
//    * @deprecated
//    */
//   rightArrowButtonText: PropTypes__default.string,

//   /**
//    * Disable specific date. @DateIOType
//    * @template TDate
//    * @param {TDate} day The date to test.
//    * @returns {boolean} Returns `true` if the date should be disabled.
//    */
//   shouldDisableDate: PropTypes__default.func,

//   /**
//    * Disable specific months dynamically.
//    * Works like `shouldDisableDate` but for month selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} month The month to check.
//    * @returns {boolean} If `true` the month will be disabled.
//    */
//   shouldDisableMonth: PropTypes__default.func,

//   /**
//    * Disable specific years dynamically.
//    * Works like `shouldDisableDate` but for year selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} year The year to test.
//    * @returns {boolean} Returns `true` if the year should be disabled.
//    */
//   shouldDisableYear: PropTypes__default.func,

//   /**
//    * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
//    * @default false
//    */
//   showDaysOutsideCurrentMonth: PropTypes__default.bool,

//   /**
//    * Controlled open view.
//    */
//   view: PropTypes__default.oneOf(['day', 'month', 'year']),

//   /**
//    * Views for calendar picker.
//    * @default ['year', 'day']
//    */
//   views: PropTypes__default.arrayOf(PropTypes__default.oneOf(['day', 'month', 'year']).isRequired)
// } : void 0;

// const CLOCK_WIDTH = 220;
// const CLOCK_HOUR_WIDTH = 36;
// const clockCenter = {
//   x: CLOCK_WIDTH / 2,
//   y: CLOCK_WIDTH / 2
// };
// const baseClockPoint = {
//   x: clockCenter.x,
//   y: 0
// };
// const cx = baseClockPoint.x - clockCenter.x;
// const cy = baseClockPoint.y - clockCenter.y;

// const rad2deg = rad => rad * (180 / Math.PI);

// const getAngleValue = (step, offsetX, offsetY) => {
//   const x = offsetX - clockCenter.x;
//   const y = offsetY - clockCenter.y;
//   const atan = Math.atan2(cx, cy) - Math.atan2(x, y);
//   let deg = rad2deg(atan);
//   deg = Math.round(deg / step) * step;
//   deg %= 360;
//   const value = Math.floor(deg / step) || 0;
//   const delta = x ** 2 + y ** 2;
//   const distance = Math.sqrt(delta);
//   return {
//     value,
//     distance
//   };
// };

// const getMinutes = (offsetX, offsetY, step = 1) => {
//   const angleStep = step * 6;
//   let {
//     value
//   } = getAngleValue(angleStep, offsetX, offsetY);
//   value = value * step % 60;
//   return value;
// };
// const getHours = (offsetX, offsetY, ampm) => {
//   const {
//     value,
//     distance
//   } = getAngleValue(30, offsetX, offsetY);
//   let hour = value || 12;

//   if (!ampm) {
//     if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
//       hour += 12;
//       hour %= 24;
//     }
//   } else {
//     hour %= 12;
//   }

//   return hour;
// };

// function getClockPointerUtilityClass(slot) {
//   return generateUtilityClass$1('MuiClockPointer', slot);
// }
// generateUtilityClasses$1('MuiClockPointer', ['root', 'thumb']);

// const _excluded$K = ["className", "hasSelected", "isInner", "type", "value"];

// const useUtilityClasses$d = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     thumb: ['thumb']
//   };
//   return unstable_composeClasses(slots, getClockPointerUtilityClass, classes);
// };

// const ClockPointerRoot = styled$1('div', {
//   name: 'MuiClockPointer',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })(({
//   theme,
//   ownerState
// }) => _extends$u({
//   width: 2,
//   backgroundColor: theme.palette.primary.main,
//   position: 'absolute',
//   left: 'calc(50% - 1px)',
//   bottom: '50%',
//   transformOrigin: 'center bottom 0px'
// }, ownerState.shouldAnimate && {
//   transition: theme.transitions.create(['transform', 'height'])
// }));
// const ClockPointerThumb = styled$1('div', {
//   name: 'MuiClockPointer',
//   slot: 'Thumb',
//   overridesResolver: (_, styles) => styles.thumb
// })(({
//   theme,
//   ownerState
// }) => _extends$u({
//   width: 4,
//   height: 4,
//   backgroundColor: theme.palette.primary.contrastText,
//   borderRadius: '50%',
//   position: 'absolute',
//   top: -21,
//   left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
//   border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${theme.palette.primary.main}`,
//   boxSizing: 'content-box'
// }, ownerState.hasSelected && {
//   backgroundColor: theme.palette.primary.main
// }));
// /**
//  * @ignore - internal component.
//  */

// function ClockPointer(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiClockPointer'
//   });

//   const {
//     className,
//     isInner,
//     type,
//     value
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$K);

//   const previousType = React.useRef(type);
//   React.useEffect(() => {
//     previousType.current = type;
//   }, [type]);

//   const ownerState = _extends$u({}, props, {
//     shouldAnimate: previousType.current !== type
//   });

//   const classes = useUtilityClasses$d(ownerState);

//   const getAngleStyle = () => {
//     const max = type === 'hours' ? 12 : 60;
//     let angle = 360 / max * value;

//     if (type === 'hours' && value > 12) {
//       angle -= 360; // round up angle to max 360 degrees
//     }

//     return {
//       height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
//       transform: `rotateZ(${angle}deg)`
//     };
//   };

//   return /*#__PURE__*/jsx(ClockPointerRoot, _extends$u({
//     style: getAngleStyle(),
//     className: clsx$1(className, classes.root),
//     ownerState: ownerState
//   }, other, {
//     children: /*#__PURE__*/jsx(ClockPointerThumb, {
//       ownerState: ownerState,
//       className: classes.thumb
//     })
//   }));
// }

// function getClockUtilityClass(slot) {
//   return generateUtilityClass$1('MuiClock', slot);
// }
// generateUtilityClasses$1('MuiClock', ['root', 'clock', 'wrapper', 'squareMask', 'pin', 'amButton', 'pmButton']);

// const useUtilityClasses$c = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     clock: ['clock'],
//     wrapper: ['wrapper'],
//     squareMask: ['squareMask'],
//     pin: ['pin'],
//     amButton: ['amButton'],
//     pmButton: ['pmButton']
//   };
//   return composeClasses(slots, getClockUtilityClass, classes);
// };

// const ClockRoot = styled$1('div', {
//   name: 'MuiClock',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })(({
//   theme
// }) => ({
//   display: 'flex',
//   justifyContent: 'center',
//   alignItems: 'center',
//   margin: theme.spacing(2)
// }));
// const ClockClock = styled$1('div', {
//   name: 'MuiClock',
//   slot: 'Clock',
//   overridesResolver: (_, styles) => styles.clock
// })({
//   backgroundColor: 'rgba(0,0,0,.07)',
//   borderRadius: '50%',
//   height: 220,
//   width: 220,
//   flexShrink: 0,
//   position: 'relative',
//   pointerEvents: 'none'
// });
// const ClockWrapper = styled$1('div', {
//   name: 'MuiClock',
//   slot: 'Wrapper',
//   overridesResolver: (_, styles) => styles.wrapper
// })({
//   '&:focus': {
//     outline: 'none'
//   }
// });
// const ClockSquareMask = styled$1('div', {
//   name: 'MuiClock',
//   slot: 'SquareMask',
//   overridesResolver: (_, styles) => styles.squareMask
// })(({
//   ownerState
// }) => _extends$u({
//   width: '100%',
//   height: '100%',
//   position: 'absolute',
//   pointerEvents: 'auto',
//   outline: 0,
//   // Disable scroll capabilities.
//   touchAction: 'none',
//   userSelect: 'none'
// }, ownerState.disabled ? {} : {
//   '@media (pointer: fine)': {
//     cursor: 'pointer',
//     borderRadius: '50%'
//   },
//   '&:active': {
//     cursor: 'move'
//   }
// }));
// const ClockPin = styled$1('div', {
//   name: 'MuiClock',
//   slot: 'Pin',
//   overridesResolver: (_, styles) => styles.pin
// })(({
//   theme
// }) => ({
//   width: 6,
//   height: 6,
//   borderRadius: '50%',
//   backgroundColor: theme.palette.primary.main,
//   position: 'absolute',
//   top: '50%',
//   left: '50%',
//   transform: 'translate(-50%, -50%)'
// }));
// const ClockAmButton = styled$1(IconButton$1, {
//   name: 'MuiClock',
//   slot: 'AmButton',
//   overridesResolver: (_, styles) => styles.amButton
// })(({
//   theme,
//   ownerState
// }) => _extends$u({
//   zIndex: 1,
//   position: 'absolute',
//   bottom: ownerState.ampmInClock ? 64 : 8,
//   left: 8
// }, ownerState.meridiemMode === 'am' && {
//   backgroundColor: theme.palette.primary.main,
//   color: theme.palette.primary.contrastText,
//   '&:hover': {
//     backgroundColor: theme.palette.primary.light
//   }
// }));
// const ClockPmButton = styled$1(IconButton$1, {
//   name: 'MuiClock',
//   slot: 'PmButton',
//   overridesResolver: (_, styles) => styles.pmButton
// })(({
//   theme,
//   ownerState
// }) => _extends$u({
//   zIndex: 1,
//   position: 'absolute',
//   bottom: ownerState.ampmInClock ? 64 : 8,
//   right: 8
// }, ownerState.meridiemMode === 'pm' && {
//   backgroundColor: theme.palette.primary.main,
//   color: theme.palette.primary.contrastText,
//   '&:hover': {
//     backgroundColor: theme.palette.primary.light
//   }
// }));
// /**
//  * @ignore - internal component.
//  */

// function Clock(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiClock'
//   });
//   const {
//     ampm,
//     ampmInClock,
//     autoFocus,
//     children,
//     date,
//     getClockLabelText,
//     handleMeridiemChange,
//     isTimeDisabled,
//     meridiemMode,
//     minutesStep = 1,
//     onChange,
//     selectedId,
//     type,
//     value,
//     disabled,
//     readOnly,
//     className
//   } = props;
//   const ownerState = props;
//   const utils = useUtils();
//   const wrapperVariant = React.useContext(WrapperVariantContext);
//   const isMoving = React.useRef(false);
//   const classes = useUtilityClasses$c(ownerState);
//   const isSelectedTimeDisabled = isTimeDisabled(value, type);
//   const isPointerInner = !ampm && type === 'hours' && (value < 1 || value > 12);

//   const handleValueChange = (newValue, isFinish) => {
//     if (disabled || readOnly) {
//       return;
//     }

//     if (isTimeDisabled(newValue, type)) {
//       return;
//     }

//     onChange(newValue, isFinish);
//   };

//   const setTime = (event, isFinish) => {
//     let {
//       offsetX,
//       offsetY
//     } = event;

//     if (offsetX === undefined) {
//       const rect = event.target.getBoundingClientRect();
//       offsetX = event.changedTouches[0].clientX - rect.left;
//       offsetY = event.changedTouches[0].clientY - rect.top;
//     }

//     const newSelectedValue = type === 'seconds' || type === 'minutes' ? getMinutes(offsetX, offsetY, minutesStep) : getHours(offsetX, offsetY, Boolean(ampm));
//     handleValueChange(newSelectedValue, isFinish);
//   };

//   const handleTouchMove = event => {
//     isMoving.current = true;
//     setTime(event, 'shallow');
//   };

//   const handleTouchEnd = event => {
//     if (isMoving.current) {
//       setTime(event, 'finish');
//       isMoving.current = false;
//     }
//   };

//   const handleMouseMove = event => {
//     // event.buttons & PRIMARY_MOUSE_BUTTON
//     if (event.buttons > 0) {
//       setTime(event.nativeEvent, 'shallow');
//     }
//   };

//   const handleMouseUp = event => {
//     if (isMoving.current) {
//       isMoving.current = false;
//     }

//     setTime(event.nativeEvent, 'finish');
//   };

//   const hasSelected = React.useMemo(() => {
//     if (type === 'hours') {
//       return true;
//     }

//     return value % 5 === 0;
//   }, [type, value]);
//   const keyboardControlStep = type === 'minutes' ? minutesStep : 1;
//   const listboxRef = React.useRef(null); // Since this is rendered when a Popper is opened we can't use passive effects.
//   // Focusing in passive effects in Popper causes scroll jump.

//   useEnhancedEffect(() => {
//     if (autoFocus) {
//       // The ref not being resolved would be a bug in MUI.
//       listboxRef.current.focus();
//     }
//   }, [autoFocus]);

//   const handleKeyDown = event => {
//     // TODO: Why this early exit?
//     if (isMoving.current) {
//       return;
//     }

//     switch (event.key) {
//       case 'Home':
//         // annulate both hours and minutes
//         handleValueChange(0, 'partial');
//         event.preventDefault();
//         break;

//       case 'End':
//         handleValueChange(type === 'minutes' ? 59 : 23, 'partial');
//         event.preventDefault();
//         break;

//       case 'ArrowUp':
//         handleValueChange(value + keyboardControlStep, 'partial');
//         event.preventDefault();
//         break;

//       case 'ArrowDown':
//         handleValueChange(value - keyboardControlStep, 'partial');
//         event.preventDefault();
//         break;

//     }
//   };

//   return /*#__PURE__*/jsxs(ClockRoot, {
//     className: clsx$1(className, classes.root),
//     children: [/*#__PURE__*/jsxs(ClockClock, {
//       className: classes.clock,
//       children: [/*#__PURE__*/jsx(ClockSquareMask, {
//         onTouchMove: handleTouchMove,
//         onTouchEnd: handleTouchEnd,
//         onMouseUp: handleMouseUp,
//         onMouseMove: handleMouseMove,
//         ownerState: {
//           disabled
//         },
//         className: classes.squareMask
//       }), !isSelectedTimeDisabled && /*#__PURE__*/jsxs(React.Fragment, {
//         children: [/*#__PURE__*/jsx(ClockPin, {
//           className: classes.pin
//         }), date && /*#__PURE__*/jsx(ClockPointer, {
//           type: type,
//           value: value,
//           isInner: isPointerInner,
//           hasSelected: hasSelected
//         })]
//       }), /*#__PURE__*/jsx(ClockWrapper, {
//         "aria-activedescendant": selectedId,
//         "aria-label": getClockLabelText(type, date, utils),
//         ref: listboxRef,
//         role: "listbox",
//         onKeyDown: handleKeyDown,
//         tabIndex: 0,
//         className: classes.wrapper,
//         children: children
//       })]
//     }), ampm && (wrapperVariant === 'desktop' || ampmInClock) && /*#__PURE__*/jsxs(React.Fragment, {
//       children: [/*#__PURE__*/jsx(ClockAmButton, {
//         onClick: readOnly ? undefined : () => handleMeridiemChange('am'),
//         disabled: disabled || meridiemMode === null,
//         ownerState: ownerState,
//         className: classes.amButton,
//         children: /*#__PURE__*/jsx(Typography, {
//           variant: "caption",
//           children: "AM"
//         })
//       }), /*#__PURE__*/jsx(ClockPmButton, {
//         disabled: disabled || meridiemMode === null,
//         onClick: readOnly ? undefined : () => handleMeridiemChange('pm'),
//         ownerState: ownerState,
//         className: classes.pmButton,
//         children: /*#__PURE__*/jsx(Typography, {
//           variant: "caption",
//           children: "PM"
//         })
//       })]
//     })]
//   });
// }

// function getClockNumberUtilityClass(slot) {
//   return generateUtilityClass$1('MuiClockNumber', slot);
// }
// const clockNumberClasses = generateUtilityClasses$1('MuiClockNumber', ['root', 'selected', 'disabled']);

// const _excluded$J = ["className", "disabled", "index", "inner", "label", "selected"];

// const useUtilityClasses$b = ownerState => {
//   const {
//     classes,
//     selected,
//     disabled
//   } = ownerState;
//   const slots = {
//     root: ['root', selected && 'selected', disabled && 'disabled']
//   };
//   return unstable_composeClasses(slots, getClockNumberUtilityClass, classes);
// };

// const ClockNumberRoot = styled$1('span', {
//   name: 'MuiClockNumber',
//   slot: 'Root',
//   overridesResolver: (_, styles) => [styles.root, {
//     [`&.${clockNumberClasses.disabled}`]: styles.disabled
//   }, {
//     [`&.${clockNumberClasses.selected}`]: styles.selected
//   }]
// })(({
//   theme,
//   ownerState
// }) => _extends$u({
//   height: CLOCK_HOUR_WIDTH,
//   width: CLOCK_HOUR_WIDTH,
//   position: 'absolute',
//   left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
//   display: 'inline-flex',
//   justifyContent: 'center',
//   alignItems: 'center',
//   borderRadius: '50%',
//   color: theme.palette.text.primary,
//   fontFamily: theme.typography.fontFamily,
//   '&:focused': {
//     backgroundColor: theme.palette.background.paper
//   },
//   [`&.${clockNumberClasses.selected}`]: {
//     color: theme.palette.primary.contrastText
//   },
//   [`&.${clockNumberClasses.disabled}`]: {
//     pointerEvents: 'none',
//     color: theme.palette.text.disabled
//   }
// }, ownerState.inner && _extends$u({}, theme.typography.body2, {
//   color: theme.palette.text.secondary
// })));
// /**
//  * @ignore - internal component.
//  */

// function ClockNumber(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiClockNumber'
//   });

//   const {
//     className,
//     disabled,
//     index,
//     inner,
//     label,
//     selected
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$J);

//   const ownerState = props;
//   const classes = useUtilityClasses$b(ownerState);
//   const angle = index % 12 / 12 * Math.PI * 2 - Math.PI / 2;
//   const length = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
//   const x = Math.round(Math.cos(angle) * length);
//   const y = Math.round(Math.sin(angle) * length);
//   return /*#__PURE__*/jsx(ClockNumberRoot, _extends$u({
//     className: clsx$1(className, classes.root),
//     "aria-disabled": disabled ? true : undefined,
//     "aria-selected": selected ? true : undefined,
//     role: "option",
//     style: {
//       transform: `translate(${x}px, ${y + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
//     },
//     ownerState: ownerState
//   }, other, {
//     children: label
//   }));
// }

// /**
//  * @ignore - internal component.
//  */
// const getHourNumbers = ({
//   ampm,
//   date,
//   getClockNumberText,
//   isDisabled,
//   selectedId,
//   utils
// }) => {
//   const currentHours = date ? utils.getHours(date) : null;
//   const hourNumbers = [];
//   const startHour = ampm ? 1 : 0;
//   const endHour = ampm ? 12 : 23;

//   const isSelected = hour => {
//     if (currentHours === null) {
//       return false;
//     }

//     if (ampm) {
//       if (hour === 12) {
//         return currentHours === 12 || currentHours === 0;
//       }

//       return currentHours === hour || currentHours - 12 === hour;
//     }

//     return currentHours === hour;
//   };

//   for (let hour = startHour; hour <= endHour; hour += 1) {
//     let label = hour.toString();

//     if (hour === 0) {
//       label = '00';
//     }

//     const inner = !ampm && (hour === 0 || hour > 12);
//     label = utils.formatNumber(label);
//     const selected = isSelected(hour);
//     hourNumbers.push( /*#__PURE__*/jsx(ClockNumber, {
//       id: selected ? selectedId : undefined,
//       index: hour,
//       inner: inner,
//       selected: selected,
//       disabled: isDisabled(hour),
//       label: label,
//       "aria-label": getClockNumberText(label)
//     }, hour));
//   }

//   return hourNumbers;
// };
// const getMinutesNumbers = ({
//   utils,
//   value,
//   isDisabled,
//   getClockNumberText,
//   selectedId
// }) => {
//   const f = utils.formatNumber;
//   return [[5, f('05')], [10, f('10')], [15, f('15')], [20, f('20')], [25, f('25')], [30, f('30')], [35, f('35')], [40, f('40')], [45, f('45')], [50, f('50')], [55, f('55')], [0, f('00')]].map(([numberValue, label], index) => {
//     const selected = numberValue === value;
//     return /*#__PURE__*/jsx(ClockNumber, {
//       label: label,
//       id: selected ? selectedId : undefined,
//       index: index + 1,
//       inner: false,
//       disabled: isDisabled(numberValue),
//       selected: selected,
//       "aria-label": getClockNumberText(label)
//     }, numberValue);
//   });
// };

// function getClockPickerUtilityClass(slot) {
//   return generateUtilityClass$1('MuiClockPicker', slot);
// }
// generateUtilityClasses$1('MuiClockPicker', ['root', 'arrowSwitcher']);

// const useUtilityClasses$a = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     arrowSwitcher: ['arrowSwitcher']
//   };
//   return unstable_composeClasses(slots, getClockPickerUtilityClass, classes);
// };

// const ClockPickerRoot = styled$1(PickerViewRoot, {
//   name: 'MuiClockPicker',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })({
//   display: 'flex',
//   flexDirection: 'column'
// });
// const ClockPickerArrowSwitcher = styled$1(PickersArrowSwitcher, {
//   name: 'MuiClockPicker',
//   slot: 'ArrowSwitcher',
//   overridesResolver: (props, styles) => styles.arrowSwitcher
// })({
//   position: 'absolute',
//   right: 12,
//   top: 15
// });
// const deprecatedPropsWarning = buildDeprecatedPropsWarning('Props for translation are deprecated. See https://mui.com/x/react-date-pickers/localization for more information.');
// /**
//  *
//  * API:
//  *
//  * - [ClockPicker API](https://mui.com/x/api/date-pickers/clock-picker/)
//  */

// const ClockPicker = /*#__PURE__*/React.forwardRef(function ClockPicker(inProps, ref) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiClockPicker'
//   });
//   const {
//     ampm = false,
//     ampmInClock = false,
//     autoFocus,
//     components,
//     componentsProps,
//     date,
//     disableIgnoringDatePartForTimeValidation,
//     getClockLabelText: getClockLabelTextProp,
//     getHoursClockNumberText: getHoursClockNumberTextProp,
//     getMinutesClockNumberText: getMinutesClockNumberTextProp,
//     getSecondsClockNumberText: getSecondsClockNumberTextProp,
//     leftArrowButtonText: leftArrowButtonTextProp,
//     maxTime,
//     minTime,
//     minutesStep = 1,
//     rightArrowButtonText: rightArrowButtonTextProp,
//     shouldDisableTime,
//     showViewSwitcher,
//     onChange,
//     view,
//     views = ['hours', 'minutes'],
//     openTo,
//     onViewChange,
//     className,
//     disabled,
//     readOnly
//   } = props;
//   deprecatedPropsWarning({
//     leftArrowButtonText: leftArrowButtonTextProp,
//     rightArrowButtonText: rightArrowButtonTextProp,
//     getClockLabelText: getClockLabelTextProp,
//     getHoursClockNumberText: getHoursClockNumberTextProp,
//     getMinutesClockNumberText: getMinutesClockNumberTextProp,
//     getSecondsClockNumberText: getSecondsClockNumberTextProp
//   });
//   const localeText = useLocaleText();
//   const leftArrowButtonText = leftArrowButtonTextProp != null ? leftArrowButtonTextProp : localeText.openPreviousView;
//   const rightArrowButtonText = rightArrowButtonTextProp != null ? rightArrowButtonTextProp : localeText.openNextView;
//   const getClockLabelText = getClockLabelTextProp != null ? getClockLabelTextProp : localeText.clockLabelText;
//   const getHoursClockNumberText = getHoursClockNumberTextProp != null ? getHoursClockNumberTextProp : localeText.hoursClockNumberText;
//   const getMinutesClockNumberText = getMinutesClockNumberTextProp != null ? getMinutesClockNumberTextProp : localeText.minutesClockNumberText;
//   const getSecondsClockNumberText = getSecondsClockNumberTextProp != null ? getSecondsClockNumberTextProp : localeText.secondsClockNumberText;
//   const {
//     openView,
//     setOpenView,
//     nextView,
//     previousView,
//     handleChangeAndOpenNext
//   } = useViews({
//     view,
//     views,
//     openTo,
//     onViewChange,
//     onChange
//   });
//   const now = useNow();
//   const utils = useUtils();
//   const dateOrMidnight = React.useMemo(() => date || utils.setSeconds(utils.setMinutes(utils.setHours(now, 0), 0), 0), [date, now, utils]);
//   const {
//     meridiemMode,
//     handleMeridiemChange
//   } = useMeridiemMode(dateOrMidnight, ampm, handleChangeAndOpenNext);
//   const isTimeDisabled = React.useCallback((rawValue, viewType) => {
//     const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);

//     const containsValidTime = ({
//       start,
//       end
//     }) => {
//       if (minTime && isAfter(minTime, end)) {
//         return false;
//       }

//       if (maxTime && isAfter(start, maxTime)) {
//         return false;
//       }

//       return true;
//     };

//     const isValidValue = (value, step = 1) => {
//       if (value % step !== 0) {
//         return false;
//       }

//       if (shouldDisableTime) {
//         return !shouldDisableTime(value, viewType);
//       }

//       return true;
//     };

//     switch (viewType) {
//       case 'hours':
//         {
//           const value = convertValueToMeridiem(rawValue, meridiemMode, ampm);
//           const dateWithNewHours = utils.setHours(dateOrMidnight, value);
//           const start = utils.setSeconds(utils.setMinutes(dateWithNewHours, 0), 0);
//           const end = utils.setSeconds(utils.setMinutes(dateWithNewHours, 59), 59);
//           return !containsValidTime({
//             start,
//             end
//           }) || !isValidValue(value);
//         }

//       case 'minutes':
//         {
//           const dateWithNewMinutes = utils.setMinutes(dateOrMidnight, rawValue);
//           const start = utils.setSeconds(dateWithNewMinutes, 0);
//           const end = utils.setSeconds(dateWithNewMinutes, 59);
//           return !containsValidTime({
//             start,
//             end
//           }) || !isValidValue(rawValue, minutesStep);
//         }

//       case 'seconds':
//         {
//           const dateWithNewSeconds = utils.setSeconds(dateOrMidnight, rawValue);
//           const start = dateWithNewSeconds;
//           const end = dateWithNewSeconds;
//           return !containsValidTime({
//             start,
//             end
//           }) || !isValidValue(rawValue);
//         }

//       default:
//         throw new Error('not supported');
//     }
//   }, [ampm, dateOrMidnight, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils]);
//   const selectedId = unstable_useId();
//   const viewProps = React.useMemo(() => {
//     switch (openView) {
//       case 'hours':
//         {
//           const handleHoursChange = (value, isFinish) => {
//             const valueWithMeridiem = convertValueToMeridiem(value, meridiemMode, ampm);
//             handleChangeAndOpenNext(utils.setHours(dateOrMidnight, valueWithMeridiem), isFinish);
//           };

//           return {
//             onChange: handleHoursChange,
//             value: utils.getHours(dateOrMidnight),
//             children: getHourNumbers({
//               date,
//               utils,
//               ampm,
//               onChange: handleHoursChange,
//               getClockNumberText: getHoursClockNumberText,
//               isDisabled: value => disabled || isTimeDisabled(value, 'hours'),
//               selectedId
//             })
//           };
//         }

//       case 'minutes':
//         {
//           const minutesValue = utils.getMinutes(dateOrMidnight);

//           const handleMinutesChange = (value, isFinish) => {
//             handleChangeAndOpenNext(utils.setMinutes(dateOrMidnight, value), isFinish);
//           };

//           return {
//             value: minutesValue,
//             onChange: handleMinutesChange,
//             children: getMinutesNumbers({
//               utils,
//               value: minutesValue,
//               onChange: handleMinutesChange,
//               getClockNumberText: getMinutesClockNumberText,
//               isDisabled: value => disabled || isTimeDisabled(value, 'minutes'),
//               selectedId
//             })
//           };
//         }

//       case 'seconds':
//         {
//           const secondsValue = utils.getSeconds(dateOrMidnight);

//           const handleSecondsChange = (value, isFinish) => {
//             handleChangeAndOpenNext(utils.setSeconds(dateOrMidnight, value), isFinish);
//           };

//           return {
//             value: secondsValue,
//             onChange: handleSecondsChange,
//             children: getMinutesNumbers({
//               utils,
//               value: secondsValue,
//               onChange: handleSecondsChange,
//               getClockNumberText: getSecondsClockNumberText,
//               isDisabled: value => disabled || isTimeDisabled(value, 'seconds'),
//               selectedId
//             })
//           };
//         }

//       default:
//         throw new Error('You must provide the type for ClockView');
//     }
//   }, [openView, utils, date, ampm, getHoursClockNumberText, getMinutesClockNumberText, getSecondsClockNumberText, meridiemMode, handleChangeAndOpenNext, dateOrMidnight, isTimeDisabled, selectedId, disabled]);
//   const ownerState = props;
//   const classes = useUtilityClasses$a(ownerState);
//   return /*#__PURE__*/jsxs(ClockPickerRoot, {
//     ref: ref,
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState,
//     children: [showViewSwitcher && /*#__PURE__*/jsx(ClockPickerArrowSwitcher, {
//       className: classes.arrowSwitcher,
//       leftArrowButtonText: leftArrowButtonText,
//       rightArrowButtonText: rightArrowButtonText,
//       components: components,
//       componentsProps: componentsProps,
//       onLeftClick: () => setOpenView(previousView),
//       onRightClick: () => setOpenView(nextView),
//       isLeftDisabled: !previousView,
//       isRightDisabled: !nextView,
//       ownerState: ownerState
//     }), /*#__PURE__*/jsx(Clock, _extends$u({
//       autoFocus: autoFocus,
//       date: date,
//       ampmInClock: ampmInClock,
//       type: openView,
//       ampm: ampm,
//       getClockLabelText: getClockLabelText,
//       minutesStep: minutesStep,
//       isTimeDisabled: isTimeDisabled,
//       meridiemMode: meridiemMode,
//       handleMeridiemChange: handleMeridiemChange,
//       selectedId: selectedId,
//       disabled: disabled,
//       readOnly: readOnly
//     }, viewProps))]
//   });
// });
// process.env.NODE_ENV !== "production" ? ClockPicker.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------

//   /**
//    * 12h/24h view for hour selection clock.
//    * @default false
//    */
//   ampm: PropTypes__default.bool,

//   /**
//    * Display ampm controls under the clock (instead of in the toolbar).
//    * @default false
//    */
//   ampmInClock: PropTypes__default.bool,

//   /**
//    * Set to `true` if focus should be moved to clock picker.
//    */
//   autoFocus: PropTypes__default.bool,

//   /**
//    * Override or extend the styles applied to the component.
//    */
//   classes: PropTypes__default.object,
//   className: PropTypes__default.string,

//   /**
//    * Overrideable components.
//    * @default {}
//    */
//   components: PropTypes__default.object,

//   /**
//    * The props used for each component slot.
//    * @default {}
//    */
//   componentsProps: PropTypes__default.object,

//   /**
//    * Selected date @DateIOType.
//    */
//   date: PropTypes__default.any,

//   /**
//    * If `true`, the picker and text field are disabled.
//    * @default false
//    */
//   disabled: PropTypes__default.bool,

//   /**
//    * Do not ignore date part when validating min/max time.
//    * @default false
//    */
//   disableIgnoringDatePartForTimeValidation: PropTypes__default.bool,

//   /**
//    * Accessible text that helps user to understand which time and view is selected.
//    * @template TDate
//    * @param {ClockPickerView} view The current view rendered.
//    * @param {TDate | null} time The current time.
//    * @param {MuiPickersAdapter<TDate>} adapter The current date adapter.
//    * @returns {string} The clock label.
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    * @default <TDate extends any>(
//    *   view: ClockView,
//    *   time: TDate | null,
//    *   adapter: MuiPickersAdapter<TDate>,
//    * ) =>
//    *   `Select ${view}. ${
//    *     time === null ? 'No time selected' : `Selected time is ${adapter.format(time, 'fullTime')}`
//    *   }`
//    */
//   getClockLabelText: PropTypes__default.func,

//   /**
//    * Get clock number aria-text for hours.
//    * @param {string} hours The hours to format.
//    * @returns {string} the formatted hours text.
//    * @default (hours: string) => `${hours} hours`
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   getHoursClockNumberText: PropTypes__default.func,

//   /**
//    * Get clock number aria-text for minutes.
//    * @param {string} minutes The minutes to format.
//    * @returns {string} the formatted minutes text.
//    * @default (minutes: string) => `${minutes} minutes`
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   getMinutesClockNumberText: PropTypes__default.func,

//   /**
//    * Get clock number aria-text for seconds.
//    * @param {string} seconds The seconds to format.
//    * @returns {string} the formatted seconds text.
//    * @default (seconds: string) => `${seconds} seconds`
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   getSecondsClockNumberText: PropTypes__default.func,

//   /**
//    * Left arrow icon aria-label text.
//    * @default 'open previous view'
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   leftArrowButtonText: PropTypes__default.string,

//   /**
//    * Max time acceptable time.
//    * For input validation date part of passed object will be ignored if `disableIgnoringDatePartForTimeValidation` not specified.
//    */
//   maxTime: PropTypes__default.any,

//   /**
//    * Min time acceptable time.
//    * For input validation date part of passed object will be ignored if `disableIgnoringDatePartForTimeValidation` not specified.
//    */
//   minTime: PropTypes__default.any,

//   /**
//    * Step over minutes.
//    * @default 1
//    */
//   minutesStep: PropTypes__default.number,

//   /**
//    * On change callback @DateIOType.
//    */
//   onChange: PropTypes__default.func.isRequired,

//   /**
//    * Callback fired on view change.
//    * @param {ClockPickerView} view The new view.
//    */
//   onViewChange: PropTypes__default.func,

//   /**
//    * Initially open view.
//    * @default 'hours'
//    */
//   openTo: PropTypes__default.oneOf(['hours', 'minutes', 'seconds']),

//   /**
//    * Make picker read only.
//    * @default false
//    */
//   readOnly: PropTypes__default.bool,

//   /**
//    * Right arrow icon aria-label text.
//    * @default 'open next view'
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   rightArrowButtonText: PropTypes__default.string,

//   /**
//    * Dynamically check if time is disabled or not.
//    * If returns `false` appropriate time point will ot be acceptable.
//    * @param {number} timeValue The value to check.
//    * @param {ClockPickerView} clockType The clock type of the timeValue.
//    * @returns {boolean} Returns `true` if the time should be disabled
//    */
//   shouldDisableTime: PropTypes__default.func,
//   showViewSwitcher: PropTypes__default.bool,

//   /**
//    * Controlled open view.
//    */
//   view: PropTypes__default.oneOf(['hours', 'minutes', 'seconds']),

//   /**
//    * Views for calendar picker.
//    * @default ['hours', 'minutes']
//    */
//   views: PropTypes__default.arrayOf(PropTypes__default.oneOf(['hours', 'minutes', 'seconds']).isRequired)
// } : void 0;

// const isYearOnlyView = views => views.length === 1 && views[0] === 'year';
// const isYearAndMonthViews = views => views.length === 2 && views.indexOf('month') !== -1 && views.indexOf('year') !== -1;

// const getFormatAndMaskByViews = (views, utils) => {
//   if (isYearOnlyView(views)) {
//     return {
//       inputFormat: utils.formats.year
//     };
//   }

//   if (isYearAndMonthViews(views)) {
//     return {
//       disableMaskedInput: true,
//       inputFormat: utils.formats.monthAndYear
//     };
//   }

//   return {
//     inputFormat: utils.formats.keyboardDate
//   };
// };

// function useDatePickerDefaultizedProps(props, name) {
//   var _themeProps$views;

//   const utils = useUtils();
//   const defaultDates = useDefaultDates(); // This is technically unsound if the type parameters appear in optional props.
//   // Optional props can be filled by `useThemeProps` with types that don't match the type parameters.

//   const themeProps = useThemeProps({
//     props,
//     name
//   });
//   const views = (_themeProps$views = themeProps.views) != null ? _themeProps$views : ['year', 'day'];
//   return _extends$u({
//     openTo: 'day',
//     disableFuture: false,
//     disablePast: false
//   }, getFormatAndMaskByViews(views, utils), themeProps, {
//     views,
//     minDate: parseNonNullablePickerDate(utils, themeProps.minDate, defaultDates.minDate),
//     maxDate: parseNonNullablePickerDate(utils, themeProps.maxDate, defaultDates.maxDate)
//   });
// }
// const datePickerValueManager = {
//   emptyValue: null,
//   getTodayValue: utils => utils.date(),
//   parseInput: parsePickerInputValue,
//   areValuesEqual: (utils, a, b) => utils.isEqual(a, b)
// };

// function getPickersToolbarUtilityClass(slot) {
//   return generateUtilityClass$1('MuiPickersToolbar', slot);
// }
// const pickersToolbarClasses = generateUtilityClasses$1('MuiPickersToolbar', ['root', 'content', 'penIconButton', 'penIconButtonLandscape']);

// const useUtilityClasses$9 = ownerState => {
//   const {
//     classes,
//     isLandscape
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     content: ['content'],
//     penIconButton: ['penIconButton', isLandscape && 'penIconButtonLandscape']
//   };
//   return unstable_composeClasses(slots, getPickersToolbarUtilityClass, classes);
// };

// const PickersToolbarRoot = styled$1('div', {
//   name: 'MuiPickersToolbar',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })(({
//   theme,
//   ownerState
// }) => _extends$u({
//   display: 'flex',
//   flexDirection: 'column',
//   alignItems: 'flex-start',
//   justifyContent: 'space-between',
//   padding: theme.spacing(2, 3)
// }, ownerState.isLandscape && {
//   height: 'auto',
//   maxWidth: 160,
//   padding: 16,
//   justifyContent: 'flex-start',
//   flexWrap: 'wrap'
// }));
// const PickersToolbarContent = styled$1(Grid, {
//   name: 'MuiPickersToolbar',
//   slot: 'Content',
//   overridesResolver: (props, styles) => styles.content
// })(({
//   ownerState
// }) => _extends$u({
//   flex: 1
// }, !ownerState.isLandscape && {
//   alignItems: 'center'
// }));
// const PickersToolbarPenIconButton = styled$1(IconButton$1, {
//   name: 'MuiPickersToolbar',
//   slot: 'PenIconButton',
//   overridesResolver: (props, styles) => [{
//     [`&.${pickersToolbarClasses.penIconButtonLandscape}`]: styles.penIconButtonLandscape
//   }, styles.penIconButton]
// })({});

// const getViewTypeIcon = viewType => viewType === 'clock' ? /*#__PURE__*/jsx(Clock$1, {
//   color: "inherit"
// }) : /*#__PURE__*/jsx(Calendar, {
//   color: "inherit"
// });

// const PickersToolbar = /*#__PURE__*/React.forwardRef(function PickersToolbar(inProps, ref) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiPickersToolbar'
//   });
//   const {
//     children,
//     className,
//     getMobileKeyboardInputViewButtonText,
//     isLandscape,
//     isMobileKeyboardViewOpen,
//     landscapeDirection = 'column',
//     toggleMobileKeyboardView,
//     toolbarTitle,
//     viewType = 'calendar'
//   } = props;
//   const ownerState = props;
//   const localeText = useLocaleText();
//   const classes = useUtilityClasses$9(ownerState);
//   return /*#__PURE__*/jsxs(PickersToolbarRoot, {
//     ref: ref,
//     className: clsx$1(classes.root, className),
//     ownerState: ownerState,
//     children: [/*#__PURE__*/jsx(Typography, {
//       color: "text.secondary",
//       variant: "overline",
//       children: toolbarTitle
//     }), /*#__PURE__*/jsxs(PickersToolbarContent, {
//       container: true,
//       justifyContent: "space-between",
//       className: classes.content,
//       ownerState: ownerState,
//       direction: isLandscape ? landscapeDirection : 'row',
//       alignItems: isLandscape ? 'flex-start' : 'flex-end',
//       children: [children, /*#__PURE__*/jsx(PickersToolbarPenIconButton, {
//         onClick: toggleMobileKeyboardView,
//         className: classes.penIconButton,
//         ownerState: ownerState,
//         color: "inherit",
//         "aria-label": getMobileKeyboardInputViewButtonText ? getMobileKeyboardInputViewButtonText(isMobileKeyboardViewOpen, viewType) : localeText.inputModeToggleButtonAriaLabel(isMobileKeyboardViewOpen, viewType),
//         children: isMobileKeyboardViewOpen ? getViewTypeIcon(viewType) : /*#__PURE__*/jsx(Pen, {
//           color: "inherit"
//         })
//       })]
//     })]
//   });
// });

// function getDatePickerToolbarUtilityClass(slot) {
//   return generateUtilityClass$1('MuiDatePickerToolbar', slot);
// }
// generateUtilityClasses$1('MuiDatePickerToolbar', ['root', 'title']);

// const _excluded$I = ["parsedValue", "isLandscape", "isMobileKeyboardViewOpen", "onChange", "toggleMobileKeyboardView", "toolbarFormat", "toolbarPlaceholder", "toolbarTitle", "views"];

// const useUtilityClasses$8 = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     title: ['title']
//   };
//   return unstable_composeClasses(slots, getDatePickerToolbarUtilityClass, classes);
// };

// const DatePickerToolbarRoot = styled$1(PickersToolbar, {
//   name: 'MuiDatePickerToolbar',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })({});
// const DatePickerToolbarTitle = styled$1(Typography, {
//   name: 'MuiDatePickerToolbar',
//   slot: 'Title',
//   overridesResolver: (_, styles) => styles.title
// })(({
//   ownerState
// }) => _extends$u({}, ownerState.isLandscape && {
//   margin: 'auto 16px auto auto'
// }));

// /**
//  * @ignore - internal component.
//  */
// const DatePickerToolbar = /*#__PURE__*/React.forwardRef(function DatePickerToolbar(inProps, ref) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiDatePickerToolbar'
//   });

//   const {
//     parsedValue,
//     isLandscape,
//     isMobileKeyboardViewOpen,
//     toggleMobileKeyboardView,
//     toolbarFormat,
//     toolbarPlaceholder = '––',
//     toolbarTitle: toolbarTitleProp,
//     views
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$I);

//   const utils = useUtils();
//   const localeText = useLocaleText();
//   const classes = useUtilityClasses$8(props);
//   const toolbarTitle = toolbarTitleProp != null ? toolbarTitleProp : localeText.datePickerDefaultToolbarTitle;
//   const dateText = React.useMemo(() => {
//     if (!parsedValue) {
//       return toolbarPlaceholder;
//     }

//     if (toolbarFormat) {
//       return utils.formatByString(parsedValue, toolbarFormat);
//     }

//     if (isYearOnlyView(views)) {
//       return utils.format(parsedValue, 'year');
//     }

//     if (isYearAndMonthViews(views)) {
//       return utils.format(parsedValue, 'month');
//     } // Little localization hack (Google is doing the same for android native pickers):
//     // For english localization it is convenient to include weekday into the date "Mon, Jun 1".
//     // For other locales using strings like "June 1", without weekday.


//     return /en/.test(utils.getCurrentLocaleCode()) ? utils.format(parsedValue, 'normalDateWithWeekday') : utils.format(parsedValue, 'normalDate');
//   }, [parsedValue, toolbarFormat, toolbarPlaceholder, utils, views]);
//   const ownerState = props;
//   return /*#__PURE__*/jsx(DatePickerToolbarRoot, _extends$u({
//     ref: ref,
//     toolbarTitle: toolbarTitle,
//     isMobileKeyboardViewOpen: isMobileKeyboardViewOpen,
//     toggleMobileKeyboardView: toggleMobileKeyboardView,
//     isLandscape: isLandscape,
//     className: classes.root
//   }, other, {
//     children: /*#__PURE__*/jsx(DatePickerToolbarTitle, {
//       variant: "h4",
//       align: isLandscape ? 'left' : 'center',
//       ownerState: ownerState,
//       className: classes.title,
//       children: dateText
//     })
//   }));
// });

// const _excluded$H = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
// const PickersActionBar = props => {
//   const {
//     onAccept,
//     onClear,
//     onCancel,
//     onSetToday,
//     actions
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$H);

//   const wrapperVariant = React.useContext(WrapperVariantContext);
//   const localeText = useLocaleText();
//   const actionsArray = typeof actions === 'function' ? actions(wrapperVariant) : actions;

//   if (actionsArray == null || actionsArray.length === 0) {
//     return null;
//   }

//   const buttons = actionsArray == null ? void 0 : actionsArray.map(actionType => {
//     switch (actionType) {
//       case 'clear':
//         return /*#__PURE__*/jsx(Button$2, {
//           onClick: onClear,
//           children: localeText.clearButtonLabel
//         }, actionType);

//       case 'cancel':
//         return /*#__PURE__*/jsx(Button$2, {
//           onClick: onCancel,
//           children: localeText.cancelButtonLabel
//         }, actionType);

//       case 'accept':
//         return /*#__PURE__*/jsx(Button$2, {
//           onClick: onAccept,
//           children: localeText.okButtonLabel
//         }, actionType);

//       case 'today':
//         return /*#__PURE__*/jsx(Button$2, {
//           onClick: onSetToday,
//           children: localeText.todayButtonLabel
//         }, actionType);

//       default:
//         return null;
//     }
//   });
//   return /*#__PURE__*/jsx(DialogActions$1, _extends$u({}, other, {
//     children: buttons
//   }));
// };

// function getPickersPopperUtilityClass(slot) {
//   return generateUtilityClass$1('MuiPickersPopper', slot);
// }
// generateUtilityClasses$1('MuiPickersPopper', ['root', 'paper']);

// const _excluded$G = ["onClick", "onTouchStart"];

// const useUtilityClasses$7 = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     paper: ['paper']
//   };
//   return unstable_composeClasses(slots, getPickersPopperUtilityClass, classes);
// };

// const PickersPopperRoot = styled$1(Popper$1, {
//   name: 'MuiPickersPopper',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })(({
//   theme
// }) => ({
//   zIndex: theme.zIndex.modal
// }));
// const PickersPopperPaper = styled$1(Paper$1, {
//   name: 'MuiPickersPopper',
//   slot: 'Paper',
//   overridesResolver: (_, styles) => styles.paper
// })(({
//   ownerState
// }) => _extends$u({
//   transformOrigin: 'top center',
//   outline: 0
// }, ownerState.placement === 'top' && {
//   transformOrigin: 'bottom center'
// }));

// function clickedRootScrollbar(event, doc) {
//   return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
// }

// /**
//  * Based on @mui/material/ClickAwayListener without the customization.
//  * We can probably strip away even more since children won't be portaled.
//  * @param {boolean} active Only listen to clicks when the popper is opened.
//  * @param {(event: MouseEvent | TouchEvent) => void} onClickAway The callback to call when clicking outside the popper.
//  * @returns {Array} The ref and event handler to listen to the outside clicks.
//  */
// function useClickAwayListener(active, onClickAway) {
//   const movedRef = React.useRef(false);
//   const syntheticEventRef = React.useRef(false);
//   const nodeRef = React.useRef(null);
//   const activatedRef = React.useRef(false);
//   React.useEffect(() => {
//     if (!active) {
//       return undefined;
//     } // Ensure that this hook is not "activated" synchronously.
//     // https://github.com/facebook/react/issues/20074


//     function armClickAwayListener() {
//       activatedRef.current = true;
//     }

//     document.addEventListener('mousedown', armClickAwayListener, true);
//     document.addEventListener('touchstart', armClickAwayListener, true);
//     return () => {
//       document.removeEventListener('mousedown', armClickAwayListener, true);
//       document.removeEventListener('touchstart', armClickAwayListener, true);
//       activatedRef.current = false;
//     };
//   }, [active]); // The handler doesn't take event.defaultPrevented into account:
//   //
//   // event.preventDefault() is meant to stop default behaviors like
//   // clicking a checkbox to check it, hitting a button to submit a form,
//   // and hitting left arrow to move the cursor in a text input etc.
//   // Only special HTML elements have these default behaviors.

//   const handleClickAway = useEventCallback$2(event => {
//     if (!activatedRef.current) {
//       return;
//     } // Given developers can stop the propagation of the synthetic event,
//     // we can only be confident with a positive value.


//     const insideReactTree = syntheticEventRef.current;
//     syntheticEventRef.current = false;
//     const doc = ownerDocument$1(nodeRef.current); // 1. IE11 support, which trigger the handleClickAway even after the unbind
//     // 2. The child might render null.
//     // 3. Behave like a blur listener.

//     if (!nodeRef.current || // is a TouchEvent?
//     'clientX' in event && clickedRootScrollbar(event, doc)) {
//       return;
//     } // Do not act if user performed touchmove


//     if (movedRef.current) {
//       movedRef.current = false;
//       return;
//     }

//     let insideDOM; // If not enough, can use https://github.com/DieterHolvoet/event-propagation-path/blob/master/propagationPath.js

//     if (event.composedPath) {
//       insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
//     } else {
//       insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
//     }

//     if (!insideDOM && !insideReactTree) {
//       onClickAway(event);
//     }
//   }); // Keep track of mouse/touch events that bubbled up through the portal.

//   const handleSynthetic = () => {
//     syntheticEventRef.current = true;
//   };

//   React.useEffect(() => {
//     if (active) {
//       const doc = ownerDocument$1(nodeRef.current);

//       const handleTouchMove = () => {
//         movedRef.current = true;
//       };

//       doc.addEventListener('touchstart', handleClickAway);
//       doc.addEventListener('touchmove', handleTouchMove);
//       return () => {
//         doc.removeEventListener('touchstart', handleClickAway);
//         doc.removeEventListener('touchmove', handleTouchMove);
//       };
//     }

//     return undefined;
//   }, [active, handleClickAway]);
//   React.useEffect(() => {
//     // TODO This behavior is not tested automatically
//     // It's unclear whether this is due to different update semantics in test (batched in act() vs discrete on click).
//     // Or if this is a timing related issues due to different Transition components
//     // Once we get rid of all the manual scheduling (e.g. setTimeout(update, 0)) we can revisit this code+test.
//     if (active) {
//       const doc = ownerDocument$1(nodeRef.current);
//       doc.addEventListener('click', handleClickAway);
//       return () => {
//         doc.removeEventListener('click', handleClickAway); // cleanup `handleClickAway`

//         syntheticEventRef.current = false;
//       };
//     }

//     return undefined;
//   }, [active, handleClickAway]);
//   return [nodeRef, handleSynthetic, handleSynthetic];
// }

// function PickersPopper(inProps) {
//   var _components$ActionBar;

//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiPickersPopper'
//   });
//   const {
//     anchorEl,
//     children,
//     containerRef = null,
//     onBlur,
//     onClose,
//     onClear,
//     onAccept,
//     onCancel,
//     onSetToday,
//     open,
//     PopperProps,
//     role,
//     TransitionComponent = Grow$1,
//     TrapFocusProps,
//     PaperProps = {},
//     components,
//     componentsProps
//   } = props;
//   React.useEffect(() => {
//     function handleKeyDown(nativeEvent) {
//       // IE11, Edge (prior to using Bink?) use 'Esc'
//       if (open && (nativeEvent.key === 'Escape' || nativeEvent.key === 'Esc')) {
//         onClose();
//       }
//     }

//     document.addEventListener('keydown', handleKeyDown);
//     return () => {
//       document.removeEventListener('keydown', handleKeyDown);
//     };
//   }, [onClose, open]);
//   const lastFocusedElementRef = React.useRef(null);
//   React.useEffect(() => {
//     if (role === 'tooltip') {
//       return;
//     }

//     if (open) {
//       lastFocusedElementRef.current = getActiveElement(document);
//     } else if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
//       // make sure the button is flushed with updated label, before returning focus to it
//       // avoids issue, where screen reader could fail to announce selected date after selection
//       setTimeout(() => {
//         if (lastFocusedElementRef.current instanceof HTMLElement) {
//           lastFocusedElementRef.current.focus();
//         }
//       });
//     }
//   }, [open, role]);
//   const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open, onBlur != null ? onBlur : onClose);
//   const paperRef = React.useRef(null);
//   const handleRef = useForkRef$1(paperRef, containerRef);
//   const handlePaperRef = useForkRef$1(handleRef, clickAwayRef);
//   const ownerState = props;
//   const classes = useUtilityClasses$7(ownerState);

//   const {
//     onClick: onPaperClickProp,
//     onTouchStart: onPaperTouchStartProp
//   } = PaperProps,
//         otherPaperProps = _objectWithoutPropertiesLoose$k(PaperProps, _excluded$G);

//   const handleKeyDown = event => {
//     if (event.key === 'Escape') {
//       // stop the propagation to avoid closing parent modal
//       event.stopPropagation();
//       onClose();
//     }
//   };

//   const ActionBar = (_components$ActionBar = components == null ? void 0 : components.ActionBar) != null ? _components$ActionBar : PickersActionBar;
//   const PaperContent = (components == null ? void 0 : components.PaperContent) || React.Fragment;
//   return /*#__PURE__*/jsx(PickersPopperRoot, _extends$u({
//     transition: true,
//     role: role,
//     open: open,
//     anchorEl: anchorEl,
//     onKeyDown: handleKeyDown,
//     className: classes.root
//   }, PopperProps, {
//     children: ({
//       TransitionProps,
//       placement
//     }) => /*#__PURE__*/jsx(TrapFocus, _extends$u({
//       open: open,
//       disableAutoFocus: true // pickers are managing focus position manually
//       // without this prop the focus is returned to the button before `aria-label` is updated
//       // which would force screen readers to read too old label
//       ,
//       disableRestoreFocus: true,
//       disableEnforceFocus: role === 'tooltip',
//       isEnabled: () => true
//     }, TrapFocusProps, {
//       children: /*#__PURE__*/jsx(TransitionComponent, _extends$u({}, TransitionProps, {
//         children: /*#__PURE__*/jsx(PickersPopperPaper, _extends$u({
//           tabIndex: -1,
//           elevation: 8,
//           ref: handlePaperRef,
//           onClick: event => {
//             onPaperClick(event);

//             if (onPaperClickProp) {
//               onPaperClickProp(event);
//             }
//           },
//           onTouchStart: event => {
//             onPaperTouchStart(event);

//             if (onPaperTouchStartProp) {
//               onPaperTouchStartProp(event);
//             }
//           },
//           ownerState: _extends$u({}, ownerState, {
//             placement
//           }),
//           className: classes.paper
//         }, otherPaperProps, {
//           children: /*#__PURE__*/jsxs(PaperContent, _extends$u({}, componentsProps == null ? void 0 : componentsProps.paperContent, {
//             children: [children, /*#__PURE__*/jsx(ActionBar, _extends$u({
//               onAccept: onAccept,
//               onClear: onClear,
//               onCancel: onCancel,
//               onSetToday: onSetToday,
//               actions: []
//             }, componentsProps == null ? void 0 : componentsProps.actionBar))]
//           }))
//         }))
//       }))
//     }))
//   }));
// }

// function DesktopWrapper(props) {
//   const {
//     children,
//     DateInputProps,
//     KeyboardDateInputComponent,
//     onClear,
//     onDismiss,
//     onCancel,
//     onAccept,
//     onSetToday,
//     open,
//     PopperProps,
//     PaperProps,
//     TransitionComponent,
//     components,
//     componentsProps
//   } = props;
//   const ownInputRef = React.useRef(null);
//   const inputRef = useForkRef$1(DateInputProps.inputRef, ownInputRef);
//   return /*#__PURE__*/jsxs(WrapperVariantContext.Provider, {
//     value: "desktop",
//     children: [/*#__PURE__*/jsx(KeyboardDateInputComponent, _extends$u({}, DateInputProps, {
//       inputRef: inputRef
//     })), /*#__PURE__*/jsx(PickersPopper, {
//       role: "dialog",
//       open: open,
//       anchorEl: ownInputRef.current,
//       TransitionComponent: TransitionComponent,
//       PopperProps: PopperProps,
//       PaperProps: PaperProps,
//       onClose: onDismiss,
//       onCancel: onCancel,
//       onClear: onClear,
//       onAccept: onAccept,
//       onSetToday: onSetToday,
//       components: components,
//       componentsProps: componentsProps,
//       children: children
//     })]
//   });
// }

// const useRifm = props => {
//   const [, refresh] = useReducer$1(c => c + 1, 0);
//   const valueRef = useRef$2(null);
//   const {
//     replace,
//     append
//   } = props;
//   const userValue = replace ? replace(props.format(props.value)) : props.format(props.value); // state of delete button see comments below about inputType support

//   const isDeleleteButtonDownRef = useRef$2(false);

//   const onChange = evt => {
//     if (process.env.NODE_ENV !== 'production') {
//       if (evt.target.type === 'number') {
//         console.error('Rifm does not support input type=number, use type=tel instead.');
//         return;
//       }

//       if (evt.target.type === 'date') {
//         console.error('Rifm does not support input type=date.');
//         return;
//       }
//     }

//     const eventValue = evt.target.value;
//     valueRef.current = [eventValue, // eventValue
//     evt.target, // input
//     eventValue.length > userValue.length, // isSizeIncreaseOperation
//     isDeleleteButtonDownRef.current, // isDeleleteButtonDown
//     userValue === props.format(eventValue) // isNoOperation
//     ];

//     if (process.env.NODE_ENV !== 'production') {
//       const formattedEventValue = props.format(eventValue);

//       if (eventValue !== formattedEventValue && eventValue.toLowerCase() === formattedEventValue.toLowerCase()) {
//         console.warn('Case enforcement does not work with format. Please use replace={value => value.toLowerCase()} instead');
//       }
//     } // The main trick is to update underlying input with non formatted value (= eventValue)
//     // that allows us to calculate right cursor position after formatting (see getCursorPosition)
//     // then we format new value and call props.onChange with masked/formatted value
//     // and finally we are able to set cursor position into right place


//     refresh();
//   }; // React prints warn on server in non production mode about useLayoutEffect usage
//   // in both cases it's noop


//   if (process.env.NODE_ENV === 'production' || typeof window !== 'undefined') {
//     useLayoutEffect(() => {
//       if (valueRef.current == null) return;
//       let [eventValue, input, isSizeIncreaseOperation, isDeleleteButtonDown, // No operation means that value itself hasn't been changed, BTW cursor, selection etc can be changed
//       isNoOperation] = valueRef.current;
//       valueRef.current = null; // this usually occurs on deleting special symbols like ' here 123'123.00
//       // in case of isDeleleteButtonDown cursor should move differently vs backspace

//       const deleteWasNoOp = isDeleleteButtonDown && isNoOperation;
//       const valueAfterSelectionStart = eventValue.slice(input.selectionStart);
//       const acceptedCharIndexAfterDelete = valueAfterSelectionStart.search(props.accept || /\d/g);
//       const charsToSkipAfterDelete = acceptedCharIndexAfterDelete !== -1 ? acceptedCharIndexAfterDelete : 0; // Create string from only accepted symbols

//       const clean = str => (str.match(props.accept || /\d/g) || []).join('');

//       const valueBeforeSelectionStart = clean(eventValue.substr(0, input.selectionStart)); // trying to find cursor position in formatted value having knowledge about valueBeforeSelectionStart
//       // This works because we assume that format doesn't change the order of accepted symbols.
//       // Imagine we have formatter which adds ' symbol between numbers, and by default we refuse all non numeric symbols
//       // for example we had input = 1'2|'4 (| means cursor position) then user entered '3' symbol
//       // inputValue = 1'23'|4 so valueBeforeSelectionStart = 123 and formatted value = 1'2'3'4
//       // calling getCursorPosition("1'2'3'4") will give us position after 3, 1'2'3|'4
//       // so for formatting just this function to determine cursor position after formatting is enough
//       // with masking we need to do some additional checks see `mask` below

//       const getCursorPosition = val => {
//         let start = 0;
//         let cleanPos = 0;

//         for (let i = 0; i !== valueBeforeSelectionStart.length; ++i) {
//           let newPos = val.indexOf(valueBeforeSelectionStart[i], start) + 1;
//           let newCleanPos = clean(val).indexOf(valueBeforeSelectionStart[i], cleanPos) + 1; // this skips position change if accepted symbols order was broken
//           // For example fixes edge case with fixed point numbers:
//           // You have '0|.00', then press 1, it becomes 01|.00 and after format 1.00, this breaks our assumption
//           // that order of accepted symbols is not changed after format,
//           // so here we don't update start position if other accepted symbols was inbetween current and new position

//           if (newCleanPos - cleanPos > 1) {
//             newPos = start;
//             newCleanPos = cleanPos;
//           }

//           cleanPos = Math.max(newCleanPos, cleanPos);
//           start = Math.max(start, newPos);
//         }

//         return start;
//       }; // Masking part, for masks if size of mask is above some value
//       // we need to replace symbols instead of do nothing as like in format


//       if (props.mask === true && isSizeIncreaseOperation && !isNoOperation) {
//         let start = getCursorPosition(eventValue);
//         const c = clean(eventValue.substr(start))[0];
//         start = eventValue.indexOf(c, start);
//         eventValue = `${eventValue.substr(0, start)}${eventValue.substr(start + 1)}`;
//       }

//       let formattedValue = props.format(eventValue);

//       if (append != null && // cursor at the end
//       input.selectionStart === eventValue.length && !isNoOperation) {
//         if (isSizeIncreaseOperation) {
//           formattedValue = append(formattedValue);
//         } else {
//           // If after delete last char is special character and we use append
//           // delete it too
//           // was: "12-3|" backspace pressed, then should be "12|"
//           if (clean(formattedValue.slice(-1)) === '') {
//             formattedValue = formattedValue.slice(0, -1);
//           }
//         }
//       }

//       const replacedValue = replace ? replace(formattedValue) : formattedValue;

//       if (userValue === replacedValue) {
//         // if nothing changed for formatted value, just refresh so userValue will be used at render
//         refresh();
//       } else {
//         props.onChange(replacedValue);
//       }

//       return () => {
//         let start = getCursorPosition(formattedValue); // Visually improves working with masked values,
//         // like cursor jumping over refused symbols
//         // as an example date mask: was "5|1-24-3" then user pressed "6"
//         // it becomes "56-|12-43" with this code, and "56|-12-43" without

//         if (props.mask != null && (isSizeIncreaseOperation || isDeleleteButtonDown && !deleteWasNoOp)) {
//           while (formattedValue[start] && clean(formattedValue[start]) === '') {
//             start += 1;
//           }
//         }

//         input.selectionStart = input.selectionEnd = start + (deleteWasNoOp ? 1 + charsToSkipAfterDelete : 0);
//       };
//     });
//   }

//   useEffect$2(() => {
//     // until https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType will be supported
//     // by all major browsers (now supported by: +chrome, +safari, ?edge, !firefox)
//     // there is no way I found to distinguish in onChange
//     // backspace or delete was called in some situations
//     // firefox track https://bugzilla.mozilla.org/show_bug.cgi?id=1447239
//     const handleKeyDown = evt => {
//       if (evt.code === 'Delete') {
//         isDeleleteButtonDownRef.current = true;
//       }
//     };

//     const handleKeyUp = evt => {
//       if (evt.code === 'Delete') {
//         isDeleleteButtonDownRef.current = false;
//       }
//     };

//     document.addEventListener('keydown', handleKeyDown);
//     document.addEventListener('keyup', handleKeyUp);
//     return () => {
//       document.removeEventListener('keydown', handleKeyDown);
//       document.removeEventListener('keyup', handleKeyUp);
//     };
//   }, []);
//   return {
//     value: valueRef.current != null ? valueRef.current[0] : userValue,
//     onChange
//   };
// };

// const getDisplayDate = (utils, rawValue, inputFormat) => {
//   const date = utils.date(rawValue);
//   const isEmpty = rawValue === null;

//   if (isEmpty) {
//     return '';
//   }

//   return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?
//   // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.
//   // Or we ensure `formatByString` is callable with `null`.
//   date, inputFormat) : '';
// };
// const MASK_USER_INPUT_SYMBOL = '_';
// const staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';
// const staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';
// function getMaskFromCurrentFormat(mask, format, acceptRegex, utils) {
//   if (mask) {
//     return mask;
//   }

//   const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);
//   const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);
//   const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');

//   if (inferredFormatPatternWith1Digits === inferredFormatPatternWith2Digits) {
//     return inferredFormatPatternWith1Digits;
//   }

//   if (process.env.NODE_ENV !== 'production') {
//     console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\n'));
//   }

//   return '';
// }
// function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {
//   if (!mask) {
//     return false;
//   }

//   const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);
//   const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);
//   const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');
//   const isMaskValid = inferredFormatPatternWith2Digits === inferredFormatPatternWith1Digits && mask === inferredFormatPatternWith2Digits;

//   if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {
//     if (format.includes('MMM')) {
//       console.warn([`Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\n'));
//     } else if (inferredFormatPatternWith2Digits && inferredFormatPatternWith2Digits !== inferredFormatPatternWith1Digits) {
//       console.warn([`Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`, `Falling down to uncontrolled no-mask input.`].join('\n'));
//     } else if (mask) {
//       console.warn([`The mask "${mask}" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`].join('\n'));
//     }
//   }

//   return isMaskValid;
// }
// const maskedDateFormatter = (mask, acceptRegexp) => value => {
//   let outputCharIndex = 0;
//   return value.split('').map((char, inputCharIndex) => {
//     acceptRegexp.lastIndex = 0;

//     if (outputCharIndex > mask.length - 1) {
//       return '';
//     }

//     const maskChar = mask[outputCharIndex];
//     const nextMaskChar = mask[outputCharIndex + 1];
//     const acceptedChar = acceptRegexp.test(char) ? char : '';
//     const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;
//     outputCharIndex += formattedChar.length;
//     const isLastCharacter = inputCharIndex === value.length - 1;

//     if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {
//       // when cursor at the end of mask part (e.g. month) prerender next symbol "21" -> "21/"
//       return formattedChar ? formattedChar + nextMaskChar : '';
//     }

//     return formattedChar;
//   }).join('');
// };

// const useMaskedInput = ({
//   acceptRegex = /[\d]/gi,
//   disabled,
//   disableMaskedInput,
//   ignoreInvalidInputs,
//   inputFormat,
//   inputProps,
//   label,
//   mask,
//   onChange,
//   rawValue,
//   readOnly,
//   rifmFormatter,
//   TextFieldProps,
//   validationError
// }) => {
//   const utils = useUtils();
//   const formatHelperText = utils.getFormatHelperText(inputFormat);
//   const {
//     shouldUseMaskedInput,
//     maskToUse
//   } = React.useMemo(() => {
//     // formatting of dates is a quite slow thing, so do not make useless .format calls
//     if (disableMaskedInput) {
//       return {
//         shouldUseMaskedInput: false,
//         maskToUse: ''
//       };
//     }

//     const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);
//     return {
//       shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),
//       maskToUse: computedMaskToUse
//     };
//   }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);
//   const formatter = React.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : st => st, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`

//   const parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input

//   const [innerInputValue, setInnerInputValue] = React.useState(parsedValue); // control the input text

//   const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React.useState(getDisplayDate(utils, rawValue, inputFormat)); // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201

//   const prevRawValue = React.useRef();
//   const prevLocale = React.useRef(utils.locale);
//   const prevInputFormat = React.useRef(inputFormat);
//   React.useEffect(() => {
//     const rawValueHasChanged = rawValue !== prevRawValue.current;
//     const localeHasChanged = utils.locale !== prevLocale.current;
//     const inputFormatHasChanged = inputFormat !== prevInputFormat.current;
//     prevRawValue.current = rawValue;
//     prevLocale.current = utils.locale;
//     prevInputFormat.current = inputFormat;

//     if (!rawValueHasChanged && !localeHasChanged && !inputFormatHasChanged) {
//       return;
//     }

//     const newParsedValue = rawValue === null ? null : utils.date(rawValue);
//     const isAcceptedValue = rawValue === null || utils.isValid(newParsedValue);
//     let innerEqualsParsed = innerInputValue === null && newParsedValue === null; // equal by being both null

//     if (innerInputValue !== null && newParsedValue !== null) {
//       const areEqual = utils.isEqual(innerInputValue, newParsedValue);

//       if (areEqual) {
//         innerEqualsParsed = true;
//       } else {
//         const diff = Math.abs(utils.getDiff(innerInputValue, newParsedValue)); // diff in ms

//         innerEqualsParsed = diff === 0 ? areEqual // if no diff, use equal to test the time-zone
//         : diff < 1000; // accept a difference bellow 1s
//       }
//     }

//     if (!localeHasChanged && !inputFormatHasChanged && (!isAcceptedValue || innerEqualsParsed)) {
//       return;
//     } // When dev set a new valid value, we trust them


//     const newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);
//     setInnerInputValue(newParsedValue);
//     setInnerDisplayedInputValue(newDisplayDate);
//   }, [utils, rawValue, inputFormat, innerInputValue]);

//   const handleChange = text => {
//     const finalString = text === '' || text === mask ? '' : text;
//     setInnerDisplayedInputValue(finalString);
//     const date = finalString === null ? null : utils.parse(finalString, inputFormat);

//     if (ignoreInvalidInputs && !utils.isValid(date)) {
//       return;
//     }

//     setInnerInputValue(date);
//     onChange(date, finalString || undefined);
//   };

//   const rifmProps = useRifm({
//     value: innerDisplayedInputValue,
//     onChange: handleChange,
//     format: rifmFormatter || formatter
//   });
//   const inputStateArgs = shouldUseMaskedInput ? rifmProps : {
//     value: innerDisplayedInputValue,
//     onChange: event => {
//       handleChange(event.currentTarget.value);
//     }
//   };
//   return _extends$u({
//     label,
//     disabled,
//     error: validationError,
//     inputProps: _extends$u({}, inputStateArgs, {
//       disabled,
//       placeholder: formatHelperText,
//       readOnly,
//       type: shouldUseMaskedInput ? 'tel' : 'text'
//     }, inputProps)
//   }, TextFieldProps);
// };

// const _excluded$F = ["className", "components", "disableOpenPicker", "getOpenDialogAriaText", "InputAdornmentProps", "InputProps", "inputRef", "openPicker", "OpenPickerButtonProps", "renderInput"];
// const KeyboardDateInput = /*#__PURE__*/React.forwardRef(function KeyboardDateInput(props, ref) {
//   const {
//     className,
//     components = {},
//     disableOpenPicker,
//     getOpenDialogAriaText: getOpenDialogAriaTextProp,
//     InputAdornmentProps,
//     InputProps,
//     inputRef,
//     openPicker,
//     OpenPickerButtonProps,
//     renderInput
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$F);

//   const localeText = useLocaleText();
//   const getOpenDialogAriaText = getOpenDialogAriaTextProp != null ? getOpenDialogAriaTextProp : localeText.openDatePickerDialogue;
//   const utils = useUtils();
//   const textFieldProps = useMaskedInput(other);
//   const adornmentPosition = (InputAdornmentProps == null ? void 0 : InputAdornmentProps.position) || 'end';
//   const OpenPickerIcon = components.OpenPickerIcon || Calendar;
//   return renderInput(_extends$u({
//     ref,
//     inputRef,
//     className
//   }, textFieldProps, {
//     InputProps: _extends$u({}, InputProps, {
//       [`${adornmentPosition}Adornment`]: disableOpenPicker ? undefined : /*#__PURE__*/jsx(InputAdornment$1, _extends$u({
//         position: adornmentPosition
//       }, InputAdornmentProps, {
//         children: /*#__PURE__*/jsx(IconButton$1, _extends$u({
//           edge: adornmentPosition,
//           disabled: other.disabled || other.readOnly,
//           "aria-label": getOpenDialogAriaText(other.rawValue, utils)
//         }, OpenPickerButtonProps, {
//           onClick: openPicker,
//           children: /*#__PURE__*/jsx(OpenPickerIcon, {})
//         }))
//       }))
//     })
//   }));
// });

// function getOrientation() {
//   if (typeof window === 'undefined') {
//     return 'portrait';
//   }

//   if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
//     return Math.abs(window.screen.orientation.angle) === 90 ? 'landscape' : 'portrait';
//   } // Support IOS safari


//   if (window.orientation) {
//     return Math.abs(Number(window.orientation)) === 90 ? 'landscape' : 'portrait';
//   }

//   return 'portrait';
// }

// const useIsLandscape = (views, customOrientation) => {
//   const [orientation, setOrientation] = React.useState(getOrientation);
//   useEnhancedEffect(() => {
//     const eventHandler = () => {
//       setOrientation(getOrientation());
//     };

//     window.addEventListener('orientationchange', eventHandler);
//     return () => {
//       window.removeEventListener('orientationchange', eventHandler);
//     };
//   }, []);

//   if (arrayIncludes(views, ['hours', 'minutes', 'seconds'])) {
//     // could not display 13:34:44 in landscape mode
//     return false;
//   }

//   const orientationToUse = customOrientation || orientation;
//   return orientationToUse === 'landscape';
// };

// const useFocusManagement = ({
//   autoFocus,
//   openView
// }) => {
//   const [focusedView, setFocusedView] = React.useState(autoFocus ? openView : null);
//   const setFocusedViewCallback = React.useCallback(view => newHasFocus => {
//     if (newHasFocus) {
//       setFocusedView(view);
//     } else {
//       setFocusedView(prevFocusedView => view === prevFocusedView ? null : prevFocusedView);
//     }
//   }, []);
//   return {
//     focusedView,
//     setFocusedView: setFocusedViewCallback
//   };
// };

// function getCalendarOrClockPickerUtilityClass(slot) {
//   return generateUtilityClass$1('MuiCalendarOrClockPicker', slot);
// }
// generateUtilityClasses$1('MuiCalendarOrClockPicker', ['root', 'mobileKeyboardInputView']);

// const _excluded$E = ["autoFocus", "className", "parsedValue", "DateInputProps", "isMobileKeyboardViewOpen", "onDateChange", "onViewChange", "openTo", "orientation", "showToolbar", "toggleMobileKeyboardView", "ToolbarComponent", "toolbarFormat", "toolbarPlaceholder", "toolbarTitle", "views", "dateRangeIcon", "timeIcon", "hideTabs", "classes"];

// const useUtilityClasses$6 = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     mobileKeyboardInputView: ['mobileKeyboardInputView']
//   };
//   return unstable_composeClasses(slots, getCalendarOrClockPickerUtilityClass, classes);
// };

// const MobileKeyboardInputView = styled$1('div', {
//   name: 'MuiCalendarOrClockPicker',
//   slot: 'MobileKeyboardInputView',
//   overridesResolver: (_, styles) => styles.mobileKeyboardInputView
// })({
//   padding: '16px 24px'
// });
// const PickerRoot = styled$1('div', {
//   name: 'MuiCalendarOrClockPicker',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })(({
//   ownerState
// }) => _extends$u({
//   display: 'flex',
//   flexDirection: 'column'
// }, ownerState.isLandscape && {
//   flexDirection: 'row'
// }));
// const MobileKeyboardTextFieldProps = {
//   fullWidth: true
// };

// const isDatePickerView = view => view === 'year' || view === 'month' || view === 'day';

// const isTimePickerView = view => view === 'hours' || view === 'minutes' || view === 'seconds';

// let warnedOnceNotValidOpenTo = false;
// function CalendarOrClockPicker(inProps) {
//   var _other$components, _other$componentsProp;

//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiCalendarOrClockPicker'
//   });

//   const {
//     autoFocus,
//     parsedValue,
//     DateInputProps,
//     isMobileKeyboardViewOpen,
//     onDateChange,
//     onViewChange,
//     openTo,
//     orientation,
//     showToolbar,
//     toggleMobileKeyboardView,
//     ToolbarComponent = () => null,
//     toolbarFormat,
//     toolbarPlaceholder,
//     toolbarTitle,
//     views,
//     dateRangeIcon,
//     timeIcon,
//     hideTabs
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$E);

//   const TabsComponent = (_other$components = other.components) == null ? void 0 : _other$components.Tabs;
//   const isLandscape = useIsLandscape(views, orientation);
//   const wrapperVariant = React.useContext(WrapperVariantContext);
//   const classes = useUtilityClasses$6(props);
//   const toShowToolbar = showToolbar != null ? showToolbar : wrapperVariant !== 'desktop';
//   const showTabs = !hideTabs && typeof window !== 'undefined' && window.innerHeight > 667;
//   const handleDateChange = React.useCallback((newDate, selectionState) => {
//     onDateChange(newDate, wrapperVariant, selectionState);
//   }, [onDateChange, wrapperVariant]);
//   const handleViewChange = React.useCallback(newView => {
//     if (isMobileKeyboardViewOpen) {
//       toggleMobileKeyboardView();
//     }

//     if (onViewChange) {
//       onViewChange(newView);
//     }
//   }, [isMobileKeyboardViewOpen, onViewChange, toggleMobileKeyboardView]);

//   if (process.env.NODE_ENV !== 'production') {
//     if (!warnedOnceNotValidOpenTo && !views.includes(openTo)) {
//       console.warn(`MUI: \`openTo="${openTo}"\` is not a valid prop.`, `It must be an element of \`views=["${views.join('", "')}"]\`.`);
//       warnedOnceNotValidOpenTo = true;
//     }
//   }

//   const {
//     openView,
//     setOpenView,
//     handleChangeAndOpenNext
//   } = useViews({
//     view: undefined,
//     views,
//     openTo,
//     onChange: handleDateChange,
//     onViewChange: handleViewChange
//   });
//   const {
//     focusedView,
//     setFocusedView
//   } = useFocusManagement({
//     autoFocus,
//     openView
//   });
//   return /*#__PURE__*/jsxs(PickerRoot, {
//     ownerState: {
//       isLandscape
//     },
//     className: classes.root,
//     children: [toShowToolbar && /*#__PURE__*/jsx(ToolbarComponent, _extends$u({}, other, {
//       views: views,
//       isLandscape: isLandscape,
//       parsedValue: parsedValue,
//       onChange: handleDateChange,
//       setOpenView: setOpenView,
//       openView: openView,
//       toolbarTitle: toolbarTitle,
//       toolbarFormat: toolbarFormat,
//       toolbarPlaceholder: toolbarPlaceholder,
//       isMobileKeyboardViewOpen: isMobileKeyboardViewOpen,
//       toggleMobileKeyboardView: toggleMobileKeyboardView
//     })), showTabs && !!TabsComponent && /*#__PURE__*/jsx(TabsComponent, _extends$u({
//       dateRangeIcon: dateRangeIcon,
//       timeIcon: timeIcon,
//       view: openView,
//       onChange: setOpenView
//     }, (_other$componentsProp = other.componentsProps) == null ? void 0 : _other$componentsProp.tabs)), /*#__PURE__*/jsx(PickerViewRoot, {
//       children: isMobileKeyboardViewOpen ? /*#__PURE__*/jsx(MobileKeyboardInputView, {
//         className: classes.mobileKeyboardInputView,
//         children: /*#__PURE__*/jsx(KeyboardDateInput, _extends$u({}, DateInputProps, {
//           ignoreInvalidInputs: true,
//           disableOpenPicker: true,
//           TextFieldProps: MobileKeyboardTextFieldProps
//         }))
//       }) : /*#__PURE__*/jsxs(React.Fragment, {
//         children: [isDatePickerView(openView) && /*#__PURE__*/jsx(CalendarPicker, _extends$u({
//           autoFocus: autoFocus,
//           date: parsedValue,
//           onViewChange: setOpenView,
//           onChange: handleChangeAndOpenNext,
//           view: openView // Unclear why the predicate `isDatePickerView` does not imply the casted type
//           ,
//           views: views.filter(isDatePickerView),
//           focusedView: focusedView,
//           onFocusedViewChange: setFocusedView
//         }, other)), isTimePickerView(openView) && /*#__PURE__*/jsx(ClockPicker, _extends$u({}, other, {
//           autoFocus: autoFocus,
//           date: parsedValue,
//           view: openView // Unclear why the predicate `isDatePickerView` does not imply the casted type
//           ,
//           views: views.filter(isTimePickerView),
//           onChange: handleChangeAndOpenNext,
//           onViewChange: setOpenView,
//           showViewSwitcher: wrapperVariant === 'desktop'
//         }))]
//       })
//     })]
//   });
// }

// const useOpenState = ({
//   open,
//   onOpen,
//   onClose
// }) => {
//   const isControllingOpenProp = React.useRef(typeof open === 'boolean').current;
//   const [openState, setIsOpenState] = React.useState(false); // It is required to update inner state in useEffect in order to avoid situation when
//   // Our component is not mounted yet, but `open` state is set to `true` (e.g. initially opened)

//   React.useEffect(() => {
//     if (isControllingOpenProp) {
//       if (typeof open !== 'boolean') {
//         throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');
//       }

//       setIsOpenState(open);
//     }
//   }, [isControllingOpenProp, open]);
//   const setIsOpen = React.useCallback(newIsOpen => {
//     if (!isControllingOpenProp) {
//       setIsOpenState(newIsOpen);
//     }

//     if (newIsOpen && onOpen) {
//       onOpen();
//     }

//     if (!newIsOpen && onClose) {
//       onClose();
//     }
//   }, [isControllingOpenProp, onOpen, onClose]);
//   return {
//     isOpen: openState,
//     setIsOpen
//   };
// };

// const usePickerState = (props, valueManager) => {
//   const {
//     onAccept,
//     onChange,
//     value,
//     closeOnSelect
//   } = props;
//   const utils = useUtils();
//   const {
//     isOpen,
//     setIsOpen
//   } = useOpenState(props);
//   const parsedDateValue = React.useMemo(() => valueManager.parseInput(utils, value), [valueManager, utils, value]);
//   const [lastValidDateValue, setLastValidDateValue] = React.useState(parsedDateValue);
//   const [dateState, setDateState] = React.useState(() => ({
//     committed: parsedDateValue,
//     draft: parsedDateValue,
//     resetFallback: parsedDateValue
//   }));
//   const setDate = React.useCallback(params => {
//     setDateState(prev => {
//       switch (params.action) {
//         case 'setAll':
//         case 'acceptAndClose':
//           {
//             return {
//               draft: params.value,
//               committed: params.value,
//               resetFallback: params.value
//             };
//           }

//         case 'setCommitted':
//           {
//             return _extends$u({}, prev, {
//               draft: params.value,
//               committed: params.value
//             });
//           }

//         case 'setDraft':
//           {
//             return _extends$u({}, prev, {
//               draft: params.value
//             });
//           }

//         default:
//           {
//             return prev;
//           }
//       }
//     });

//     if (params.forceOnChangeCall || !params.skipOnChangeCall && !valueManager.areValuesEqual(utils, dateState.committed, params.value)) {
//       onChange(params.value);
//     }

//     if (params.action === 'acceptAndClose') {
//       setIsOpen(false);

//       if (onAccept && !valueManager.areValuesEqual(utils, dateState.resetFallback, params.value)) {
//         onAccept(params.value);
//       }
//     }
//   }, [onAccept, onChange, setIsOpen, dateState, utils, valueManager]);
//   React.useEffect(() => {
//     if (utils.isValid(parsedDateValue)) {
//       setLastValidDateValue(parsedDateValue);
//     }
//   }, [utils, parsedDateValue]);
//   React.useEffect(() => {
//     if (isOpen) {
//       // Update all dates in state to equal the current prop value
//       setDate({
//         action: 'setAll',
//         value: parsedDateValue,
//         skipOnChangeCall: true
//       });
//     }
//   }, [isOpen]); // eslint-disable-line react-hooks/exhaustive-deps
//   // Set the draft and committed date to equal the new prop value.

//   if (!valueManager.areValuesEqual(utils, dateState.committed, parsedDateValue)) {
//     setDate({
//       action: 'setCommitted',
//       value: parsedDateValue,
//       skipOnChangeCall: true
//     });
//   }

//   const wrapperProps = React.useMemo(() => ({
//     open: isOpen,
//     onClear: () => {
//       // Reset all date in state to the empty value and close picker.
//       setDate({
//         value: valueManager.emptyValue,
//         action: 'acceptAndClose',
//         // force `onChange` in cases like input (value) === `Invalid date`
//         forceOnChangeCall: !valueManager.areValuesEqual(utils, value, valueManager.emptyValue)
//       });
//     },
//     onAccept: () => {
//       // Set all date in state to equal the current draft value and close picker.
//       setDate({
//         value: dateState.draft,
//         action: 'acceptAndClose',
//         // force `onChange` in cases like input (value) === `Invalid date`
//         forceOnChangeCall: !valueManager.areValuesEqual(utils, value, parsedDateValue)
//       });
//     },
//     onDismiss: () => {
//       // Set all dates in state to equal the last committed date.
//       // e.g. Reset the state to the last committed value.
//       setDate({
//         value: dateState.committed,
//         action: 'acceptAndClose'
//       });
//     },
//     onCancel: () => {
//       // Set all dates in state to equal the last accepted date and close picker.
//       // e.g. Reset the state to the last accepted value
//       setDate({
//         value: dateState.resetFallback,
//         action: 'acceptAndClose'
//       });
//     },
//     onSetToday: () => {
//       // Set all dates in state to equal today and close picker.
//       setDate({
//         value: valueManager.getTodayValue(utils),
//         action: 'acceptAndClose'
//       });
//     }
//   }), [setDate, isOpen, utils, dateState, valueManager, value, parsedDateValue]); // Mobile keyboard view is a special case.
//   // When it's open picker should work like closed, because we are just showing text field

//   const [isMobileKeyboardViewOpen, setMobileKeyboardViewOpen] = React.useState(false);
//   const pickerProps = React.useMemo(() => ({
//     parsedValue: dateState.draft,
//     isMobileKeyboardViewOpen,
//     toggleMobileKeyboardView: () => setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen),
//     onDateChange: (newDate, wrapperVariant, selectionState = 'partial') => {
//       switch (selectionState) {
//         case 'shallow':
//           {
//             // Update the `draft` state but do not fire `onChange`
//             return setDate({
//               action: 'setDraft',
//               value: newDate,
//               skipOnChangeCall: true
//             });
//           }

//         case 'partial':
//           {
//             // Update the `draft` state and fire `onChange`
//             return setDate({
//               action: 'setDraft',
//               value: newDate
//             });
//           }

//         case 'finish':
//           {
//             if (closeOnSelect != null ? closeOnSelect : wrapperVariant === 'desktop') {
//               // Set all dates in state to equal the new date and close picker.
//               return setDate({
//                 value: newDate,
//                 action: 'acceptAndClose'
//               });
//             } // Updates the `committed` state and fire `onChange`


//             return setDate({
//               value: newDate,
//               action: 'setCommitted'
//             });
//           }

//         default:
//           {
//             throw new Error('MUI: Invalid selectionState passed to `onDateChange`');
//           }
//       }
//     }
//   }), [setDate, isMobileKeyboardViewOpen, dateState.draft, closeOnSelect]);
//   const handleInputChange = React.useCallback((newParsedValue, keyboardInputValue) => {
//     const cleanParsedValue = valueManager.valueReducer ? valueManager.valueReducer(utils, lastValidDateValue, newParsedValue) : newParsedValue;
//     onChange(cleanParsedValue, keyboardInputValue);
//   }, [onChange, valueManager, lastValidDateValue, utils]);
//   const inputProps = React.useMemo(() => ({
//     onChange: handleInputChange,
//     open: isOpen,
//     rawValue: value,
//     openPicker: () => setIsOpen(true)
//   }), [handleInputChange, isOpen, value, setIsOpen]);
//   const pickerState = {
//     pickerProps,
//     inputProps,
//     wrapperProps
//   };
//   React.useDebugValue(pickerState, () => ({
//     MuiPickerState: {
//       dateState,
//       other: pickerState
//     }
//   }));
//   return pickerState;
// };

// const _excluded$D = ["onChange", "PopperProps", "PaperProps", "ToolbarComponent", "TransitionComponent", "value", "components", "componentsProps"];

// /**
//  *
//  * Demos:
//  *
//  * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
//  *
//  * API:
//  *
//  * - [DesktopDatePicker API](https://mui.com/x/api/date-pickers/desktop-date-picker/)
//  */
// const DesktopDatePicker = /*#__PURE__*/React.forwardRef(function DesktopDatePicker(inProps, ref) {
//   const props = useDatePickerDefaultizedProps(inProps, 'MuiDesktopDatePicker');
//   const validationError = useDateValidation(props) !== null;
//   const {
//     pickerProps,
//     inputProps,
//     wrapperProps
//   } = usePickerState(props, datePickerValueManager);

//   const {
//     PopperProps,
//     PaperProps,
//     ToolbarComponent = DatePickerToolbar,
//     TransitionComponent,
//     components,
//     componentsProps
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$D);

//   const AllDateInputProps = _extends$u({}, inputProps, other, {
//     components,
//     componentsProps,
//     ref,
//     validationError
//   });

//   return /*#__PURE__*/jsx(DesktopWrapper, _extends$u({}, wrapperProps, {
//     DateInputProps: AllDateInputProps,
//     KeyboardDateInputComponent: KeyboardDateInput,
//     PopperProps: PopperProps,
//     PaperProps: PaperProps,
//     TransitionComponent: TransitionComponent,
//     components: components,
//     componentsProps: componentsProps,
//     children: /*#__PURE__*/jsx(CalendarOrClockPicker, _extends$u({}, pickerProps, {
//       autoFocus: true,
//       toolbarTitle: props.label || props.toolbarTitle,
//       ToolbarComponent: ToolbarComponent,
//       DateInputProps: AllDateInputProps,
//       components: components,
//       componentsProps: componentsProps
//     }, other))
//   }));
// });
// process.env.NODE_ENV !== "production" ? DesktopDatePicker.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------

//   /**
//    * Regular expression to detect "accepted" symbols.
//    * @default /\dap/gi
//    */
//   acceptRegex: PropTypes__default.instanceOf(RegExp),
//   autoFocus: PropTypes__default.bool,
//   children: PropTypes__default.node,

//   /**
//    * className applied to the root component.
//    */
//   className: PropTypes__default.string,

//   /**
//    * If `true` the popup or dialog will immediately close after submitting full date.
//    * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
//    */
//   closeOnSelect: PropTypes__default.bool,

//   /**
//    * Overrideable components.
//    * @default {}
//    */
//   components: PropTypes__default.object,

//   /**
//    * The props used for each component slot.
//    * @default {}
//    */
//   componentsProps: PropTypes__default.object,

//   /**
//    * Formats the day of week displayed in the calendar header.
//    * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
//    * @returns {string} The name to display.
//    * @default (day) => day.charAt(0).toUpperCase()
//    */
//   dayOfWeekFormatter: PropTypes__default.func,

//   /**
//    * Default calendar month displayed when `value={null}`.
//    */
//   defaultCalendarMonth: PropTypes__default.any,

//   /**
//    * If `true`, the picker and text field are disabled.
//    * @default false
//    */
//   disabled: PropTypes__default.bool,

//   /**
//    * If `true` future days are disabled.
//    * @default false
//    */
//   disableFuture: PropTypes__default.bool,

//   /**
//    * If `true`, today's date is rendering without highlighting with circle.
//    * @default false
//    */
//   disableHighlightToday: PropTypes__default.bool,

//   /**
//    * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
//    * @default false
//    */
//   disableMaskedInput: PropTypes__default.bool,

//   /**
//    * Do not render open picker button (renders only text field with validation).
//    * @default false
//    */
//   disableOpenPicker: PropTypes__default.bool,

//   /**
//    * If `true` past days are disabled.
//    * @default false
//    */
//   disablePast: PropTypes__default.bool,

//   /**
//    * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
//    * @template TInputDate, TDate
//    * @param {TInputDate} date The date from which we want to add an aria-text.
//    * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
//    * @returns {string} The aria-text to render inside the dialog.
//    * @default (date, utils) => `Choose date, selected date is ${utils.format(utils.date(date), 'fullDate')}`
//    */
//   getOpenDialogAriaText: PropTypes__default.func,

//   /**
//    * Get aria-label text for switching between views button.
//    * @param {CalendarPickerView} currentView The view from which we want to get the button text.
//    * @returns {string} The label of the view.
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   getViewSwitchingButtonText: PropTypes__default.func,
//   ignoreInvalidInputs: PropTypes__default.bool,

//   /**
//    * Props to pass to keyboard input adornment.
//    */
//   InputAdornmentProps: PropTypes__default.object,

//   /**
//    * Format string.
//    */
//   inputFormat: PropTypes__default.string,
//   InputProps: PropTypes__default.object,

//   /**
//    * Pass a ref to the `input` element.
//    */
//   inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.shape({
//     current: PropTypes__default.object
//   })]),
//   label: PropTypes__default.node,

//   /**
//    * Left arrow icon aria-label text.
//    * @deprecated
//    */
//   leftArrowButtonText: PropTypes__default.string,

//   /**
//    * If `true` renders `LoadingComponent` in calendar instead of calendar view.
//    * Can be used to preload information and show it in calendar.
//    * @default false
//    */
//   loading: PropTypes__default.bool,

//   /**
//    * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
//    */
//   mask: PropTypes__default.string,

//   /**
//    * Maximal selectable date. @DateIOType
//    */
//   maxDate: PropTypes__default.any,

//   /**
//    * Minimal selectable date. @DateIOType
//    */
//   minDate: PropTypes__default.any,

//   /**
//    * Callback fired when date is accepted @DateIOType.
//    * @template TValue
//    * @param {TValue} value The value that was just accepted.
//    */
//   onAccept: PropTypes__default.func,

//   /**
//    * Callback fired when the value (the selected date) changes @DateIOType.
//    * @template TValue
//    * @param {TValue} value The new parsed value.
//    * @param {string} keyboardInputValue The current value of the keyboard input.
//    */
//   onChange: PropTypes__default.func.isRequired,

//   /**
//    * Callback fired when the popup requests to be closed.
//    * Use in controlled mode (see open).
//    */
//   onClose: PropTypes__default.func,

//   /**
//    * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
//    * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
//    * This can be used to render appropriate form error.
//    *
//    * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
//    * @DateIOType
//    *
//    * @template TError, TInputValue
//    * @param {TError} reason The reason why the current value is not valid.
//    * @param {TInputValue} value The invalid value.
//    */
//   onError: PropTypes__default.func,

//   /**
//    * Callback firing on month change @DateIOType.
//    * @template TDate
//    * @param {TDate} month The new month.
//    * @returns {void|Promise} -
//    */
//   onMonthChange: PropTypes__default.func,

//   /**
//    * Callback fired when the popup requests to be opened.
//    * Use in controlled mode (see open).
//    */
//   onOpen: PropTypes__default.func,

//   /**
//    * Callback fired on view change.
//    * @param {CalendarPickerView} view The new view.
//    */
//   onViewChange: PropTypes__default.func,

//   /**
//    * Callback firing on year change @DateIOType.
//    * @template TDate
//    * @param {TDate} year The new year.
//    */
//   onYearChange: PropTypes__default.func,

//   /**
//    * Control the popup or dialog open state.
//    */
//   open: PropTypes__default.bool,

//   /**
//    * Props to pass to keyboard adornment button.
//    */
//   OpenPickerButtonProps: PropTypes__default.object,

//   /**
//    * First view to show.
//    * Must be a valid option from `views` list
//    * @default 'day'
//    */
//   openTo: PropTypes__default.oneOf(['day', 'month', 'year']),

//   /**
//    * Force rendering in particular orientation.
//    */
//   orientation: PropTypes__default.oneOf(['landscape', 'portrait']),

//   /**
//    * Paper props passed down to [Paper](https://mui.com/material-ui/api/paper/) component.
//    */
//   PaperProps: PropTypes__default.object,

//   /**
//    * Popper props passed down to [Popper](https://mui.com/material-ui/api/popper/) component.
//    */
//   PopperProps: PropTypes__default.object,

//   /**
//    * Make picker read only.
//    * @default false
//    */
//   readOnly: PropTypes__default.bool,

//   /**
//    * Disable heavy animations.
//    * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
//    */
//   reduceAnimations: PropTypes__default.bool,

//   /**
//    * Custom renderer for day. Check the [PickersDay](https://mui.com/x/api/date-pickers/pickers-day/) component.
//    * @template TDate
//    * @param {TDate} day The day to render.
//    * @param {Array<TDate | null>} selectedDays The days currently selected.
//    * @param {PickersDayProps<TDate>} pickersDayProps The props of the day to render.
//    * @returns {JSX.Element} The element representing the day.
//    */
//   renderDay: PropTypes__default.func,

//   /**
//    * The `renderInput` prop allows you to customize the rendered input.
//    * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
//    * Pay specific attention to the `ref` and `inputProps` keys.
//    * @example ```jsx
//    * renderInput={props => <TextField {...props} />}
//    * ````
//    * @param {MuiTextFieldPropsType} props The props of the input.
//    * @returns {React.ReactNode} The node to render as the input.
//    */
//   renderInput: PropTypes__default.func.isRequired,

//   /**
//    * Component displaying when passed `loading` true.
//    * @returns {React.ReactNode} The node to render when loading.
//    * @default () => <span data-mui-test="loading-progress">...</span>
//    */
//   renderLoading: PropTypes__default.func,

//   /**
//    * Custom formatter to be passed into Rifm component.
//    * @param {string} str The un-formatted string.
//    * @returns {string} The formatted string.
//    */
//   rifmFormatter: PropTypes__default.func,

//   /**
//    * Right arrow icon aria-label text.
//    * @deprecated
//    */
//   rightArrowButtonText: PropTypes__default.string,

//   /**
//    * Disable specific date. @DateIOType
//    * @template TDate
//    * @param {TDate} day The date to test.
//    * @returns {boolean} Returns `true` if the date should be disabled.
//    */
//   shouldDisableDate: PropTypes__default.func,

//   /**
//    * Disable specific months dynamically.
//    * Works like `shouldDisableDate` but for month selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} month The month to check.
//    * @returns {boolean} If `true` the month will be disabled.
//    */
//   shouldDisableMonth: PropTypes__default.func,

//   /**
//    * Disable specific years dynamically.
//    * Works like `shouldDisableDate` but for year selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} year The year to test.
//    * @returns {boolean} Returns `true` if the year should be disabled.
//    */
//   shouldDisableYear: PropTypes__default.func,

//   /**
//    * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
//    * @default false
//    */
//   showDaysOutsideCurrentMonth: PropTypes__default.bool,

//   /**
//    * If `true`, show the toolbar even in desktop mode.
//    */
//   showToolbar: PropTypes__default.bool,

//   /**
//    * Component that will replace default toolbar renderer.
//    * @default DatePickerToolbar
//    */
//   ToolbarComponent: PropTypes__default.elementType,

//   /**
//    * Date format, that is displaying in toolbar.
//    */
//   toolbarFormat: PropTypes__default.string,

//   /**
//    * Mobile picker date value placeholder, displaying if `value` === `null`.
//    * @default '–'
//    */
//   toolbarPlaceholder: PropTypes__default.node,

//   /**
//    * Mobile picker title, displaying in the toolbar.
//    * @default 'Select date'
//    */
//   toolbarTitle: PropTypes__default.node,

//   /**
//    * Custom component for popper [Transition](https://mui.com/material-ui/transitions/#transitioncomponent-prop).
//    */
//   TransitionComponent: PropTypes__default.elementType,

//   /**
//    * The value of the picker.
//    */
//   value: PropTypes__default.any,

//   /**
//    * Array of views to show.
//    * @default ['year', 'day']
//    */
//   views: PropTypes__default.arrayOf(PropTypes__default.oneOf(['day', 'month', 'year']).isRequired)
// } : void 0;

// function useDateTimePickerDefaultizedProps(props, name) {
//   var _themeProps$ampm, _themeProps$minDateTi, _themeProps$maxDateTi, _themeProps$minDateTi2, _themeProps$maxDateTi2;

//   // This is technically unsound if the type parameters appear in optional props.
//   // Optional props can be filled by `useThemeProps` with types that don't match the type parameters.
//   const themeProps = useThemeProps({
//     props,
//     name
//   });
//   const utils = useUtils();
//   const defaultDates = useDefaultDates();
//   const ampm = (_themeProps$ampm = themeProps.ampm) != null ? _themeProps$ampm : utils.is12HourCycleInCurrentLocale();

//   if (themeProps.orientation != null && themeProps.orientation !== 'portrait') {
//     throw new Error('We are not supporting custom orientation for DateTimePicker yet :(');
//   }

//   return _extends$u({
//     ampm,
//     orientation: 'portrait',
//     openTo: 'day',
//     views: ['year', 'day', 'hours', 'minutes'],
//     ampmInClock: true,
//     acceptRegex: ampm ? /[\dap]/gi : /\d/gi,
//     disableMaskedInput: false,
//     inputFormat: ampm ? utils.formats.keyboardDateTime12h : utils.formats.keyboardDateTime24h,
//     disableIgnoringDatePartForTimeValidation: Boolean(themeProps.minDateTime || themeProps.maxDateTime),
//     disablePast: false,
//     disableFuture: false
//   }, themeProps, {
//     minDate: parseNonNullablePickerDate(utils, (_themeProps$minDateTi = themeProps.minDateTime) != null ? _themeProps$minDateTi : themeProps.minDate, defaultDates.minDate),
//     maxDate: parseNonNullablePickerDate(utils, (_themeProps$maxDateTi = themeProps.maxDateTime) != null ? _themeProps$maxDateTi : themeProps.maxDate, defaultDates.maxDate),
//     minTime: (_themeProps$minDateTi2 = themeProps.minDateTime) != null ? _themeProps$minDateTi2 : themeProps.minTime,
//     maxTime: (_themeProps$maxDateTi2 = themeProps.maxDateTime) != null ? _themeProps$maxDateTi2 : themeProps.maxTime
//   });
// }
// const dateTimePickerValueManager = {
//   emptyValue: null,
//   getTodayValue: utils => utils.date(),
//   parseInput: parsePickerInputValue,
//   areValuesEqual: (utils, a, b) => utils.isEqual(a, b)
// };
// const resolveViewTypeFromView = view => {
//   switch (view) {
//     case 'year':
//     case 'month':
//     case 'day':
//       return 'calendar';

//     default:
//       return 'clock';
//   }
// };

// function getPickersToolbarTextUtilityClass(slot) {
//   // TODO v6: Rename 'PrivatePickersToolbarText' to 'MuiPickersToolbarText' to follow convention
//   return generateUtilityClass$1('PrivatePickersToolbarText', slot);
// } // TODO v6: Rename 'PrivatePickersToolbarText' to 'MuiPickersToolbarText' to follow convention

// const pickersToolbarTextClasses = generateUtilityClasses$1('PrivatePickersToolbarText', ['root', 'selected']);

// const _excluded$C = ["className", "selected", "value"];

// const useUtilityClasses$5 = ownerState => {
//   const {
//     classes,
//     selected
//   } = ownerState;
//   const slots = {
//     root: ['root', selected && 'selected']
//   };
//   return unstable_composeClasses(slots, getPickersToolbarTextUtilityClass, classes);
// };

// const PickersToolbarTextRoot = styled$1(Typography, {
//   name: 'PrivatePickersToolbarText',
//   slot: 'Root',
//   overridesResolver: (_, styles) => [styles.root, {
//     [`&.${pickersToolbarTextClasses.selected}`]: styles.selected
//   }]
// })(({
//   theme
// }) => ({
//   transition: theme.transitions.create('color'),
//   color: theme.palette.text.secondary,
//   [`&.${pickersToolbarTextClasses.selected}`]: {
//     color: theme.palette.text.primary
//   }
// }));
// const PickersToolbarText = /*#__PURE__*/React.forwardRef(function PickersToolbarText(props, ref) {
//   // TODO v6: add 'useThemeProps' once the component class names are aligned
//   const {
//     className,
//     value
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$C);

//   const classes = useUtilityClasses$5(props);
//   return /*#__PURE__*/jsx(PickersToolbarTextRoot, _extends$u({
//     ref: ref,
//     className: clsx$1(className, classes.root),
//     component: "span"
//   }, other, {
//     children: value
//   }));
// });

// const _excluded$B = ["align", "className", "selected", "typographyClassName", "value", "variant"];

// const useUtilityClasses$4 = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root']
//   };
//   return unstable_composeClasses(slots, getPickersToolbarUtilityClass, classes);
// };

// const PickersToolbarButtonRoot = styled$1(Button$2, {
//   name: 'MuiPickersToolbarButton',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })({
//   padding: 0,
//   minWidth: 16,
//   textTransform: 'none'
// });
// const PickersToolbarButton = /*#__PURE__*/React.forwardRef(function PickersToolbarButton(inProps, ref) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiPickersToolbarButton'
//   });

//   const {
//     align,
//     className,
//     selected,
//     typographyClassName,
//     value,
//     variant
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$B);

//   const classes = useUtilityClasses$4(props);
//   return /*#__PURE__*/jsx(PickersToolbarButtonRoot, _extends$u({
//     variant: "text",
//     ref: ref,
//     className: clsx$1(className, classes.root)
//   }, other, {
//     children: /*#__PURE__*/jsx(PickersToolbarText, {
//       align: align,
//       className: typographyClassName,
//       variant: variant,
//       value: value,
//       selected: selected
//     })
//   }));
// });

// function getDateTimePickerToolbarUtilityClass(slot) {
//   return generateUtilityClass$1('MuiDateTimePickerToolbar', slot);
// }
// generateUtilityClasses$1('MuiDateTimePickerToolbar', ['root', 'dateContainer', 'timeContainer', 'separator']);

// const _excluded$A = ["ampm", "parsedValue", "isMobileKeyboardViewOpen", "onChange", "openView", "setOpenView", "toggleMobileKeyboardView", "toolbarFormat", "toolbarPlaceholder", "toolbarTitle", "views"];

// const useUtilityClasses$3 = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     dateContainer: ['dateContainer'],
//     timeContainer: ['timeContainer'],
//     separator: ['separator']
//   };
//   return unstable_composeClasses(slots, getDateTimePickerToolbarUtilityClass, classes);
// };

// const DateTimePickerToolbarRoot = styled$1(PickersToolbar, {
//   name: 'MuiDateTimePickerToolbar',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })(({
//   theme
// }) => ({
//   paddingLeft: 16,
//   paddingRight: 16,
//   justifyContent: 'space-around',
//   position: 'relative',
//   [`& .${pickersToolbarClasses.penIconButton}`]: _extends$u({
//     position: 'absolute',
//     top: 8
//   }, theme.direction === 'rtl' ? {
//     left: 8
//   } : {
//     right: 8
//   })
// }));
// const DateTimePickerToolbarDateContainer = styled$1('div', {
//   name: 'MuiDateTimePickerToolbar',
//   slot: 'DateContainer',
//   overridesResolver: (props, styles) => styles.dateContainer
// })({
//   display: 'flex',
//   flexDirection: 'column',
//   alignItems: 'flex-start'
// });
// const DateTimePickerToolbarTimeContainer = styled$1('div', {
//   name: 'MuiDateTimePickerToolbar',
//   slot: 'TimeContainer',
//   overridesResolver: (props, styles) => styles.timeContainer
// })({
//   display: 'flex'
// });
// const DateTimePickerToolbarSeparator = styled$1(PickersToolbarText, {
//   name: 'MuiDateTimePickerToolbar',
//   slot: 'Separator',
//   overridesResolver: (props, styles) => styles.separator
// })({
//   margin: '0 4px 0 2px',
//   cursor: 'default'
// });
// /**
//  * @ignore - internal component.
//  */

// function DateTimePickerToolbar(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiDateTimePickerToolbar'
//   });

//   const {
//     ampm,
//     parsedValue,
//     isMobileKeyboardViewOpen,
//     openView,
//     setOpenView,
//     toggleMobileKeyboardView,
//     toolbarFormat,
//     toolbarPlaceholder = '––',
//     toolbarTitle: toolbarTitleProp,
//     views
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$A);

//   const ownerState = props;
//   const utils = useUtils();
//   const localeText = useLocaleText();
//   const classes = useUtilityClasses$3(ownerState);
//   const toolbarTitle = toolbarTitleProp != null ? toolbarTitleProp : localeText.dateTimePickerDefaultToolbarTitle;

//   const formatHours = time => ampm ? utils.format(time, 'hours12h') : utils.format(time, 'hours24h');

//   const dateText = React.useMemo(() => {
//     if (!parsedValue) {
//       return toolbarPlaceholder;
//     }

//     if (toolbarFormat) {
//       return utils.formatByString(parsedValue, toolbarFormat);
//     }

//     return utils.format(parsedValue, 'shortDate');
//   }, [parsedValue, toolbarFormat, toolbarPlaceholder, utils]);
//   return /*#__PURE__*/jsxs(DateTimePickerToolbarRoot, _extends$u({
//     toolbarTitle: toolbarTitle,
//     isMobileKeyboardViewOpen: isMobileKeyboardViewOpen,
//     toggleMobileKeyboardView: toggleMobileKeyboardView,
//     className: classes.root,
//     viewType: resolveViewTypeFromView(openView)
//   }, other, {
//     isLandscape: false,
//     ownerState: ownerState,
//     children: [/*#__PURE__*/jsxs(DateTimePickerToolbarDateContainer, {
//       className: classes.dateContainer,
//       ownerState: ownerState,
//       children: [views.includes('year') && /*#__PURE__*/jsx(PickersToolbarButton, {
//         tabIndex: -1,
//         variant: "subtitle1",
//         onClick: () => setOpenView('year'),
//         selected: openView === 'year',
//         value: parsedValue ? utils.format(parsedValue, 'year') : '–'
//       }), views.includes('day') && /*#__PURE__*/jsx(PickersToolbarButton, {
//         tabIndex: -1,
//         variant: "h4",
//         onClick: () => setOpenView('day'),
//         selected: openView === 'day',
//         value: dateText
//       })]
//     }), /*#__PURE__*/jsxs(DateTimePickerToolbarTimeContainer, {
//       className: classes.timeContainer,
//       ownerState: ownerState,
//       children: [views.includes('hours') && /*#__PURE__*/jsx(PickersToolbarButton, {
//         variant: "h3",
//         onClick: () => setOpenView('hours'),
//         selected: openView === 'hours',
//         value: parsedValue ? formatHours(parsedValue) : '--'
//       }), views.includes('minutes') && /*#__PURE__*/jsxs(React.Fragment, {
//         children: [/*#__PURE__*/jsx(DateTimePickerToolbarSeparator, {
//           variant: "h3",
//           value: ":",
//           className: classes.separator,
//           ownerState: ownerState
//         }), /*#__PURE__*/jsx(PickersToolbarButton, {
//           variant: "h3",
//           onClick: () => setOpenView('minutes'),
//           selected: openView === 'minutes',
//           value: parsedValue ? utils.format(parsedValue, 'minutes') : '--'
//         })]
//       }), views.includes('seconds') && /*#__PURE__*/jsxs(React.Fragment, {
//         children: [/*#__PURE__*/jsx(DateTimePickerToolbarSeparator, {
//           variant: "h3",
//           value: ":",
//           className: classes.separator,
//           ownerState: ownerState
//         }), /*#__PURE__*/jsx(PickersToolbarButton, {
//           variant: "h3",
//           onClick: () => setOpenView('seconds'),
//           selected: openView === 'seconds',
//           value: parsedValue ? utils.format(parsedValue, 'seconds') : '--'
//         })]
//       })]
//     })]
//   }));
// }

// const validateTime$1 = ({
//   adapter,
//   value,
//   props
// }) => {
//   const {
//     minTime,
//     maxTime,
//     minutesStep,
//     shouldDisableTime,
//     disableIgnoringDatePartForTimeValidation
//   } = props;
//   const date = adapter.utils.date(value);
//   const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, adapter.utils);

//   if (value === null) {
//     return null;
//   }

//   switch (true) {
//     case !adapter.utils.isValid(value):
//       return 'invalidDate';

//     case Boolean(minTime && isAfter(minTime, date)):
//       return 'minTime';

//     case Boolean(maxTime && isAfter(date, maxTime)):
//       return 'maxTime';

//     case Boolean(shouldDisableTime && shouldDisableTime(adapter.utils.getHours(date), 'hours')):
//       return 'shouldDisableTime-hours';

//     case Boolean(shouldDisableTime && shouldDisableTime(adapter.utils.getMinutes(date), 'minutes')):
//       return 'shouldDisableTime-minutes';

//     case Boolean(shouldDisableTime && shouldDisableTime(adapter.utils.getSeconds(date), 'seconds')):
//       return 'shouldDisableTime-seconds';

//     case Boolean(minutesStep && adapter.utils.getMinutes(date) % minutesStep !== 0):
//       return 'minutesStep';

//     default:
//       return null;
//   }
// };

// const _excluded$z = ["minDate", "maxDate", "disableFuture", "shouldDisableDate", "disablePast"];
// const validateDateTime = ({
//   props,
//   value,
//   adapter
// }) => {
//   const {
//     minDate,
//     maxDate,
//     disableFuture,
//     shouldDisableDate,
//     disablePast
//   } = props,
//         timeValidationProps = _objectWithoutPropertiesLoose$k(props, _excluded$z);

//   const dateValidationResult = validateDate$1({
//     adapter,
//     value,
//     props: {
//       minDate,
//       maxDate,
//       disableFuture,
//       shouldDisableDate,
//       disablePast
//     }
//   });

//   if (dateValidationResult !== null) {
//     return dateValidationResult;
//   }

//   return validateTime$1({
//     adapter,
//     value,
//     props: timeValidationProps
//   });
// };

// const isSameDateTimeError = (a, b) => a === b;

// function useDateTimeValidation(props) {
//   return useValidation(props, validateDateTime, isSameDateTimeError);
// }

// function getDateTimePickerTabsUtilityClass(slot) {
//   return generateUtilityClass$1('MuiDateTimePickerTabs', slot);
// }
// generateUtilityClasses$1('MuiDateTimePickerTabs', ['root']);

// const viewToTab = openView => {
//   if (['day', 'month', 'year'].includes(openView)) {
//     return 'date';
//   }

//   return 'time';
// };

// const tabToView = tab => {
//   if (tab === 'date') {
//     return 'day';
//   }

//   return 'hours';
// };

// const useUtilityClasses$2 = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root']
//   };
//   return unstable_composeClasses(slots, getDateTimePickerTabsUtilityClass, classes);
// };

// const DateTimePickerTabsRoot = styled$1(Tabs$1, {
//   name: 'MuiDateTimePickerTabs',
//   slot: 'Root',
//   overridesResolver: (_, styles) => styles.root
// })(({
//   ownerState,
//   theme
// }) => _extends$u({
//   boxShadow: `0 -1px 0 0 inset ${theme.palette.divider}`
// }, ownerState.wrapperVariant === 'desktop' && {
//   order: 1,
//   boxShadow: `0 1px 0 0 inset ${theme.palette.divider}`,
//   [`& .${tabsClasses.indicator}`]: {
//     bottom: 'auto',
//     top: 0
//   }
// }));

// const DateTimePickerTabs = function DateTimePickerTabs(inProps) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiDateTimePickerTabs'
//   });
//   const {
//     dateRangeIcon = /*#__PURE__*/jsx(DateRange, {}),
//     onChange,
//     timeIcon = /*#__PURE__*/jsx(Time, {}),
//     view
//   } = props;
//   const localeText = useLocaleText();
//   const wrapperVariant = React.useContext(WrapperVariantContext);

//   const ownerState = _extends$u({}, props, {
//     wrapperVariant
//   });

//   const classes = useUtilityClasses$2(ownerState);

//   const handleChange = (event, value) => {
//     onChange(tabToView(value));
//   };

//   return /*#__PURE__*/jsxs(DateTimePickerTabsRoot, {
//     ownerState: ownerState,
//     variant: "fullWidth",
//     value: viewToTab(view),
//     onChange: handleChange,
//     className: classes.root,
//     children: [/*#__PURE__*/jsx(Tab$1, {
//       value: "date",
//       "aria-label": localeText.dateTableLabel,
//       icon: /*#__PURE__*/jsx(React.Fragment, {
//         children: dateRangeIcon
//       })
//     }), /*#__PURE__*/jsx(Tab$1, {
//       value: "time",
//       "aria-label": localeText.timeTableLabel,
//       icon: /*#__PURE__*/jsx(React.Fragment, {
//         children: timeIcon
//       })
//     })]
//   });
// };

// process.env.NODE_ENV !== "production" ? DateTimePickerTabs.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------

//   /**
//    * Override or extend the styles applied to the component.
//    */
//   classes: PropTypes__default.object,

//   /**
//    * Date tab icon.
//    * @default DateRange
//    */
//   dateRangeIcon: PropTypes__default.node,

//   /**
//    * Callback called when tab is clicked
//    * @param {CalendarOrClockPickerView} view Picker view that was clicked
//    */
//   onChange: PropTypes__default.func.isRequired,

//   /**
//    * Time tab icon.
//    * @default Time
//    */
//   timeIcon: PropTypes__default.node,

//   /**
//    * Open picker view
//    */
//   view: PropTypes__default.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired
// } : void 0;

// const _excluded$y = ["onChange", "PaperProps", "PopperProps", "ToolbarComponent", "TransitionComponent", "value", "components", "componentsProps", "hideTabs"];

// /**
//  *
//  * Demos:
//  *
//  * - [Date Time Picker](https://mui.com/x/react-date-pickers/date-time-picker/)
//  *
//  * API:
//  *
//  * - [DesktopDateTimePicker API](https://mui.com/x/api/date-pickers/desktop-date-time-picker/)
//  */
// const DesktopDateTimePicker = /*#__PURE__*/React.forwardRef(function DesktopDateTimePicker(inProps, ref) {
//   const props = useDateTimePickerDefaultizedProps(inProps, 'MuiDesktopDateTimePicker');
//   const validationError = useDateTimeValidation(props) !== null;
//   const {
//     pickerProps,
//     inputProps,
//     wrapperProps
//   } = usePickerState(props, dateTimePickerValueManager);

//   const {
//     PaperProps,
//     PopperProps,
//     ToolbarComponent = DateTimePickerToolbar,
//     TransitionComponent,
//     components: providedComponents,
//     componentsProps,
//     hideTabs = true
//   } = props,
//         other = _objectWithoutPropertiesLoose$k(props, _excluded$y);

//   const components = React.useMemo(() => _extends$u({
//     Tabs: DateTimePickerTabs
//   }, providedComponents), [providedComponents]);

//   const AllDateInputProps = _extends$u({}, inputProps, other, {
//     components,
//     componentsProps,
//     ref,
//     validationError
//   });

//   return /*#__PURE__*/jsx(DesktopWrapper, _extends$u({}, wrapperProps, {
//     DateInputProps: AllDateInputProps,
//     KeyboardDateInputComponent: KeyboardDateInput,
//     PopperProps: PopperProps,
//     PaperProps: PaperProps,
//     TransitionComponent: TransitionComponent,
//     components: components,
//     componentsProps: componentsProps,
//     children: /*#__PURE__*/jsx(CalendarOrClockPicker, _extends$u({}, pickerProps, {
//       autoFocus: true,
//       toolbarTitle: props.label || props.toolbarTitle,
//       ToolbarComponent: ToolbarComponent,
//       DateInputProps: AllDateInputProps,
//       components: components,
//       componentsProps: componentsProps,
//       hideTabs: hideTabs
//     }, other))
//   }));
// });
// process.env.NODE_ENV !== "production" ? DesktopDateTimePicker.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------

//   /**
//    * Regular expression to detect "accepted" symbols.
//    * @default /\dap/gi
//    */
//   acceptRegex: PropTypes__default.instanceOf(RegExp),

//   /**
//    * 12h/24h view for hour selection clock.
//    * @default `utils.is12HourCycleInCurrentLocale()`
//    */
//   ampm: PropTypes__default.bool,

//   /**
//    * Display ampm controls under the clock (instead of in the toolbar).
//    * @default false
//    */
//   ampmInClock: PropTypes__default.bool,
//   autoFocus: PropTypes__default.bool,
//   children: PropTypes__default.node,

//   /**
//    * className applied to the root component.
//    */
//   className: PropTypes__default.string,

//   /**
//    * If `true` the popup or dialog will immediately close after submitting full date.
//    * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
//    */
//   closeOnSelect: PropTypes__default.bool,

//   /**
//    * Overrideable components.
//    * @default {}
//    */
//   components: PropTypes__default.object,

//   /**
//    * The props used for each component slot.
//    * @default {}
//    */
//   componentsProps: PropTypes__default.object,

//   /**
//    * Date tab icon.
//    */
//   dateRangeIcon: PropTypes__default.node,

//   /**
//    * Formats the day of week displayed in the calendar header.
//    * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
//    * @returns {string} The name to display.
//    * @default (day) => day.charAt(0).toUpperCase()
//    */
//   dayOfWeekFormatter: PropTypes__default.func,

//   /**
//    * Default calendar month displayed when `value={null}`.
//    */
//   defaultCalendarMonth: PropTypes__default.any,

//   /**
//    * If `true`, the picker and text field are disabled.
//    * @default false
//    */
//   disabled: PropTypes__default.bool,

//   /**
//    * If `true` future days are disabled.
//    * @default false
//    */
//   disableFuture: PropTypes__default.bool,

//   /**
//    * If `true`, today's date is rendering without highlighting with circle.
//    * @default false
//    */
//   disableHighlightToday: PropTypes__default.bool,

//   /**
//    * Do not ignore date part when validating min/max time.
//    * @default false
//    */
//   disableIgnoringDatePartForTimeValidation: PropTypes__default.bool,

//   /**
//    * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
//    * @default false
//    */
//   disableMaskedInput: PropTypes__default.bool,

//   /**
//    * Do not render open picker button (renders only text field with validation).
//    * @default false
//    */
//   disableOpenPicker: PropTypes__default.bool,

//   /**
//    * If `true` past days are disabled.
//    * @default false
//    */
//   disablePast: PropTypes__default.bool,

//   /**
//    * Accessible text that helps user to understand which time and view is selected.
//    * @template TDate
//    * @param {ClockPickerView} view The current view rendered.
//    * @param {TDate | null} time The current time.
//    * @param {MuiPickersAdapter<TDate>} adapter The current date adapter.
//    * @returns {string} The clock label.
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    * @default <TDate extends any>(
//    *   view: ClockView,
//    *   time: TDate | null,
//    *   adapter: MuiPickersAdapter<TDate>,
//    * ) =>
//    *   `Select ${view}. ${
//    *     time === null ? 'No time selected' : `Selected time is ${adapter.format(time, 'fullTime')}`
//    *   }`
//    */
//   getClockLabelText: PropTypes__default.func,

//   /**
//    * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
//    * @template TInputDate, TDate
//    * @param {TInputDate} date The date from which we want to add an aria-text.
//    * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
//    * @returns {string} The aria-text to render inside the dialog.
//    * @default (date, utils) => `Choose date, selected date is ${utils.format(utils.date(date), 'fullDate')}`
//    */
//   getOpenDialogAriaText: PropTypes__default.func,

//   /**
//    * Get aria-label text for switching between views button.
//    * @param {CalendarPickerView} currentView The view from which we want to get the button text.
//    * @returns {string} The label of the view.
//    * @deprecated Use the `localeText` prop of `LocalizationProvider` instead, see https://mui.com/x/react-date-pickers/localization/.
//    */
//   getViewSwitchingButtonText: PropTypes__default.func,

//   /**
//    * Toggles visibility of date time switching tabs
//    * @default false for mobile, true for desktop
//    */
//   hideTabs: PropTypes__default.bool,
//   ignoreInvalidInputs: PropTypes__default.bool,

//   /**
//    * Props to pass to keyboard input adornment.
//    */
//   InputAdornmentProps: PropTypes__default.object,

//   /**
//    * Format string.
//    */
//   inputFormat: PropTypes__default.string,
//   InputProps: PropTypes__default.object,

//   /**
//    * Pass a ref to the `input` element.
//    */
//   inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.shape({
//     current: PropTypes__default.object
//   })]),
//   label: PropTypes__default.node,

//   /**
//    * Left arrow icon aria-label text.
//    * @deprecated
//    */
//   leftArrowButtonText: PropTypes__default.string,

//   /**
//    * If `true` renders `LoadingComponent` in calendar instead of calendar view.
//    * Can be used to preload information and show it in calendar.
//    * @default false
//    */
//   loading: PropTypes__default.bool,

//   /**
//    * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
//    */
//   mask: PropTypes__default.string,

//   /**
//    * Maximal selectable date. @DateIOType
//    */
//   maxDate: PropTypes__default.any,

//   /**
//    * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
//    */
//   maxDateTime: PropTypes__default.any,

//   /**
//    * Max time acceptable time.
//    * For input validation date part of passed object will be ignored if `disableIgnoringDatePartForTimeValidation` not specified.
//    */
//   maxTime: PropTypes__default.any,

//   /**
//    * Minimal selectable date. @DateIOType
//    */
//   minDate: PropTypes__default.any,

//   /**
//    * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
//    */
//   minDateTime: PropTypes__default.any,

//   /**
//    * Min time acceptable time.
//    * For input validation date part of passed object will be ignored if `disableIgnoringDatePartForTimeValidation` not specified.
//    */
//   minTime: PropTypes__default.any,

//   /**
//    * Step over minutes.
//    * @default 1
//    */
//   minutesStep: PropTypes__default.number,

//   /**
//    * Callback fired when date is accepted @DateIOType.
//    * @template TValue
//    * @param {TValue} value The value that was just accepted.
//    */
//   onAccept: PropTypes__default.func,

//   /**
//    * Callback fired when the value (the selected date) changes @DateIOType.
//    * @template TValue
//    * @param {TValue} value The new parsed value.
//    * @param {string} keyboardInputValue The current value of the keyboard input.
//    */
//   onChange: PropTypes__default.func.isRequired,

//   /**
//    * Callback fired when the popup requests to be closed.
//    * Use in controlled mode (see open).
//    */
//   onClose: PropTypes__default.func,

//   /**
//    * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
//    * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
//    * This can be used to render appropriate form error.
//    *
//    * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
//    * @DateIOType
//    *
//    * @template TError, TInputValue
//    * @param {TError} reason The reason why the current value is not valid.
//    * @param {TInputValue} value The invalid value.
//    */
//   onError: PropTypes__default.func,

//   /**
//    * Callback firing on month change @DateIOType.
//    * @template TDate
//    * @param {TDate} month The new month.
//    * @returns {void|Promise} -
//    */
//   onMonthChange: PropTypes__default.func,

//   /**
//    * Callback fired when the popup requests to be opened.
//    * Use in controlled mode (see open).
//    */
//   onOpen: PropTypes__default.func,

//   /**
//    * Callback fired on view change.
//    * @param {CalendarOrClockPickerView} view The new view.
//    */
//   onViewChange: PropTypes__default.func,

//   /**
//    * Callback firing on year change @DateIOType.
//    * @template TDate
//    * @param {TDate} year The new year.
//    */
//   onYearChange: PropTypes__default.func,

//   /**
//    * Control the popup or dialog open state.
//    */
//   open: PropTypes__default.bool,

//   /**
//    * Props to pass to keyboard adornment button.
//    */
//   OpenPickerButtonProps: PropTypes__default.object,

//   /**
//    * First view to show.
//    * Must be a valid option from `views` list
//    * @default 'day'
//    */
//   openTo: PropTypes__default.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),

//   /**
//    * Force rendering in particular orientation.
//    */
//   orientation: PropTypes__default.oneOf(['landscape', 'portrait']),

//   /**
//    * Paper props passed down to [Paper](https://mui.com/material-ui/api/paper/) component.
//    */
//   PaperProps: PropTypes__default.object,

//   /**
//    * Popper props passed down to [Popper](https://mui.com/material-ui/api/popper/) component.
//    */
//   PopperProps: PropTypes__default.object,

//   /**
//    * Make picker read only.
//    * @default false
//    */
//   readOnly: PropTypes__default.bool,

//   /**
//    * Disable heavy animations.
//    * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
//    */
//   reduceAnimations: PropTypes__default.bool,

//   /**
//    * Custom renderer for day. Check the [PickersDay](https://mui.com/x/api/date-pickers/pickers-day/) component.
//    * @template TDate
//    * @param {TDate} day The day to render.
//    * @param {Array<TDate | null>} selectedDays The days currently selected.
//    * @param {PickersDayProps<TDate>} pickersDayProps The props of the day to render.
//    * @returns {JSX.Element} The element representing the day.
//    */
//   renderDay: PropTypes__default.func,

//   /**
//    * The `renderInput` prop allows you to customize the rendered input.
//    * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
//    * Pay specific attention to the `ref` and `inputProps` keys.
//    * @example ```jsx
//    * renderInput={props => <TextField {...props} />}
//    * ````
//    * @param {MuiTextFieldPropsType} props The props of the input.
//    * @returns {React.ReactNode} The node to render as the input.
//    */
//   renderInput: PropTypes__default.func.isRequired,

//   /**
//    * Component displaying when passed `loading` true.
//    * @returns {React.ReactNode} The node to render when loading.
//    * @default () => <span data-mui-test="loading-progress">...</span>
//    */
//   renderLoading: PropTypes__default.func,

//   /**
//    * Custom formatter to be passed into Rifm component.
//    * @param {string} str The un-formatted string.
//    * @returns {string} The formatted string.
//    */
//   rifmFormatter: PropTypes__default.func,

//   /**
//    * Right arrow icon aria-label text.
//    * @deprecated
//    */
//   rightArrowButtonText: PropTypes__default.string,

//   /**
//    * Disable specific date. @DateIOType
//    * @template TDate
//    * @param {TDate} day The date to test.
//    * @returns {boolean} Returns `true` if the date should be disabled.
//    */
//   shouldDisableDate: PropTypes__default.func,

//   /**
//    * Disable specific months dynamically.
//    * Works like `shouldDisableDate` but for month selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} month The month to check.
//    * @returns {boolean} If `true` the month will be disabled.
//    */
//   shouldDisableMonth: PropTypes__default.func,

//   /**
//    * Dynamically check if time is disabled or not.
//    * If returns `false` appropriate time point will ot be acceptable.
//    * @param {number} timeValue The value to check.
//    * @param {ClockPickerView} clockType The clock type of the timeValue.
//    * @returns {boolean} Returns `true` if the time should be disabled
//    */
//   shouldDisableTime: PropTypes__default.func,

//   /**
//    * Disable specific years dynamically.
//    * Works like `shouldDisableDate` but for year selection view @DateIOType.
//    * @template TDate
//    * @param {TDate} year The year to test.
//    * @returns {boolean} Returns `true` if the year should be disabled.
//    */
//   shouldDisableYear: PropTypes__default.func,

//   /**
//    * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
//    * @default false
//    */
//   showDaysOutsideCurrentMonth: PropTypes__default.bool,

//   /**
//    * If `true`, show the toolbar even in desktop mode.
//    */
//   showToolbar: PropTypes__default.bool,

//   /**
//    * Time tab icon.
//    */
//   timeIcon: PropTypes__default.node,

//   /**
//    * Component that will replace default toolbar renderer.
//    * @default DateTimePickerToolbar
//    */
//   ToolbarComponent: PropTypes__default.elementType,

//   /**
//    * Date format, that is displaying in toolbar.
//    */
//   toolbarFormat: PropTypes__default.string,

//   /**
//    * Mobile picker date value placeholder, displaying if `value` === `null`.
//    * @default '–'
//    */
//   toolbarPlaceholder: PropTypes__default.node,

//   /**
//    * Mobile picker title, displaying in the toolbar.
//    * @default 'Select date & time'
//    */
//   toolbarTitle: PropTypes__default.node,

//   /**
//    * Custom component for popper [Transition](https://mui.com/material-ui/transitions/#transitioncomponent-prop).
//    */
//   TransitionComponent: PropTypes__default.elementType,

//   /**
//    * The value of the picker.
//    */
//   value: PropTypes__default.any,

//   /**
//    * Array of views to show.
//    * @default ['year', 'day', 'hours', 'minutes']
//    */
//   views: PropTypes__default.arrayOf(PropTypes__default.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired)
// } : void 0;

// var _templateObject$1v;
// var StyledDatePicker = styled(DesktopDatePicker)(_templateObject$1v || (_templateObject$1v = _taggedTemplateLiteral$1(["\n  .MuiIconButton-root {\n    color: ", ";\n  }\n  .MuiIconButton-root:hover {\n    color: ", ";\n    background-color: transparent;\n  }\n  .MuiIconButton-root:disabled {\n    color: ", ";\n    background-color: transparent;\n  }\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return alpha$2(theme.variables.grayBase, 0.66);
// }, function (_ref2) {
//   var theme = _ref2.theme;
//   return theme.variables.btnPrimaryBg;
// }, function (_ref3) {
//   var theme = _ref3.theme;
//   return alpha$2(theme.variables.grayBase, 0.38);
// });

// /**
//  * Date picker is to select a date, or a range of dates.
//  */
// function DatePicker(_ref) {
//   var idProp = _ref.id,
//     value = _ref.value,
//     fullWidth = _ref.fullWidth,
//     onError = _ref.onError,
//     required = _ref.required,
//     inputProps = _ref.inputProps,
//     onChange = _ref.onChange,
//     helperText = _ref.helperText,
//     minDate = _ref.minDate,
//     format = _ref.format,
//     maxDate = _ref.maxDate,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     error = _ref.error,
//     label = _ref.label;
//   var id = useId(idProp);
//   return /*#__PURE__*/React.createElement(LocalizationProvider, {
//     dateAdapter: AdapterDateFns
//   }, /*#__PURE__*/React.createElement(StyledDatePicker, {
//     InputAdornmentProps: {
//       sx: {
//         pr: 4,
//         pl: 0
//       }
//     },
//     label: label,
//     inputProps: inputProps,
//     value: value,
//     onChange: onChange,
//     onError: onError,
//     dayOfWeekFormatter: function dayOfWeekFormatter(day) {
//       return "".concat(day, ".");
//     },
//     renderInput: function renderInput(params) {
//       return /*#__PURE__*/React.createElement(TextField$2, _extends$v({
//         id: id,
//         fullWidth: fullWidth
//       }, params, {
//         helperText: helperText,
//         error: error,
//         required: required
//       }));
//     },
//     minDate: minDate,
//     inputFormat: format,
//     maxDate: maxDate,
//     disabled: disabled,
//     className: className
//   }));
// }
// DatePicker.propTypes = {
//   /**
//    * Id of the input
//    */
//   id: PropTypes__default.string,
//   /**
//    * Picker value
//    */
//   value: PropTypes__default.instanceOf(Date),
//   /**
//    * If `true`, the input will take up the full width of its container.
//    */
//   fullWidth: PropTypes__default.bool,
//   /**
//    * Callback fired when new error should be displayed
//    */
//   onError: PropTypes__default.func,
//   /**
//    * Label is displayed as required
//    */
//   required: PropTypes__default.bool,
//   /**
//    * Props for input base
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * onChange callback
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Content for helper text
//    */
//   helperText: PropTypes__default.node,
//   /**
//    * Min selectable date
//    */
//   minDate: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.instanceOf(Date)]),
//   /**
//    * DateTime format specifier
//    */
//   format: PropTypes__default.string,
//   /**
//    * Max selectable date
//    */
//   maxDate: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.instanceOf(Date)]),
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * Disable the field
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Display label in error state
//    */
//   error: PropTypes__default.bool,
//   /**
//    * Text for label
//    */
//   label: PropTypes__default.string
// };
// DatePicker.defaultProps = {
//   id: undefined,
//   value: null,
//   fullWidth: false,
//   onError: undefined,
//   required: false,
//   inputProps: {},
//   onChange: function onChange() {
//     return null;
//   },
//   helperText: '',
//   minDate: undefined,
//   format: 'MM/dd/yyyy',
//   // fallback since the adapter needs this to have a value
//   maxDate: undefined,
//   className: '',
//   disabled: false,
//   error: false,
//   label: undefined
// };

// var _templateObject$1u;
// var StyledDateTimePicker = styled(DesktopDateTimePicker)(_templateObject$1u || (_templateObject$1u = _taggedTemplateLiteral$1(["\n  .MuiIconButton-root {\n    color: ", ";\n  }\n  .MuiIconButton-root:hover {\n    color: ", ";\n    background-color: transparent;\n  }\n  .MuiIconButton-root:disabled {\n    color: ", ";\n    background-color: transparent;\n  }\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return alpha$2(theme.variables.grayBase, 0.66);
// }, function (_ref2) {
//   var theme = _ref2.theme;
//   return theme.variables.btnPrimaryBg;
// }, function (_ref3) {
//   var theme = _ref3.theme;
//   return alpha$2(theme.variables.grayBase, 0.38);
// });

// /**
//  * DateTimePicker is to select a date and time.
//  */
// function DateTimePicker(_ref) {
//   var idProp = _ref.id,
//     label = _ref.label,
//     value = _ref.value,
//     required = _ref.required,
//     onChange = _ref.onChange,
//     onError = _ref.onError,
//     inputProps = _ref.inputProps,
//     helperText = _ref.helperText,
//     format = _ref.format,
//     minDate = _ref.minDate,
//     maxDate = _ref.maxDate,
//     error = _ref.error,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     fullWidth = _ref.fullWidth;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(LocalizationProvider, {
//     dateAdapter: AdapterDateFns
//   }, /*#__PURE__*/React__default.createElement(StyledDateTimePicker, {
//     InputAdornmentProps: {
//       sx: {
//         pr: 4,
//         pl: 0
//       }
//     },
//     label: label,
//     inputProps: inputProps,
//     value: value,
//     onChange: onChange,
//     onError: onError,
//     dayOfWeekFormatter: function dayOfWeekFormatter(day) {
//       return "".concat(day, ".");
//     },
//     renderInput: function renderInput(params) {
//       return /*#__PURE__*/React__default.createElement(TextField$2, _extends$v({
//         id: id,
//         fullWidth: fullWidth
//       }, params, {
//         helperText: helperText,
//         error: error,
//         required: required
//       }));
//     },
//     minDate: minDate,
//     inputFormat: format,
//     maxDate: maxDate,
//     disabled: disabled,
//     className: className
//   }));
// }
// DateTimePicker.propTypes = {
//   /**
//    * Id of the input
//    */
//   id: PropTypes__default.string,
//   /**
//    * Text for label
//    */
//   label: PropTypes__default.string,
//   /**
//    * Picker value
//    */
//   value: PropTypes__default.instanceOf(Date),
//   /**
//    * Label is displayed as required
//    */
//   required: PropTypes__default.bool,
//   /**
//    * onChange callback
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Callback fired when new error should be displayed
//    */
//   onError: PropTypes__default.func,
//   /**
//    * Props for input base
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * Content for helper text
//    */
//   helperText: PropTypes__default.node,
//   /**
//    * DateTime format specifier
//    */
//   format: PropTypes__default.string,
//   /**
//    * Min selectable date
//    */
//   minDate: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.instanceOf(Date)]),
//   /**
//    * Max selectable date
//    */
//   maxDate: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.instanceOf(Date)]),
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * Display label in error state
//    */
//   error: PropTypes__default.bool,
//   /**
//    * Disable the field
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * If `true`, the input will take up the full width of its container.
//    */
//   fullWidth: PropTypes__default.bool
// };
// DateTimePicker.defaultProps = {
//   id: undefined,
//   label: undefined,
//   value: null,
//   required: false,
//   onChange: function onChange() {
//     return null;
//   },
//   onError: undefined,
//   inputProps: {},
//   helperText: '',
//   format: 'MM/dd/yyyy hh:mm a',
//   // fallback since the adapter needs this to have a value
//   minDate: undefined,
//   maxDate: undefined,
//   className: '',
//   error: false,
//   disabled: false,
//   fullWidth: false
// };

// var _templateObject$1t, _templateObject2$R;
// var StyledCard = styled(Card)(_templateObject$1t || (_templateObject$1t = _taggedTemplateLiteral$1(["\n  display: flex;\n  box-shadow: 0rem 0.125rem 1.478rem #e4e6e9;\n  background: linear-gradient(180deg, #ffffff 50%, #efefef 100%);\n  flex-direction: column;\n  text-align: center;\n  justify-content: space-evenly;\n  font-weight: 600;\n  height: 16.188rem;\n  border-radius: 0.375rem;\n  border-top: 0.125rem solid #dddddd;\n  border-bottom: 0.625rem solid #dddddd;\n  position: relative;\n  left: 1rem;\n"])));
// var StyledSpan$4 = styled.span(_templateObject2$R || (_templateObject2$R = _taggedTemplateLiteral$1(["\n  font-size: ", ";\n  line-height: ", ";\n"])), function (props) {
//   return props.fontSize;
// }, function (props) {
//   return props.lineHeight;
// });

// /**
//  * Component for Calendar to show data day wise
//  */
// function DayCalendar(_ref) {
//   var data = _ref.data,
//     cardWidth = _ref.cardWidth;
//   var _data = _slicedToArray$b(data, 3),
//     monthYear = _data[0],
//     date = _data[1],
//     day = _data[2];
//   return /*#__PURE__*/React__default.createElement(StyledCard, {
//     width: cardWidth
//   }, /*#__PURE__*/React__default.createElement(StyledSpan$4, {
//     fontSize: "1.875rem",
//     lineHeight: "0.688rem"
//   }, monthYear), /*#__PURE__*/React__default.createElement(StyledSpan$4, {
//     fontSize: "3.938rem",
//     lineHeight: "2.875rem"
//   }, date < 10 ? "0".concat(date) : date), /*#__PURE__*/React__default.createElement(StyledSpan$4, {
//     fontSize: "1.5rem",
//     lineHeight: "2.063rem"
//   }, day));
// }
// DayCalendar.propTypes = {
//   /**
//    * Contains Month Year Day Week data for calander
//    */
//   data: PropTypes__default.arrayOf(PropTypes__default.string),
//   /**
//    * Set the width of card
//    */
//   cardWidth: PropTypes__default.string
// };
// DayCalendar.defaultProps = {
//   data: [],
//   cardWidth: '22rem'
// };

// var _templateObject$1s;
// var StyledMuiDivider = styled(MuiDivider)(_templateObject$1s || (_templateObject$1s = _taggedTemplateLiteral$1(["\n &.MuiDivider-vertical {\n    width: 1px;\n}\n"])));

// /**
//  * Dividers are thin lines that group content in lists or other containers
//  */
// function Divider(_ref) {
//   var className = _ref.className,
//     orientation = _ref.orientation,
//     flexItem = _ref.flexItem,
//     light = _ref.light;
//   return /*#__PURE__*/React__default.createElement(StyledMuiDivider, {
//     className: className,
//     orientation: orientation,
//     flexItem: flexItem,
//     light: light
//   });
// }
// Divider.propTypes = {
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * The divider orientation.
//    */
//   orientation: PropTypes__default.oneOf(['horizontal', 'vertical']),
//   /**
//    * The component used for the root node. Either a string to use a HTML element or a component.
//    */
//   flexItem: PropTypes__default.bool,
//   /**
//    * If true, the divider will have a lighter color.
//    */
//   light: PropTypes__default.bool
// };
// Divider.defaultProps = {
//   className: undefined,
//   orientation: 'horizontal',
//   flexItem: false,
//   light: false
// };

// /**
//  * The Drawer component is a panel that slides out from the edge of the screen.
//  * It can be useful when you need users to complete a task or view some details without leaving the current page.
//  */
// function Drawer(_ref) {
//   var anchor = _ref.anchor,
//     elevation = _ref.elevation,
//     children = _ref.children,
//     className = _ref.className,
//     onClose = _ref.onClose,
//     open = _ref.open,
//     variant = _ref.variant,
//     hideBackdrop = _ref.hideBackdrop;
//   return /*#__PURE__*/React__default.createElement(MuiDrawer, {
//     anchor: anchor,
//     elevation: elevation,
//     onClose: onClose,
//     open: open,
//     variant: variant,
//     className: className,
//     hideBackdrop: hideBackdrop
//   }, children);
// }

// // PropType check
// Drawer.propTypes = {
//   /**
//    * Side from which the drawer will appear.The elevation of the drawer.
//    */
//   anchor: PropTypes__default.oneOf(['bottom', 'left', 'right', 'top']),
//   /**
//    * The elevation of the drawer.The content of the component.
//    */
//   elevation: PropTypes__default.number,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * If true, the component is shown.
//    */
//   open: PropTypes__default.bool,
//   /**
//    * The variant to use.
//    */
//   variant: PropTypes__default.oneOf(['permanent', 'persistent', 'temporary']),
//   /**
//    * If true, the backdrop is not rendered.
//    */
//   hideBackdrop: PropTypes__default.bool
// };
// Drawer.defaultProps = {
//   anchor: undefined,
//   elevation: 16,
//   children: null,
//   className: '',
//   onClose: undefined,
//   open: false,
//   variant: 'temporary',
//   hideBackdrop: false
// };

// var _templateObject$1r;
// var StyledFile = styled.input.attrs(function () {
//   return {
//     type: 'file'
//   };
// })(_templateObject$1r || (_templateObject$1r = _taggedTemplateLiteral$1(["\n  position: absolute;\n  opacity: 0;\n  display: none;\n"])));

// var _excluded$x = ["multiple", "accept", "onSelect"];

// /**
//  * The FileUploadButton component is used for file selector to look like button.
//  */
// function FileUploadButton(props) {
//   var _this = this;
//   var inputRef = useRef$2(null);
//   var onButtonClick = function onButtonClick() {
//     inputRef.current.click();
//   };
//   var multiple = props.multiple,
//     accept = props.accept,
//     onSelect = props.onSelect,
//     otherProps = _objectWithoutProperties$j(props, _excluded$x);
//   var onFileSelect = function onFileSelect(event) {
//     if (!onSelect) {
//       return;
//     }
//     onSelect.apply(_this, [event.target.files]);
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(StyledFile, {
//     ref: inputRef,
//     multiple: multiple,
//     accept: accept,
//     onChange: onFileSelect,
//     "aria-hidden": "true"
//   }), /*#__PURE__*/React__default.createElement(Button$1, _extends$v({}, otherProps, {
//     onClick: onButtonClick
//   })));
// }
// FileUploadButton.propTypes = {
//   /**
//    * if files need to be selected multiple
//    */
//   multiple: PropTypes__default.bool,
//   /**
//    * [accept](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept) attribute to be applied on the file input
//    */
//   accept: PropTypes__default.string,
//   /**
//    * On files select handler
//    */
//   onSelect: PropTypes__default.func,
//   /**
//    * Disabled state of the button
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Button variant
//    */
//   variant: PropTypes__default.oneOf(['primary', 'secondary', 'text']),
//   /**
//    * Text on the button
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// FileUploadButton.defaultProps = {
//   multiple: false,
//   accept: undefined,
//   onSelect: undefined,
//   variant: 'secondary',
//   disabled: false,
//   className: undefined
// };

// /**
//  * FlextGrid is used when you have a set of items and want to space them out evenly in a container.
//  */
// function FlexGrid(_ref) {
//   var alignContent = _ref.alignContent,
//     alignItems = _ref.alignItems,
//     children = _ref.children,
//     className = _ref.className,
//     component = _ref.component,
//     container = _ref.container,
//     direction = _ref.direction,
//     item = _ref.item,
//     justify = _ref.justify,
//     lg = _ref.lg,
//     md = _ref.md,
//     sm = _ref.sm,
//     spacing = _ref.spacing,
//     wrap = _ref.wrap,
//     xl = _ref.xl,
//     xs = _ref.xs,
//     ariaHidden = _ref.ariaHidden;
//   return /*#__PURE__*/React__default.createElement(Grid, {
//     alignContent: alignContent,
//     alignItems: alignItems,
//     component: component,
//     container: container,
//     direction: direction,
//     item: item,
//     justifyContent: justify,
//     lg: lg,
//     md: md,
//     sm: sm,
//     spacing: spacing,
//     wrap: wrap,
//     xl: xl,
//     xs: xs,
//     className: className,
//     "aria-hidden": ariaHidden
//   }, children);
// }
// FlexGrid.propTypes = {
//   alignContent: PropTypes__default.oneOf(['stretch', 'center', 'flex-start', 'flex-end', 'space-between', 'space-around']),
//   alignItems: PropTypes__default.oneOf(['flex-start', 'center', 'flex-end', 'stretch', 'baseline']),
//   children: PropTypes__default.node,
//   className: PropTypes__default.string,
//   component: PropTypes__default.elementType,
//   container: PropTypes__default.bool,
//   direction: PropTypes__default.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),
//   item: PropTypes__default.bool,
//   justify: PropTypes__default.oneOf(['flex-start', 'center', 'flex-end', 'space-between', 'space-around', 'space-evenly']),
//   lg: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
//   md: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
//   sm: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
//   spacing: PropTypes__default.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
//   wrap: PropTypes__default.oneOf(['nowrap', 'wrap', 'wrap-reverse']),
//   xl: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
//   xs: PropTypes__default.oneOf([false, 'auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
//   /**
//    * aria-hidden for text
//    */
//   ariaHidden: PropTypes__default.bool
// };
// FlexGrid.defaultProps = {
//   alignContent: undefined,
//   alignItems: undefined,
//   children: null,
//   className: '',
//   component: 'div',
//   container: undefined,
//   direction: undefined,
//   item: undefined,
//   justify: undefined,
//   lg: undefined,
//   md: undefined,
//   sm: undefined,
//   spacing: undefined,
//   wrap: undefined,
//   xl: undefined,
//   xs: undefined,
//   ariaHidden: undefined
// };

// var _templateObject$1q, _templateObject2$Q;
// var StyledFormLabel$1 = styled(FormLabel$1)(_templateObject$1q || (_templateObject$1q = _taggedTemplateLiteral$1(["\n  font-weight: bold;\n  color: inherit;\n  line-height: 1.75rem;\n"])));
// var RequiredFormLabel = styled(StyledFormLabel$1)(_templateObject2$Q || (_templateObject2$Q = _taggedTemplateLiteral$1(["\n  &:after {\n    content: ' *';\n    color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.brandDanger;
// });

// /**
//  * The FormLabels are used for placing the label in the desired position and also applying the styles to the label.
//  */
// function FormLabel(_ref) {
//   var children = _ref.children,
//     component = _ref.component,
//     className = _ref.className,
//     required = _ref.required;
//   var Label = StyledFormLabel$1;
//   Label = required ? RequiredFormLabel : StyledFormLabel$1;
//   return /*#__PURE__*/React__default.createElement(Label, {
//     component: component,
//     focused: false,
//     className: className
//   }, children);
// }
// FormLabel.propTypes = {
//   /**
//    * The content of the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * The component used for the root node. Either a string to use a HTML element or a component.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * If true, the label will indicate that the input is required (*).
//    */
//   required: PropTypes__default.bool
// };
// FormLabel.defaultProps = {
//   children: undefined,
//   component: 'legend',
//   className: undefined,
//   required: false
// };

// var LocaleContext = /*#__PURE__*/createContext();

// // Will provide locale related user information such as date formats and timezone
// var useLocaleContext = function useLocaleContext() {
//   var context = useContext(LocaleContext);
//   if (!context) {
//     throw new Error('LocaleContext must be used within LocaleContextProvider!');
//   }
//   return context;
// };

// /**
//  * FormattedDateTime component is used to dates in the user's format and timezone
//  */
// function FormattedDateTime(_ref) {
//   var utcDateValue = _ref.utcDateValue;
//   var localeContextData = useLocaleContext();
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     formattedDateString = _useState2[0],
//     setFormattedDate = _useState2[1];
//   useEffect$2(function () {
//     setFormattedDate(function () {
//       var timeZone = localeContextData.timeZone;
//       var dateTimeFormat = localeContextData.dateTimeFormat;
//       if (!utcDateValue) {
//         return;
//       }
//       if (!dateTimeFormat || !timeZone) {
//         return;
//       }
//       if (parseInt(moment.tz(timeZone).zoneAbbr(), 10)) {
//         dateTimeFormat = dateTimeFormat.replace('z', '');
//         return moment.utc(utcDateValue).tz(timeZone).format(dateTimeFormat);
//       }
//       return moment.utc(utcDateValue).tz(timeZone).format(dateTimeFormat);
//     });
//   }, [localeContextData, utcDateValue]);
//   return /*#__PURE__*/React__default.createElement("span", null, formattedDateString);
// }
// FormattedDateTime.propTypes = {
//   /**
//    * UTC value from database.
//    */
//   utcDateValue: PropTypes__default.string.isRequired
// };
// FormattedDateTime.defaultProps = {};

// function GridList(_ref) {
//   var rowHeight = _ref.rowHeight,
//     cols = _ref.cols,
//     children = _ref.children,
//     className = _ref.className,
//     component = _ref.component,
//     gap = _ref.gap;
//   return /*#__PURE__*/React__default.createElement(MuiImageList, {
//     rowHeight: rowHeight,
//     cols: cols,
//     component: component,
//     gap: gap,
//     className: className
//   }, children);
// }

// // PropType check
// GridList.propTypes = {
//   /**
//    * row height of the card
//    */
//   rowHeight: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * Number of coloumns
//    */
//   cols: PropTypes__default.number,
//   /**
//    * Children for the card action
//    */
//   children: PropTypes__default.node,
//   /**
//    * classname
//    */
//   className: PropTypes__default.string,
//   /**
//    * Component
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * gap between the cards
//    */
//   gap: PropTypes__default.number
// };
// GridList.defaultProps = {
//   rowHeight: undefined,
//   cols: undefined,
//   children: null,
//   className: '',
//   component: 'ul',
//   gap: undefined
// };

// var _excluded$w = ["children", "addEndListener", "appear", "easing", "timeout", "className"];
// function Grow(props) {
//   var children = props.children,
//     addEndListener = props.addEndListener,
//     appear = props.appear,
//     easing = props.easing,
//     timeout = props.timeout,
//     className = props.className,
//     leftovers = _objectWithoutProperties$j(props, _excluded$w);
//   return /*#__PURE__*/React__default.createElement(Grow$1, _extends$v({}, leftovers, {
//     className: className,
//     addEndListener: addEndListener,
//     appear: appear,
//     easing: easing,
//     timeout: timeout
//   }), children);
// }
// Grow.propTypes = {
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * Add a custom transition end trigger. Called with the transitioning DOM node and a done callback. Allows for more fine grained transition end logic. Note: Timeouts are still used as a fallback if provided.
//    */
//   addEndListener: PropTypes__default.func,
//   /**
//    * Perform the enter transition when it first mounts if in is also true. Set this to false to disable this behavior.
//    */
//   appear: PropTypes__default.bool,
//   /**
//    * The transition timing function. You may specify a single easing or a object containing enter and exit values.
//    */
//   easing: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.shape({})]),
//   /**
//   * The duration for the transition, in milliseconds. You may specify a single timeout for all transitions, or individually with an object.
//   Set to 'auto' to automatically calculate transition time based on height.
//   */
//   timeout: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number, PropTypes__default.shape({})]),
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node
// };
// Grow.defaultProps = {
//   className: undefined,
//   addEndListener: undefined,
//   appear: true,
//   easing: undefined,
//   timeout: 'auto',
//   children: undefined
// };

// var _templateObject$1p;
// var StyledHighlighter$1 = styled(Highlighter$1)(_templateObject$1p || (_templateObject$1p = _taggedTemplateLiteral$1(["\n  .markstyles {\n    background-color: transparent;\n    color: ", ";\n    text-decoration: underline;\n    font-style: italic;\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// });

// /**
//  * Highlight allows you to highlight substrings of a text.
//  */
// function Highlighter(_ref) {
//   var textToHighlight = _ref.textToHighlight,
//     searchText = _ref.searchText,
//     className = _ref.className;
//   var searchWords = [];
//   if (searchText !== '' && searchText !== undefined && searchText.length > 0) {
//     searchWords = searchText && searchText.split(/\s/).filter(function (word) {
//       return word;
//     });
//   }
//   return /*#__PURE__*/React__default.createElement(StyledHighlighter$1, {
//     highlightClassName: "markstyles",
//     searchWords: searchWords,
//     textToHighlight: textToHighlight,
//     autoEscape: true,
//     className: className
//   });
// }

// // PropType check
// Highlighter.propTypes = {
//   /**
//    * Text to highlight
//    */
//   textToHighlight: PropTypes__default.string.isRequired,
//   /**
//    * Search text
//    */
//   searchText: PropTypes__default.string.isRequired,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Highlighter.defaultProps = {
//   className: ''
// };

// /**
// - Component for Icon Button.
// - Icon buttons are commonly used in app bars and toolbars.
// */
// function IconButton(_ref) {
//   var idProp = _ref.id,
//     color = _ref.color,
//     size = _ref.size,
//     children = _ref.children,
//     onClick = _ref.onClick,
//     label = _ref.label,
//     disableRipple = _ref.disableRipple,
//     disableFocusRipple = _ref.disableFocusRipple,
//     disabled = _ref.disabled,
//     className = _ref.className,
//     ariaHasPopUp = _ref.ariaHasPopUp,
//     ariaExpanded = _ref.ariaExpanded,
//     onKeyDown = _ref.onKeyDown,
//     ariaDescribedby = _ref.ariaDescribedby;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(IconButton$1, {
//     id: id,
//     color: color,
//     size: size,
//     onClick: onClick,
//     "aria-label": label,
//     disableRipple: disableRipple,
//     disableFocusRipple: disableFocusRipple,
//     disabled: disabled,
//     className: className,
//     "aria-haspopup": ariaHasPopUp,
//     "aria-expanded": ariaExpanded,
//     onKeyDown: onKeyDown,
//     "aria-describedby": ariaDescribedby
//   }, children);
// }

// // PropType check
// IconButton.propTypes = {
//   /**
//    * Id of the button
//    */
//   id: PropTypes__default.string,
//   /**
//    * Color of the component to use
//    */
//   color: PropTypes__default.oneOf(['default', 'inherit', 'primary', 'secondary']),
//   /**
//    * Size of the button
//    */
//   size: PropTypes__default.oneOf(['small', 'medium', 'large']),
//   /**
//    * On Click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Icon element
//    */
//   children: PropTypes__default.node,
//   /**
//    * aria-label of the IconButton
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * If true, the keyboard focus ripple will be disabled.
//    */
//   disableFocusRipple: PropTypes__default.bool,
//   /**
//    * If true, the ripple effect will be disabled.
//    */
//   disableRipple: PropTypes__default.bool,
//   /**
//    * If true, the button will be disabled.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * aria-haspopup attribute to be used for icon button
//    */
//   ariaHasPopUp: PropTypes__default.bool,
//   /**
//    * aria-expanded attribute to be used for icon button
//    */
//   ariaExpanded: PropTypes__default.bool,
//   /**
//    * On onKeyDown handler
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * aria-describedby attribute to be used for icon button
//    */
//   ariaDescribedby: PropTypes__default.string
// };
// IconButton.defaultProps = {
//   id: undefined,
//   color: 'default',
//   size: 'large',
//   onClick: undefined,
//   children: undefined,
//   disableFocusRipple: false,
//   disableRipple: false,
//   disabled: false,
//   className: undefined,
//   ariaHasPopUp: undefined,
//   ariaExpanded: undefined,
//   onKeyDown: undefined,
//   ariaDescribedby: undefined
// };

// /**
//  * Component for Input Adornment.
//  * Input Adornment are commonly used to add a prefix, a suffix or an action to an input.
//  */
// function InputAdornment(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     component = _ref.component,
//     position = _ref.position;
//   return /*#__PURE__*/React__default.createElement(InputAdornment$1, {
//     className: className,
//     component: component,
//     position: position
//   }, children);
// }
// InputAdornment.propTypes = {
//   /**
//    * The content of the component, normally an `IconButton` or string.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * The component used for the root node.
//    * Either a string to use a HTML element or a component.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * The position this adornment should appear relative to the `Input`.
//    */
//   position: PropTypes__default.oneOf(['start', 'end'])
// };
// InputAdornment.defaultProps = {
//   className: undefined,
//   component: 'div',
//   position: 'end'
// };

// var _templateObject$1o;
// var RequiredSpan = styled.span(_templateObject$1o || (_templateObject$1o = _taggedTemplateLiteral$1(["\n  font-weight: bold;\n  color: ", ";\n  padding-left: 0.35rem;\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return theme.variables.brandDanger;
// });

// function RequiredIndicator(_ref) {
//   var className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(RequiredSpan, {
//     className: className
//   }, "*");
// }
// RequiredIndicator.propTypes = {
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// RequiredIndicator.defaultProps = {
//   className: undefined
// };

// function Label$8(_ref) {
//   var label = _ref.label,
//     required = _ref.required,
//     children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiLabel, {
//     className: className,
//     label: /*#__PURE__*/React__default.createElement(React__default.Fragment, null, label, required && /*#__PURE__*/React__default.createElement(RequiredIndicator, null)),
//     control: children
//   });
// }
// Label$8.propTypes = {
//   /**
//    * A control element.
//    */
//   children: PropTypes__default.element.isRequired,
//   /**
//    * Label text to be used for the input field
//    */
//   label: PropTypes__default.node.isRequired,
//   /**
//    * If `true`, label is required
//    */
//   required: PropTypes__default.bool,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Label$8.defaultProps = {
//   required: false,
//   className: undefined
// };

// /**
// - Menu List is generally used to render menu items.
// - It can also be used to handle the focus.
// * */

// function MenuList(_ref) {
//   var id = _ref.id,
//     className = _ref.className,
//     children = _ref.children,
//     autoFocusItem = _ref.autoFocusItem,
//     onKeyDown = _ref.onKeyDown,
//     role = _ref.role,
//     ariaLabel = _ref.ariaLabel,
//     tabIndex = _ref.tabIndex;
//   return /*#__PURE__*/React__default.createElement(MuiMenuList, {
//     id: id,
//     className: className,
//     autoFocusItem: autoFocusItem,
//     onKeyDown: onKeyDown,
//     role: role,
//     "aria-label": ariaLabel,
//     tabIndex: tabIndex
//   }, children);
// }

// // PropType check
// MenuList.propTypes = {
//   /**
//    * MenuList contents are normally MenuItems.
//    */
//   children: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * unique id for the menulist
//    */
//   id: PropTypes__default.string,
//   /* If true, will focus the first menuitem , if flase it prevent focus on first menuitem */
//   autoFocusItem: PropTypes__default.bool,
//   /**
//    * On onKeyDown handler
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * role of menulist
//    */
//   role: PropTypes__default.string,
//   /**
//    * aria -label for ul
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * To set tabindex
//    */
//   tabIndex: PropTypes__default.number
// };
// MenuList.defaultProps = {
//   children: undefined,
//   className: '',
//   id: '',
//   autoFocusItem: false,
//   onKeyDown: undefined,
//   role: 'menu',
//   ariaLabel: '',
//   tabIndex: undefined
// };

// var _templateObject$1n;
// var StyledMenuList$2 = styled(MenuList)(_templateObject$1n || (_templateObject$1n = _taggedTemplateLiteral$1(["\n  background-color: ", ";\n  width: auto;\n  height: auto;\n  box-shadow: 0 0 0.3125rem rgba(00, 00, 00, 0.5);\n  border-radius: 0.125rem;\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n"])), function (props) {
//   return curriedLighten$1(0.2, props.theme.variables.bodyBg);
// });

// /**
// - Light Menu List is generally used to render menu items.
// - It can also be used to handle the focus.
// * */

// function LightMenuList(_ref) {
//   var id = _ref.id,
//     className = _ref.className,
//     children = _ref.children,
//     autoFocusItem = _ref.autoFocusItem;
//   return /*#__PURE__*/React__default.createElement(StyledMenuList$2, {
//     id: id,
//     className: className,
//     autoFocusItem: autoFocusItem
//   }, children);
// }

// // PropType check
// LightMenuList.propTypes = {
//   /**
//    * MenuList contents are normally MenuItems.
//    */
//   children: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * unique id for the menulist
//    */
//   id: PropTypes__default.string,
//   /* If true, will focus the first menuitem , if flase it prevent focus on first menuitem */
//   autoFocusItem: PropTypes__default.bool
// };
// LightMenuList.defaultProps = {
//   children: undefined,
//   className: undefined,
//   id: undefined,
//   autoFocusItem: false
// };

// var _templateObject$1m;
// var StyledLineClampText = styled.div(_templateObject$1m || (_templateObject$1m = _taggedTemplateLiteral$1(["\n        display: -webkit-box;\n        -webkit-line-clamp: ", ";\n        -webkit-box-orient: vertical;\n        overflow: hidden;\n        text-overflow: ellipsis;\n"])), function (props) {
//   return props.maxLines;
// });

// /**
//  * Line ClampText component is used to display text max numbers lines.
//  */
// function LineClampText(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     maxLines = _ref.maxLines;
//   return /*#__PURE__*/React__default.createElement(StyledLineClampText, {
//     className: className,
//     maxLines: maxLines
//   }, children);
// }

// // PropType check
// LineClampText.propTypes = {
//   /**
//    * Children of the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * max number of lines to show
//    */
//   maxLines: PropTypes__default.number
// };
// LineClampText.defaultProps = {
//   children: undefined,
//   className: undefined,
//   maxLines: 4
// };

// var _templateObject$1l;
// var StyledMuiLink = styled(MuiLink)(_templateObject$1l || (_templateObject$1l = _taggedTemplateLiteral$1(["\n  color: ", ";\n  font-weight: ", ";\n  &.Mui-focusVisible {\n    text-decoration: ", ";\n  }\n  cursor: ", ";\n"])), function (props) {
//   return props.disabled ? alpha$1(props.theme.variables.textColor, 0.7) : props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.disabled ? 'Normal' : 'Bold';
// }, function (props) {
//   return props.disabled ? 'none' : 'underline';
// }, function (props) {
//   return props.disabled ? 'default' : 'pointer';
// });

// /**
//  * A Link Component which allows to customize the anchor elements
//  */
// function Link$1(_ref) {
//   var idProp = _ref.id,
//     className = _ref.className,
//     children = _ref.children,
//     component = _ref.component,
//     underline = _ref.underline,
//     onClick = _ref.onClick,
//     href = _ref.href,
//     target = _ref.target,
//     disabled = _ref.disabled;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(StyledMuiLink, {
//     id: id,
//     component: component,
//     className: className,
//     underline: underline,
//     onClick: onClick,
//     href: disabled ? null : href,
//     target: target,
//     rel: "noopener noreferrer",
//     disabled: disabled
//   }, children);
// }
// Link$1.propTypes = {
//   /**
//    * id of the link component.
//    */
//   id: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The content of the link.
//    */
//   children: PropTypes__default.node,
//   /**
//    * The component used for the root node
//    */
//   component: PropTypes__default.string,
//   /**
//    * Controls when the link should have an underline.
//    */
//   underline: PropTypes__default.oneOf(['none', 'hover', 'always']),
//   /**
//    * On click handler.
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * The URL that the hyperlink points to.
//    */
//   href: PropTypes__default.string,
//   /**
//    * The target to open a page.
//    */
//   target: PropTypes__default.string,
//   /**
//    * Disabled state of the button
//    */
//   disabled: PropTypes__default.bool
// };
// Link$1.defaultProps = {
//   id: undefined,
//   className: undefined,
//   children: '',
//   component: 'a',
//   underline: 'hover',
//   onClick: undefined,
//   href: '#',
//   target: '',
//   disabled: false
// };

// function List(_ref) {
//   var component = _ref.component,
//     children = _ref.children,
//     className = _ref.className,
//     role = _ref.role,
//     ariaLabel = _ref.ariaLabel;
//   return /*#__PURE__*/React__default.createElement(MuiList, {
//     component: component,
//     disablePadding: true,
//     className: className,
//     role: role,
//     "aria-label": ariaLabel
//   }, children);
// }
// List.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * The component used for the root node.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * role property for list
//    */
//   role: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for list
//    */
//   ariaLabel: PropTypes__default.string
// };
// List.defaultProps = {
//   children: undefined,
//   component: 'ul',
//   className: undefined,
//   role: undefined,
//   ariaLabel: null
// };

// function ListItem(_ref) {
//   var onClick = _ref.onClick,
//     className = _ref.className,
//     component = _ref.component,
//     selected = _ref.selected,
//     path = _ref.path,
//     children = _ref.children,
//     role = _ref.role,
//     disabled = _ref.disabled,
//     dragProviderProps = _ref.dragProviderProps,
//     innerRef = _ref.innerRef;
//   return /*#__PURE__*/React__default.createElement(MuiListItem, _extends$v({}, dragProviderProps.draggableProps, dragProviderProps.dragHandleProps, {
//     onClick: onClick,
//     button: !!onClick,
//     className: className,
//     component: component,
//     selected: selected,
//     to: path,
//     "aria-disabled": disabled,
//     role: role,
//     ref: innerRef,
//     "aria-selected": selected
//   }), children);
// }
// ListItem.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * onClick for listitem type button
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * If `true`, list item selected
//    */
//   selected: PropTypes__default.bool,
//   /**
//    * The component used for the root node.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * path to navigate, only applicable when component is `Link`
//    */
//   path: PropTypes__default.string,
//   /**
//    * Disabled prop for aria-disabled.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Role for the list item
//    */
//   role: PropTypes__default.string,
//   /**
//    * Props applied to the container component if used
//    */
//   dragProviderProps: PropTypes__default.shape({
//     draggableProps: PropTypes__default.shape({}),
//     dragHandleProps: PropTypes__default.shape({})
//   }),
//   /**
//    * Element reference
//    */
//   innerRef: PropTypes__default.func
// };
// ListItem.defaultProps = {
//   children: undefined,
//   onClick: undefined,
//   className: '',
//   selected: false,
//   component: 'li',
//   path: undefined,
//   disabled: undefined,
//   role: undefined,
//   dragProviderProps: {},
//   innerRef: undefined
// };

// var LiveRegionContext = /*#__PURE__*/createContext();

// var useLiveRegionContext = function useLiveRegionContext() {
//   var context = useContext(LiveRegionContext);
//   if (!context) {
//     throw new Error('LiveRegionContext must be used within LiveRegionContextProvider!');
//   }
//   return context;
// };

// var _templateObject$1k;
// var StyledLiveRegion = styled.div(_templateObject$1k || (_templateObject$1k = _taggedTemplateLiteral$1(["\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  padding: 0;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n"])));

// var LiveRegion = function LiveRegion() {
//   var _useLiveRegionContext = useLiveRegionContext(),
//     liveRegionMessage = _useLiveRegionContext.liveRegionMessage;
//   return /*#__PURE__*/React__default.createElement(StyledLiveRegion, {
//     "aria-live": "assertive",
//     "aria-atomic": true
//   }, liveRegionMessage);
// };

// /**
//  * Loader indicators commonly known as spinners
//  */
// function Loader(_ref) {
//   var size = _ref.size,
//     inheritColor = _ref.inheritColor,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(CircularProgress, {
//     size: "".concat(size, "rem"),
//     className: className,
//     color: inheritColor ? 'inherit' : 'primary'
//   });
// }
// Loader.propTypes = {
//   /**
//    * The size of the circle (unit: rem).
//    */
//   size: PropTypes__default.number,
//   /**
//    * if `true`, color of the Loader will be inherited from parent element
//    */
//   inheritColor: PropTypes__default.bool,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Loader.defaultProps = {
//   size: 2.5,
//   inheritColor: false,
//   className: undefined
// };

// var _templateObject$1j;
// var StyledMuiMenuItem = styled(MuiMenuItem)(_templateObject$1j || (_templateObject$1j = _taggedTemplateLiteral$1(["\nmin-height:", "rem;\n"])), function (props) {
//   return props.minheight;
// });

// /**
//  * Component for Menu Item.
//  * Menu Items are used within the Menu list.
//  */

// var MenuItem = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
//   var idProp = props.id,
//     minheight = props.minheight,
//     selected = props.selected,
//     children = props.children,
//     onClick = props.onClick,
//     className = props.className,
//     component = props.component,
//     path = props.path,
//     role = props.role,
//     onKeyDown = props.onKeyDown;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(StyledMuiMenuItem, _extends$v({
//     id: id,
//     minheight: minheight,
//     className: className,
//     onClick: onClick,
//     selected: selected,
//     tabIndex: 0,
//     component: component,
//     to: path,
//     innerref: ref,
//     role: role
//   }, props, {
//     onKeyDown: onKeyDown
//   }), children);
// });

// // PropType check
// MenuItem.propTypes = {
//   /**
//    * Id of the element
//    */
//   id: PropTypes__default.string,
//   /**
//    * MenuItem min-height in rem
//    */
//   minheight: PropTypes__default.number,
//   /**
//    * MenuItem selected state
//    */
//   selected: PropTypes__default.bool,
//   /**
//    * Elements to be shown within MenuItem
//    */
//   children: PropTypes__default.node,
//   /**
//    * On Click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The component used for the root node.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * path to navigate, only applicable when component is `Link`
//    */
//   path: PropTypes__default.string,
//   /**
//    * role property for menu item
//    */
//   role: PropTypes__default.string,
//   /**
//    * On keyDown handler
//    */
//   onKeyDown: PropTypes__default.func
// };
// MenuItem.defaultProps = {
//   id: undefined,
//   minheight: 2,
//   selected: false,
//   children: undefined,
//   onClick: undefined,
//   className: '',
//   component: undefined,
//   path: undefined,
//   role: 'menuitem',
//   onKeyDown: undefined
// };

// var _templateObject$1i;
// var StyledDialogContent = styled(DialogContent$1)(_templateObject$1i || (_templateObject$1i = _taggedTemplateLiteral$1(["\n  &.MuiDialogContent-root {\n      padding: 0rem 1rem 1rem 1rem;\n      font-size: 1rem;\n      line-height: 2rem;\n      color: ", ";\n}\n"])), function (props) {
//   return props.theme.variables.textColor;
// });

// function DialogContent(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledDialogContent, {
//     className: className
//   }, children);
// }
// DialogContent.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class Name
//    */
//   className: PropTypes__default.string
// };
// DialogContent.defaultProps = {
//   children: null,
//   className: undefined
// };

// var _templateObject$1h;
// var StyledDialogActions = styled(DialogActions$1)(_templateObject$1h || (_templateObject$1h = _taggedTemplateLiteral$1(["\n&.MuiDialogActions-root {\n    padding: 0rem 1rem 1rem 1rem;\n\n    > :not(:first-child) {\n      margin-left: 1rem;\n  }\n  }\n"])));

// function DialogActions(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledDialogActions, {
//     className: className
//   }, children);
// }
// DialogActions.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class Name
//    */
//   className: PropTypes__default.string
// };
// DialogActions.defaultProps = {
//   children: null,
//   className: undefined
// };

// /**
//  * PageTitle component is used to display page heading.
//  */

// function PageTitle(_ref) {
//   var title = _ref.title;
//   return /*#__PURE__*/React__default.createElement("h1", null, title);
// }

// // PropType check
// PageTitle.propTypes = {
//   /**
//    * title text
//    */
//   title: PropTypes__default.string
// };
// PageTitle.defaultProps = {
//   /**
//    * default title
//    */
//   title: ''
// };

// var _templateObject$1g, _templateObject2$P;
// var StyledPagination = styled(Pagination$2)(_templateObject$1g || (_templateObject$1g = _taggedTemplateLiteral$1(["\n  .Mui-selected {\n    pointer-events: none;\n    cursor: default;\n  }\n  .MuiPaginationItem-root {\n    color: ", ";\n    margin-top: ", ";\n    font-size: 0.875rem;\n    background: ", ";\n    &:hover {\n      border: 0.063rem solid;\n      border-color: ", ";\n    }\n    &:focus {\n      border: 0.063rem solid;\n      border-color: ", ";\n    }\n  }\n  &.MuiPaginationItem-icon {\n    font-size: 1.5rem;\n  }\n  .Mui-selected {\n    background-color: ", ";\n    color: ", ";\n    &:hover {\n      background-color: ", ";\n    }\n    &:focus {\n      background-color: ", ";\n    }\n  }\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return theme.variables.textColor;
// }, function (_ref2) {
//   var theme = _ref2.theme;
//   return theme.spacing(0);
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (_ref3) {
//   var theme = _ref3.theme;
//   return theme.variables.btnPrimaryBg;
// }, function (_ref4) {
//   var theme = _ref4.theme;
//   return theme.variables.btnPrimaryBg;
// }, function (p) {
//   return p.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (p) {
//   return p.theme.variables.btnPrimaryBg;
// }, function (p) {
//   return p.theme.variables.btnPrimaryBg;
// });
// var PaginationContainer$1 = styled.div(_templateObject2$P || (_templateObject2$P = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: center;\n"])));

// /**
//  * Pagination: The Pagination component enables the user to select a specific page from a range of pages.
//  */

// function Pagination$1(_ref) {
//   var component = _ref.component,
//     boundaryCount = _ref.boundaryCount,
//     color = _ref.color,
//     count = _ref.count,
//     defaultPage = _ref.defaultPage,
//     disabled = _ref.disabled,
//     getItemAriaLabel = _ref.getItemAriaLabel,
//     hideNextButton = _ref.hideNextButton,
//     hidePrevButton = _ref.hidePrevButton,
//     onChange = _ref.onChange,
//     page = _ref.page,
//     renderItem = _ref.renderItem,
//     shape = _ref.shape,
//     showFirstButton = _ref.showFirstButton,
//     showLastButton = _ref.showLastButton,
//     siblingCount = _ref.siblingCount,
//     size = _ref.size,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(PaginationContainer$1, null, /*#__PURE__*/React__default.createElement(StyledPagination, {
//     component: component,
//     boundaryCount: boundaryCount,
//     color: color,
//     count: count,
//     defaultPage: defaultPage,
//     disabled: disabled,
//     getItemAriaLabel: getItemAriaLabel,
//     hideNextButton: hideNextButton,
//     hidePrevButton: hidePrevButton,
//     onChange: onChange,
//     page: page,
//     renderItem: renderItem,
//     shape: shape,
//     showFirstButton: showFirstButton,
//     showLastButton: showLastButton,
//     siblingCount: siblingCount,
//     size: size,
//     className: className
//   }));
// }
// Pagination$1.propTypes = {
//   /**
//    * The component used for the root node. Either a string to use a HTML element or a component
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * Number of always visible pages at the beginning and end.
//    */
//   boundaryCount: PropTypes__default.number,
//   /**
//    * The active color.
//    */
//   color: PropTypes__default.string,
//   /**
//    * The total number of pages.
//    */
//   count: PropTypes__default.number.isRequired,
//   /**
//    * The page selected by default when the component is uncontrolled.
//    */
//   defaultPage: PropTypes__default.number,
//   /**
//    * If disabled true, the pagination component will be disabled.
//    */
//   disabled: PropTypes__default.bool.isRequired,
//   /**
//    * a function which returns a string value that provides a user-friendly name for the current page.
//    */
//   getItemAriaLabel: PropTypes__default.func,
//   /**
//    * If hideNextButton true, hide the next-page button.
//    */
//   hideNextButton: PropTypes__default.bool,
//   /**
//    * If hidePrevButton true, hide the previous-page button..
//    */
//   hidePrevButton: PropTypes__default.bool,
//   /**
//    * Callback fired when the page is changed.
//    */
//   onChange: PropTypes__default.func.isRequired,
//   /**
//    * The current page
//    */
//   page: PropTypes__default.number.isRequired,
//   /**
//    * Render the item.
//    */
//   renderItem: PropTypes__default.func,
//   /**
//    * The shape of the pagination items
//    */
//   shape: PropTypes__default.string,
//   /**
//    * If showFirstButton true, show the first-page button.
//    */
//   showFirstButton: PropTypes__default.bool,
//   /**
//    * If showLastButton true, show the last-page button.
//    */
//   showLastButton: PropTypes__default.bool,
//   /**
//    * siblingCount number of always visible pages before and after the current page.
//    */
//   siblingCount: PropTypes__default.number,
//   /**
//    * The size of the pagination component.
//    */
//   size: PropTypes__default.string,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string
// };
// Pagination$1.defaultProps = {
//   component: 'div',
//   boundaryCount: 1,
//   color: 'standard',
//   getItemAriaLabel: undefined,
//   hideNextButton: false,
//   hidePrevButton: false,
//   renderItem: undefined,
//   shape: 'rounded',
//   showFirstButton: false,
//   showLastButton: false,
//   siblingCount: 1,
//   size: 'medium',
//   className: undefined,
//   defaultPage: 1
// };

// var _templateObject$1f;
// var StyledPaper = styled(Paper$1)(_templateObject$1f || (_templateObject$1f = _taggedTemplateLiteral$1(["\n  height: 100%;\n  width: 100%;\n"])));

// /**
//  * Component to render Paper.
//  * This is used to provide flat, opaque texture of paper to the background of a page.
//  */
// function Paper(_ref) {
//   var elevation = _ref.elevation,
//     children = _ref.children,
//     className = _ref.className,
//     role = _ref.role;
//   return /*#__PURE__*/React__default.createElement(StyledPaper, {
//     elevation: elevation,
//     className: className,
//     role: role
//   }, children);
// }
// Paper.propTypes = {
//   /**
//    * The content of the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * Shadow depth. It accepts values between 0 and 24 inclusive
//    */
//   elevation: PropTypes__default.number,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * role property for paper
//    */
//   role: PropTypes__default.string
// };
// Paper.defaultProps = {
//   children: undefined,
//   elevation: 2,
//   className: '',
//   role: undefined
// };

// /**
//  * Component for Popper.
//  * Its functionality is to position any UI element that "pops out" from the flow
//  * of your document and floats near a target element.
//  * It can be used for tooltip, popovers, drop-downs, and more.
//  */
// function Popper(props) {
//   var id = props.id,
//     anchorEl = props.anchorEl,
//     placement = props.placement,
//     toggle = props.toggle,
//     children = props.children,
//     className = props.className,
//     disableAutoAdjust = props.disableAutoAdjust,
//     transition = props.transition,
//     disablePortal = props.disablePortal,
//     role = props.role;
//   return /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(Popper$1, {
//     id: id,
//     role: role,
//     open: toggle,
//     anchorEl: anchorEl,
//     placement: placement,
//     transition: transition,
//     disablePortal: disablePortal,
//     modifiers: [{
//       name: 'flip',
//       enabled: false
//     }, {
//       name: 'preventOverflow',
//       enabled: disableAutoAdjust
//     }, {
//       name: 'hide',
//       enabled: false
//     }],
//     className: className
//   }, children));
// }
// Popper.propTypes = {
//   /**
//    * placement of Popper Div
//    */
//   placement: PropTypes__default.oneOf(['top-start', 'top', 'top-end', 'left-start', 'left', 'left-end', 'right-start', 'right', 'right-end', 'bottom-start', 'bottom', 'bottom-end']),
//   /**
//    *anchorEl: element to which Popper Div attaches
//    */
//   anchorEl: PropTypes__default.oneOfType([PropTypes__default.object]),
//   /**
//    * toggle value of the Popper Div
//    */
//   toggle: PropTypes__default.bool,
//   /**
//    * Child elements for the component
//    */
//   children: PropTypes__default.oneOfType([PropTypes__default.node, PropTypes__default.func]),
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * disableAutoAdjust is used to fix the horizontal alignment
//    */
//   disableAutoAdjust: PropTypes__default.bool,
//   /**
//    * role property
//    */
//   role: PropTypes__default.string,
//   /**
//    * id property
//    */
//   id: PropTypes__default.string,
//   /**
//    * transition
//    */
//   transition: PropTypes__default.bool,
//   /**
//    * disable Portal
//    */
//   disablePortal: PropTypes__default.bool
// };
// Popper.defaultProps = {
//   placement: 'bottom-start',
//   anchorEl: null,
//   toggle: false,
//   children: undefined,
//   className: null,
//   disableAutoAdjust: true,
//   role: 'tooltip',
//   id: 'simple-popper',
//   transition: false,
//   disablePortal: false
// };

// /**
//  * The ProgressBar component is used to provide status of ongoing process.
//  */
// function ProgressBar(_ref) {
//   var className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(LinearProgress, {
//     className: className
//   });
// }
// ProgressBar.propTypes = {
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// ProgressBar.defaultProps = {
//   className: undefined
// };

// var _templateObject$1e;
// var StyledRadio = styled(MuiRadio)(_templateObject$1e || (_templateObject$1e = _taggedTemplateLiteral$1(["\n  .MuiSvgIcon-root {\n    height: 1.25rem;\n    width: 1.25rem;\n  }\n"])));

// /**
//  * Radio buttons let people select one option from a set of options.
//  */
// function Radio(_ref) {
//   var checked = _ref.checked,
//     value = _ref.value,
//     disabled = _ref.disabled,
//     onChange = _ref.onChange,
//     ariaLabel = _ref.ariaLabel,
//     inputProps = _ref.inputProps,
//     innerRef = _ref.innerRef,
//     className = _ref.className,
//     ariaLabelledBy = _ref.ariaLabelledBy,
//     id = _ref.id;
//   return /*#__PURE__*/React__default.createElement(StyledRadio, {
//     checked: checked,
//     value: value,
//     color: "primary",
//     disabled: disabled,
//     onChange: onChange,
//     size: "small",
//     inputProps: _objectSpread2$1(_objectSpread2$1({}, inputProps), {}, {
//       'aria-label': ariaLabel,
//       'aria-labelledby': ariaLabelledBy
//     }),
//     ref: innerRef,
//     className: className,
//     id: id
//   });
// }
// Radio.propTypes = {
//   /**
//    * If `true`, the component is checked. Keep this undefined to control from RadioGroup
//    */
//   checked: PropTypes__default.bool,
//   /**
//    * value of the selected radio button
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * If `true`, the radio will be disabled. Keep this undefined to control from RadioGroup
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Callback fired when the state is changed.
//    *
//    * @param {object} event The event source of the callback.
//    * You can pull out the new value by accessing `event.target.value` (string).
//    * You can pull out the new checked state by accessing `event.target.checked` (boolean).
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for input field
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * Element ref
//    */
//   innerRef: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]),
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * ariaLabelledBy prop for input
//    */
//   ariaLabelledBy: PropTypes__default.string,
//   /**
//    * Id of the Radio
//    */
//   id: PropTypes__default.string
// };
// Radio.defaultProps = {
//   value: '',
//   disabled: undefined,
//   checked: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   ariaLabel: null,
//   inputProps: undefined,
//   innerRef: undefined,
//   className: '',
//   ariaLabelledBy: undefined,
//   id: undefined
// };

// /**
//  * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.
//  * For licensing, see LICENSE.md.
//  */
// function loadScript (src, opts, cb) {
//   var head = document.head || document.getElementsByTagName('head')[0];
//   var script = document.createElement('script');
//   if (typeof opts === 'function') {
//     cb = opts;
//     opts = {};
//   }
//   opts = opts || {};
//   cb = cb || function () {};
//   script.type = opts.type || 'text/javascript';
//   script.charset = opts.charset || 'utf8';
//   script.async = 'async' in opts ? !!opts.async : true;
//   script.src = src;
//   if (opts.attrs) {
//     setAttributes(script, opts.attrs);
//   }
//   if (opts.text) {
//     script.text = String(opts.text);
//   }
//   var onend = 'onload' in script ? stdOnEnd : ieOnEnd;
//   onend(script, cb);
//   if (!script.onload) {
//     stdOnEnd(script, cb);
//   }
//   head.appendChild(script);
// }
// function setAttributes(script, attrs) {
//   for (var attr in attrs) {
//     script.setAttribute(attr, attrs[attr]);
//   }
// }
// function stdOnEnd(script, cb) {
//   script.onload = function () {
//     this.onerror = this.onload = null;
//     cb(null, script);
//   };
//   script.onerror = function () {
//     this.onerror = this.onload = null;
//     cb(new Error('Failed to load ' + this.src), script);
//   };
// }
// function ieOnEnd(script, cb) {
//   script.onreadystatechange = function () {
//     if (this.readyState != 'complete' && this.readyState != 'loaded') {
//       return;
//     }
//     this.onreadystatechange = null;
//     cb(null, script);
//   };
// }

// var promise;
// function getEditorNamespace(editorURL, onNamespaceLoaded) {
//   if ('CKEDITOR' in window) {
//     return Promise.resolve(CKEDITOR);
//   }
//   if (typeof editorURL !== 'string' || editorURL.length < 1) {
//     return Promise.reject(new TypeError('CKEditor URL must be a non-empty string.'));
//   }
//   if (!promise) {
//     promise = getEditorNamespace.scriptLoader(editorURL).then(function (res) {
//       if (onNamespaceLoaded) {
//         onNamespaceLoaded(res);
//       }
//       return res;
//     });
//   }
//   return promise;
// }
// getEditorNamespace.scriptLoader = function (editorURL) {
//   return new Promise(function (scriptResolve, scriptReject) {
//     loadScript(editorURL, function (err) {
//       promise = undefined;
//       if (err) {
//         return scriptReject(err);
//       } else if (!window.CKEDITOR) {
//         return scriptReject(new Error('Script loaded from editorUrl doesn\'t provide CKEDITOR namespace.'));
//       }
//       scriptResolve(CKEDITOR);
//     });
//   });
// };

// /**
//  * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
//  * For licensing, see LICENSE.md.
//  */

// var __assign = function() {
//     __assign = Object.assign || function __assign(t) {
//         for (var s, i = 1, n = arguments.length; i < n; i++) {
//             s = arguments[i];
//             for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
//         }
//         return t;
//     };
//     return __assign.apply(this, arguments);
// };
// function __rest(s, e) {
//     var t = {};
//     for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
//         t[p] = s[p];
//     if (s != null && typeof Object.getOwnPropertySymbols === "function")
//         for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
//             if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
//                 t[p[i]] = s[p[i]];
//         }
//     return t;
// }
// function __spreadArray(to, from, pack) {
//     if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
//         if (ar || !(i in from)) {
//             if (!ar) ar = Array.prototype.slice.call(from, 0, i);
//             ar[i] = from[i];
//         }
//     }
//     return to.concat(ar || Array.prototype.slice.call(from));
// }

// var events = [
//     'activeEnterModeChange',
//     'activeFilterChange',
//     'afterCommandExec',
//     'afterInsertHtml',
//     'afterPaste',
//     'afterPasteFromWord',
//     'afterSetData',
//     'afterUndoImage',
//     'ariaEditorHelpLabel',
//     'ariaWidget',
//     'autogrow',
//     'beforeCommandExec',
//     'beforeDestroy',
//     'beforeGetData',
//     'beforeModeUnload',
//     'beforeSetMode',
//     'beforeUndoImage',
//     'blur',
//     'change',
//     'configLoaded',
//     'contentDirChanged',
//     'contentDom',
//     'contentDomInvalidated',
//     'contentDomUnload',
//     'contentPreview',
//     'customConfigLoaded',
//     'dataFiltered',
//     'dataReady',
//     'destroy',
//     'dialogHide',
//     'dialogShow',
//     'dirChanged',
//     'doubleclick',
//     'dragend',
//     'dragstart',
//     'drop',
//     'elementsPathUpdate',
//     'exportPdf',
//     'fileUploadRequest',
//     'fileUploadResponse',
//     'floatingSpaceLayout',
//     'focus',
//     'getData',
//     'getSnapshot',
//     'insertElement',
//     'insertHtml',
//     'insertText',
//     'instanceReady',
//     'key',
//     'langLoaded',
//     'loadSnapshot',
//     'loaded',
//     'lockSnapshot',
//     'maximize',
//     'menuShow',
//     'mode',
//     'notificationHide',
//     'notificationShow',
//     'notificationUpdate',
//     'paste',
//     'pasteFromWord',
//     'pluginsLoaded',
//     'readOnly',
//     'removeFormatCleanup',
//     'required',
//     'resize',
//     'save',
//     'saveSnapshot',
//     'selectionChange',
//     'setData',
//     'stylesRemove',
//     'stylesSet',
//     'template',
//     'toDataFormat',
//     'toHtml',
//     'uiSpace',
//     'unlockSnapshot',
//     'updateSnapshot',
//     'widgetDefinition'
// ];
// var namespaceEvents = ['beforeLoad', 'namespaceLoaded'];
// var defaultEvents = __spreadArray(__spreadArray([], events, true), namespaceEvents, true);
// var EVENT_PREFIX = '__CKE__';
// function prefixEventName(evtName) {
//     return "".concat(EVENT_PREFIX).concat(evtName);
// }
// function stripPrefix(prefixedEventName) {
//     return prefixedEventName.substr(EVENT_PREFIX.length);
// }
// function eventNameToHandlerName(evtName) {
//     var cap = evtName.substr(0, 1).toUpperCase() + evtName.substr(1);
//     return "on".concat(cap);
// }
// function handlerNameToEventName(handlerName) {
//     return handlerName.substr(2, 1).toLowerCase() + handlerName.substr(3);
// }
// var CKEditorEventAction = __spreadArray(__spreadArray([], events, true), namespaceEvents, true).reduce(function (acc, evtName) {
//     var _a;
//     return __assign(__assign({}, acc), (_a = {}, _a[evtName] = prefixEventName(evtName), _a));
// }, {});

// function camelToKebab(str) {
//     return str
//         .split(/(?=[A-Z])/)
//         .join('-')
//         .toLowerCase();
// }
// function uniqueName() {
//     return Math.random()
//         .toString(36)
//         .replace(/[^a-z]+/g, '')
//         .substr(0, 5);
// }
// function getStyle(type, status, style) {
//     var hidden = { display: 'none', visibility: 'hidden' };
//     if (type === 'classic') {
//         return hidden;
//     }
//     return status === 'ready' ? style !== null && style !== void 0 ? style : undefined : hidden;
// }

// function registerEditorEventHandler(_a) {
//     var debug = _a.debug, editor = _a.editor, evtName = _a.evtName, handler = _a.handler, listenerData = _a.listenerData, priority = _a.priority;
//     var handlerId = debug && uniqueName();
//     var _handler = handler;
//     if (debug) {
//         _handler = function (args) {
//             console.log({
//                 operation: 'invoke',
//                 editor: editor.name,
//                 evtName: evtName,
//                 handlerId: handlerId,
//                 data: args.data,
//                 listenerData: args.listenerData
//             });
//             handler(args);
//         };
//     }
//     if (debug) {
//         console.log({
//             operation: 'register',
//             editor: editor.name,
//             evtName: evtName,
//             handlerId: handlerId
//         });
//     }
//     editor.on(evtName, _handler, null, listenerData, priority);
//     return function () {
//         if (debug) {
//             console.log({
//                 operation: 'unregister',
//                 editor: editor.name,
//                 evtName: evtName,
//                 handlerId: handlerId
//             });
//         }
//         editor.removeListener(evtName, _handler);
//     };
// }

// var useEffect$1 = React.useEffect, useReducer = React.useReducer, useRef$1 = React.useRef;
// var defEditorUrl = 'https://cdn.ckeditor.com/4.19.0/standard-all/ckeditor.js';
// var defConfig = {};
// function useCKEditor(_a) {
//     var config = _a.config, debug = _a.debug, dispatchEvent = _a.dispatchEvent, _b = _a.subscribeTo, subscribeTo = _b === void 0 ? defaultEvents : _b, editorUrl = _a.editorUrl, element = _a.element, initContent = _a.initContent, _c = _a.type, type = _c === void 0 ? 'classic' : _c;
//     var editorUrlRef = useRef$1(editorUrl || defEditorUrl);
//     var subscribeToRef = useRef$1(subscribeTo !== null && subscribeTo !== void 0 ? subscribeTo : defaultEvents);
//     var debugRef = useRef$1(debug);
//     var dispatchEventRef = useRef$1(dispatchEvent);
//     var initContentRef = useRef$1(initContent);
//     var configRef = useRef$1(config || defConfig);
//     var typeRef = useRef$1(type);
//     var _d = useReducer(reducer, {
//         editor: undefined,
//         hookStatus: 'init'
//     }), _e = _d[0], editor = _e.editor, hookStatus = _e.hookStatus, dispatch = _d[1];
//     useEffect$1(function () {
//         if (element && !editor) {
//             dispatch({ type: 'loading' });
//             var onNamespaceLoaded = function (CKEDITOR) {
//                 var _a;
//                 if (subscribeToRef.current.indexOf('namespaceLoaded') !== -1) {
//                     (_a = dispatchEventRef.current) === null || _a === void 0 ? void 0 : _a.call(dispatchEventRef, {
//                         type: CKEditorEventAction.namespaceLoaded,
//                         payload: CKEDITOR
//                     });
//                 }
//             };
//             var initEditor = function (CKEDITOR) {
//                 var _a;
//                 var isInline = typeRef.current === 'inline';
//                 var isReadOnly = configRef.current.readOnly;
//                 if (subscribeToRef.current.indexOf('beforeLoad') !== -1) {
//                     (_a = dispatchEventRef.current) === null || _a === void 0 ? void 0 : _a.call(dispatchEventRef, {
//                         type: CKEditorEventAction.beforeLoad,
//                         payload: CKEDITOR
//                     });
//                 }
//                 var editor = CKEDITOR[isInline ? 'inline' : 'replace'](element, configRef.current);
//                 var subscribedEditorEvents = subscribeToRef.current.filter(function (evtName) { return namespaceEvents.indexOf(evtName) === -1; });
//                 subscribedEditorEvents.forEach(function (evtName) {
//                     registerEditorEventHandler({
//                         debug: debugRef.current,
//                         editor: editor,
//                         evtName: evtName,
//                         handler: function (payload) {
//                             var _a;
//                             (_a = dispatchEventRef.current) === null || _a === void 0 ? void 0 : _a.call(dispatchEventRef, {
//                                 type: "".concat(EVENT_PREFIX).concat(evtName),
//                                 payload: payload
//                             });
//                         }
//                     });
//                 });
//                 registerEditorEventHandler({
//                     debug: debugRef.current,
//                     editor: editor,
//                     evtName: 'loaded',
//                     handler: function () {
//                         dispatch({ type: 'loaded' });
//                     },
//                     priority: -1
//                 });
//                 registerEditorEventHandler({
//                     debug: debugRef.current,
//                     editor: editor,
//                     evtName: 'instanceReady',
//                     handler: function (_a) {
//                         var editor = _a.editor;
//                         dispatch({ type: 'ready' });
//                         if (isInline && !isReadOnly) {
//                             editor.setReadOnly(false);
//                         }
//                         if (initContentRef.current) {
//                             editor.setData(initContentRef.current, {
//                                 noSnapshot: true,
//                                 callback: function () {
//                                     editor.resetUndo();
//                                 }
//                             });
//                         }
//                     },
//                     priority: -1
//                 });
//                 registerEditorEventHandler({
//                     debug: debugRef.current,
//                     editor: editor,
//                     evtName: 'destroy',
//                     handler: function () {
//                         dispatch({ type: 'destroyed' });
//                     },
//                     priority: -1
//                 });
//                 dispatch({
//                     type: 'unloaded',
//                     payload: editor
//                 });
//             };
//             getEditorNamespace(editorUrlRef.current, onNamespaceLoaded)
//                 .then(initEditor)
//                 .catch(function (error) {
//                 if (process.env.NODE_ENV !== 'test') {
//                     console.error(error);
//                 }
//                 dispatch({ type: 'error' });
//             });
//         }
//         return function () {
//             if (editor) {
//                 editor.destroy();
//             }
//         };
//     }, [editor, element]);
//     return {
//         editor: editor,
//         status: editor === null || editor === void 0 ? void 0 : editor.status,
//         error: hookStatus === 'error',
//         loading: hookStatus === 'loading'
//     };
// }
// function reducer(state, action) {
//     switch (action.type) {
//         case 'init':
//             return __assign(__assign({}, state), { hookStatus: 'init' });
//         case 'loading':
//             return __assign(__assign({}, state), { hookStatus: 'loading' });
//         case 'unloaded':
//             return {
//                 editor: action.payload,
//                 hookStatus: 'unloaded'
//             };
//         case 'loaded':
//             return __assign(__assign({}, state), { hookStatus: 'loaded' });
//         case 'ready':
//             return __assign(__assign({}, state), { hookStatus: 'ready' });
//         case 'destroyed':
//             return {
//                 editor: undefined,
//                 hookStatus: 'destroyed'
//             };
//         case 'error':
//             return {
//                 editor: undefined,
//                 hookStatus: 'error'
//             };
//         default:
//             return state;
//     }
// }

// var useEffect = React.useEffect, useRef = React.useRef, useState = React.useState;
// function CKEditor(_a) {
//     var _b = _a.config, config = _b === void 0 ? {} : _b, debug = _a.debug, editorUrl = _a.editorUrl, initData = _a.initData, name = _a.name, readOnly = _a.readOnly, style = _a.style, type = _a.type,
//     handlers = __rest(_a, ["config", "debug", "editorUrl", "initData", "name", "readOnly", "style", "type"]);
//     var _c = useState(null), element = _c[0], setElement = _c[1];
//     var refs = useRef(handlers);
//     var dispatchEvent = function (_a) {
//         var type = _a.type, payload = _a.payload;
//         var handlerName = eventNameToHandlerName(stripPrefix(type));
//         var handler = refs.current[handlerName];
//         if (handler) {
//             handler(payload);
//         }
//     };
//     if (config && typeof readOnly === 'boolean') {
//         config.readOnly = readOnly;
//     }
//     var _d = useCKEditor({
//         config: config,
//         dispatchEvent: dispatchEvent,
//         debug: debug,
//         editorUrl: editorUrl,
//         element: element,
//         initContent: typeof initData === 'string' ? initData : undefined,
//         subscribeTo: Object.keys(handlers)
//             .filter(function (key) { return key.indexOf('on') === 0; })
//             .map(handlerNameToEventName),
//         type: type
//     }), editor = _d.editor, status = _d.status;
//     useEffect(function () {
//         var canSetStyles = type !== 'inline' &&
//             editor &&
//             (status === 'loaded' || status === 'ready');
//         if (style && canSetStyles) {
//             editor.container.setStyles(style);
//         }
//         return function () {
//             if (style && canSetStyles) {
//                 Object.keys(style)
//                     .map(camelToKebab)
//                     .forEach(function (styleName) {
//                     editor.container.removeStyle(styleName);
//                 });
//             }
//         };
//     }, [editor, status, style, type]);
//     useEffect(function () {
//         if (editor && status === 'ready' && typeof readOnly === 'boolean') {
//             editor.setReadOnly(readOnly);
//         }
//     }, [editor, status, readOnly]);
//     return (React.createElement("div", { id: name !== null && name !== void 0 ? name : undefined, ref: setElement, style: getStyle(type !== null && type !== void 0 ? type : 'classic', status, style) }, typeof initData === 'string' ? null : initData));
// }
// var propTypes = __assign({
//     config: PropTypes.object,
//     debug: PropTypes.bool,
//     editorUrl: PropTypes.string,
//     initData: PropTypes.node,
//     name: PropTypes.string,
//     readOnly: PropTypes.bool,
//     style: PropTypes.object,
//     type: PropTypes.oneOf(['classic', 'inline']) }, defaultEvents.reduce(function (acc, key) {
//     var _a;
//     return __assign(__assign({}, acc), (_a = {}, _a[eventNameToHandlerName(key)] = PropTypes.func, _a));
// }, {}));
// CKEditor.propTypes = propTypes;

// /**
//  * Rich Text Editor let users enter text
//  */
// function RichTextEditor(_ref) {
//   var type = _ref.type,
//     config = _ref.config,
//     initData = _ref.initData,
//     name = _ref.name,
//     readOnly = _ref.readOnly,
//     style = _ref.style,
//     onChange = _ref.onChange,
//     onFocus = _ref.onFocus,
//     onBlur = _ref.onBlur,
//     onReady = _ref.onReady;
//   var editorRef = useRef$2(null);
//   useEffect$2(function () {
//     // Update CKEditor's initial data when initData prop changes
//     if (editorRef.current && initData !== undefined) {
//       editorRef.current.editor.setData(initData);
//     }
//   }, [initData]);
//   return /*#__PURE__*/React__default.createElement(CKEditor, {
//     type: type,
//     config: config,
//     initData: initData,
//     name: name,
//     readOnly: readOnly,
//     style: style,
//     onChange: onChange,
//     onFocus: onFocus,
//     onBlur: onBlur,
//     onInstanceReady: onReady
//   });
// }
// RichTextEditor.propTypes = {
//   /**
//    * Variant of the CKeditor editors
//    */
//   type: PropTypes__default.oneOf(['classic']),
//   /**
//    * Value of name attribute to be used for input field
//    */
//   name: PropTypes__default.string,
//   /**
//    * If `true`, the radio will be disabled. Keep this undefined to control from FormGroup
//    */
//   readOnly: PropTypes__default.bool,
//   /**
//    * Props for RichTextEditor base
//    */
//   config: PropTypes__default.shape({
//     extraPlugins: PropTypes__default.string
//   }),
//   /**
//    * Initial data for the Rich Text Editor. This is only set once upon instantiation.
//    */
//   initData: PropTypes__default.node,
//   /**
//    * Callback fired when the state is changed.
//    *
//    * @param {object} event The event source of the callback.
//    * You can pull out the new value by accessing `event.target.value` (string).
//    */
//   style: PropTypes__default.func,
//   /**
//    * OnChange event handler
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * onFocus event handler
//    */
//   onFocus: PropTypes__default.func,
//   /**
//    * onBlur event handler
//    */
//   onBlur: PropTypes__default.func,
//   /**
//    * onReady event handler
//    */

//   onReady: PropTypes__default.func
// };
// RichTextEditor.defaultProps = {
//   type: 'classic',
//   config: {
//     extraPlugins: 'indentblock, colorbutton, font, autocomplete, justify'
//   },
//   initData: undefined,
//   name: undefined,
//   readOnly: undefined,
//   style: undefined,
//   onChange: undefined,
//   onFocus: undefined,
//   onReady: undefined,
//   onBlur: undefined
// };

// /**
//  * @remix-run/router v1.14.1
//  *
//  * Copyright (c) Remix Software Inc.
//  *
//  * This source code is licensed under the MIT license found in the
//  * LICENSE.md file in the root directory of this source tree.
//  *
//  * @license MIT
//  */
// function _extends$t() {
//   _extends$t = Object.assign ? Object.assign.bind() : function (target) {
//     for (var i = 1; i < arguments.length; i++) {
//       var source = arguments[i];
//       for (var key in source) {
//         if (Object.prototype.hasOwnProperty.call(source, key)) {
//           target[key] = source[key];
//         }
//       }
//     }
//     return target;
//   };
//   return _extends$t.apply(this, arguments);
// }

// ////////////////////////////////////////////////////////////////////////////////
// //#region Types and Constants
// ////////////////////////////////////////////////////////////////////////////////
// /**
//  * Actions represent the type of change to a location value.
//  */
// var Action;
// (function (Action) {
//   /**
//    * A POP indicates a change to an arbitrary index in the history stack, such
//    * as a back or forward navigation. It does not describe the direction of the
//    * navigation, only that the current index changed.
//    *
//    * Note: This is the default action for newly created history objects.
//    */
//   Action["Pop"] = "POP";
//   /**
//    * A PUSH indicates a new entry being added to the history stack, such as when
//    * a link is clicked and a new page loads. When this happens, all subsequent
//    * entries in the stack are lost.
//    */
//   Action["Push"] = "PUSH";
//   /**
//    * A REPLACE indicates the entry at the current index in the history stack
//    * being replaced by a new one.
//    */
//   Action["Replace"] = "REPLACE";
// })(Action || (Action = {}));
// function invariant$1(value, message) {
//   if (value === false || value === null || typeof value === "undefined") {
//     throw new Error(message);
//   }
// }
// function warning(cond, message) {
//   if (!cond) {
//     // eslint-disable-next-line no-console
//     if (typeof console !== "undefined") console.warn(message);
//     try {
//       // Welcome to debugging history!
//       //
//       // This error is thrown as a convenience, so you can more easily
//       // find the source for a warning that appears in the console by
//       // enabling "pause on exceptions" in your JavaScript debugger.
//       throw new Error(message);
//       // eslint-disable-next-line no-empty
//     } catch (e) {}
//   }
// }
// /**
//  * Creates a string URL path from the given pathname, search, and hash components.
//  */
// function createPath(_ref) {
//   let {
//     pathname = "/",
//     search = "",
//     hash = ""
//   } = _ref;
//   if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
//   if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
//   return pathname;
// }
// /**
//  * Parses a string URL path into its separate pathname, search, and hash components.
//  */
// function parsePath(path) {
//   let parsedPath = {};
//   if (path) {
//     let hashIndex = path.indexOf("#");
//     if (hashIndex >= 0) {
//       parsedPath.hash = path.substr(hashIndex);
//       path = path.substr(0, hashIndex);
//     }
//     let searchIndex = path.indexOf("?");
//     if (searchIndex >= 0) {
//       parsedPath.search = path.substr(searchIndex);
//       path = path.substr(0, searchIndex);
//     }
//     if (path) {
//       parsedPath.pathname = path;
//     }
//   }
//   return parsedPath;
// }
// //#endregion

// var ResultType;
// (function (ResultType) {
//   ResultType["data"] = "data";
//   ResultType["deferred"] = "deferred";
//   ResultType["redirect"] = "redirect";
//   ResultType["error"] = "error";
// })(ResultType || (ResultType = {}));
// /**
//  * Performs pattern matching on a URL pathname and returns information about
//  * the match.
//  *
//  * @see https://reactrouter.com/utils/match-path
//  */
// function matchPath(pattern, pathname) {
//   if (typeof pattern === "string") {
//     pattern = {
//       path: pattern,
//       caseSensitive: false,
//       end: true
//     };
//   }
//   let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
//   let match = pathname.match(matcher);
//   if (!match) return null;
//   let matchedPathname = match[0];
//   let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
//   let captureGroups = match.slice(1);
//   let params = compiledParams.reduce((memo, _ref, index) => {
//     let {
//       paramName,
//       isOptional
//     } = _ref;
//     // We need to compute the pathnameBase here using the raw splat value
//     // instead of using params["*"] later because it will be decoded then
//     if (paramName === "*") {
//       let splatValue = captureGroups[index] || "";
//       pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
//     }
//     const value = captureGroups[index];
//     if (isOptional && !value) {
//       memo[paramName] = undefined;
//     } else {
//       memo[paramName] = safelyDecodeURIComponent(value || "", paramName);
//     }
//     return memo;
//   }, {});
//   return {
//     params,
//     pathname: matchedPathname,
//     pathnameBase,
//     pattern
//   };
// }
// function compilePath(path, caseSensitive, end) {
//   if (caseSensitive === void 0) {
//     caseSensitive = false;
//   }
//   if (end === void 0) {
//     end = true;
//   }
//   warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
//   let params = [];
//   let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
//   .replace(/^\/*/, "/") // Make sure it has a leading /
//   .replace(/[\\.*+^${}|()[\]]/g, "\\$&") // Escape special regex chars
//   .replace(/\/:(\w+)(\?)?/g, (_, paramName, isOptional) => {
//     params.push({
//       paramName,
//       isOptional: isOptional != null
//     });
//     return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
//   });
//   if (path.endsWith("*")) {
//     params.push({
//       paramName: "*"
//     });
//     regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
//     : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
//   } else if (end) {
//     // When matching to the end, ignore trailing slashes
//     regexpSource += "\\/*$";
//   } else if (path !== "" && path !== "/") {
//     // If our path is non-empty and contains anything beyond an initial slash,
//     // then we have _some_ form of path in our regex, so we should expect to
//     // match only if we find the end of this path segment.  Look for an optional
//     // non-captured trailing slash (to match a portion of the URL) or the end
//     // of the path (if we've matched to the end).  We used to do this with a
//     // word boundary but that gives false positives on routes like
//     // /user-preferences since `-` counts as a word boundary.
//     regexpSource += "(?:(?=\\/|$))";
//   } else ;
//   let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
//   return [matcher, params];
// }
// function safelyDecodeURIComponent(value, paramName) {
//   try {
//     return decodeURIComponent(value);
//   } catch (error) {
//     warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
//     return value;
//   }
// }
// /**
//  * @private
//  */
// function stripBasename(pathname, basename) {
//   if (basename === "/") return pathname;
//   if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
//     return null;
//   }
//   // We want to leave trailing slash behavior in the user's control, so if they
//   // specify a basename with a trailing slash, we should support it
//   let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
//   let nextChar = pathname.charAt(startIndex);
//   if (nextChar && nextChar !== "/") {
//     // pathname does not start with basename/
//     return null;
//   }
//   return pathname.slice(startIndex) || "/";
// }
// /**
//  * Returns a resolved path object relative to the given pathname.
//  *
//  * @see https://reactrouter.com/utils/resolve-path
//  */
// function resolvePath(to, fromPathname) {
//   if (fromPathname === void 0) {
//     fromPathname = "/";
//   }
//   let {
//     pathname: toPathname,
//     search = "",
//     hash = ""
//   } = typeof to === "string" ? parsePath(to) : to;
//   let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
//   return {
//     pathname,
//     search: normalizeSearch(search),
//     hash: normalizeHash(hash)
//   };
// }
// function resolvePathname(relativePath, fromPathname) {
//   let segments = fromPathname.replace(/\/+$/, "").split("/");
//   let relativeSegments = relativePath.split("/");
//   relativeSegments.forEach(segment => {
//     if (segment === "..") {
//       // Keep the root "" segment so the pathname starts at /
//       if (segments.length > 1) segments.pop();
//     } else if (segment !== ".") {
//       segments.push(segment);
//     }
//   });
//   return segments.length > 1 ? segments.join("/") : "/";
// }
// function getInvalidPathError(char, field, dest, path) {
//   return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
// }
// /**
//  * @private
//  *
//  * When processing relative navigation we want to ignore ancestor routes that
//  * do not contribute to the path, such that index/pathless layout routes don't
//  * interfere.
//  *
//  * For example, when moving a route element into an index route and/or a
//  * pathless layout route, relative link behavior contained within should stay
//  * the same.  Both of the following examples should link back to the root:
//  *
//  *   <Route path="/">
//  *     <Route path="accounts" element={<Link to=".."}>
//  *   </Route>
//  *
//  *   <Route path="/">
//  *     <Route path="accounts">
//  *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
//  *         <Route index element={<Link to=".."} />  // <-- Does not contribute
//  *       </Route
//  *     </Route>
//  *   </Route>
//  */
// function getPathContributingMatches(matches) {
//   return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
// }
// // Return the array of pathnames for the current route matches - used to
// // generate the routePathnames input for resolveTo()
// function getResolveToMatches(matches, v7_relativeSplatPath) {
//   let pathMatches = getPathContributingMatches(matches);
//   // When v7_relativeSplatPath is enabled, use the full pathname for the leaf
//   // match so we include splat values for "." links.  See:
//   // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329
//   if (v7_relativeSplatPath) {
//     return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);
//   }
//   return pathMatches.map(match => match.pathnameBase);
// }
// /**
//  * @private
//  */
// function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
//   if (isPathRelative === void 0) {
//     isPathRelative = false;
//   }
//   let to;
//   if (typeof toArg === "string") {
//     to = parsePath(toArg);
//   } else {
//     to = _extends$t({}, toArg);
//     invariant$1(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
//     invariant$1(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
//     invariant$1(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
//   }
//   let isEmptyPath = toArg === "" || to.pathname === "";
//   let toPathname = isEmptyPath ? "/" : to.pathname;
//   let from;
//   // Routing is relative to the current pathname if explicitly requested.
//   //
//   // If a pathname is explicitly provided in `to`, it should be relative to the
//   // route context. This is explained in `Note on `<Link to>` values` in our
//   // migration guide from v5 as a means of disambiguation between `to` values
//   // that begin with `/` and those that do not. However, this is problematic for
//   // `to` values that do not provide a pathname. `to` can simply be a search or
//   // hash string, in which case we should assume that the navigation is relative
//   // to the current location's pathname and *not* the route pathname.
//   if (toPathname == null) {
//     from = locationPathname;
//   } else {
//     let routePathnameIndex = routePathnames.length - 1;
//     // With relative="route" (the default), each leading .. segment means
//     // "go up one route" instead of "go up one URL segment".  This is a key
//     // difference from how <a href> works and a major reason we call this a
//     // "to" value instead of a "href".
//     if (!isPathRelative && toPathname.startsWith("..")) {
//       let toSegments = toPathname.split("/");
//       while (toSegments[0] === "..") {
//         toSegments.shift();
//         routePathnameIndex -= 1;
//       }
//       to.pathname = toSegments.join("/");
//     }
//     from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
//   }
//   let path = resolvePath(to, from);
//   // Ensure the pathname has a trailing slash if the original "to" had one
//   let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
//   // Or if this was a link to the current path which has a trailing slash
//   let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
//   if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
//     path.pathname += "/";
//   }
//   return path;
// }
// /**
//  * @private
//  */
// const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
// /**
//  * @private
//  */
// const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
// /**
//  * @private
//  */
// const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

// const validMutationMethodsArr = ["post", "put", "patch", "delete"];
// ["get", ...validMutationMethodsArr];

// /**
//  * React Router v6.21.1
//  *
//  * Copyright (c) Remix Software Inc.
//  *
//  * This source code is licensed under the MIT license found in the
//  * LICENSE.md file in the root directory of this source tree.
//  *
//  * @license MIT
//  */

// function _extends$s() {
//   _extends$s = Object.assign ? Object.assign.bind() : function (target) {
//     for (var i = 1; i < arguments.length; i++) {
//       var source = arguments[i];
//       for (var key in source) {
//         if (Object.prototype.hasOwnProperty.call(source, key)) {
//           target[key] = source[key];
//         }
//       }
//     }
//     return target;
//   };
//   return _extends$s.apply(this, arguments);
// }

// // Create react-specific types from the agnostic types in @remix-run/router to
// // export from react-router
// const DataRouterContext = /*#__PURE__*/React.createContext(null);
// if (process.env.NODE_ENV !== "production") {
//   DataRouterContext.displayName = "DataRouter";
// }
// const DataRouterStateContext = /*#__PURE__*/React.createContext(null);
// if (process.env.NODE_ENV !== "production") {
//   DataRouterStateContext.displayName = "DataRouterState";
// }
// const AwaitContext = /*#__PURE__*/React.createContext(null);
// if (process.env.NODE_ENV !== "production") {
//   AwaitContext.displayName = "Await";
// }

// /**
//  * A Navigator is a "location changer"; it's how you get to different locations.
//  *
//  * Every history instance conforms to the Navigator interface, but the
//  * distinction is useful primarily when it comes to the low-level `<Router>` API
//  * where both the location and a navigator must be provided separately in order
//  * to avoid "tearing" that may occur in a suspense-enabled app if the action
//  * and/or location were to be read directly from the history instance.
//  */

// const NavigationContext = /*#__PURE__*/React.createContext(null);
// if (process.env.NODE_ENV !== "production") {
//   NavigationContext.displayName = "Navigation";
// }
// const LocationContext = /*#__PURE__*/React.createContext(null);
// if (process.env.NODE_ENV !== "production") {
//   LocationContext.displayName = "Location";
// }
// const RouteContext = /*#__PURE__*/React.createContext({
//   outlet: null,
//   matches: [],
//   isDataRoute: false
// });
// if (process.env.NODE_ENV !== "production") {
//   RouteContext.displayName = "Route";
// }
// const RouteErrorContext = /*#__PURE__*/React.createContext(null);
// if (process.env.NODE_ENV !== "production") {
//   RouteErrorContext.displayName = "RouteError";
// }

// /**
//  * Returns the full href for the given "to" value. This is useful for building
//  * custom links that are also accessible and preserve right-click behavior.
//  *
//  * @see https://reactrouter.com/hooks/use-href
//  */
// function useHref(to, _temp) {
//   let {
//     relative
//   } = _temp === void 0 ? {} : _temp;
//   !useInRouterContext() ? process.env.NODE_ENV !== "production" ? invariant$1(false, // TODO: This error is probably because they somehow have 2 versions of the
//   // router loaded. We can help them understand how to avoid that.
//   "useHref() may be used only in the context of a <Router> component.") : invariant$1(false) : void 0;
//   let {
//     basename,
//     navigator
//   } = React.useContext(NavigationContext);
//   let {
//     hash,
//     pathname,
//     search
//   } = useResolvedPath(to, {
//     relative
//   });
//   let joinedPathname = pathname;

//   // If we're operating within a basename, prepend it to the pathname prior
//   // to creating the href.  If this is a root navigation, then just use the raw
//   // basename which allows the basename to have full control over the presence
//   // of a trailing slash on root links
//   if (basename !== "/") {
//     joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
//   }
//   return navigator.createHref({
//     pathname: joinedPathname,
//     search,
//     hash
//   });
// }

// /**
//  * Returns true if this component is a descendant of a `<Router>`.
//  *
//  * @see https://reactrouter.com/hooks/use-in-router-context
//  */
// function useInRouterContext() {
//   return React.useContext(LocationContext) != null;
// }

// /**
//  * Returns the current location object, which represents the current URL in web
//  * browsers.
//  *
//  * Note: If you're using this it may mean you're doing some of your own
//  * "routing" in your app, and we'd like to know what your use case is. We may
//  * be able to provide something higher-level to better suit your needs.
//  *
//  * @see https://reactrouter.com/hooks/use-location
//  */
// function useLocation() {
//   !useInRouterContext() ? process.env.NODE_ENV !== "production" ? invariant$1(false, // TODO: This error is probably because they somehow have 2 versions of the
//   // router loaded. We can help them understand how to avoid that.
//   "useLocation() may be used only in the context of a <Router> component.") : invariant$1(false) : void 0;
//   return React.useContext(LocationContext).location;
// }

// /**
//  * The interface for the navigate() function returned from useNavigate().
//  */

// const navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when " + "your component is first rendered.";

// // Mute warnings for calls to useNavigate in SSR environments
// function useIsomorphicLayoutEffect(cb) {
//   let isStatic = React.useContext(NavigationContext).static;
//   if (!isStatic) {
//     // We should be able to get rid of this once react 18.3 is released
//     // See: https://github.com/facebook/react/pull/26395
//     // eslint-disable-next-line react-hooks/rules-of-hooks
//     React.useLayoutEffect(cb);
//   }
// }

// /**
//  * Returns an imperative method for changing the location. Used by `<Link>`s, but
//  * may also be used by other elements to change the location.
//  *
//  * @see https://reactrouter.com/hooks/use-navigate
//  */
// function useNavigate() {
//   let {
//     isDataRoute
//   } = React.useContext(RouteContext);
//   // Conditional usage is OK here because the usage of a data router is static
//   // eslint-disable-next-line react-hooks/rules-of-hooks
//   return isDataRoute ? useNavigateStable() : useNavigateUnstable();
// }
// function useNavigateUnstable() {
//   !useInRouterContext() ? process.env.NODE_ENV !== "production" ? invariant$1(false, // TODO: This error is probably because they somehow have 2 versions of the
//   // router loaded. We can help them understand how to avoid that.
//   "useNavigate() may be used only in the context of a <Router> component.") : invariant$1(false) : void 0;
//   let dataRouterContext = React.useContext(DataRouterContext);
//   let {
//     basename,
//     future,
//     navigator
//   } = React.useContext(NavigationContext);
//   let {
//     matches
//   } = React.useContext(RouteContext);
//   let {
//     pathname: locationPathname
//   } = useLocation();
//   let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
//   let activeRef = React.useRef(false);
//   useIsomorphicLayoutEffect(() => {
//     activeRef.current = true;
//   });
//   let navigate = React.useCallback(function (to, options) {
//     if (options === void 0) {
//       options = {};
//     }
//     process.env.NODE_ENV !== "production" ? warning(activeRef.current, navigateEffectWarning) : void 0;

//     // Short circuit here since if this happens on first render the navigate
//     // is useless because we haven't wired up our history listener yet
//     if (!activeRef.current) return;
//     if (typeof to === "number") {
//       navigator.go(to);
//       return;
//     }
//     let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");

//     // If we're operating within a basename, prepend it to the pathname prior
//     // to handing off to history (but only if we're not in a data router,
//     // otherwise it'll prepend the basename inside of the router).
//     // If this is a root navigation, then we navigate to the raw basename
//     // which allows the basename to have full control over the presence of a
//     // trailing slash on root links
//     if (dataRouterContext == null && basename !== "/") {
//       path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
//     }
//     (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
//   }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
//   return navigate;
// }

// /**
//  * Resolves the pathname of the given `to` value against the current location.
//  *
//  * @see https://reactrouter.com/hooks/use-resolved-path
//  */
// function useResolvedPath(to, _temp2) {
//   let {
//     relative
//   } = _temp2 === void 0 ? {} : _temp2;
//   let {
//     future
//   } = React.useContext(NavigationContext);
//   let {
//     matches
//   } = React.useContext(RouteContext);
//   let {
//     pathname: locationPathname
//   } = useLocation();
//   let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
//   return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
// }
// var DataRouterHook$1 = /*#__PURE__*/function (DataRouterHook) {
//   DataRouterHook["UseBlocker"] = "useBlocker";
//   DataRouterHook["UseRevalidator"] = "useRevalidator";
//   DataRouterHook["UseNavigateStable"] = "useNavigate";
//   return DataRouterHook;
// }(DataRouterHook$1 || {});
// var DataRouterStateHook$1 = /*#__PURE__*/function (DataRouterStateHook) {
//   DataRouterStateHook["UseBlocker"] = "useBlocker";
//   DataRouterStateHook["UseLoaderData"] = "useLoaderData";
//   DataRouterStateHook["UseActionData"] = "useActionData";
//   DataRouterStateHook["UseRouteError"] = "useRouteError";
//   DataRouterStateHook["UseNavigation"] = "useNavigation";
//   DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
//   DataRouterStateHook["UseMatches"] = "useMatches";
//   DataRouterStateHook["UseRevalidator"] = "useRevalidator";
//   DataRouterStateHook["UseNavigateStable"] = "useNavigate";
//   DataRouterStateHook["UseRouteId"] = "useRouteId";
//   return DataRouterStateHook;
// }(DataRouterStateHook$1 || {});
// function getDataRouterConsoleError$1(hookName) {
//   return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
// }
// function useDataRouterContext$1(hookName) {
//   let ctx = React.useContext(DataRouterContext);
//   !ctx ? process.env.NODE_ENV !== "production" ? invariant$1(false, getDataRouterConsoleError$1(hookName)) : invariant$1(false) : void 0;
//   return ctx;
// }
// function useRouteContext(hookName) {
//   let route = React.useContext(RouteContext);
//   !route ? process.env.NODE_ENV !== "production" ? invariant$1(false, getDataRouterConsoleError$1(hookName)) : invariant$1(false) : void 0;
//   return route;
// }

// // Internal version with hookName-aware debugging
// function useCurrentRouteId(hookName) {
//   let route = useRouteContext(hookName);
//   let thisRoute = route.matches[route.matches.length - 1];
//   !thisRoute.route.id ? process.env.NODE_ENV !== "production" ? invariant$1(false, hookName + " can only be used on routes that contain a unique \"id\"") : invariant$1(false) : void 0;
//   return thisRoute.route.id;
// }

// /**
//  * Returns the ID for the nearest contextual route
//  */
// function useRouteId() {
//   return useCurrentRouteId(DataRouterStateHook$1.UseRouteId);
// }

// /**
//  * Stable version of useNavigate that is used when we are in the context of
//  * a RouterProvider.
//  */
// function useNavigateStable() {
//   let {
//     router
//   } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable);
//   let id = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
//   let activeRef = React.useRef(false);
//   useIsomorphicLayoutEffect(() => {
//     activeRef.current = true;
//   });
//   let navigate = React.useCallback(function (to, options) {
//     if (options === void 0) {
//       options = {};
//     }
//     process.env.NODE_ENV !== "production" ? warning(activeRef.current, navigateEffectWarning) : void 0;

//     // Short circuit here since if this happens on first render the navigate
//     // is useless because we haven't wired up our router subscriber yet
//     if (!activeRef.current) return;
//     if (typeof to === "number") {
//       router.navigate(to);
//     } else {
//       router.navigate(to, _extends$s({
//         fromRouteId: id
//       }, options));
//     }
//   }, [router, id]);
//   return navigate;
// }
// new Promise(() => {});

// /**
//  * React Router DOM v6.21.1
//  *
//  * Copyright (c) Remix Software Inc.
//  *
//  * This source code is licensed under the MIT license found in the
//  * LICENSE.md file in the root directory of this source tree.
//  *
//  * @license MIT
//  */

// function _extends$r() {
//   _extends$r = Object.assign ? Object.assign.bind() : function (target) {
//     for (var i = 1; i < arguments.length; i++) {
//       var source = arguments[i];
//       for (var key in source) {
//         if (Object.prototype.hasOwnProperty.call(source, key)) {
//           target[key] = source[key];
//         }
//       }
//     }
//     return target;
//   };
//   return _extends$r.apply(this, arguments);
// }
// function _objectWithoutPropertiesLoose$j(source, excluded) {
//   if (source == null) return {};
//   var target = {};
//   var sourceKeys = Object.keys(source);
//   var key, i;
//   for (i = 0; i < sourceKeys.length; i++) {
//     key = sourceKeys[i];
//     if (excluded.indexOf(key) >= 0) continue;
//     target[key] = source[key];
//   }
//   return target;
// }

// const defaultMethod = "get";
// const defaultEncType = "application/x-www-form-urlencoded";
// function isHtmlElement(object) {
//   return object != null && typeof object.tagName === "string";
// }
// function isButtonElement(object) {
//   return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
// }
// function isFormElement(object) {
//   return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
// }
// function isInputElement(object) {
//   return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
// }
// function isModifiedEvent(event) {
//   return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
// }
// function shouldProcessLinkClick(event, target) {
//   return event.button === 0 && (
//   // Ignore everything but left clicks
//   !target || target === "_self") &&
//   // Let browser handle "target=_blank" etc.
//   !isModifiedEvent(event) // Ignore clicks with modifier keys
//   ;
// }
// // One-time check for submitter support
// let _formDataSupportsSubmitter = null;
// function isFormDataSubmitterSupported() {
//   if (_formDataSupportsSubmitter === null) {
//     try {
//       new FormData(document.createElement("form"),
//       // @ts-expect-error if FormData supports the submitter parameter, this will throw
//       0);
//       _formDataSupportsSubmitter = false;
//     } catch (e) {
//       _formDataSupportsSubmitter = true;
//     }
//   }
//   return _formDataSupportsSubmitter;
// }
// const supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
// function getFormEncType(encType) {
//   if (encType != null && !supportedFormEncTypes.has(encType)) {
//     process.env.NODE_ENV !== "production" ? warning(false, "\"" + encType + "\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` " + ("and will default to \"" + defaultEncType + "\"")) : void 0;
//     return null;
//   }
//   return encType;
// }
// function getFormSubmissionInfo(target, basename) {
//   let method;
//   let action;
//   let encType;
//   let formData;
//   let body;
//   if (isFormElement(target)) {
//     // When grabbing the action from the element, it will have had the basename
//     // prefixed to ensure non-JS scenarios work, so strip it since we'll
//     // re-prefix in the router
//     let attr = target.getAttribute("action");
//     action = attr ? stripBasename(attr, basename) : null;
//     method = target.getAttribute("method") || defaultMethod;
//     encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
//     formData = new FormData(target);
//   } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
//     let form = target.form;
//     if (form == null) {
//       throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
//     }
//     // <button>/<input type="submit"> may override attributes of <form>
//     // When grabbing the action from the element, it will have had the basename
//     // prefixed to ensure non-JS scenarios work, so strip it since we'll
//     // re-prefix in the router
//     let attr = target.getAttribute("formaction") || form.getAttribute("action");
//     action = attr ? stripBasename(attr, basename) : null;
//     method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
//     encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
//     // Build a FormData object populated from a form and submitter
//     formData = new FormData(form, target);
//     // If this browser doesn't support the `FormData(el, submitter)` format,
//     // then tack on the submitter value at the end.  This is a lightweight
//     // solution that is not 100% spec compliant.  For complete support in older
//     // browsers, consider using the `formdata-submitter-polyfill` package
//     if (!isFormDataSubmitterSupported()) {
//       let {
//         name,
//         type,
//         value
//       } = target;
//       if (type === "image") {
//         let prefix = name ? name + "." : "";
//         formData.append(prefix + "x", "0");
//         formData.append(prefix + "y", "0");
//       } else if (name) {
//         formData.append(name, value);
//       }
//     }
//   } else if (isHtmlElement(target)) {
//     throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
//   } else {
//     method = defaultMethod;
//     action = null;
//     encType = defaultEncType;
//     body = target;
//   }
//   // Send body for <Form encType="text/plain" so we encode it into text
//   if (formData && encType === "text/plain") {
//     body = formData;
//     formData = undefined;
//   }
//   return {
//     action,
//     method: method.toLowerCase(),
//     encType,
//     formData,
//     body
//   };
// }

// const _excluded$v = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"],
//   _excluded2$6 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"],
//   _excluded3$1 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"];
// const ViewTransitionContext = /*#__PURE__*/React.createContext({
//   isTransitioning: false
// });
// if (process.env.NODE_ENV !== "production") {
//   ViewTransitionContext.displayName = "ViewTransition";
// }
// const FetchersContext = /*#__PURE__*/React.createContext(new Map());
// if (process.env.NODE_ENV !== "production") {
//   FetchersContext.displayName = "Fetchers";
// }
// if (process.env.NODE_ENV !== "production") ;
// const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
// const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
// /**
//  * The public API for rendering a history-aware `<a>`.
//  */
// const Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref7, ref) {
//   let {
//       onClick,
//       relative,
//       reloadDocument,
//       replace,
//       state,
//       target,
//       to,
//       preventScrollReset,
//       unstable_viewTransition
//     } = _ref7,
//     rest = _objectWithoutPropertiesLoose$j(_ref7, _excluded$v);
//   let {
//     basename
//   } = React.useContext(NavigationContext);
//   // Rendered into <a href> for absolute URLs
//   let absoluteHref;
//   let isExternal = false;
//   if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
//     // Render the absolute href server- and client-side
//     absoluteHref = to;
//     // Only check for external origins client-side
//     if (isBrowser$1) {
//       try {
//         let currentUrl = new URL(window.location.href);
//         let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
//         let path = stripBasename(targetUrl.pathname, basename);
//         if (targetUrl.origin === currentUrl.origin && path != null) {
//           // Strip the protocol/origin/basename for same-origin absolute URLs
//           to = path + targetUrl.search + targetUrl.hash;
//         } else {
//           isExternal = true;
//         }
//       } catch (e) {
//         // We can't do external URL detection without a valid URL
//         process.env.NODE_ENV !== "production" ? warning(false, "<Link to=\"" + to + "\"> contains an invalid URL which will probably break " + "when clicked - please update to a valid URL path.") : void 0;
//       }
//     }
//   }
//   // Rendered into <a href> for relative URLs
//   let href = useHref(to, {
//     relative
//   });
//   let internalOnClick = useLinkClickHandler(to, {
//     replace,
//     state,
//     target,
//     preventScrollReset,
//     relative,
//     unstable_viewTransition
//   });
//   function handleClick(event) {
//     if (onClick) onClick(event);
//     if (!event.defaultPrevented) {
//       internalOnClick(event);
//     }
//   }
//   return (
//     /*#__PURE__*/
//     // eslint-disable-next-line jsx-a11y/anchor-has-content
//     React.createElement("a", _extends$r({}, rest, {
//       href: absoluteHref || href,
//       onClick: isExternal || reloadDocument ? onClick : handleClick,
//       ref: ref,
//       target: target
//     }))
//   );
// });
// if (process.env.NODE_ENV !== "production") {
//   Link.displayName = "Link";
// }
// /**
//  * A `<Link>` wrapper that knows if it's "active" or not.
//  */
// const NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref8, ref) {
//   let {
//       "aria-current": ariaCurrentProp = "page",
//       caseSensitive = false,
//       className: classNameProp = "",
//       end = false,
//       style: styleProp,
//       to,
//       unstable_viewTransition,
//       children
//     } = _ref8,
//     rest = _objectWithoutPropertiesLoose$j(_ref8, _excluded2$6);
//   let path = useResolvedPath(to, {
//     relative: rest.relative
//   });
//   let location = useLocation();
//   let routerState = React.useContext(DataRouterStateContext);
//   let {
//     navigator
//   } = React.useContext(NavigationContext);
//   let isTransitioning = routerState != null &&
//   // Conditional usage is OK here because the usage of a data router is static
//   // eslint-disable-next-line react-hooks/rules-of-hooks
//   useViewTransitionState(path) && unstable_viewTransition === true;
//   let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
//   let locationPathname = location.pathname;
//   let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
//   if (!caseSensitive) {
//     locationPathname = locationPathname.toLowerCase();
//     nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
//     toPathname = toPathname.toLowerCase();
//   }
//   // If the `to` has a trailing slash, look at that exact spot.  Otherwise,
//   // we're looking for a slash _after_ what's in `to`.  For example:
//   //
//   // <NavLink to="/users"> and <NavLink to="/users/">
//   // both want to look for a / at index 6 to match URL `/users/matt`
//   const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
//   let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
//   let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
//   let renderProps = {
//     isActive,
//     isPending,
//     isTransitioning
//   };
//   let ariaCurrent = isActive ? ariaCurrentProp : undefined;
//   let className;
//   if (typeof classNameProp === "function") {
//     className = classNameProp(renderProps);
//   } else {
//     // If the className prop is not a function, we use a default `active`
//     // class for <NavLink />s that are active. In v5 `active` was the default
//     // value for `activeClassName`, but we are removing that API and can still
//     // use the old default behavior for a cleaner upgrade path and keep the
//     // simple styling rules working as they currently do.
//     className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
//   }
//   let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
//   return /*#__PURE__*/React.createElement(Link, _extends$r({}, rest, {
//     "aria-current": ariaCurrent,
//     className: className,
//     ref: ref,
//     style: style,
//     to: to,
//     unstable_viewTransition: unstable_viewTransition
//   }), typeof children === "function" ? children(renderProps) : children);
// });
// if (process.env.NODE_ENV !== "production") {
//   NavLink.displayName = "NavLink";
// }
// /**
//  * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
//  * that the interaction with the server is with `fetch` instead of new document
//  * requests, allowing components to add nicer UX to the page as the form is
//  * submitted and returns with data.
//  */
// const Form = /*#__PURE__*/React.forwardRef((_ref9, forwardedRef) => {
//   let {
//       fetcherKey,
//       navigate,
//       reloadDocument,
//       replace,
//       state,
//       method = defaultMethod,
//       action,
//       onSubmit,
//       relative,
//       preventScrollReset,
//       unstable_viewTransition
//     } = _ref9,
//     props = _objectWithoutPropertiesLoose$j(_ref9, _excluded3$1);
//   let submit = useSubmit();
//   let formAction = useFormAction(action, {
//     relative
//   });
//   let formMethod = method.toLowerCase() === "get" ? "get" : "post";
//   let submitHandler = event => {
//     onSubmit && onSubmit(event);
//     if (event.defaultPrevented) return;
//     event.preventDefault();
//     let submitter = event.nativeEvent.submitter;
//     let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
//     submit(submitter || event.currentTarget, {
//       fetcherKey,
//       method: submitMethod,
//       navigate,
//       replace,
//       state,
//       relative,
//       preventScrollReset,
//       unstable_viewTransition
//     });
//   };
//   return /*#__PURE__*/React.createElement("form", _extends$r({
//     ref: forwardedRef,
//     method: formMethod,
//     action: formAction,
//     onSubmit: reloadDocument ? onSubmit : submitHandler
//   }, props));
// });
// if (process.env.NODE_ENV !== "production") {
//   Form.displayName = "Form";
// }
// if (process.env.NODE_ENV !== "production") ;
// //#endregion
// ////////////////////////////////////////////////////////////////////////////////
// //#region Hooks
// ////////////////////////////////////////////////////////////////////////////////
// var DataRouterHook;
// (function (DataRouterHook) {
//   DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
//   DataRouterHook["UseSubmit"] = "useSubmit";
//   DataRouterHook["UseSubmitFetcher"] = "useSubmitFetcher";
//   DataRouterHook["UseFetcher"] = "useFetcher";
//   DataRouterHook["useViewTransitionState"] = "useViewTransitionState";
// })(DataRouterHook || (DataRouterHook = {}));
// var DataRouterStateHook;
// (function (DataRouterStateHook) {
//   DataRouterStateHook["UseFetcher"] = "useFetcher";
//   DataRouterStateHook["UseFetchers"] = "useFetchers";
//   DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
// })(DataRouterStateHook || (DataRouterStateHook = {}));
// // Internal hooks
// function getDataRouterConsoleError(hookName) {
//   return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
// }
// function useDataRouterContext(hookName) {
//   let ctx = React.useContext(DataRouterContext);
//   !ctx ? process.env.NODE_ENV !== "production" ? invariant$1(false, getDataRouterConsoleError(hookName)) : invariant$1(false) : void 0;
//   return ctx;
// }
// // External hooks
// /**
//  * Handles the click behavior for router `<Link>` components. This is useful if
//  * you need to create custom `<Link>` components with the same click behavior we
//  * use in our exported `<Link>`.
//  */
// function useLinkClickHandler(to, _temp) {
//   let {
//     target,
//     replace: replaceProp,
//     state,
//     preventScrollReset,
//     relative,
//     unstable_viewTransition
//   } = _temp === void 0 ? {} : _temp;
//   let navigate = useNavigate();
//   let location = useLocation();
//   let path = useResolvedPath(to, {
//     relative
//   });
//   return React.useCallback(event => {
//     if (shouldProcessLinkClick(event, target)) {
//       event.preventDefault();
//       // If the URL hasn't changed, a regular <a> will do a replace instead of
//       // a push, so do the same here unless the replace prop is explicitly set
//       let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);
//       navigate(to, {
//         replace,
//         state,
//         preventScrollReset,
//         relative,
//         unstable_viewTransition
//       });
//     }
//   }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
// }
// function validateClientSideSubmission() {
//   if (typeof document === "undefined") {
//     throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
//   }
// }
// let fetcherId = 0;
// let getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";
// /**
//  * Returns a function that may be used to programmatically submit a form (or
//  * some arbitrary data) to the server.
//  */
// function useSubmit() {
//   let {
//     router
//   } = useDataRouterContext(DataRouterHook.UseSubmit);
//   let {
//     basename
//   } = React.useContext(NavigationContext);
//   let currentRouteId = useRouteId();
//   return React.useCallback(function (target, options) {
//     if (options === void 0) {
//       options = {};
//     }
//     validateClientSideSubmission();
//     let {
//       action,
//       method,
//       encType,
//       formData,
//       body
//     } = getFormSubmissionInfo(target, basename);
//     if (options.navigate === false) {
//       let key = options.fetcherKey || getUniqueFetcherId();
//       router.fetch(key, currentRouteId, options.action || action, {
//         preventScrollReset: options.preventScrollReset,
//         formData,
//         body,
//         formMethod: options.method || method,
//         formEncType: options.encType || encType,
//         unstable_flushSync: options.unstable_flushSync
//       });
//     } else {
//       router.navigate(options.action || action, {
//         preventScrollReset: options.preventScrollReset,
//         formData,
//         body,
//         formMethod: options.method || method,
//         formEncType: options.encType || encType,
//         replace: options.replace,
//         state: options.state,
//         fromRouteId: currentRouteId,
//         unstable_flushSync: options.unstable_flushSync,
//         unstable_viewTransition: options.unstable_viewTransition
//       });
//     }
//   }, [router, basename, currentRouteId]);
// }
// // v7: Eventually we should deprecate this entirely in favor of using the
// // router method directly?
// function useFormAction(action, _temp2) {
//   let {
//     relative
//   } = _temp2 === void 0 ? {} : _temp2;
//   let {
//     basename
//   } = React.useContext(NavigationContext);
//   let routeContext = React.useContext(RouteContext);
//   !routeContext ? process.env.NODE_ENV !== "production" ? invariant$1(false, "useFormAction must be used inside a RouteContext") : invariant$1(false) : void 0;
//   let [match] = routeContext.matches.slice(-1);
//   // Shallow clone path so we can modify it below, otherwise we modify the
//   // object referenced by useMemo inside useResolvedPath
//   let path = _extends$r({}, useResolvedPath(action ? action : ".", {
//     relative
//   }));
//   // If no action was specified, browsers will persist current search params
//   // when determining the path, so match that behavior
//   // https://github.com/remix-run/remix/issues/927
//   let location = useLocation();
//   if (action == null) {
//     // Safe to write to this directly here since if action was undefined, we
//     // would have called useResolvedPath(".") which will never include a search
//     path.search = location.search;
//     // When grabbing search params from the URL, remove any included ?index param
//     // since it might not apply to our contextual route.  We add it back based
//     // on match.route.index below
//     let params = new URLSearchParams(path.search);
//     if (params.has("index") && params.get("index") === "") {
//       params.delete("index");
//       path.search = params.toString() ? "?" + params.toString() : "";
//     }
//   }
//   if ((!action || action === ".") && match.route.index) {
//     path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
//   }
//   // If we're operating within a basename, prepend it to the pathname prior
//   // to creating the form action.  If this is a root navigation, then just use
//   // the raw basename which allows the basename to have full control over the
//   // presence of a trailing slash on root actions
//   if (basename !== "/") {
//     path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
//   }
//   return createPath(path);
// }
// /**
//  * Return a boolean indicating if there is an active view transition to the
//  * given href.  You can use this value to render CSS classes or viewTransitionName
//  * styles onto your elements
//  *
//  * @param href The destination href
//  * @param [opts.relative] Relative routing type ("route" | "path")
//  */
// function useViewTransitionState(to, opts) {
//   if (opts === void 0) {
//     opts = {};
//   }
//   let vtContext = React.useContext(ViewTransitionContext);
//   !(vtContext != null) ? process.env.NODE_ENV !== "production" ? invariant$1(false, "`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  " + "Did you accidentally import `RouterProvider` from `react-router`?") : invariant$1(false) : void 0;
//   let {
//     basename
//   } = useDataRouterContext(DataRouterHook.useViewTransitionState);
//   let path = useResolvedPath(to, {
//     relative: opts.relative
//   });
//   if (!vtContext.isTransitioning) {
//     return false;
//   }
//   let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
//   let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
//   // Transition is active if we're going to or coming from the indicated
//   // destination.  This ensures that other PUSH navigations that reverse
//   // an indicated transition apply.  I.e., on the list view you have:
//   //
//   //   <NavLink to="/details/1" unstable_viewTransition>
//   //
//   // If you click the breadcrumb back to the list view:
//   //
//   //   <NavLink to="/list" unstable_viewTransition>
//   //
//   // We should apply the transition because it's indicated as active going
//   // from /list -> /details/1 and therefore should be active on the reverse
//   // (even though this isn't strictly a POP reverse)
//   return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
// }

// /**
//  * Component for Route Link Component.
//  * Provides declarative, accessible navigation around your application.
//  */
// var RouteLink = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
//   var idProp = props.id,
//     to = props.to,
//     className = props.className,
//     children = props.children,
//     role = props.role,
//     onClick = props.onClick,
//     txtarialabel = props.txtarialabel,
//     txtariadescribedby = props.txtariadescribedby;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(Link, _extends$v({
//     id: id,
//     to: to,
//     className: className,
//     ref: ref,
//     role: role,
//     onClick: onClick,
//     "aria-label": txtarialabel,
//     "aria-describedby": txtariadescribedby
//   }, props), children);
// });

// // PropType check
// RouteLink.propTypes = {
//   /**
//    * Id of the button
//    */
//   id: PropTypes__default.string,
//   /**
//    * Link location
//    */
//   to: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.object, PropTypes__default.func]),
//   /**
//    * Content of Link
//    */
//   children: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * role attribute to be set to the link
//    */
//   role: PropTypes__default.string,
//   /**
//    * On Click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   txtarialabel: PropTypes__default.string,
//   /**
//    * value of aria-describedby
//    */
//   txtariadescribedby: PropTypes__default.string
// };
// RouteLink.defaultProps = {
//   id: undefined,
//   to: '',
//   children: '',
//   className: undefined,
//   role: undefined,
//   onClick: function onClick() {},
//   txtarialabel: null,
//   txtariadescribedby: undefined
// };

// /**
//  * Returns positions of an element
//  * @param {{top: Number, bottom: Number, scrollTop: Number}} el
//  */
// var getPositions = function getPositions(el) {
//   var position = {
//     top: el.offsetTop,
//     bottom: el.offsetTop + el.clientHeight,
//     scrollTop: el.scrollTop
//   };
//   return position;
// };

// /**
//  *
//  * @param {DOMRect} childRect
//  * @param {DOMRect} parentRect
//  * @returns {Number} percentage of visibility
//  */
// var calculateVisibilityRatio = function calculateVisibilityRatio(_ref, _ref2) {
//   var childTop = _ref.top,
//     childBottom = _ref.bottom;
//   var parentTop = _ref2.top,
//     parentBottom = _ref2.bottom;
//   if (childTop >= parentTop && childBottom <= parentBottom) {
//     return 100;
//   }
//   if (childTop <= parentTop && childBottom >= parentBottom) {
//     var height = childBottom - childTop;
//     var visibileHeight = parentBottom - parentTop;
//     return visibileHeight * 100 / height;
//   }
//   if (childBottom >= parentTop && childBottom <= parentBottom) {
//     var _height = childBottom - childTop;
//     var _visibileHeight = childBottom - parentTop;
//     return _visibileHeight * 100 / _height;
//   }
//   if (childTop >= parentTop && childTop <= parentBottom) {
//     var _height2 = childBottom - childTop;
//     var _visibileHeight2 = parentBottom - childTop;
//     return _visibileHeight2 * 100 / _height2;
//   }
//   return 0;
// };

// /**
//  * Given an element, it determines if the element is visible
//  * @param {Node} el
//  * @returns {Number} percentage of visibility
//  */
// var isScrolledIntoView = function isScrolledIntoView(el) {
//   var elPosition = getPositions(el);
//   var parentPosition = getPositions(el.parentElement);
//   elPosition.top -= parentPosition.scrollTop;
//   elPosition.bottom -= parentPosition.scrollTop;
//   return calculateVisibilityRatio(elPosition, parentPosition);
// };

// /**
//  * Given a parentNode and attributeName to look into the child,
//  * it gives a key value pair object of url and element node.
//  * @param {Node} parentEl
//  * @param {String} attributeName
//  * @returns {Object.<string, Node>} KeyValue pair of path and element node.
//  */
// var parseChildNodes = function parseChildNodes(parentEl, attributeName) {
//   var childNodes = {};
//   for (var index = 0; index < parentEl.children.length; index += 1) {
//     var el = parentEl.children[index];
//     var attribute = el.attributes.getNamedItem(attributeName);
//     if (attribute && attribute.value) {
//       childNodes[attribute.value] = el;
//     }
//   }
//   return childNodes;
// };

// /**
//  * Scrolls into the view if it is not already.
//  * Return false if already scrolled/not found
//  * @param {String} currentRoute
//  * @param {Object} childNodes
//  * @returns {Boolean} is scrolled into view succesfully
//  */
// var scrollToTheView = function scrollToTheView(currentRoute, childNodes) {
//   var el = childNodes[currentRoute];
//   // Couldn't find it. ignore
//   if (!el) {
//     return false;
//   }

//   // scroll into the view smoothly
//   el.scrollIntoView({
//     behavior: 'smooth'
//   });
//   return true;
// };

// /**
//  * Evaluate the list of sections which are in view
//  * and gives an array of routes
//  * @param {Object} childNodes
//  * @param {Node} focusedElement If passed, this will take precedence for bestActive
//  * @returns {{activeSections: String[], bestActive: String}} return list of active section urls and bestActive
//  */
// var evaluateActiveSections = function evaluateActiveSections(childNodes, focusedElement) {
//   var bestActive = '';
//   var newActiveSections = [];
//   // loop through children and check if they are visible
//   Object.keys(childNodes).forEach(function (childPath) {
//     var el = childNodes[childPath];
//     var visibilityPercentage = isScrolledIntoView(el);
//     if (visibilityPercentage > 1) {
//       newActiveSections.push(childPath);
//     }

//     // If a focused element is passed. take is as priority
//     if (focusedElement === el) {
//       bestActive = childPath;
//     } else if (!bestActive && visibilityPercentage >= 50) {
//       bestActive = childPath;
//     }
//   });
//   return {
//     activeSections: newActiveSections,
//     bestActive: bestActive || newActiveSections[0]
//   };
// };

// /**
//  *
//  * Component to provide scrollable routing to a container
//  */
// var RouterScrollContainer = function RouterScrollContainer(_ref) {
//   var currentRoute = _ref.currentRoute,
//     children = _ref.children,
//     className = _ref.className,
//     attributeName = _ref.attributeName,
//     onActiveChange = _ref.onActiveChange;
//   var _useState = useState$1([]),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     activeSections = _useState2[0],
//     setActiveSections = _useState2[1];
//   var containerRef = useRef$2(null);
//   var navigate = useNavigate();
//   var _useState3 = useState$1({}),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     childNodes = _useState4[0],
//     setChildNodes = _useState4[1];
//   var _useState5 = useState$1(null),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     setScrollTimer = _useState6[1];
//   var _useState7 = useState$1(''),
//     _useState8 = _slicedToArray$b(_useState7, 2),
//     setActivatedRoute = _useState8[1];
//   var _useState9 = useState$1(undefined),
//     _useState10 = _slicedToArray$b(_useState9, 2),
//     focusedElement = _useState10[0],
//     setFocusedElement = _useState10[1];
//   var _useState11 = useState$1(null),
//     _useState12 = _slicedToArray$b(_useState11, 2),
//     setFocusTimer = _useState12[1];

//   /**
//    * Lets evaluate its children. And put a listener on containerRef and attributeName changes
//    */
//   useEffect$2(function () {
//     setChildNodes(parseChildNodes(containerRef.current, attributeName));
//   }, [containerRef, attributeName]);

//   /**
//    * Actively checks for new sections which need to be active.
//    * and the first element will be change to route
//    */
//   var checkForActiveSections = useCallback(function (newFocusedElement) {
//     var newActiveSections = evaluateActiveSections(childNodes, newFocusedElement);

//     // No active sections. Seems something went wrong. Lets ingore
//     if (!newActiveSections.activeSections.length) {
//       return null;
//     }
//     // Change the state to new active sections
//     setActiveSections(newActiveSections.activeSections);

//     // Lets trigger the event
//     onActiveChange(newActiveSections.activeSections);
//     return newActiveSections;
//   }, [childNodes, onActiveChange]);

//   /**
//    * Whenever currentRoute changed, lets change scroll position the relevant section
//    */
//   useEffect$2(function () {
//     var timer = setTimeout(function () {
//       setActivatedRoute(function (oldRoute) {
//         if (oldRoute === currentRoute) {
//           return oldRoute;
//         }
//         if (!scrollToTheView(currentRoute, childNodes)) {
//           // Something failed. lets ignore.
//           return oldRoute;
//         }

//         // lets look for active sections.
//         // May this is first time and we could have more than once active section.
//         // Lets evaluate
//         setScrollTimer(function (oldTimer) {
//           clearTimeout(oldTimer);
//           return setTimeout(function () {
//             checkForActiveSections();
//           }, 100);
//         });
//         setActiveSections([currentRoute]);
//         return currentRoute;
//       });
//     }, 100);
//     return function () {
//       return clearTimeout(timer);
//     };
//   }, [currentRoute, childNodes, checkForActiveSections]);
//   var doHandleScroll = useCallback(function (newFocusedElement) {
//     // If no active sections yet. Lets wait for it evaluate.
//     // This can be buggy if currentRoute is not set properly
//     if (!activeSections || !activeSections.length) {
//       return;
//     }
//     var newActiveSections = checkForActiveSections(newFocusedElement);
//     if (!newActiveSections) {
//       return;
//     }
//     // If the first section from previous state and new state change. Lets change the route.
//     if (currentRoute !== newActiveSections.bestActive) {
//       setActivatedRoute(newActiveSections.bestActive);
//       navigate(newActiveSections.bestActive);
//     }
//   }, [activeSections, currentRoute, navigate, checkForActiveSections]);

//   // On container scroll
//   var handleScroll = useCallback(function () {
//     // On scroll event lets trigger a timer
//     setScrollTimer(function (oldTimer) {
//       // clear previous timer before starting this
//       clearTimeout(oldTimer);

//       // Start the timer
//       return setTimeout(function () {
//         doHandleScroll(focusedElement);
//       }, 100);
//     });
//   }, [doHandleScroll, focusedElement]);
//   var changeFocus = useCallback(function (newFocusedElement) {
//     setFocusedElement(newFocusedElement);
//     doHandleScroll(newFocusedElement);
//   }, [doHandleScroll]);
//   var handleFocus = useCallback(function (e) {
//     var currentTarget = e.currentTarget,
//       target = e.target;
//     setFocusTimer(function (oldTimer) {
//       clearTimeout(oldTimer);
//       return setTimeout(function () {
//         var rootContainer = currentTarget;
//         var newFocusedElement = target;
//         var rootChildren = Object.values(childNodes);
//         while (rootContainer !== newFocusedElement) {
//           if (rootChildren.includes(newFocusedElement)) {
//             break;
//           }
//           newFocusedElement = newFocusedElement.parentNode;
//           if (!newFocusedElement) {
//             break;
//           }
//         }
//         if (newFocusedElement) {
//           changeFocus(newFocusedElement, currentRoute, activeSections);
//         }
//       }, 100);
//     });
//   }, [currentRoute, childNodes, activeSections, changeFocus] // currentRoute and activeSections giving wrong values at other places (call stack) if they are not part of this dependency
//   );
//   var handleBlur = useCallback(function (e) {
//     setFocusTimer(function (oldTimer) {
//       clearTimeout(oldTimer);
//       return setTimeout(function () {
//         changeFocus(null);
//       }, 100);
//     });
//   }, [changeFocus]);
//   return /*#__PURE__*/React__default.createElement("div", {
//     "data-testid": "scrollContainer",
//     className: className,
//     ref: containerRef,
//     onScroll: handleScroll,
//     onFocus: handleFocus,
//     onBlur: handleBlur
//   }, children);
// };
// RouterScrollContainer.propTypes = {
//   /**
//    * set the current route
//    */
//   currentRoute: PropTypes__default.string.isRequired,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Classname to be assigned to the container
//    */
//   className: PropTypes__default.string,
//   /**
//    * Attribute name of the element to look for route in the child
//    */
//   attributeName: PropTypes__default.string,
//   /**
//    * Gives array of active section ids
//    */
//   onActiveChange: PropTypes__default.func
// };
// RouterScrollContainer.defaultProps = {
//   attributeName: 'data-section-url',
//   className: undefined,
//   onActiveChange: function onActiveChange() {
//     return null;
//   }
// };

// /**
//  * SectionTitle component is used to display section heading.
//  */

// function SectionTitle(_ref) {
//   var title = _ref.title;
//   return /*#__PURE__*/React__default.createElement("h2", null, title);
// }

// // PropType check
// SectionTitle.propTypes = {
//   /**
//    * title text
//    */
//   title: PropTypes__default.string
// };
// SectionTitle.defaultProps = {
//   /**
//    * default title
//    */
//   title: ''
// };

// /**
//  * SumTotal wrapper for Material-UI Chip component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  */
// function SumtChipWrapper(_ref) {
//   var id = _ref.id,
//     color = _ref.color,
//     label = _ref.label,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(Chip, {
//     id: id,
//     color: color,
//     className: className,
//     label: label,
//     size: "small",
//     variant: "outlined"
//   });
// }
// SumtChipWrapper.propTypes = {
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The color of the component.
//    */
//   color: PropTypes__default.oneOf(['default', 'primary', 'secondary']),
//   /**
//    * Id of the component.
//    */
//   id: PropTypes__default.string,
//   /**
//    * The content of the label.
//    */
//   label: PropTypes__default.node
// };
// SumtChipWrapper.defaultProps = {
//   className: undefined,
//   color: 'default',
//   id: undefined,
//   label: undefined
// };

// var _templateObject$1d;
// var StyledSumtChipWrapper = styled(SumtChipWrapper)(_templateObject$1d || (_templateObject$1d = _taggedTemplateLiteral$1(["\n  ", "\n"])), function (props) {
//   return "\n    background-color: ".concat(curriedTransparentize$1(0.7, props.theme.variables[props.themeVar]), ";\n    border-color: ").concat(props.theme.variables[props.themeVar], ";\n    height: 1.5rem;\n    & .MuiChip-label {\n        color: ").concat(curriedDarken$1(0.2, props.theme.variables[props.themeVar]), ";\n        font: 600 0.75rem ").concat(props.theme.variables.fontFamilyBase, ";\n        padding: 0.25rem 0.5rem;\n    }");
// });

// /**
//  * Status labels are static elements which you can apply to signify status, tags or any other information you find useful
//  */
// function StatusLabel(_ref) {
//   var id = _ref.id,
//     status = _ref.status,
//     label = _ref.label;
//   var colorToThemeVar = {
//     inactive: 'textColor',
//     active: 'brandSuccess',
//     error: 'brandDanger',
//     info: 'brandInfo',
//     warning: 'brandWarning'
//   };
//   var themeVar = colorToThemeVar[status];
//   return /*#__PURE__*/React__default.createElement(StyledSumtChipWrapper, {
//     id: id,
//     themeVar: themeVar,
//     color: "primary",
//     label: label
//   });
// }
// StatusLabel.propTypes = {
//   /**
//    * Id of the label
//    */
//   id: PropTypes__default.string,
//   /**
//    * The content of the label.
//    */
//   label: PropTypes__default.node,
//   /**
//    * The color of the component.
//    */
//   status: PropTypes__default.oneOf(['inactive', 'active', 'info', 'warning', 'error'])
// };
// StatusLabel.defaultProps = {
//   id: undefined,
//   label: undefined,
//   status: 'inactive'
// };

// var _templateObject$1c, _templateObject2$O;
// var StyledDiv$5 = styled.div(_templateObject$1c || (_templateObject$1c = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: right;\n"])));
// var StyledRibbon = styled.div(_templateObject2$O || (_templateObject2$O = _taggedTemplateLiteral$1(["\n  ", "\n"])), function (props) {
//   return "\nbackground: ".concat(props.theme.variables[props.themeVar], ";\nposition: relative;\nmin-width: 5rem;\nheight: 1.275rem;\ntext-align: right;\nfont-size: 0.75rem;\nfont-weight: 600;\ntext-align: right;\ncolor: #fff;\npadding: 0.094rem 0.4rem 0 1.0rem;\nvertical-align: middle;\n\n:after {\n  content: \"\";\n  position: absolute;\n  top: -0.013rem;\n  left: -0.063rem;\n  border-left: 0.6875rem solid ").concat(props.theme.variables.bodyBg, ";\n  border-right: 0.6875rem solid transparent;\n  border-top: 0.6875rem solid transparent;\n  border-bottom: 0.6875rem solid transparent;\n}\n");
// });

// /**
//  * statusRibbon is used to display various kinds of status information on ribbon.
//  */
// function StatusRibbon(_ref) {
//   var label = _ref.label,
//     status = _ref.status;
//   var colorToThemeVar = {
//     attended: 'brandAttended',
//     overdue: 'brandOverdue',
//     inprogress: 'brandInprogress',
//     registered: 'brandRegistered',
//     waitinglist: 'brandWaitinglist',
//     assigned: 'brandAssigned',
//     waived: 'brandWaived',
//     pendingapproval: 'brandPendingapproval',
//     canceled: 'brandCanceled',
//     noshow: 'brandNoshow'
//   };
//   var themeVar = colorToThemeVar[status];
//   return /*#__PURE__*/React__default.createElement(StyledDiv$5, null, /*#__PURE__*/React__default.createElement(StyledRibbon, {
//     themeVar: themeVar !== null && themeVar !== void 0 ? themeVar : 'brandAssigned'
//   }, label));
// }
// StatusRibbon.propTypes = {
//   /**
//    * status ribbon text
//    */
//   label: PropTypes__default.string,
//   /**
//    * The color of the component.
//    */
//   status: PropTypes__default.oneOf(['attended', 'overdue', 'inprogress', 'registered', 'waitinglist', 'assigned', 'waived', 'pendingapproval', 'canceled', 'noshow'])
// };
// StatusRibbon.defaultProps = {
//   label: '',
//   status: 'assigned'
// };

// var _excluded$u = ["disabled", "children"];

// /**
//  * SumTotal wrapper for Material-UI Step component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  */
// function Step(_ref) {
//   var disabled = _ref.disabled,
//     children = _ref.children,
//     otherProps = _objectWithoutProperties$j(_ref, _excluded$u);
//   // eslint-disable-next-line react/prop-types
//   var active = otherProps.active,
//     completed = otherProps.completed,
//     index = otherProps.index,
//     connector = otherProps.connector,
//     last = otherProps.last;
//   return /*#__PURE__*/React__default.createElement(MuiStep, {
//     disabled: disabled,
//     active: active,
//     completed: completed,
//     index: index,
//     connector: connector,
//     last: last,
//     "aria-current": active ? 'step' : undefined
//   }, children);
// }
// Step.propTypes = {
//   /**
//    * Mark the step as disabled, will also disable the button if
//    * `StepButton` is a child of `Step`. Is passed to child components.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Should be `Step` sub-components such as `StepLabel`, `StepContent`.
//    */
//   children: PropTypes__default.node
// };
// Step.defaultProps = {
//   disabled: false,
//   children: undefined
// };

// var _excluded$t = ["disabled", "children"];

// /**
//  * SumTotal wrapper for Material-UI StepLabel component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  */
// function StepLabel(_ref) {
//   var disabled = _ref.disabled,
//     children = _ref.children,
//     otherProps = _objectWithoutProperties$j(_ref, _excluded$t);
//   // eslint-disable-next-line react/prop-types
//   var active = otherProps.active,
//     completed = otherProps.completed,
//     last = otherProps.last,
//     icon = otherProps.icon;
//   return /*#__PURE__*/React__default.createElement(MuiStepLabel, {
//     disabled: disabled,
//     active: active,
//     completed: completed,
//     last: last,
//     icon: icon
//   }, children);
// }
// StepLabel.propTypes = {
//   /**
//    * Mark the step as disabled, will also disable the button if
//    * `StepButton` is a child of `Step`. Is passed to child components.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Children for the component
//    */
//   children: PropTypes__default.node
// };
// StepLabel.defaultProps = {
//   disabled: false,
//   children: undefined
// };

// /**
//  * A stepper component is used to indicate progress through a multi-step process.
//  */
// var Stepper = function Stepper(_ref) {
//   var children = _ref.children,
//     activeStep = _ref.activeStep;
//   return /*#__PURE__*/React__default.createElement(Steppers, {
//     alternativeLabel: true,
//     activeStep: activeStep
//   }, children);
// };
// Stepper.propTypes = {
//   /**
//    * The content of the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * Set the active step (zero based index). Set to -1 to disable all the steps
//    */
//   activeStep: PropTypes__default.number
// };
// Stepper.defaultProps = {
//   activeStep: 0,
//   children: undefined
// };

// /**
//  * Tab component for displaying the tab props data.
//  */
// var Tab = function Tab(_ref) {
//   var label = _ref.label,
//     value = _ref.value,
//     onChange = _ref.onChange,
//     selected = _ref.selected,
//     className = _ref.className,
//     idProp = _ref.id;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(Tab$1, {
//     label: label,
//     value: value,
//     onChange: onChange,
//     selected: selected,
//     className: className,
//     id: id
//   });
// };
// Tab.propTypes = {
//   /**
//    * You can provide your own value. Otherwise, we fallback to the child position index.
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//   /**
//    * The label element.
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * Callback fired when the value changes.
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * If true, the tab will be selected or not.
//    */
//   selected: PropTypes__default.bool,
//   /**
//    * Provides classname for Tab component.
//    */
//   className: PropTypes__default.string,
//   /**
//    * id of the tab button.
//    */
//   id: PropTypes__default.string
// };
// Tab.defaultProps = {
//   selected: false,
//   onChange: function onChange() {
//     return null;
//   },
//   className: undefined,
//   id: undefined
// };

// var _templateObject$1b, _templateObject2$N;
// var TablePaginationWithActions = styled(TablePagination$1)(_templateObject$1b || (_templateObject$1b = _taggedTemplateLiteral$1(["\n  .MuiTablePagination-actions {\n    display: ", ";\n    color: ", ";\n  }\n  &.MuiTablePagination-root {\n    margin-top: -0.75rem;\n    overflow: visible;\n  }\n  .MuiSelect-select:focus {\n    border: 0.063rem solid;\n    border-radius: 0.25rem;\n    border-color: ", ";\n  }\n  .MuiTablePagination-selectIcon {\n    margin-right: 0.3125rem;\n  }\n  .MuiTablePagination-selectLabel,\n  .MuiTablePagination-displayedRows {\n    font-size: 0.875rem;\n    color: ", ";\n    margin: 0.063rem 0rem 0rem 0rem;\n  }\n  .MuiInputBase-root {\n    margin-top: 0.25rem;\n  }\n"])), function (props) {
//   return props.hideactions ? 'none' : 'unset';
// }, function (_ref) {
//   var theme = _ref.theme;
//   return theme.variables.textColor;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (_ref2) {
//   var theme = _ref2.theme;
//   return theme.variables.textColor;
// });
// var StyledSpan$3 = styled.span(_templateObject2$N || (_templateObject2$N = _taggedTemplateLiteral$1(["\n  position: absolute;\n  width: 0.06rem;\n  height: 0.06rem;\n  margin: -0.06rem;\n  padding: 0;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n"])));

// /**
//  * Table Pagination is an interface tool for splitting up large amounts of data to make it easier for users to navigate.
//  */
// function TablePagination(_ref) {
//   var count = _ref.count,
//     page = _ref.page,
//     rowsPerPage = _ref.rowsPerPage,
//     component = _ref.component,
//     onChangePage = _ref.onChangePage,
//     onChangeRowsPerPage = _ref.onChangeRowsPerPage,
//     rowsPerPageOptions = _ref.rowsPerPageOptions,
//     hideactions = _ref.hideactions,
//     className = _ref.className,
//     labelRowsPerPage = _ref.labelRowsPerPage,
//     ActionsComponent = _ref.ActionsComponent,
//     translations = _ref.translations;
//   return /*#__PURE__*/React__default.createElement(TablePaginationWithActions, {
//     hideactions: hideactions ? 1 : 0,
//     component: component,
//     count: count,
//     page: page,
//     onPageChange: onChangePage,
//     rowsPerPage: rowsPerPage,
//     labelRowsPerPage: labelRowsPerPage,
//     rowsPerPageOptions: rowsPerPageOptions,
//     onRowsPerPageChange: onChangeRowsPerPage,
//     labelDisplayedRows: function labelDisplayedRows(_ref2) {
//       var from = _ref2.from,
//         to = _ref2.to;
//       return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(StyledSpan$3, null, translations.RCORE_SCREEN_READER_TEXT_FOR_DISPLAYED_ROWS || 'Showing'), "".concat(from, "-").concat(to));
//     },
//     className: className,
//     ActionsComponent: ActionsComponent
//   });
// }
// TablePagination.propTypes = {
//   /**
//    * Count of the total number of pages.
//    */
//   count: PropTypes__default.number.isRequired,
//   /**
//    * The current page.
//    */
//   page: PropTypes__default.number.isRequired,
//   /**
//    * The number of rows per page.
//    */
//   rowsPerPage: PropTypes__default.number.isRequired,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onChangePage: PropTypes__default.func,
//   /**
//    * Callback fired when the number of rows per page is change
//    */
//   onChangeRowsPerPage: PropTypes__default.func.isRequired,
//   /**
//    * labelRowsPerPage text to be used for the input field
//    */
//   labelRowsPerPage: PropTypes__default.string.isRequired,
//   /**
//    *The component used for the root node. Either a string to use a HTML element or a component
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * Customizes the options of the rows per page select field. If less than two options are available, no select field will be displayed.
//    */
//   rowsPerPageOptions: PropTypes__default.arrayOf(PropTypes__default.oneOfType([PropTypes__default.number])).isRequired,
//   /**
//    * Value of hideactions used for hidding the next and prev actions.
//    */
//   hideactions: PropTypes__default.bool,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * The component used for displaying the actions. Either a string to use a HTML element or a component.
//    */
//   ActionsComponent: PropTypes__default.elementType,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string)
// };
// TablePagination.defaultProps = {
//   component: 'div',
//   hideactions: true,
//   className: undefined,
//   ActionsComponent: undefined,
//   onChangePage: function onChangePage() {
//     return null;
//   },
//   translations: {}
// };

// var _templateObject$1a;
// var StyledSumtTabs = styled(Tabs$1)(_templateObject$1a || (_templateObject$1a = _taggedTemplateLiteral$1(["\n    .MuiTab-root {\n        color: ", ";\n        font-weight: bold;\n        font-size : 0.8rem;\n        min-width: 6rem;\n        opacity: unset;\n    }\n\n    .Mui-selected {\n        color: ", ";\n    }\n\n    .MuiTabs-indicator {\n        background-color: ", ";\n        height: 0.2rem;\n        color: ", ";\n    }\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.textColor;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });

// /**
//  * Tabs component for displaying the tabs data.
//  */
// function Tabs(_ref) {
//   var arialabel = _ref.arialabel,
//     children = _ref.children,
//     onChange = _ref.onChange,
//     value = _ref.value,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledSumtTabs, {
//     "aria-label": arialabel,
//     onChange: onChange,
//     value: value,
//     className: className
//   }, children);
// }
// Tabs.propTypes = {
//   /**
//    * The content of the component
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * The value of the currently selected Tab. If you don't want any selected Tab, you can set this property to false.
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//   /**
//    * Callback fired when the value changes.
//    */
//   onChange: PropTypes__default.func.isRequired,
//   /**
//    * Override or extend the styles applied to the component. See CSS API below for more details.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The label for the Tabs as a string.
//    */
//   arialabel: PropTypes__default.string
// };
// Tabs.defaultProps = {
//   className: undefined,
//   arialabel: undefined
// };

// /**
//  * Text fields let users enter and edit text
//  */
// var TextField = function TextField(_ref) {
//   var type = _ref.type,
//     variant = _ref.variant,
//     label = _ref.label,
//     placeholder = _ref.placeholder,
//     inputProps = _ref.inputProps,
//     InputProps = _ref.InputProps,
//     inputLabelProps = _ref.inputLabelProps,
//     className = _ref.className,
//     required = _ref.required,
//     multiline = _ref.multiline,
//     rows = _ref.rows,
//     value = _ref.value,
//     name = _ref.name,
//     onChange = _ref.onChange,
//     error = _ref.error,
//     helperText = _ref.helperText,
//     disabled = _ref.disabled,
//     idProp = _ref.id,
//     fullWidth = _ref.fullWidth,
//     onKeyUp = _ref.onKeyUp,
//     autoFocus = _ref.autoFocus,
//     inputRef = _ref.inputRef,
//     onKeyDown = _ref.onKeyDown,
//     onBlur = _ref.onBlur;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(TextField$2, {
//     type: type,
//     variant: variant,
//     label: label,
//     placeholder: placeholder,
//     inputProps: inputProps,
//     InputProps: InputProps,
//     InputLabelProps: inputLabelProps,
//     className: className,
//     required: required,
//     multiline: multiline,
//     minRows: rows,
//     value: value,
//     name: name,
//     onChange: onChange,
//     error: error,
//     helperText: helperText,
//     disabled: disabled,
//     id: id,
//     fullWidth: fullWidth,
//     onKeyUp: onKeyUp,
//     autoFocus: autoFocus,
//     inputRef: inputRef,
//     onKeyDown: onKeyDown,
//     onBlur: onBlur
//   });
// };
// TextField.propTypes = {
//   /**
//    * Type of input
//    */
//   type: PropTypes__default.oneOf(['text', 'search', 'number', 'password']),
//   /**
//    * variant of the MUI text input
//    */
//   variant: PropTypes__default.oneOf(['standard', 'outlined']),
//   /**
//    * Text for label
//    */
//   label: PropTypes__default.string,
//   /**
//    * Text for placeholder
//    */
//   placeholder: PropTypes__default.string,
//   /**
//    * Props for input label
//    */
//   inputLabelProps: PropTypes__default.shape({}),
//   /**
//    * Props for input base
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * Props applied to the Input element
//    */
//   InputProps: PropTypes__default.shape({}),
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * Label is displayed as required
//    */
//   required: PropTypes__default.bool,
//   /**
//    * Renders the textarea
//    */
//   multiline: PropTypes__default.bool,
//   /**
//    * Number of rows to display
//    */
//   rows: PropTypes__default.number,
//   /**
//    * Value of the input
//    */
//   value: PropTypes__default.string,
//   /**
//    * Name of the input
//    */
//   name: PropTypes__default.string,
//   /**
//    * On Change handler
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Display label in error state
//    */
//   error: PropTypes__default.bool,
//   /**
//    * Content for helper text
//    */
//   helperText: PropTypes__default.node,
//   /**
//    * Disable the input
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Id of the input
//    */
//   id: PropTypes__default.string,
//   /**
//    * If `true`, the input will take up the full width of its container.
//    */
//   fullWidth: PropTypes__default.bool,
//   /**
//    * Event handler for keypress
//    */
//   onKeyUp: PropTypes__default.func,
//   /**
//    * If true, the input element will be focused during the first mount.
//    */
//   autoFocus: PropTypes__default.bool,
//   /**
//    * Pass a ref to the input element
//    */
//   inputRef: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func, PropTypes__default.string]),
//   /**
//    * Event handler for keydown
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * On blur handler
//    */
//   onBlur: PropTypes__default.func
// };
// TextField.defaultProps = {
//   type: undefined,
//   variant: 'outlined',
//   label: undefined,
//   placeholder: undefined,
//   inputLabelProps: undefined,
//   inputProps: undefined,
//   InputProps: undefined,
//   className: '',
//   required: false,
//   multiline: false,
//   rows: undefined,
//   value: '',
//   name: '',
//   onChange: function onChange() {
//     return null;
//   },
//   error: false,
//   helperText: '',
//   disabled: false,
//   id: undefined,
//   fullWidth: false,
//   onKeyUp: function onKeyUp() {
//     return null;
//   },
//   autoFocus: false,
//   inputRef: undefined,
//   onKeyDown: undefined,
//   onBlur: undefined
// };

// var _templateObject$19;
// var SrOnlySpan = styled.span(_templateObject$19 || (_templateObject$19 = _taggedTemplateLiteral$1(["\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  padding: 0;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n"])));

// /**
//  * Converts seconds to a duration in the format of xxh xxm xxs
//  */
// function TimeConversion(_ref) {
//   var seconds = _ref.seconds,
//     translations = _ref.translations,
//     language = _ref.language;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     formattedTimeString = _useState2[0],
//     setFormattedTime = _useState2[1];
//   useEffect$2(function () {
//     setFormattedTime(function () {
//       var hourStringShort = translations.HOUR_SHORT_TRANSLATION || 'h';
//       var minuteStringShort = translations.MINUTE_SHORT_TRANSLATION || 'm';
//       var secondStringShort = translations.SECONDS_SHORT_TRANSLATION || 's';
//       var hoursTotal = Math.floor(seconds / 3600);
//       var minutesTotal = Math.floor((seconds - hoursTotal * 3600) / 60);
//       var secondsTotal = seconds - hoursTotal * 3600 - minutesTotal * 60;
//       var buildTimeString = '';
//       if (hoursTotal >= 1) {
//         buildTimeString = "".concat(hoursTotal + hourStringShort, " ");
//       }
//       if (minutesTotal >= 1) {
//         buildTimeString = "".concat(buildTimeString + minutesTotal + minuteStringShort, " ");
//       }
//       if (secondsTotal >= 1 && hoursTotal < 1) {
//         buildTimeString = "".concat(buildTimeString + secondsTotal + secondStringShort, " ");
//       }
//       return buildTimeString;
//     });
//   }, [seconds, translations]);
//   return /*#__PURE__*/React__default.createElement("span", null, /*#__PURE__*/React__default.createElement("span", {
//     "aria-hidden": "true"
//   }, formattedTimeString), /*#__PURE__*/React__default.createElement(SrOnlySpan, null, humanizeDuration(seconds * 1000, {
//     delimiter: [' '],
//     units: ['h', 'm', 's'],
//     largest: 2,
//     language: language,
//     fallbacks: ['en']
//   })));
// }
// TimeConversion.propTypes = {
//   /**
//    * Amount of seconds to convert into the TimeFormat.
//    */
//   seconds: PropTypes__default.number.isRequired,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string).isRequired,
//   /**
//    * Language code for HumanizeDirective
//    */
//   language: PropTypes__default.string
// };
// TimeConversion.defaultProps = {
//   language: 'en'
// };

// /**
//  * Tooltips display informative text when users hover, focus on an element.
//  */

// function Tooltip$1(_ref) {
//   var title = _ref.title,
//     arrow = _ref.arrow,
//     placement = _ref.placement,
//     children = _ref.children,
//     className = _ref.className,
//     open = _ref.open,
//     PopperProps = _ref.PopperProps;
//   return /*#__PURE__*/React__default.createElement(MuiTooltip, {
//     title: title,
//     arrow: arrow,
//     placement: placement,
//     className: className,
//     open: open,
//     PopperProps: PopperProps
//   }, children);
// }

// // PropType check
// Tooltip$1.propTypes = {
//   /**
//    * Tooltip title
//    */
//   title: PropTypes__default.node,
//   /**
//    * adds an arrow to the tooltip
//    */
//   arrow: PropTypes__default.bool,
//   /**
//    * Tooltip placement
//    */
//   placement: PropTypes__default.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
//   /**
//    * Child elements for the component
//    * Note: Tooltip component expects children element that supports forwardref.
//    */
//   children: PropTypes__default.element,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Flag that determines if the tooltip is displayed
//    */
//   open: PropTypes__default.bool,
//   /**
//    * Object to set props on the Tooltip's Popper comopnoent
//    */
//   PopperProps: PropTypes__default.shape({})
// };
// Tooltip$1.defaultProps = {
//   title: '',
//   arrow: false,
//   placement: 'bottom',
//   children: undefined,
//   className: '',
//   open: undefined,
//   PopperProps: undefined
// };

// /**
//  * Determines if a given element is a DOM element name (i.e. not a React component).
//  */
// function isHostComponent(element) {
//   return typeof element === 'string';
// }

// /**
//  * Type of the ownerState based on the type of an element it applies to.
//  * This resolves to the provided OwnerState for React components and `undefined` for host components.
//  * Falls back to `OwnerState | undefined` when the exact type can't be determined in development time.
//  */

// /**
//  * Appends the ownerState object to the props, merging with the existing one if necessary.
//  *
//  * @param elementType Type of the element that owns the `existingProps`. If the element is a DOM node or undefined, `ownerState` is not applied.
//  * @param otherProps Props of the element.
//  * @param ownerState
//  */
// function appendOwnerState(elementType, otherProps, ownerState) {
//   if (elementType === undefined || isHostComponent(elementType)) {
//     return otherProps;
//   }
//   return _extends$u({}, otherProps, {
//     ownerState: _extends$u({}, otherProps.ownerState, ownerState)
//   });
// }

// /**
//  * Extracts event handlers from a given object.
//  * A prop is considered an event handler if it is a function and its name starts with `on`.
//  *
//  * @param object An object to extract event handlers from.
//  * @param excludeKeys An array of keys to exclude from the returned object.
//  */
// function extractEventHandlers(object, excludeKeys = []) {
//   if (object === undefined) {
//     return {};
//   }
//   const result = {};
//   Object.keys(object).filter(prop => prop.match(/^on[A-Z]/) && typeof object[prop] === 'function' && !excludeKeys.includes(prop)).forEach(prop => {
//     result[prop] = object[prop];
//   });
//   return result;
// }

// /**
//  * If `componentProps` is a function, calls it with the provided `ownerState`.
//  * Otherwise, just returns `componentProps`.
//  */
// function resolveComponentProps(componentProps, ownerState, slotState) {
//   if (typeof componentProps === 'function') {
//     return componentProps(ownerState, slotState);
//   }
//   return componentProps;
// }

// /**
//  * Removes event handlers from the given object.
//  * A field is considered an event handler if it is a function with a name beginning with `on`.
//  *
//  * @param object Object to remove event handlers from.
//  * @returns Object with event handlers removed.
//  */
// function omitEventHandlers(object) {
//   if (object === undefined) {
//     return {};
//   }
//   const result = {};
//   Object.keys(object).filter(prop => !(prop.match(/^on[A-Z]/) && typeof object[prop] === 'function')).forEach(prop => {
//     result[prop] = object[prop];
//   });
//   return result;
// }

// /**
//  * Merges the slot component internal props (usually coming from a hook)
//  * with the externally provided ones.
//  *
//  * The merge order is (the latter overrides the former):
//  * 1. The internal props (specified as a getter function to work with get*Props hook result)
//  * 2. Additional props (specified internally on a Base UI component)
//  * 3. External props specified on the owner component. These should only be used on a root slot.
//  * 4. External props specified in the `slotProps.*` prop.
//  * 5. The `className` prop - combined from all the above.
//  * @param parameters
//  * @returns
//  */
// function mergeSlotProps(parameters) {
//   const {
//     getSlotProps,
//     additionalProps,
//     externalSlotProps,
//     externalForwardedProps,
//     className
//   } = parameters;
//   if (!getSlotProps) {
//     // The simpler case - getSlotProps is not defined, so no internal event handlers are defined,
//     // so we can simply merge all the props without having to worry about extracting event handlers.
//     const joinedClasses = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
//     const mergedStyle = _extends$u({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
//     const props = _extends$u({}, additionalProps, externalForwardedProps, externalSlotProps);
//     if (joinedClasses.length > 0) {
//       props.className = joinedClasses;
//     }
//     if (Object.keys(mergedStyle).length > 0) {
//       props.style = mergedStyle;
//     }
//     return {
//       props,
//       internalRef: undefined
//     };
//   }

//   // In this case, getSlotProps is responsible for calling the external event handlers.
//   // We don't need to include them in the merged props because of this.

//   const eventHandlers = extractEventHandlers(_extends$u({}, externalForwardedProps, externalSlotProps));
//   const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
//   const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
//   const internalSlotProps = getSlotProps(eventHandlers);

//   // The order of classes is important here.
//   // Emotion (that we use in libraries consuming Base UI) depends on this order
//   // to properly override style. It requires the most important classes to be last
//   // (see https://github.com/mui/material-ui/pull/33205) for the related discussion.
//   const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
//   const mergedStyle = _extends$u({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
//   const props = _extends$u({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
//   if (joinedClasses.length > 0) {
//     props.className = joinedClasses;
//   }
//   if (Object.keys(mergedStyle).length > 0) {
//     props.style = mergedStyle;
//   }
//   return {
//     props,
//     internalRef: internalSlotProps.ref
//   };
// }

// const _excluded$s = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
// /**
//  * @ignore - do not document.
//  * Builds the props to be passed into the slot of an unstyled component.
//  * It merges the internal props of the component with the ones supplied by the user, allowing to customize the behavior.
//  * If the slot component is not a host component, it also merges in the `ownerState`.
//  *
//  * @param parameters.getSlotProps - A function that returns the props to be passed to the slot component.
//  */
// function useSlotProps(parameters) {
//   var _parameters$additiona;
//   const {
//       elementType,
//       externalSlotProps,
//       ownerState,
//       skipResolvingSlotProps = false
//     } = parameters,
//     rest = _objectWithoutPropertiesLoose$k(parameters, _excluded$s);
//   const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
//   const {
//     props: mergedProps,
//     internalRef
//   } = mergeSlotProps(_extends$u({}, rest, {
//     externalSlotProps: resolvedComponentsProps
//   }));
//   const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
//   const props = appendOwnerState(elementType, _extends$u({}, mergedProps, {
//     ref
//   }), ownerState);
//   return props;
// }

// const _excluded$r = ["element"];
// function findIndex(array, comp) {
//   for (let i = 0; i < array.length; i += 1) {
//     if (comp(array[i])) {
//       return i;
//     }
//   }
//   return -1;
// }
// function binaryFindElement(array, element) {
//   let start = 0;
//   let end = array.length - 1;
//   while (start <= end) {
//     const middle = Math.floor((start + end) / 2);
//     if (array[middle].element === element) {
//       return middle;
//     }

//     // eslint-disable-next-line no-bitwise
//     if (array[middle].element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING) {
//       end = middle - 1;
//     } else {
//       start = middle + 1;
//     }
//   }
//   return start;
// }
// const DescendantContext = /*#__PURE__*/React.createContext({});
// if (process.env.NODE_ENV !== 'production') {
//   DescendantContext.displayName = 'DescendantContext';
// }
// function usePrevious(value) {
//   const ref = React.useRef(null);
//   React.useEffect(() => {
//     ref.current = value;
//   }, [value]);
//   return ref.current;
// }
// const noop$2 = () => {};

// /**
//  * This hook registers our descendant by passing it into an array. We can then
//  * search that array by to find its index when registering it in the component.
//  * We use this for focus management, keyboard navigation, and typeahead
//  * functionality for some components.
//  *
//  * The hook accepts the element node
//  *
//  * Our main goals with this are:
//  *   1) maximum composability,
//  *   2) minimal API friction
//  *   3) SSR compatibility*
//  *   4) concurrent safe
//  *   5) index always up-to-date with the tree despite changes
//  *   6) works with memoization of any component in the tree (hopefully)
//  *
//  * * As for SSR, the good news is that we don't actually need the index on the
//  * server for most use-cases, as we are only using it to determine the order of
//  * composed descendants for keyboard navigation.
//  */
// function useDescendant(descendant) {
//   const [, forceUpdate] = React.useState();
//   const {
//     registerDescendant = noop$2,
//     unregisterDescendant = noop$2,
//     descendants = [],
//     parentId = null
//   } = React.useContext(DescendantContext);

//   // This will initially return -1 because we haven't registered the descendant
//   // on the first render. After we register, this will then return the correct
//   // index on the following render, and we will re-register descendants
//   // so that everything is up-to-date before the user interacts with a
//   // collection.
//   const index = findIndex(descendants, item => item.element === descendant.element);
//   const previousDescendants = usePrevious(descendants);

//   // We also need to re-register descendants any time ANY of the other
//   // descendants have changed. My brain was melting when I wrote this and it
//   // feels a little off, but checking in render and using the result in the
//   // effect's dependency array works well enough.
//   const someDescendantsHaveChanged = descendants.some((newDescendant, position) => {
//     return previousDescendants && previousDescendants[position] && previousDescendants[position].element !== newDescendant.element;
//   });

//   // Prevent any flashing
//   useEnhancedEffect(() => {
//     if (descendant.element) {
//       registerDescendant(_extends$u({}, descendant, {
//         index
//       }));
//       return () => {
//         unregisterDescendant(descendant.element);
//       };
//     }
//     forceUpdate({});
//     return undefined;
//   }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged, descendant]);
//   return {
//     parentId,
//     index
//   };
// }
// function DescendantProvider(props) {
//   const {
//     children,
//     id
//   } = props;
//   const [items, set] = React.useState([]);
//   const registerDescendant = React.useCallback(_ref => {
//     let {
//         element
//       } = _ref,
//       other = _objectWithoutPropertiesLoose$k(_ref, _excluded$r);
//     set(oldItems => {
//       if (oldItems.length === 0) {
//         // If there are no items, register at index 0 and bail.
//         return [_extends$u({}, other, {
//           element,
//           index: 0
//         })];
//       }
//       const index = binaryFindElement(oldItems, element);
//       let newItems;
//       if (oldItems[index] && oldItems[index].element === element) {
//         // If the element is already registered, just use the same array
//         newItems = oldItems;
//       } else {
//         // When registering a descendant, we need to make sure we insert in
//         // into the array in the same order that it appears in the DOM. So as
//         // new descendants are added or maybe some are removed, we always know
//         // that the array is up-to-date and correct.
//         //
//         // So here we look at our registered descendants and see if the new
//         // element we are adding appears earlier than an existing descendant's
//         // DOM node via `node.compareDocumentPosition`. If it does, we insert
//         // the new element at this index. Because `registerDescendant` will be
//         // called in an effect every time the descendants state value changes,
//         // we should be sure that this index is accurate when descendent
//         // elements come or go from our component.

//         const newItem = _extends$u({}, other, {
//           element,
//           index
//         });

//         // If an index is not found we will push the element to the end.
//         newItems = oldItems.slice();
//         newItems.splice(index, 0, newItem);
//       }
//       newItems.forEach((item, position) => {
//         item.index = position;
//       });
//       return newItems;
//     });
//   }, []);
//   const unregisterDescendant = React.useCallback(element => {
//     set(oldItems => oldItems.filter(item => element !== item.element));
//   }, []);
//   const value = React.useMemo(() => ({
//     descendants: items,
//     registerDescendant,
//     unregisterDescendant,
//     parentId: id
//   }), [items, registerDescendant, unregisterDescendant, id]);
//   return /*#__PURE__*/jsx(DescendantContext.Provider, {
//     value: value,
//     children: children
//   });
// }
// process.env.NODE_ENV !== "production" ? DescendantProvider.propTypes = {
//   children: PropTypes__default.node,
//   id: PropTypes__default.string
// } : void 0;

// const DEFAULT_TREE_VIEW_CONTEXT_VALUE = {
//   instance: null,
//   multiSelect: false,
//   disabledItemsFocusable: false,
//   treeId: undefined,
//   icons: {
//     defaultCollapseIcon: null,
//     defaultExpandIcon: null,
//     defaultParentIcon: null,
//     defaultEndIcon: null
//   }
// };

// /**
//  * @ignore - internal component.
//  */
// const TreeViewContext = /*#__PURE__*/React.createContext(DEFAULT_TREE_VIEW_CONTEXT_VALUE);
// if (process.env.NODE_ENV !== 'production') {
//   TreeViewContext.displayName = 'TreeViewContext';
// }

// const useTreeViewContext = () => React.useContext(TreeViewContext);

// function useTreeItem(nodeId) {
//   const {
//     instance,
//     multiSelect
//   } = useTreeViewContext();
//   const expandable = instance ? instance.isNodeExpandable(nodeId) : false;
//   const expanded = instance ? instance.isNodeExpanded(nodeId) : false;
//   const focused = instance ? instance.isNodeFocused(nodeId) : false;
//   const selected = instance ? instance.isNodeSelected(nodeId) : false;
//   const disabled = instance ? instance.isNodeDisabled(nodeId) : false;
//   const handleExpansion = event => {
//     if (instance && !disabled) {
//       if (!focused) {
//         instance.focusNode(event, nodeId);
//       }
//       const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);

//       // If already expanded and trying to toggle selection don't close
//       if (expandable && !(multiple && instance.isNodeExpanded(nodeId))) {
//         instance.toggleNodeExpansion(event, nodeId);
//       }
//     }
//   };
//   const handleSelection = event => {
//     if (instance && !disabled) {
//       if (!focused) {
//         instance.focusNode(event, nodeId);
//       }
//       const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
//       if (multiple) {
//         if (event.shiftKey) {
//           instance.selectRange(event, {
//             end: nodeId
//           });
//         } else {
//           instance.selectNode(event, nodeId, true);
//         }
//       } else {
//         instance.selectNode(event, nodeId);
//       }
//     }
//   };
//   const preventSelection = event => {
//     if (event.shiftKey || event.ctrlKey || event.metaKey || disabled) {
//       // Prevent text selection
//       event.preventDefault();
//     }
//   };
//   return {
//     disabled,
//     expanded,
//     selected,
//     focused,
//     handleExpansion,
//     handleSelection,
//     preventSelection
//   };
// }

// const _excluded$q = ["classes", "className", "displayIcon", "expansionIcon", "icon", "label", "nodeId", "onClick", "onMouseDown"];
// /**
//  * @ignore - internal component.
//  */
// const TreeItemContent = /*#__PURE__*/React.forwardRef(function TreeItemContent(props, ref) {
//   const {
//       classes,
//       className,
//       displayIcon,
//       expansionIcon,
//       icon: iconProp,
//       label,
//       nodeId,
//       onClick,
//       onMouseDown
//     } = props,
//     other = _objectWithoutPropertiesLoose$k(props, _excluded$q);
//   const {
//     disabled,
//     expanded,
//     selected,
//     focused,
//     handleExpansion,
//     handleSelection,
//     preventSelection
//   } = useTreeItem(nodeId);
//   const icon = iconProp || expansionIcon || displayIcon;
//   const handleMouseDown = event => {
//     preventSelection(event);
//     if (onMouseDown) {
//       onMouseDown(event);
//     }
//   };
//   const handleClick = event => {
//     handleExpansion(event);
//     handleSelection(event);
//     if (onClick) {
//       onClick(event);
//     }
//   };
//   return (
//     /*#__PURE__*/
//     /* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions -- Key event is handled by the TreeView */
//     jsxs("div", _extends$u({}, other, {
//       className: clsx(className, classes.root, expanded && classes.expanded, selected && classes.selected, focused && classes.focused, disabled && classes.disabled),
//       onClick: handleClick,
//       onMouseDown: handleMouseDown,
//       ref: ref,
//       children: [/*#__PURE__*/jsx("div", {
//         className: classes.iconContainer,
//         children: icon
//       }), /*#__PURE__*/jsx("div", {
//         className: classes.label,
//         children: label
//       })]
//     }))
//   );
// });
// process.env.NODE_ENV !== "production" ? TreeItemContent.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------
//   /**
//    * Override or extend the styles applied to the component.
//    */
//   classes: PropTypes__default.object.isRequired,
//   /**
//    * className applied to the root element.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The icon to display next to the tree node's label. Either a parent or end icon.
//    */
//   displayIcon: PropTypes__default.node,
//   /**
//    * The icon to display next to the tree node's label. Either an expansion or collapse icon.
//    */
//   expansionIcon: PropTypes__default.node,
//   /**
//    * The icon to display next to the tree node's label.
//    */
//   icon: PropTypes__default.node,
//   /**
//    * The tree node label.
//    */
//   label: PropTypes__default.node,
//   /**
//    * The id of the node.
//    */
//   nodeId: PropTypes__default.string.isRequired
// } : void 0;

// function getTreeItemUtilityClass(slot) {
//   return generateUtilityClass('MuiTreeItem', slot);
// }
// const treeItemClasses = generateUtilityClasses('MuiTreeItem', ['root', 'group', 'content', 'expanded', 'selected', 'focused', 'disabled', 'iconContainer', 'label']);

// const _excluded$p = ["children", "className", "collapseIcon", "ContentComponent", "ContentProps", "endIcon", "expandIcon", "disabled", "icon", "id", "label", "nodeId", "onClick", "onMouseDown", "TransitionComponent", "TransitionProps"];
// const useUtilityClasses$1 = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root'],
//     content: ['content'],
//     expanded: ['expanded'],
//     selected: ['selected'],
//     focused: ['focused'],
//     disabled: ['disabled'],
//     iconContainer: ['iconContainer'],
//     label: ['label'],
//     group: ['group']
//   };
//   return composeClasses(slots, getTreeItemUtilityClass, classes);
// };
// const TreeItemRoot = styled$1('li', {
//   name: 'MuiTreeItem',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })({
//   listStyle: 'none',
//   margin: 0,
//   padding: 0,
//   outline: 0
// });
// const StyledTreeItemContent = styled$1(TreeItemContent, {
//   name: 'MuiTreeItem',
//   slot: 'Content',
//   overridesResolver: (props, styles) => {
//     return [styles.content, styles.iconContainer && {
//       [`& .${treeItemClasses.iconContainer}`]: styles.iconContainer
//     }, styles.label && {
//       [`& .${treeItemClasses.label}`]: styles.label
//     }];
//   }
// })(({
//   theme
// }) => ({
//   padding: '0 8px',
//   width: '100%',
//   boxSizing: 'border-box',
//   // prevent width + padding to overflow
//   display: 'flex',
//   alignItems: 'center',
//   cursor: 'pointer',
//   WebkitTapHighlightColor: 'transparent',
//   '&:hover': {
//     backgroundColor: (theme.vars || theme).palette.action.hover,
//     // Reset on touch devices, it doesn't add specificity
//     '@media (hover: none)': {
//       backgroundColor: 'transparent'
//     }
//   },
//   [`&.${treeItemClasses.disabled}`]: {
//     opacity: (theme.vars || theme).palette.action.disabledOpacity,
//     backgroundColor: 'transparent'
//   },
//   [`&.${treeItemClasses.focused}`]: {
//     backgroundColor: (theme.vars || theme).palette.action.focus
//   },
//   [`&.${treeItemClasses.selected}`]: {
//     backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
//     '&:hover': {
//       backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
//       // Reset on touch devices, it doesn't add specificity
//       '@media (hover: none)': {
//         backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
//       }
//     },
//     [`&.${treeItemClasses.focused}`]: {
//       backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha$1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
//     }
//   },
//   [`& .${treeItemClasses.iconContainer}`]: {
//     marginRight: 4,
//     width: 15,
//     display: 'flex',
//     flexShrink: 0,
//     justifyContent: 'center',
//     '& svg': {
//       fontSize: 18
//     }
//   },
//   [`& .${treeItemClasses.label}`]: _extends$u({
//     paddingLeft: 4,
//     width: '100%',
//     boxSizing: 'border-box',
//     // prevent width + padding to overflow
//     // fixes overflow - see https://github.com/mui/material-ui/issues/27372
//     minWidth: 0,
//     position: 'relative'
//   }, theme.typography.body1)
// }));
// const TreeItemGroup = styled$1(MuiCollapse, {
//   name: 'MuiTreeItem',
//   slot: 'Group',
//   overridesResolver: (props, styles) => styles.group
// })({
//   margin: 0,
//   padding: 0,
//   marginLeft: 17
// });

// /**
//  *
//  * Demos:
//  *
//  * - [Tree View](https://mui.com/x/react-tree-view/)
//  *
//  * API:
//  *
//  * - [TreeItem API](https://mui.com/x/api/tree-view/tree-item/)
//  */
// const TreeItem$1 = /*#__PURE__*/React.forwardRef(function TreeItem(inProps, ref) {
//   const props = useThemeProps({
//     props: inProps,
//     name: 'MuiTreeItem'
//   });
//   const {
//       children,
//       className,
//       collapseIcon,
//       ContentComponent = TreeItemContent,
//       ContentProps,
//       endIcon,
//       expandIcon,
//       disabled: disabledProp,
//       icon,
//       id: idProp,
//       label,
//       nodeId,
//       onClick,
//       onMouseDown,
//       TransitionComponent = MuiCollapse,
//       TransitionProps
//     } = props,
//     other = _objectWithoutPropertiesLoose$k(props, _excluded$p);
//   const {
//     icons: contextIcons,
//     multiSelect,
//     disabledItemsFocusable,
//     treeId,
//     instance
//   } = useTreeViewContext();
//   let id;
//   if (idProp != null) {
//     id = idProp;
//   } else if (treeId && nodeId) {
//     id = `${treeId}-${nodeId}`;
//   }
//   const [treeItemElement, setTreeItemElement] = React.useState(null);
//   const contentRef = React.useRef(null);
//   const handleRef = useForkRef(setTreeItemElement, ref);
//   const descendant = React.useMemo(() => ({
//     element: treeItemElement,
//     id: nodeId
//   }), [nodeId, treeItemElement]);
//   const {
//     index,
//     parentId
//   } = useDescendant(descendant);
//   const expandable = Boolean(Array.isArray(children) ? children.length : children);
//   const expanded = instance ? instance.isNodeExpanded(nodeId) : false;
//   const focused = instance ? instance.isNodeFocused(nodeId) : false;
//   const selected = instance ? instance.isNodeSelected(nodeId) : false;
//   const disabled = instance ? instance.isNodeDisabled(nodeId) : false;
//   const ownerState = _extends$u({}, props, {
//     expanded,
//     focused,
//     selected,
//     disabled
//   });
//   const classes = useUtilityClasses$1(ownerState);
//   let displayIcon;
//   let expansionIcon;
//   if (expandable) {
//     if (!expanded) {
//       expansionIcon = expandIcon || contextIcons.defaultExpandIcon;
//     } else {
//       expansionIcon = collapseIcon || contextIcons.defaultCollapseIcon;
//     }
//   }
//   if (expandable) {
//     displayIcon = contextIcons.defaultParentIcon;
//   } else {
//     displayIcon = endIcon || contextIcons.defaultEndIcon;
//   }
//   React.useEffect(() => {
//     // On the first render a node's index will be -1. We want to wait for the real index.
//     if (instance && index !== -1) {
//       instance.updateNode({
//         id: nodeId,
//         idAttribute: id,
//         index,
//         parentId,
//         expandable,
//         disabled: disabledProp
//       });
//       return () => instance.removeNode(nodeId);
//     }
//     return undefined;
//   }, [instance, parentId, index, nodeId, expandable, disabledProp, id]);
//   React.useEffect(() => {
//     if (instance && label) {
//       var _contentRef$current$t, _contentRef$current;
//       return instance.mapFirstChar(nodeId, ((_contentRef$current$t = (_contentRef$current = contentRef.current) == null ? void 0 : _contentRef$current.textContent) != null ? _contentRef$current$t : '').substring(0, 1).toLowerCase());
//     }
//     return undefined;
//   }, [instance, nodeId, label]);
//   let ariaSelected;
//   if (multiSelect) {
//     ariaSelected = selected;
//   } else if (selected) {
//     /* single-selection trees unset aria-selected on un-selected items.
//      *
//      * If the tree does not support multiple selection, aria-selected
//      * is set to true for the selected node and it is not present on any other node in the tree.
//      * Source: https://www.w3.org/WAI/ARIA/apg/patterns/treeview/
//      */
//     ariaSelected = true;
//   }
//   function handleFocus(event) {
//     // DOM focus stays on the tree which manages focus with aria-activedescendant
//     if (event.target === event.currentTarget) {
//       let rootElement;
//       if (typeof event.target.getRootNode === 'function') {
//         rootElement = event.target.getRootNode();
//       } else {
//         rootElement = ownerDocument(event.target);
//       }
//       rootElement.getElementById(treeId).focus({
//         preventScroll: true
//       });
//     }
//     const unfocusable = !disabledItemsFocusable && disabled;
//     if (instance && !focused && event.currentTarget === event.target && !unfocusable) {
//       instance.focusNode(event, nodeId);
//     }
//   }
//   return /*#__PURE__*/jsxs(TreeItemRoot, _extends$u({
//     className: clsx(classes.root, className),
//     role: "treeitem",
//     "aria-expanded": expandable ? expanded : undefined,
//     "aria-selected": ariaSelected,
//     "aria-disabled": disabled || undefined,
//     id: id,
//     tabIndex: -1
//   }, other, {
//     ownerState: ownerState,
//     onFocus: handleFocus,
//     ref: handleRef,
//     children: [/*#__PURE__*/jsx(StyledTreeItemContent, _extends$u({
//       as: ContentComponent,
//       ref: contentRef,
//       classes: {
//         root: classes.content,
//         expanded: classes.expanded,
//         selected: classes.selected,
//         focused: classes.focused,
//         disabled: classes.disabled,
//         iconContainer: classes.iconContainer,
//         label: classes.label
//       },
//       label: label,
//       nodeId: nodeId,
//       onClick: onClick,
//       onMouseDown: onMouseDown,
//       icon: icon,
//       expansionIcon: expansionIcon,
//       displayIcon: displayIcon,
//       ownerState: ownerState
//     }, ContentProps)), children && /*#__PURE__*/jsx(DescendantProvider, {
//       id: nodeId,
//       children: /*#__PURE__*/jsx(TreeItemGroup, _extends$u({
//         as: TransitionComponent,
//         unmountOnExit: true,
//         className: classes.group,
//         in: expanded,
//         component: "ul",
//         role: "group"
//       }, TransitionProps, {
//         children: children
//       }))
//     })]
//   }));
// });
// process.env.NODE_ENV !== "production" ? TreeItem$1.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Override or extend the styles applied to the component.
//    */
//   classes: PropTypes__default.object,
//   /**
//    * className applied to the root element.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The icon used to collapse the node.
//    */
//   collapseIcon: PropTypes__default.node,
//   /**
//    * The component used for the content node.
//    * @default TreeItemContent
//    */
//   ContentComponent: elementTypeAcceptingRef,
//   /**
//    * Props applied to ContentComponent.
//    */
//   ContentProps: PropTypes__default.object,
//   /**
//    * If `true`, the node is disabled.
//    * @default false
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * The icon displayed next to an end node.
//    */
//   endIcon: PropTypes__default.node,
//   /**
//    * The icon used to expand the node.
//    */
//   expandIcon: PropTypes__default.node,
//   /**
//    * The icon to display next to the tree node's label.
//    */
//   icon: PropTypes__default.node,
//   /**
//    * The tree node label.
//    */
//   label: PropTypes__default.node,
//   /**
//    * The id of the node.
//    */
//   nodeId: PropTypes__default.string.isRequired,
//   /**
//    * This prop isn't supported.
//    * Use the `onNodeFocus` callback on the tree if you need to monitor a node's focus.
//    */
//   onFocus: unsupportedProp,
//   /**
//    * The system prop that allows defining system overrides as well as additional CSS styles.
//    */
//   sx: PropTypes__default.oneOfType([PropTypes__default.arrayOf(PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object, PropTypes__default.bool])), PropTypes__default.func, PropTypes__default.object]),
//   /**
//    * The component used for the transition.
//    * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
//    * @default Collapse
//    */
//   TransitionComponent: PropTypes__default.elementType,
//   /**
//    * Props applied to the transition element.
//    * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
//    */
//   TransitionProps: PropTypes__default.object
// } : void 0;

// /**
//  * A wrapper component for TreeItem.
//  *
//  */
// function TreeItem(_ref) {
//   var nodeId = _ref.nodeId,
//     label = _ref.label,
//     children = _ref.children,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     expandIcon = _ref.expandIcon,
//     endIcon = _ref.endIcon,
//     collapseIcon = _ref.collapseIcon,
//     icon = _ref.icon,
//     onClick = _ref.onClick;
//   return /*#__PURE__*/React__default.createElement(TreeItem$1, {
//     nodeId: nodeId,
//     label: label,
//     className: className,
//     disabled: disabled,
//     endIcon: endIcon,
//     expandIcon: expandIcon,
//     icon: icon,
//     collapseIcon: collapseIcon,
//     onClick: onClick
//   }, children);
// }
// TreeItem.propTypes = {
//   /**
//    * The id of the node.
//    */
//   nodeId: PropTypes__default.string,
//   /**
//    * The tree node label.
//    */
//   label: PropTypes__default.node,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * If true, the node is disabled.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The icon used to collapse the node.
//    */
//   collapseIcon: PropTypes__default.node,
//   /**
//    * The icon displayed next to a end node.
//    */
//   endIcon: PropTypes__default.node,
//   /**
//    * The icon used to expand the node.
//    */
//   expandIcon: PropTypes__default.node,
//   /**
//    * The icon to display next to the tree node's label.
//    */
//   icon: PropTypes__default.node,
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func
// };
// TreeItem.defaultProps = {
//   nodeId: '',
//   label: undefined,
//   children: undefined,
//   disabled: false,
//   className: undefined,
//   collapseIcon: undefined,
//   endIcon: undefined,
//   expandIcon: undefined,
//   icon: undefined,
//   onClick: undefined
// };

// function getTreeViewUtilityClass(slot) {
//   return generateUtilityClass('MuiTreeView', slot);
// }
// generateUtilityClasses('MuiTreeView', ['root']);

// /**
//  * Implements the same behavior as `useControlled` but for several models.
//  * The controlled models are never stored in the state and the state is only updated if the model is not controlled.
//  */
// const useTreeViewModels = (plugins, props) => {
//   const modelsRef = React.useRef({});
//   const [modelsState, setModelsState] = React.useState(() => {
//     const initialState = {};
//     plugins.forEach(plugin => {
//       if (plugin.models) {
//         Object.entries(plugin.models).forEach(([modelName, model]) => {
//           modelsRef.current[modelName] = {
//             controlledProp: model.controlledProp,
//             defaultProp: model.defaultProp,
//             isControlled: props[model.controlledProp] !== undefined
//           };
//           initialState[modelName] = props[model.defaultProp];
//         });
//       }
//     });
//     return initialState;
//   });
//   const models = Object.fromEntries(Object.entries(modelsRef.current).map(([modelName, model]) => {
//     const value = model.isControlled ? props[model.controlledProp] : modelsState[modelName];
//     return [modelName, {
//       value,
//       setValue: newValue => {
//         if (!model.isControlled) {
//           setModelsState(prevState => _extends$u({}, prevState, {
//             [modelName]: newValue
//           }));
//         }
//       }
//     }];
//   }));

//   // We know that `modelsRef` do not vary across renders.
//   /* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */
//   if (process.env.NODE_ENV !== 'production') {
//     Object.entries(modelsRef.current).forEach(([modelName, model]) => {
//       const controlled = props[model.controlledProp];
//       const defaultProp = props[model.defaultProp];
//       React.useEffect(() => {
//         if (model.isControlled !== (controlled !== undefined)) {
//           console.error([`MUI: A component is changing the ${model.isControlled ? '' : 'un'}controlled ${modelName} state of TreeView to be ${model.isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${modelName} ` + 'element for the lifetime of the component.', "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
//         }
//       }, [controlled]);
//       const {
//         current: defaultValue
//       } = React.useRef(defaultProp);
//       React.useEffect(() => {
//         if (!model.isControlled && defaultValue !== defaultProp) {
//           console.error([`MUI: A component is changing the default ${modelName} state of an uncontrolled TreeView after being initialized. ` + `To suppress this warning opt to use a controlled TreeView.`].join('\n'));
//         }
//       }, [JSON.stringify(defaultValue)]);
//     });
//   }
//   /* eslint-enable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */

//   return models;
// };

// // Used https://gist.github.com/mudge/5830382 as a starting point.
// // See https://github.com/browserify/events/blob/master/events.js for
// // the Node.js (https://nodejs.org/api/events.html) polyfill used by webpack.
// class EventManager {
//   constructor() {
//     this.maxListeners = 20;
//     this.warnOnce = false;
//     this.events = {};
//   }
//   on(eventName, listener, options = {}) {
//     let collection = this.events[eventName];
//     if (!collection) {
//       collection = {
//         highPriority: new Map(),
//         regular: new Map()
//       };
//       this.events[eventName] = collection;
//     }
//     if (options.isFirst) {
//       collection.highPriority.set(listener, true);
//     } else {
//       collection.regular.set(listener, true);
//     }
//     if (process.env.NODE_ENV !== 'production') {
//       const collectionSize = collection.highPriority.size + collection.regular.size;
//       if (collectionSize > this.maxListeners && !this.warnOnce) {
//         this.warnOnce = true;
//         console.warn([`Possible EventEmitter memory leak detected. ${collectionSize} ${eventName} listeners added.`].join('\n'));
//       }
//     }
//   }
//   removeListener(eventName, listener) {
//     if (this.events[eventName]) {
//       this.events[eventName].regular.delete(listener);
//       this.events[eventName].highPriority.delete(listener);
//     }
//   }
//   removeAllListeners() {
//     this.events = {};
//   }
//   emit(eventName, ...args) {
//     const collection = this.events[eventName];
//     if (!collection) {
//       return;
//     }
//     const highPriorityListeners = Array.from(collection.highPriority.keys());
//     const regularListeners = Array.from(collection.regular.keys());
//     for (let i = highPriorityListeners.length - 1; i >= 0; i -= 1) {
//       const listener = highPriorityListeners[i];
//       if (collection.highPriority.has(listener)) {
//         listener.apply(this, args);
//       }
//     }
//     for (let i = 0; i < regularListeners.length; i += 1) {
//       const listener = regularListeners[i];
//       if (collection.regular.has(listener)) {
//         listener.apply(this, args);
//       }
//     }
//   }
//   once(eventName, listener) {
//     // eslint-disable-next-line consistent-this
//     const that = this;
//     this.on(eventName, function oneTimeListener(...args) {
//       that.removeListener(eventName, oneTimeListener);
//       listener.apply(that, args);
//     });
//   }
// }

// const getPreviousNode = (instance, nodeId) => {
//   const node = instance.getNode(nodeId);
//   const siblings = instance.getNavigableChildrenIds(node.parentId);
//   const nodeIndex = siblings.indexOf(nodeId);
//   if (nodeIndex === 0) {
//     return node.parentId;
//   }
//   let currentNode = siblings[nodeIndex - 1];
//   while (instance.isNodeExpanded(currentNode) && instance.getNavigableChildrenIds(currentNode).length > 0) {
//     currentNode = instance.getNavigableChildrenIds(currentNode).pop();
//   }
//   return currentNode;
// };
// const getNextNode = (instance, nodeId) => {
//   // If expanded get first child
//   if (instance.isNodeExpanded(nodeId) && instance.getNavigableChildrenIds(nodeId).length > 0) {
//     return instance.getNavigableChildrenIds(nodeId)[0];
//   }
//   let node = instance.getNode(nodeId);
//   while (node != null) {
//     // Try to get next sibling
//     const siblings = instance.getNavigableChildrenIds(node.parentId);
//     const nextSibling = siblings[siblings.indexOf(node.id) + 1];
//     if (nextSibling) {
//       return nextSibling;
//     }

//     // If the sibling does not exist, go up a level to the parent and try again.
//     node = instance.getNode(node.parentId);
//   }
//   return null;
// };
// const getLastNode = instance => {
//   let lastNode = instance.getNavigableChildrenIds(null).pop();
//   while (instance.isNodeExpanded(lastNode)) {
//     lastNode = instance.getNavigableChildrenIds(lastNode).pop();
//   }
//   return lastNode;
// };
// const getFirstNode = instance => instance.getNavigableChildrenIds(null)[0];
// const populateInstance = (instance, methods) => {
//   Object.assign(instance, methods);
// };

// const isSyntheticEvent = event => {
//   return event.isPropagationStopped !== undefined;
// };

// /**
//  * Plugin responsible for the registration of the nodes defined as JSX children of the TreeView.
//  * When we will have both a SimpleTreeView using JSX children and a TreeView using a data prop,
//  * this plugin will only be used by SimpleTreeView.
//  */
// const useTreeViewInstanceEvents = ({
//   instance
// }) => {
//   const [eventManager] = React.useState(() => new EventManager());
//   const publishEvent = React.useCallback((...args) => {
//     const [name, params, event = {}] = args;
//     event.defaultMuiPrevented = false;
//     if (isSyntheticEvent(event) && event.isPropagationStopped()) {
//       return;
//     }
//     eventManager.emit(name, params, event);
//   }, [eventManager]);
//   const subscribeEvent = React.useCallback((event, handler) => {
//     eventManager.on(event, handler);
//     return () => {
//       eventManager.removeListener(event, handler);
//     };
//   }, [eventManager]);
//   populateInstance(instance, {
//     $$publishEvent: publishEvent,
//     $$subscribeEvent: subscribeEvent
//   });
// };

// /**
//  * Internal plugins that creates the tools used by the other plugins.
//  * These plugins are used by the tree view components.
//  */
// const TREE_VIEW_CORE_PLUGINS = [useTreeViewInstanceEvents];

// const useTreeView = inParams => {
//   const plugins = [...TREE_VIEW_CORE_PLUGINS, ...inParams.plugins];
//   const params = plugins.reduce((acc, plugin) => {
//     if (plugin.getDefaultizedParams) {
//       return plugin.getDefaultizedParams(acc);
//     }
//     return acc;
//   }, inParams);
//   const models = useTreeViewModels(plugins, params);
//   const instanceRef = React.useRef({});
//   const instance = instanceRef.current;
//   const innerRootRef = React.useRef(null);
//   const handleRootRef = useForkRef(innerRootRef, inParams.rootRef);
//   const [state, setState] = React.useState(() => {
//     const temp = {};
//     plugins.forEach(plugin => {
//       if (plugin.getInitialState) {
//         Object.assign(temp, plugin.getInitialState(params));
//       }
//     });
//     return temp;
//   });
//   const rootPropsGetters = [];
//   let contextValue = DEFAULT_TREE_VIEW_CONTEXT_VALUE;
//   const runPlugin = plugin => {
//     const pluginResponse = plugin({
//       instance,
//       params,
//       state,
//       setState,
//       rootRef: innerRootRef,
//       models
//     }) || {};
//     if (pluginResponse.getRootProps) {
//       rootPropsGetters.push(pluginResponse.getRootProps);
//     }
//     if (pluginResponse.contextValue) {
//       contextValue = pluginResponse.contextValue;
//     }
//   };
//   plugins.forEach(runPlugin);
//   const getRootProps = (otherHandlers = {}) => {
//     const rootProps = _extends$u({
//       role: 'tree',
//       tabIndex: 0
//     }, otherHandlers, {
//       ref: handleRootRef
//     });
//     rootPropsGetters.forEach(rootPropsGetter => {
//       Object.assign(rootProps, rootPropsGetter(otherHandlers));
//     });
//     return rootProps;
//   };
//   return {
//     getRootProps,
//     rootRef: handleRootRef,
//     contextValue
//   };
// };

// /**
//  * Sets up the contexts for the underlying TreeItem components.
//  *
//  * @ignore - do not document.
//  */
// function TreeViewProvider(props) {
//   const {
//     value,
//     children
//   } = props;
//   return /*#__PURE__*/jsx(TreeViewContext.Provider, {
//     value: value,
//     children: /*#__PURE__*/jsx(DescendantProvider, {
//       children: children
//     })
//   });
// }

// const publishTreeViewEvent = (instance, eventName, params) => {
//   instance.$$publishEvent(eventName, params);
// };

// const useTreeViewNodes = ({
//   instance,
//   params
// }) => {
//   const nodeMap = React.useRef({});
//   const getNode = React.useCallback(nodeId => nodeMap.current[nodeId], []);
//   const insertNode = React.useCallback(node => {
//     nodeMap.current[node.id] = node;
//   }, []);
//   const removeNode = React.useCallback(nodeId => {
//     const newMap = _extends$u({}, nodeMap.current);
//     delete newMap[nodeId];
//     nodeMap.current = newMap;
//     publishTreeViewEvent(instance, 'removeNode', {
//       id: nodeId
//     });
//   }, [instance]);
//   const isNodeDisabled = React.useCallback(nodeId => {
//     if (nodeId == null) {
//       return false;
//     }
//     let node = instance.getNode(nodeId);

//     // This can be called before the node has been added to the node map.
//     if (!node) {
//       return false;
//     }
//     if (node.disabled) {
//       return true;
//     }
//     while (node.parentId != null) {
//       node = instance.getNode(node.parentId);
//       if (node.disabled) {
//         return true;
//       }
//     }
//     return false;
//   }, [instance]);
//   const getChildrenIds = useEventCallback(nodeId => Object.values(nodeMap.current).filter(node => node.parentId === nodeId).sort((a, b) => a.index - b.index).map(child => child.id));
//   const getNavigableChildrenIds = nodeId => {
//     let childrenIds = instance.getChildrenIds(nodeId);
//     if (!params.disabledItemsFocusable) {
//       childrenIds = childrenIds.filter(node => !instance.isNodeDisabled(node));
//     }
//     return childrenIds;
//   };
//   populateInstance(instance, {
//     getNode,
//     updateNode: insertNode,
//     removeNode,
//     getChildrenIds,
//     getNavigableChildrenIds,
//     isNodeDisabled
//   });
// };

// const useTreeViewExpansion = ({
//   instance,
//   params,
//   models
// }) => {
//   const isNodeExpanded = React.useCallback(nodeId => {
//     return Array.isArray(models.expanded.value) ? models.expanded.value.indexOf(nodeId) !== -1 : false;
//   }, [models.expanded.value]);
//   const isNodeExpandable = React.useCallback(nodeId => {
//     var _instance$getNode;
//     return !!((_instance$getNode = instance.getNode(nodeId)) != null && _instance$getNode.expandable);
//   }, [instance]);
//   const toggleNodeExpansion = useEventCallback((event, nodeId) => {
//     if (nodeId == null) {
//       return;
//     }
//     let newExpanded;
//     if (models.expanded.value.indexOf(nodeId) !== -1) {
//       newExpanded = models.expanded.value.filter(id => id !== nodeId);
//     } else {
//       newExpanded = [nodeId].concat(models.expanded.value);
//     }
//     if (params.onNodeToggle) {
//       params.onNodeToggle(event, newExpanded);
//     }
//     models.expanded.setValue(newExpanded);
//   });
//   const expandAllSiblings = (event, nodeId) => {
//     const node = instance.getNode(nodeId);
//     const siblings = instance.getChildrenIds(node.parentId);
//     const diff = siblings.filter(child => instance.isNodeExpandable(child) && !instance.isNodeExpanded(child));
//     const newExpanded = models.expanded.value.concat(diff);
//     if (diff.length > 0) {
//       models.expanded.setValue(newExpanded);
//       if (params.onNodeToggle) {
//         params.onNodeToggle(event, newExpanded);
//       }
//     }
//   };
//   populateInstance(instance, {
//     isNodeExpanded,
//     isNodeExpandable,
//     toggleNodeExpansion,
//     expandAllSiblings
//   });
// };
// useTreeViewExpansion.models = {
//   expanded: {
//     controlledProp: 'expanded',
//     defaultProp: 'defaultExpanded'
//   }
// };
// const DEFAULT_EXPANDED = [];
// useTreeViewExpansion.getDefaultizedParams = params => {
//   var _params$defaultExpand;
//   return _extends$u({}, params, {
//     defaultExpanded: (_params$defaultExpand = params.defaultExpanded) != null ? _params$defaultExpand : DEFAULT_EXPANDED
//   });
// };

// /**
//  * This is used to determine the start and end of a selection range so
//  * we can get the nodes between the two border nodes.
//  *
//  * It finds the nodes' common ancestor using
//  * a naive implementation of a lowest common ancestor algorithm
//  * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).
//  * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB
//  * so we can compare their indexes to work out which node comes first in a depth first search.
//  * (https://en.wikipedia.org/wiki/Depth-first_search)
//  *
//  * Another way to put it is which node is shallower in a trémaux tree
//  * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree
//  */
// const findOrderInTremauxTree = (instance, nodeAId, nodeBId) => {
//   if (nodeAId === nodeBId) {
//     return [nodeAId, nodeBId];
//   }
//   const nodeA = instance.getNode(nodeAId);
//   const nodeB = instance.getNode(nodeBId);
//   if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {
//     return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];
//   }
//   const aFamily = [nodeA.id];
//   const bFamily = [nodeB.id];
//   let aAncestor = nodeA.parentId;
//   let bAncestor = nodeB.parentId;
//   let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
//   let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
//   let continueA = true;
//   let continueB = true;
//   while (!bAncestorIsCommon && !aAncestorIsCommon) {
//     if (continueA) {
//       aFamily.push(aAncestor);
//       aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
//       continueA = aAncestor !== null;
//       if (!aAncestorIsCommon && continueA) {
//         aAncestor = instance.getNode(aAncestor).parentId;
//       }
//     }
//     if (continueB && !aAncestorIsCommon) {
//       bFamily.push(bAncestor);
//       bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
//       continueB = bAncestor !== null;
//       if (!bAncestorIsCommon && continueB) {
//         bAncestor = instance.getNode(bAncestor).parentId;
//       }
//     }
//   }
//   const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
//   const ancestorFamily = instance.getChildrenIds(commonAncestor);
//   const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
//   const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
//   return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];
// };

// const useTreeViewSelection = ({
//   instance,
//   params,
//   models
// }) => {
//   const lastSelectedNode = React.useRef(null);
//   const lastSelectionWasRange = React.useRef(false);
//   const currentRangeSelection = React.useRef([]);
//   const isNodeSelected = nodeId => Array.isArray(models.selected.value) ? models.selected.value.indexOf(nodeId) !== -1 : models.selected.value === nodeId;
//   const selectNode = (event, nodeId, multiple = false) => {
//     if (params.disableSelection) {
//       return;
//     }
//     if (multiple) {
//       if (Array.isArray(models.selected.value)) {
//         let newSelected;
//         if (models.selected.value.indexOf(nodeId) !== -1) {
//           newSelected = models.selected.value.filter(id => id !== nodeId);
//         } else {
//           newSelected = [nodeId].concat(models.selected.value);
//         }
//         if (params.onNodeSelect) {
//           params.onNodeSelect(event, newSelected);
//         }
//         models.selected.setValue(newSelected);
//       }
//     } else {
//       const newSelected = params.multiSelect ? [nodeId] : nodeId;
//       if (params.onNodeSelect) {
//         params.onNodeSelect(event, newSelected);
//       }
//       models.selected.setValue(newSelected);
//     }
//     lastSelectedNode.current = nodeId;
//     lastSelectionWasRange.current = false;
//     currentRangeSelection.current = [];
//   };
//   const getNodesInRange = (nodeAId, nodeBId) => {
//     const [first, last] = findOrderInTremauxTree(instance, nodeAId, nodeBId);
//     const nodes = [first];
//     let current = first;
//     while (current !== last) {
//       current = getNextNode(instance, current);
//       nodes.push(current);
//     }
//     return nodes;
//   };
//   const handleRangeArrowSelect = (event, nodes) => {
//     let base = models.selected.value.slice();
//     const {
//       start,
//       next,
//       current
//     } = nodes;
//     if (!next || !current) {
//       return;
//     }
//     if (currentRangeSelection.current.indexOf(current) === -1) {
//       currentRangeSelection.current = [];
//     }
//     if (lastSelectionWasRange.current) {
//       if (currentRangeSelection.current.indexOf(next) !== -1) {
//         base = base.filter(id => id === start || id !== current);
//         currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);
//       } else {
//         base.push(next);
//         currentRangeSelection.current.push(next);
//       }
//     } else {
//       base.push(next);
//       currentRangeSelection.current.push(current, next);
//     }
//     if (params.onNodeSelect) {
//       params.onNodeSelect(event, base);
//     }
//     models.selected.setValue(base);
//   };
//   const handleRangeSelect = (event, nodes) => {
//     let base = models.selected.value.slice();
//     const {
//       start,
//       end
//     } = nodes;
//     // If last selection was a range selection ignore nodes that were selected.
//     if (lastSelectionWasRange.current) {
//       base = base.filter(id => currentRangeSelection.current.indexOf(id) === -1);
//     }
//     let range = getNodesInRange(start, end);
//     range = range.filter(node => !instance.isNodeDisabled(node));
//     currentRangeSelection.current = range;
//     let newSelected = base.concat(range);
//     newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);
//     if (params.onNodeSelect) {
//       params.onNodeSelect(event, newSelected);
//     }
//     models.selected.setValue(newSelected);
//   };
//   const selectRange = (event, nodes, stacked = false) => {
//     if (params.disableSelection) {
//       return;
//     }
//     const {
//       start = lastSelectedNode.current,
//       end,
//       current
//     } = nodes;
//     if (stacked) {
//       handleRangeArrowSelect(event, {
//         start,
//         next: end,
//         current
//       });
//     } else if (start != null && end != null) {
//       handleRangeSelect(event, {
//         start,
//         end
//       });
//     }
//     lastSelectionWasRange.current = true;
//   };
//   const rangeSelectToFirst = (event, nodeId) => {
//     if (!lastSelectedNode.current) {
//       lastSelectedNode.current = nodeId;
//     }
//     const start = lastSelectionWasRange.current ? lastSelectedNode.current : nodeId;
//     instance.selectRange(event, {
//       start,
//       end: getFirstNode(instance)
//     });
//   };
//   const rangeSelectToLast = (event, nodeId) => {
//     if (!lastSelectedNode.current) {
//       lastSelectedNode.current = nodeId;
//     }
//     const start = lastSelectionWasRange.current ? lastSelectedNode.current : nodeId;
//     instance.selectRange(event, {
//       start,
//       end: getLastNode(instance)
//     });
//   };
//   populateInstance(instance, {
//     isNodeSelected,
//     selectNode,
//     selectRange,
//     rangeSelectToLast,
//     rangeSelectToFirst
//   });
//   return {
//     getRootProps: () => ({
//       'aria-multiselectable': params.multiSelect
//     })
//   };
// };
// useTreeViewSelection.models = {
//   selected: {
//     controlledProp: 'selected',
//     defaultProp: 'defaultSelected'
//   }
// };
// const DEFAULT_SELECTED = [];
// useTreeViewSelection.getDefaultizedParams = params => {
//   var _params$disableSelect, _params$multiSelect, _params$defaultSelect;
//   return _extends$u({}, params, {
//     disableSelection: (_params$disableSelect = params.disableSelection) != null ? _params$disableSelect : false,
//     multiSelect: (_params$multiSelect = params.multiSelect) != null ? _params$multiSelect : false,
//     defaultSelected: (_params$defaultSelect = params.defaultSelected) != null ? _params$defaultSelect : params.multiSelect ? DEFAULT_SELECTED : null
//   });
// };

// // If no effect ran after this amount of time, we assume that the render was not committed by React
// const CLEANUP_TIMER_LOOP_MILLIS = 1000;
// class TimerBasedCleanupTracking {
//   constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
//     this.timeouts = new Map();
//     this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
//     this.cleanupTimeout = timeout;
//   }
//   register(object, unsubscribe, unregisterToken) {
//     if (!this.timeouts) {
//       this.timeouts = new Map();
//     }
//     const timeout = setTimeout(() => {
//       if (typeof unsubscribe === 'function') {
//         unsubscribe();
//       }
//       this.timeouts.delete(unregisterToken.cleanupToken);
//     }, this.cleanupTimeout);
//     this.timeouts.set(unregisterToken.cleanupToken, timeout);
//   }
//   unregister(unregisterToken) {
//     const timeout = this.timeouts.get(unregisterToken.cleanupToken);
//     if (timeout) {
//       this.timeouts.delete(unregisterToken.cleanupToken);
//       clearTimeout(timeout);
//     }
//   }
//   reset() {
//     if (this.timeouts) {
//       this.timeouts.forEach((value, key) => {
//         this.unregister({
//           cleanupToken: key
//         });
//       });
//       this.timeouts = undefined;
//     }
//   }
// }

// class FinalizationRegistryBasedCleanupTracking {
//   constructor() {
//     this.registry = new FinalizationRegistry(unsubscribe => {
//       if (typeof unsubscribe === 'function') {
//         unsubscribe();
//       }
//     });
//   }
//   register(object, unsubscribe, unregisterToken) {
//     this.registry.register(object, unsubscribe, unregisterToken);
//   }
//   unregister(unregisterToken) {
//     this.registry.unregister(unregisterToken);
//   }

//   // eslint-disable-next-line class-methods-use-this
//   reset() {}
// }

// // We use class to make it easier to detect in heap snapshots by name
// class ObjectToBeRetainedByReact {}

// // Based on https://github.com/Bnaya/use-dispose-uncommitted/blob/main/src/finalization-registry-based-impl.ts
// // Check https://github.com/facebook/react/issues/15317 to get more information
// function createUseInstanceEventHandler(registryContainer) {
//   let cleanupTokensCounter = 0;
//   return function useInstanceEventHandler(instance, eventName, handler) {
//     if (registryContainer.registry === null) {
//       registryContainer.registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
//     }
//     const [objectRetainedByReact] = React.useState(new ObjectToBeRetainedByReact());
//     const subscription = React.useRef(null);
//     const handlerRef = React.useRef();
//     handlerRef.current = handler;
//     const cleanupTokenRef = React.useRef(null);
//     if (!subscription.current && handlerRef.current) {
//       const enhancedHandler = (params, event) => {
//         if (!event.defaultMuiPrevented) {
//           var _handlerRef$current;
//           (_handlerRef$current = handlerRef.current) == null || _handlerRef$current.call(handlerRef, params, event);
//         }
//       };
//       subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
//       cleanupTokensCounter += 1;
//       cleanupTokenRef.current = {
//         cleanupToken: cleanupTokensCounter
//       };
//       registryContainer.registry.register(objectRetainedByReact,
//       // The callback below will be called once this reference stops being retained
//       () => {
//         var _subscription$current;
//         (_subscription$current = subscription.current) == null || _subscription$current.call(subscription);
//         subscription.current = null;
//         cleanupTokenRef.current = null;
//       }, cleanupTokenRef.current);
//     } else if (!handlerRef.current && subscription.current) {
//       subscription.current();
//       subscription.current = null;
//       if (cleanupTokenRef.current) {
//         registryContainer.registry.unregister(cleanupTokenRef.current);
//         cleanupTokenRef.current = null;
//       }
//     }
//     React.useEffect(() => {
//       if (!subscription.current && handlerRef.current) {
//         const enhancedHandler = (params, event) => {
//           if (!event.defaultMuiPrevented) {
//             var _handlerRef$current2;
//             (_handlerRef$current2 = handlerRef.current) == null || _handlerRef$current2.call(handlerRef, params, event);
//           }
//         };
//         subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
//       }
//       if (cleanupTokenRef.current && registryContainer.registry) {
//         // If the effect was called, it means that this render was committed
//         // so we can trust the cleanup function to remove the listener.
//         registryContainer.registry.unregister(cleanupTokenRef.current);
//         cleanupTokenRef.current = null;
//       }
//       return () => {
//         var _subscription$current2;
//         (_subscription$current2 = subscription.current) == null || _subscription$current2.call(subscription);
//         subscription.current = null;
//       };
//     }, [instance, eventName]);
//   };
// }
// const registryContainer = {
//   registry: null
// };
// const useInstanceEventHandler = createUseInstanceEventHandler(registryContainer);

// const useTreeViewFocus = ({
//   instance,
//   params,
//   state,
//   setState,
//   models,
//   rootRef
// }) => {
//   const setFocusedNodeId = useEventCallback(nodeId => {
//     const cleanNodeId = typeof nodeId === 'function' ? nodeId(state.focusedNodeId) : nodeId;
//     setState(prevState => _extends$u({}, prevState, {
//       focusedNodeId: cleanNodeId
//     }));
//   });
//   const isNodeFocused = React.useCallback(nodeId => state.focusedNodeId === nodeId, [state.focusedNodeId]);
//   const focusNode = useEventCallback((event, nodeId) => {
//     if (nodeId) {
//       setFocusedNodeId(nodeId);
//       if (params.onNodeFocus) {
//         params.onNodeFocus(event, nodeId);
//       }
//     }
//   });
//   populateInstance(instance, {
//     isNodeFocused,
//     focusNode
//   });
//   useInstanceEventHandler(instance, 'removeNode', ({
//     id
//   }) => {
//     setFocusedNodeId(oldFocusedNodeId => {
//       if (oldFocusedNodeId === id && rootRef.current === ownerDocument(rootRef.current).activeElement) {
//         return instance.getChildrenIds(null)[0];
//       }
//       return oldFocusedNodeId;
//     });
//   });
//   const createHandleFocus = otherHandlers => event => {
//     var _otherHandlers$onFocu;
//     (_otherHandlers$onFocu = otherHandlers.onFocus) == null || _otherHandlers$onFocu.call(otherHandlers, event);

//     // if the event bubbled (which is React specific) we don't want to steal focus
//     if (event.target === event.currentTarget) {
//       const isNodeVisible = nodeId => {
//         const node = instance.getNode(nodeId);
//         return node && (node.parentId == null || instance.isNodeExpanded(node.parentId));
//       };
//       let nodeToFocusId;
//       if (Array.isArray(models.selected.value)) {
//         nodeToFocusId = models.selected.value.find(isNodeVisible);
//       } else if (models.selected.value != null && isNodeVisible(models.selected.value)) {
//         nodeToFocusId = models.selected.value;
//       }
//       if (nodeToFocusId == null) {
//         nodeToFocusId = instance.getNavigableChildrenIds(null)[0];
//       }
//       instance.focusNode(event, nodeToFocusId);
//     }
//   };
//   const createHandleBlur = otherHandlers => event => {
//     var _otherHandlers$onBlur;
//     (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);
//     setFocusedNodeId(null);
//   };
//   const focusedNode = instance.getNode(state.focusedNodeId);
//   const activeDescendant = focusedNode ? focusedNode.idAttribute : null;
//   return {
//     getRootProps: otherHandlers => ({
//       onFocus: createHandleFocus(otherHandlers),
//       onBlur: createHandleBlur(otherHandlers),
//       'aria-activedescendant': activeDescendant != null ? activeDescendant : undefined
//     })
//   };
// };
// useTreeViewFocus.getInitialState = () => ({
//   focusedNodeId: null
// });
// useTreeViewFocus.getDefaultizedParams = params => {
//   var _params$disabledItems;
//   return _extends$u({}, params, {
//     disabledItemsFocusable: (_params$disabledItems = params.disabledItemsFocusable) != null ? _params$disabledItems : false
//   });
// };

// function isPrintableCharacter(string) {
//   return string && string.length === 1 && string.match(/\S/);
// }
// function findNextFirstChar(firstChars, startIndex, char) {
//   for (let i = startIndex; i < firstChars.length; i += 1) {
//     if (char === firstChars[i]) {
//       return i;
//     }
//   }
//   return -1;
// }
// const useTreeViewKeyboardNavigation = ({
//   instance,
//   params,
//   state
// }) => {
//   const theme = useTheme$2();
//   const isRtl = theme.direction === 'rtl';
//   const firstCharMap = React.useRef({});
//   const mapFirstChar = useEventCallback((nodeId, firstChar) => {
//     firstCharMap.current[nodeId] = firstChar;
//     return () => {
//       const newMap = _extends$u({}, firstCharMap.current);
//       delete newMap[nodeId];
//       firstCharMap.current = newMap;
//     };
//   });
//   populateInstance(instance, {
//     mapFirstChar
//   });
//   const handleNextArrow = event => {
//     if (state.focusedNodeId != null && instance.isNodeExpandable(state.focusedNodeId)) {
//       if (instance.isNodeExpanded(state.focusedNodeId)) {
//         instance.focusNode(event, getNextNode(instance, state.focusedNodeId));
//       } else if (!instance.isNodeDisabled(state.focusedNodeId)) {
//         instance.toggleNodeExpansion(event, state.focusedNodeId);
//       }
//     }
//     return true;
//   };
//   const handlePreviousArrow = event => {
//     if (state.focusedNodeId == null) {
//       return false;
//     }
//     if (instance.isNodeExpanded(state.focusedNodeId) && !instance.isNodeDisabled(state.focusedNodeId)) {
//       instance.toggleNodeExpansion(event, state.focusedNodeId);
//       return true;
//     }
//     const parent = instance.getNode(state.focusedNodeId).parentId;
//     if (parent) {
//       instance.focusNode(event, parent);
//       return true;
//     }
//     return false;
//   };
//   const focusByFirstCharacter = (event, nodeId, firstChar) => {
//     let start;
//     let index;
//     const lowercaseChar = firstChar.toLowerCase();
//     const firstCharIds = [];
//     const firstChars = [];
//     // This really only works since the ids are strings
//     Object.keys(firstCharMap.current).forEach(mapNodeId => {
//       const map = instance.getNode(mapNodeId);
//       const visible = map.parentId ? instance.isNodeExpanded(map.parentId) : true;
//       const shouldBeSkipped = params.disabledItemsFocusable ? false : instance.isNodeDisabled(mapNodeId);
//       if (visible && !shouldBeSkipped) {
//         firstCharIds.push(mapNodeId);
//         firstChars.push(firstCharMap.current[mapNodeId]);
//       }
//     });

//     // Get start index for search based on position of currentItem
//     start = firstCharIds.indexOf(nodeId) + 1;
//     if (start >= firstCharIds.length) {
//       start = 0;
//     }

//     // Check remaining slots in the menu
//     index = findNextFirstChar(firstChars, start, lowercaseChar);

//     // If not found in remaining slots, check from beginning
//     if (index === -1) {
//       index = findNextFirstChar(firstChars, 0, lowercaseChar);
//     }

//     // If match was found...
//     if (index > -1) {
//       instance.focusNode(event, firstCharIds[index]);
//     }
//   };
//   const selectNextNode = (event, id) => {
//     if (!instance.isNodeDisabled(getNextNode(instance, id))) {
//       instance.selectRange(event, {
//         end: getNextNode(instance, id),
//         current: id
//       }, true);
//     }
//   };
//   const selectPreviousNode = (event, nodeId) => {
//     if (!instance.isNodeDisabled(getPreviousNode(instance, nodeId))) {
//       instance.selectRange(event, {
//         end: getPreviousNode(instance, nodeId),
//         current: nodeId
//       }, true);
//     }
//   };
//   const createHandleKeyDown = otherHandlers => event => {
//     var _otherHandlers$onKeyD;
//     (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
//     let flag = false;
//     const key = event.key;

//     // If the tree is empty there will be no focused node
//     if (event.altKey || event.currentTarget !== event.target || state.focusedNodeId == null) {
//       return;
//     }
//     const ctrlPressed = event.ctrlKey || event.metaKey;
//     switch (key) {
//       case ' ':
//         if (!params.disableSelection && !instance.isNodeDisabled(state.focusedNodeId)) {
//           flag = true;
//           if (params.multiSelect && event.shiftKey) {
//             instance.selectRange(event, {
//               end: state.focusedNodeId
//             });
//           } else if (params.multiSelect) {
//             instance.selectNode(event, state.focusedNodeId, true);
//           } else {
//             instance.selectNode(event, state.focusedNodeId);
//           }
//         }
//         event.stopPropagation();
//         break;
//       case 'Enter':
//         if (!instance.isNodeDisabled(state.focusedNodeId)) {
//           if (instance.isNodeExpandable(state.focusedNodeId)) {
//             instance.toggleNodeExpansion(event, state.focusedNodeId);
//             flag = true;
//           } else if (!params.disableSelection) {
//             flag = true;
//             if (params.multiSelect) {
//               instance.selectNode(event, state.focusedNodeId, true);
//             } else {
//               instance.selectNode(event, state.focusedNodeId);
//             }
//           }
//         }
//         event.stopPropagation();
//         break;
//       case 'ArrowDown':
//         if (params.multiSelect && event.shiftKey && !params.disableSelection) {
//           selectNextNode(event, state.focusedNodeId);
//         }
//         instance.focusNode(event, getNextNode(instance, state.focusedNodeId));
//         flag = true;
//         break;
//       case 'ArrowUp':
//         if (params.multiSelect && event.shiftKey && !params.disableSelection) {
//           selectPreviousNode(event, state.focusedNodeId);
//         }
//         instance.focusNode(event, getPreviousNode(instance, state.focusedNodeId));
//         flag = true;
//         break;
//       case 'ArrowRight':
//         if (isRtl) {
//           flag = handlePreviousArrow(event);
//         } else {
//           flag = handleNextArrow(event);
//         }
//         break;
//       case 'ArrowLeft':
//         if (isRtl) {
//           flag = handleNextArrow(event);
//         } else {
//           flag = handlePreviousArrow(event);
//         }
//         break;
//       case 'Home':
//         if (params.multiSelect && ctrlPressed && event.shiftKey && !params.disableSelection && !instance.isNodeDisabled(state.focusedNodeId)) {
//           instance.rangeSelectToFirst(event, state.focusedNodeId);
//         }
//         instance.focusNode(event, getFirstNode(instance));
//         flag = true;
//         break;
//       case 'End':
//         if (params.multiSelect && ctrlPressed && event.shiftKey && !params.disableSelection && !instance.isNodeDisabled(state.focusedNodeId)) {
//           instance.rangeSelectToLast(event, state.focusedNodeId);
//         }
//         instance.focusNode(event, getLastNode(instance));
//         flag = true;
//         break;
//       default:
//         if (key === '*') {
//           instance.expandAllSiblings(event, state.focusedNodeId);
//           flag = true;
//         } else if (params.multiSelect && ctrlPressed && key.toLowerCase() === 'a' && !params.disableSelection) {
//           instance.selectRange(event, {
//             start: getFirstNode(instance),
//             end: getLastNode(instance)
//           });
//           flag = true;
//         } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {
//           focusByFirstCharacter(event, state.focusedNodeId, key);
//           flag = true;
//         }
//     }
//     if (flag) {
//       event.preventDefault();
//       event.stopPropagation();
//     }
//   };
//   return {
//     getRootProps: otherHandlers => ({
//       onKeyDown: createHandleKeyDown(otherHandlers)
//     })
//   };
// };

// const useTreeViewContextValueBuilder = ({
//   instance,
//   params
// }) => {
//   const treeId = useId$1(params.id);
//   return {
//     getRootProps: () => ({
//       id: treeId
//     }),
//     contextValue: {
//       treeId,
//       instance: instance,
//       multiSelect: params.multiSelect,
//       disabledItemsFocusable: params.disabledItemsFocusable,
//       icons: {
//         defaultCollapseIcon: params.defaultCollapseIcon,
//         defaultEndIcon: params.defaultEndIcon,
//         defaultExpandIcon: params.defaultExpandIcon,
//         defaultParentIcon: params.defaultParentIcon
//       }
//     }
//   };
// };

// const DEFAULT_TREE_VIEW_PLUGINS = [useTreeViewNodes, useTreeViewExpansion, useTreeViewSelection, useTreeViewFocus, useTreeViewKeyboardNavigation, useTreeViewContextValueBuilder];

// // We can't infer this type from the plugin, otherwise we would lose the generics.

// const _excluded$o = ["disabledItemsFocusable", "expanded", "defaultExpanded", "onNodeToggle", "onNodeFocus", "disableSelection", "defaultSelected", "selected", "multiSelect", "onNodeSelect", "id", "defaultCollapseIcon", "defaultEndIcon", "defaultExpandIcon", "defaultParentIcon", "children"];
// const useUtilityClasses = ownerState => {
//   const {
//     classes
//   } = ownerState;
//   const slots = {
//     root: ['root']
//   };
//   return composeClasses(slots, getTreeViewUtilityClass, classes);
// };
// const TreeViewRoot = styled$1('ul', {
//   name: 'MuiTreeView',
//   slot: 'Root',
//   overridesResolver: (props, styles) => styles.root
// })({
//   padding: 0,
//   margin: 0,
//   listStyle: 'none',
//   outline: 0
// });
// /**
//  *
//  * Demos:
//  *
//  * - [Tree View](https://mui.com/x/react-tree-view/)
//  *
//  * API:
//  *
//  * - [TreeView API](https://mui.com/x/api/tree-view/tree-view/)
//  */
// const TreeView$1 = /*#__PURE__*/React.forwardRef(function TreeView(inProps, ref) {
//   const themeProps = useThemeProps({
//     props: inProps,
//     name: 'MuiTreeView'
//   });
//   const ownerState = themeProps;
//   const _ref = themeProps,
//     {
//       // Headless implementation
//       disabledItemsFocusable,
//       expanded,
//       defaultExpanded,
//       onNodeToggle,
//       onNodeFocus,
//       disableSelection,
//       defaultSelected,
//       selected,
//       multiSelect,
//       onNodeSelect,
//       id,
//       defaultCollapseIcon,
//       defaultEndIcon,
//       defaultExpandIcon,
//       defaultParentIcon,
//       // Component implementation
//       children
//     } = _ref,
//     other = _objectWithoutPropertiesLoose$k(_ref, _excluded$o);
//   const {
//     getRootProps,
//     contextValue
//   } = useTreeView({
//     disabledItemsFocusable,
//     expanded,
//     defaultExpanded,
//     onNodeToggle,
//     onNodeFocus,
//     disableSelection,
//     defaultSelected,
//     selected,
//     multiSelect,
//     onNodeSelect,
//     id,
//     defaultCollapseIcon,
//     defaultEndIcon,
//     defaultExpandIcon,
//     defaultParentIcon,
//     plugins: DEFAULT_TREE_VIEW_PLUGINS,
//     rootRef: ref
//   });
//   const classes = useUtilityClasses(themeProps);
//   const rootProps = useSlotProps({
//     elementType: TreeViewRoot,
//     externalSlotProps: {},
//     externalForwardedProps: other,
//     className: classes.root,
//     getSlotProps: getRootProps,
//     ownerState
//   });
//   return /*#__PURE__*/jsx(TreeViewProvider, {
//     value: contextValue,
//     children: /*#__PURE__*/jsx(TreeViewRoot, _extends$u({}, rootProps, {
//       children: children
//     }))
//   });
// });
// process.env.NODE_ENV !== "production" ? TreeView$1.propTypes = {
//   // ----------------------------- Warning --------------------------------
//   // | These PropTypes are generated from the TypeScript type definitions |
//   // | To update them edit the TypeScript types and run "yarn proptypes"  |
//   // ----------------------------------------------------------------------
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Override or extend the styles applied to the component.
//    */
//   classes: PropTypes__default.object,
//   /**
//    * className applied to the root element.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The default icon used to collapse the node.
//    */
//   defaultCollapseIcon: PropTypes__default.node,
//   /**
//    * The default icon displayed next to a end node. This is applied to all
//    * tree nodes and can be overridden by the TreeItem `icon` prop.
//    */
//   defaultEndIcon: PropTypes__default.node,
//   /**
//    * Expanded node ids.
//    * Used when the item's expansion is not controlled.
//    * @default []
//    */
//   defaultExpanded: PropTypes__default.arrayOf(PropTypes__default.string),
//   /**
//    * The default icon used to expand the node.
//    */
//   defaultExpandIcon: PropTypes__default.node,
//   /**
//    * The default icon displayed next to a parent node. This is applied to all
//    * parent nodes and can be overridden by the TreeItem `icon` prop.
//    */
//   defaultParentIcon: PropTypes__default.node,
//   /**
//    * Selected node ids. (Uncontrolled)
//    * When `multiSelect` is true this takes an array of strings; when false (default) a string.
//    * @default []
//    */
//   defaultSelected: PropTypes__default /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes__default.arrayOf(PropTypes__default.string), PropTypes__default.string]),
//   /**
//    * If `true`, will allow focus on disabled items.
//    * @default false
//    */
//   disabledItemsFocusable: PropTypes__default.bool,
//   /**
//    * If `true` selection is disabled.
//    * @default false
//    */
//   disableSelection: PropTypes__default.bool,
//   /**
//    * Expanded node ids.
//    * Used when the item's expansion is controlled.
//    */
//   expanded: PropTypes__default.arrayOf(PropTypes__default.string),
//   /**
//    * This prop is used to help implement the accessibility logic.
//    * If you don't provide this prop. It falls back to a randomly generated id.
//    */
//   id: PropTypes__default.string,
//   /**
//    * If true `ctrl` and `shift` will trigger multiselect.
//    * @default false
//    */
//   multiSelect: PropTypes__default.bool,
//   /**
//    * Callback fired when tree items are focused.
//    * @param {React.SyntheticEvent} event The event source of the callback **Warning**: This is a generic event not a focus event.
//    * @param {string} nodeId The id of the node focused.
//    * @param {string} value of the focused node.
//    */
//   onNodeFocus: PropTypes__default.func,
//   /**
//    * Callback fired when tree items are selected/unselected.
//    * @param {React.SyntheticEvent} event The event source of the callback
//    * @param {string[] | string} nodeIds Ids of the selected nodes. When `multiSelect` is true
//    * this is an array of strings; when false (default) a string.
//    */
//   onNodeSelect: PropTypes__default.func,
//   /**
//    * Callback fired when tree items are expanded/collapsed.
//    * @param {React.SyntheticEvent} event The event source of the callback.
//    * @param {array} nodeIds The ids of the expanded nodes.
//    */
//   onNodeToggle: PropTypes__default.func,
//   /**
//    * Selected node ids. (Controlled)
//    * When `multiSelect` is true this takes an array of strings; when false (default) a string.
//    */
//   selected: PropTypes__default.any,
//   /**
//    * The system prop that allows defining system overrides as well as additional CSS styles.
//    */
//   sx: PropTypes__default.oneOfType([PropTypes__default.arrayOf(PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.object, PropTypes__default.bool])), PropTypes__default.func, PropTypes__default.object])
// } : void 0;

// var _templateObject$18;
// var StyledTreeView = styled(TreeView$1)(_templateObject$18 || (_templateObject$18 = _taggedTemplateLiteral$1(["\n.MuiTreeItem-label{\n  padding: 0.063rem\n}"])));

// /**
//  * A tree view widget presents a hierarchical list.
//  *
//  */
// function TreeView(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     defaultCollapseIcon = _ref.defaultCollapseIcon,
//     defaultExpandIcon = _ref.defaultExpandIcon,
//     defaultEndIcon = _ref.defaultEndIcon,
//     defaultExpanded = _ref.defaultExpanded,
//     defaultParentIcon = _ref.defaultParentIcon,
//     defaultSelected = _ref.defaultSelected,
//     disabledItemsFocusable = _ref.disabledItemsFocusable,
//     disableSelection = _ref.disableSelection,
//     expanded = _ref.expanded,
//     id = _ref.id,
//     multiSelect = _ref.multiSelect,
//     onNodeFocus = _ref.onNodeFocus,
//     onNodeSelect = _ref.onNodeSelect,
//     onNodeToggle = _ref.onNodeToggle,
//     selected = _ref.selected;
//   return /*#__PURE__*/React__default.createElement(StyledTreeView, {
//     defaultCollapseIcon: defaultCollapseIcon,
//     defaultExpandIcon: defaultExpandIcon,
//     defaultEndIcon: defaultEndIcon,
//     className: className,
//     defaultExpanded: defaultExpanded,
//     defaultParentIcon: defaultParentIcon,
//     defaultSelected: defaultSelected,
//     disabledItemsFocusable: disabledItemsFocusable,
//     disableSelection: disableSelection,
//     expanded: expanded,
//     id: id,
//     multiSelect: multiSelect,
//     onNodeFocus: onNodeFocus,
//     onNodeSelect: onNodeSelect,
//     onNodeToggle: onNodeToggle,
//     selected: selected
//   }, children);
// }
// TreeView.propTypes = {
//   /**
//    * The default icon used to collapse the node.
//    */
//   defaultCollapseIcon: PropTypes__default.node,
//   /**
//    * The default icon used to expand the node.
//    */
//   defaultExpandIcon: PropTypes__default.node,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * The default icon displayed next to a end node.
//    */
//   defaultEndIcon: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Expanded node ids.
//    */
//   defaultExpanded: PropTypes__default.arrayOf(PropTypes__default.string),
//   /**
//    * The default icon displayed next to a parent node
//    */
//   defaultParentIcon: PropTypes__default.node,
//   /**
//    * Selected node ids. (Uncontrolled) When multiSelect is true this takes an array of strings; when false (default) a string.
//    */
//   defaultSelected: PropTypes__default.arrayOf(PropTypes__default.string),
//   /**
//    * If true, will allow focus on disabled items.
//    */
//   disabledItemsFocusable: PropTypes__default.bool,
//   /**
//    * If true selection is disabled.
//    */
//   disableSelection: PropTypes__default.bool,
//   /**
//    * Expanded node ids.
//    */
//   expanded: PropTypes__default.arrayOf(PropTypes__default.string),
//   /**
//    * This prop is used to help implement the accessibility logic.
//    */
//   id: PropTypes__default.string,
//   /**
//    * If true ctrl and shift will trigger multiselect.
//    */
//   multiSelect: PropTypes__default.node,
//   /**
//    * Callback fired when tree items are focused.
//    */
//   onNodeFocus: PropTypes__default.func,
//   /**
//    * Callback fired when tree items are selected/unselected.
//    */
//   onNodeSelect: PropTypes__default.func,
//   /**
//    * Callback fired when tree items are expanded/collapsed.
//    */
//   onNodeToggle: PropTypes__default.func,
//   /**
//    * Selected node ids. (Controlled) When multiSelect is true this takes an array of strings; when false (default) a string.
//    */
//   selected: PropTypes__default.arrayOf(PropTypes__default.string)
// };
// TreeView.defaultProps = {
//   children: undefined,
//   defaultCollapseIcon: undefined,
//   defaultExpandIcon: undefined,
//   defaultEndIcon: undefined,
//   className: undefined,
//   defaultExpanded: undefined,
//   defaultParentIcon: undefined,
//   defaultSelected: undefined,
//   disabledItemsFocusable: undefined,
//   disableSelection: undefined,
//   expanded: undefined,
//   id: undefined,
//   multiSelect: undefined,
//   onNodeFocus: undefined,
//   onNodeSelect: undefined,
//   onNodeToggle: undefined,
//   selected: undefined
// };

// var TableRowContext = /*#__PURE__*/createContext({});

// function LabelCell() {
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue;
//   return cellValue;
// }
// LabelCell.propTypes = {
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string
// };
// LabelCell.defaultProps = {
//   className: undefined
// };

// var _templateObject$17;
// var StyledCheckbox$1 = styled(MuiCheckbox)(_templateObject$17 || (_templateObject$17 = _taggedTemplateLiteral$1(["\n  .MuiSvgIcon-root {\n    height: 1.25rem;\n    width: 1.25rem;\n  }\n"])));

// /**
//  * Checkboxes let users select one or more items from a list, or turn an item on or off.
//  */
// function Checkbox(_ref) {
//   var checked = _ref.checked,
//     value = _ref.value,
//     disabled = _ref.disabled,
//     onChange = _ref.onChange,
//     ariaLabel = _ref.ariaLabel,
//     inputProps = _ref.inputProps,
//     innerRef = _ref.innerRef,
//     className = _ref.className,
//     ariaLabelledBy = _ref.ariaLabelledBy,
//     disableRipple = _ref.disableRipple,
//     tabIndex = _ref.tabIndex,
//     id = _ref.id,
//     indeterminate = _ref.indeterminate;
//   return /*#__PURE__*/React__default.createElement(StyledCheckbox$1, {
//     checked: checked,
//     value: value,
//     color: "primary",
//     disabled: disabled,
//     onChange: onChange,
//     size: "small",
//     inputProps: _objectSpread2$1(_objectSpread2$1({}, inputProps), {}, {
//       'aria-label': ariaLabel,
//       'aria-labelledby': ariaLabelledBy
//     }),
//     ref: innerRef,
//     className: className,
//     tabIndex: tabIndex,
//     disableRipple: disableRipple,
//     id: id,
//     indeterminate: indeterminate
//   });
// }
// Checkbox.propTypes = {
//   /**
//    * If `true`, the component is checked.
//    */
//   checked: PropTypes__default.bool,
//   /**
//    * value of the selected radio button
//    */
//   value: PropTypes__default.string,
//   /**
//    * If `true`, the radio will be disabled. Keep this undefined to control from FormGroup
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Callback fired when the state is changed.
//    *
//    * @param {object} event The event source of the callback.
//    * You can pull out the new value by accessing `event.target.value` (string).
//    * You can pull out the new checked state by accessing `event.target.checked` (boolean).
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for input field
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * Element ref
//    */
//   innerRef: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.func]),
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * ariaLabelledBy prop for input
//    */
//   ariaLabelledBy: PropTypes__default.string,
//   /**
//    * If true, the  ripple effect will be disabled
//    */
//   disableRipple: PropTypes__default.bool,
//   /**
//    * To set tabindex
//    */
//   tabIndex: PropTypes__default.number,
//   /**
//    * The id of the input element.
//    */
//   id: PropTypes__default.string,
//   /**
//    * To set indeterminate
//    */
//   indeterminate: PropTypes__default.bool
// };
// Checkbox.defaultProps = {
//   value: '',
//   disabled: undefined,
//   checked: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   ariaLabel: null,
//   inputProps: undefined,
//   innerRef: undefined,
//   className: '',
//   ariaLabelledBy: undefined,
//   disableRipple: false,
//   tabIndex: undefined,
//   id: undefined,
//   indeterminate: false
// };

// var _templateObject$16;
// var StyledCheckbox = styled(Checkbox)(_templateObject$16 || (_templateObject$16 = _taggedTemplateLiteral$1(["\n  padding: 0rem;\n"])));

// var _excluded$n = ["indeterminate", "ariaLabelledBy", "className"];
// var CheckboxCellWrapper = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
//   var indeterminate = _ref.indeterminate,
//     ariaLabelledBy = _ref.ariaLabelledBy,
//     className = _ref.className,
//     rest = _objectWithoutProperties$j(_ref, _excluded$n);
//   var defaultRef = React__default.useRef();
//   var resolvedRef = ref || defaultRef;
//   React__default.useEffect(function () {
//     resolvedRef.current.indeterminate = indeterminate;
//   }, [resolvedRef, indeterminate]);
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(StyledCheckbox, _extends$v({
//     innerRef: resolvedRef
//   }, rest, {
//     ariaLabelledBy: ariaLabelledBy,
//     className: className
//   })));
// });
// var CheckboxHeaderWrapper = function CheckboxHeaderWrapper(getToggleAllPageRowsSelectedProps, ariaLabel, className) {
//   return /*#__PURE__*/React__default.createElement(StyledCheckbox, _extends$v({}, getToggleAllPageRowsSelectedProps(), {
//     ariaLabel: ariaLabel,
//     className: className
//   }));
// };
// var CheckboxCell = function CheckboxCell(_ref2) {
//   var ariaLabelledByPropName = _ref2.ariaLabelledByPropName,
//     actionMode = _ref2.actionMode,
//     className = _ref2.className,
//     disabled = _ref2.disabled,
//     onChange = _ref2.onChange;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue,
//     cell = _useContext.cell,
//     row = _useContext.row;
//   if (actionMode === 1 && row.original.id === 'id_add') {
//     return /*#__PURE__*/React__default.createElement(LabelCell, null);
//   }
//   var handleClick = function handleClick(event) {
//     onChange(event, cell.props.row.id);
//   };
//   if (actionMode === 2) {
//     return /*#__PURE__*/React__default.createElement(StyledCheckbox, {
//       ariaLabelledBy: ariaLabelledByPropName,
//       className: className,
//       checked: cellValue,
//       disabled: disabled,
//       onChange: handleClick
//     });
//   }
//   return /*#__PURE__*/React__default.createElement(CheckboxCellWrapper, _extends$v({}, row.getToggleRowSelectedProps(), {
//     ariaLabelledBy: "".concat(row.index, "_").concat(ariaLabelledByPropName),
//     className: className
//   }));
// };
// var CheckboxHeader = function CheckboxHeader(ariaLabel, className) {
//   return {
//     id: 'selection',
//     Header: function Header(_ref3) {
//       var getToggleAllPageRowsSelectedProps = _ref3.getToggleAllPageRowsSelectedProps;
//       return CheckboxHeaderWrapper(getToggleAllPageRowsSelectedProps, ariaLabel, className);
//     },
//     label: ''
//   };
// };

// // CheckboxCellWrapper props
// CheckboxCellWrapper.propTypes = {
//   indeterminate: PropTypes__default.bool,
//   ariaLabelledBy: PropTypes__default.string,
//   actionMode: PropTypes__default.number,
//   className: PropTypes__default.string
// };
// CheckboxCellWrapper.defaultProps = {
//   indeterminate: false,
//   ariaLabelledBy: undefined,
//   actionMode: null,
//   className: undefined
// };

// // CheckboxHeaderWrapper props
// CheckboxHeaderWrapper.propTypes = {
//   getToggleAllPageRowsSelectedProps: PropTypes__default.func,
//   ariaLabel: PropTypes__default.string,
//   className: PropTypes__default.string
// };
// CheckboxHeaderWrapper.defaultProps = {
//   getToggleAllPageRowsSelectedProps: PropTypes__default.func,
//   ariaLabel: '',
//   className: undefined
// };

// // CheckboxCell props
// CheckboxCell.propTypes = {
//   /**
//    * Adds aria-labelledby prop
//    */
//   ariaLabelledByPropName: PropTypes__default.string,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   actionMode: PropTypes__default.number,
//   /**
//    * Checkbox disable
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Checkbox change callback func
//    */
//   onChange: PropTypes__default.func
// };
// CheckboxCell.defaultProps = {
//   ariaLabelledByPropName: '',
//   className: undefined,
//   actionMode: null,
//   disabled: false,
//   onChange: undefined
// };

// var _templateObject$15;
// var StyledRadioButton = styled(Radio)(_templateObject$15 || (_templateObject$15 = _taggedTemplateLiteral$1(["\n  padding: 0rem;\n"])));

// var _excluded$m = ["ariaLabelledBy", "className"];
// var RadioButtonCellWrapper = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
//   var ariaLabelledBy = _ref.ariaLabelledBy,
//     className = _ref.className,
//     rest = _objectWithoutProperties$j(_ref, _excluded$m);
//   var defaultRef = React__default.useRef();
//   var resolvedRef = ref || defaultRef;
//   React__default.useEffect(function () {
//     // resolvedRef.current.indeterminate = indeterminate;
//   }, [resolvedRef]);
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(StyledRadioButton, _extends$v({
//     innerRef: resolvedRef
//   }, rest, {
//     ariaLabelledBy: ariaLabelledBy,
//     className: className
//   })));
// });
// var RadioButtonCell = function RadioButtonCell(_ref2) {
//   var ariaLabelledByPropName = _ref2.ariaLabelledByPropName,
//     actionMode = _ref2.actionMode,
//     className = _ref2.className;
//   var _useContext = useContext(TableRowContext),
//     row = _useContext.row;
//   if (actionMode === 1 && row.original.id === 'id_add') {
//     return /*#__PURE__*/React__default.createElement(LabelCell, null);
//   }
//   return /*#__PURE__*/React__default.createElement(RadioButtonCellWrapper, _extends$v({}, row.getToggleRowSelectedProps(), {
//     ariaLabelledBy: "".concat(row.index, "_").concat(ariaLabelledByPropName),
//     className: className
//   }));
// };

// // RadioButtonCellWrapper props
// RadioButtonCellWrapper.propTypes = {
//   indeterminate: PropTypes__default.bool,
//   ariaLabelledBy: PropTypes__default.string,
//   actionMode: PropTypes__default.number,
//   className: PropTypes__default.string
// };
// RadioButtonCellWrapper.defaultProps = {
//   indeterminate: false,
//   ariaLabelledBy: undefined,
//   actionMode: null,
//   className: undefined
// };

// // RadioButtonCell props
// RadioButtonCell.propTypes = {
//   /**
//    * Adds aria-labelledby prop
//    */
//   ariaLabelledByPropName: PropTypes__default.string,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   actionMode: PropTypes__default.number
// };
// RadioButtonCell.defaultProps = {
//   ariaLabelledByPropName: '',
//   className: undefined,
//   actionMode: null
// };

// var _templateObject$14;

// // giving it a fixed height of 34px,
// // but we will change this implementation when we take Image changes requirement in next sprints
// var Img = styled.img(_templateObject$14 || (_templateObject$14 = _taggedTemplateLiteral$1(["\n  max-height: 2rem;\n  max-width: 25rem;\n  "])));

// /**
//  * The Image component is used to display images with support for fallback.
//  */
// function Image$1(_ref) {
//   var src = _ref.src,
//     alt = _ref.alt,
//     className = _ref.className,
//     id = _ref.id;
//   return /*#__PURE__*/React__default.createElement(Img, {
//     src: src,
//     alt: alt,
//     className: className,
//     id: id
//   });
// }
// Image$1.propTypes = {
//   /**
//    * source url of the image
//    */
//   src: PropTypes__default.string,
//   /**
//    * alternate text of image
//    */
//   alt: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Id property for the image element.
//    */
//   id: PropTypes__default.string
// };
// Image$1.defaultProps = {
//   src: '',
//   alt: 'image not found',
//   className: '',
//   id: ''
// };

// var _templateObject$13, _templateObject2$M, _templateObject3$u, _templateObject4$h, _templateObject5$b;
// var AccessDeniedText = styled.div(_templateObject$13 || (_templateObject$13 = _taggedTemplateLiteral$1(["\n  padding-top: 1.5rem;\n  text-align: center;\n  font-size: 1.5rem;\n  letter-spacing: 0rem;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.textColor;
// });
// var IconContainer$2 = styled.div(_templateObject2$M || (_templateObject2$M = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: center;\n"])));
// var StyledImage$2 = styled(Image$1)(_templateObject3$u || (_templateObject3$u = _taggedTemplateLiteral$1(["\n  max-width: ", "rem;\n  max-height: ", "rem;\n"])), function (props) {
//   return props.maxWidth;
// }, function (props) {
//   return props.maxHeight;
// });
// var AccessDeniedMeassage = styled.div(_templateObject4$h || (_templateObject4$h = _taggedTemplateLiteral$1(["\n  padding-top: 1rem;\n  font-size: 1.125rem;\n  margin: 0 auto;\n  letter-spacing: -0.025rem;\n  width: 24.875rem;\n  line-height: 1.3rem;\n  text-align: center;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.textColor;
// });
// var HomeButton = styled.div(_templateObject5$b || (_templateObject5$b = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding-top: 1.5rem;\n"])));

// /**
//  * Display custom message when there are no records to display.This components supports custom height and width as modal popups and few other screens will have smaller tables/less space to show this message.
//  */

// function AccessDenied(_ref) {
//   var maxHeight = _ref.maxHeight,
//     maxWidth = _ref.maxWidth,
//     src = _ref.src,
//     text = _ref.text,
//     message = _ref.message,
//     onClick = _ref.onClick,
//     buttonName = _ref.buttonName,
//     alt = _ref.alt,
//     hideHomeButton = _ref.hideHomeButton;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(IconContainer$2, null, /*#__PURE__*/React__default.createElement(StyledImage$2, {
//     src: src,
//     maxHeight: maxHeight,
//     maxWidth: maxWidth,
//     alt: alt
//   })), /*#__PURE__*/React__default.createElement(AccessDeniedText, null, text), /*#__PURE__*/React__default.createElement(AccessDeniedMeassage, null, message), !hideHomeButton && /*#__PURE__*/React__default.createElement(HomeButton, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     variant: "primary",
//     onClick: onClick
//   }, buttonName)));
// }

// // PropType check
// AccessDenied.propTypes = {
//   /**
//    * max-height of the image
//    */

//   maxHeight: PropTypes__default.number,
//   /**
//    * max-width of the image
//    */

//   maxWidth: PropTypes__default.number,
//   /**
//    * source url of the image
//    */
//   src: PropTypes__default.string,
//   /**
//    * display text
//    */
//   text: PropTypes__default.string,
//   /**
//    * display message
//    */
//   message: PropTypes__default.string,
//   /**
//    * button click function
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Text on the button
//    */
//   buttonName: PropTypes__default.node,
//   /**
//    * alternate text of profile image
//    */
//   alt: PropTypes__default.string,
//   /**
//    * Hide home button
//    */
//   hideHomeButton: PropTypes__default.bool
// };
// AccessDenied.defaultProps = {
//   maxHeight: 6.25,
//   maxWidth: 6.25,
//   src: '',
//   text: '',
//   message: '',
//   onClick: undefined,
//   buttonName: '',
//   alt: '',
//   hideHomeButton: false
// };

// var _excluded$l = ["open", "anchorEl", "onClose", "children", "className"];

// /**
//  Popover is to display some content on top of another similar to model.
// * */

// function Popover(_ref) {
//   var open = _ref.open,
//     anchorEl = _ref.anchorEl,
//     onClose = _ref.onClose,
//     children = _ref.children,
//     className = _ref.className,
//     otherProps = _objectWithoutProperties$j(_ref, _excluded$l);
//   // These are not exposed in material documentation directly, but these are needed to support custom alignment for popper.
//   var anchorOrigin = otherProps.anchorOrigin,
//     transformOrigin = otherProps.transformOrigin;
//   return /*#__PURE__*/React__default.createElement(MuiPopover, {
//     open: open,
//     anchorEl: anchorEl,
//     onClose: onClose,
//     className: className,
//     anchorOrigin: anchorOrigin,
//     transformOrigin: transformOrigin
//   }, children);
// }

// // PropType check
// Popover.propTypes = {
//   /**
//    * Menu contents are normally MenuItems.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Flag to control the visibility of menu.
//    */
//   open: PropTypes__default.bool.isRequired,
//   /**
//    * anchorEl: element to which Popper Div attaches
//    */
//   anchorEl: PropTypes__default.oneOfType([PropTypes__default.object]),
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Popover.defaultProps = {
//   children: undefined,
//   anchorEl: null,
//   onClose: undefined,
//   className: ''
// };

// var _templateObject$12;
// var IconContainer$1 = styled.div(_templateObject$12 || (_templateObject$12 = _taggedTemplateLiteral$1(["\n  fill: currentColor;\n"])));

// var IcoMoonType="selection";var icons=[{icon:{paths:["M858.918 1024c-0.028 0-0.062 0-0.096 0-243.126 0-440.218-197.092-440.218-440.218 0-82.046 22.445-158.85 61.531-224.606l-1.116 2.028c77.899-131.296 218.92-217.931 380.176-217.931 82.214 0 159.168 22.519 225.031 61.726l-2.024-1.116c65.84 37.933 119.035 91.129 155.891 154.946l1.077 2.022c37.819 63.941 60.166 140.914 60.166 223.107s-22.347 159.167-61.296 225.177l1.13-2.070c-38.046 65.647-91.216 118.704-154.94 155.534l-2.029 1.082c-63.155 37.907-139.356 60.325-220.794 60.325-0.875 0-1.75-0.003-2.624-0.008l0.135 0.001zM858.918 231.396c-194.812 0-352.739 157.926-352.739 352.739v0c-0 0.032-0 0.069-0 0.107 0 64.989 17.825 125.815 48.853 177.856l-0.88-1.594c30.412 52.738 72.802 95.467 123.626 125.411l1.596 0.87c51.138 30.538 112.792 48.593 178.662 48.593s127.524-18.055 180.281-49.487l-1.619 0.893c52.465-30.202 94.886-72.51 124.363-123.266l0.859-1.603c30.261-51.267 48.139-112.965 48.139-178.838s-17.878-127.571-49.047-180.506l0.908 1.667c-30.336-52.36-72.757-94.668-123.603-124.008l-1.619-0.862c-50.196-30.149-110.768-47.98-175.505-47.98-0.8 0-1.599 0.003-2.398 0.008l0.123-0.001zM858.918 914.298c-0.084 0-0.183 0-0.282 0-58.239 0-112.871-15.442-160.025-42.455l1.575 0.831c-47.644-25.991-86.953-61.69-116.377-104.688l-0.733-1.134-7.76-11.64v-14.11c3.413-43.479 27.78-80.609 62.901-101.613l0.592-0.328c31.583-20.94 68.263-37.532 107.513-47.763l2.542-0.563c15.52-4.412 34.854-8.478 54.579-11.336l2.564-0.305c-10.539-4.117-19.364-8.382-27.812-13.23l1.004 0.531c-24.721-14.783-44.83-34.892-59.186-58.844l-0.427-0.769c-13.764-23.306-21.896-51.357-21.896-81.306s8.132-58 22.308-82.063l-0.413 0.757c14.683-24.796 34.816-44.929 58.844-59.19l0.769-0.422c23.313-13.965 51.434-22.223 81.483-22.223s58.169 8.258 82.215 22.628l-0.733-0.406c24.796 14.683 44.929 34.816 59.19 58.844l0.422 0.769c13.97 23.254 22.232 51.315 22.232 81.306s-8.263 58.053-22.635 82.032l0.403-0.726c-14.813 24.801-35.057 44.932-59.186 59.187l-0.78 0.426c-7.636 4.65-16.477 8.929-25.733 12.351l-1.075 0.348c20.971 3.2 38.967 7.134 56.542 12.075l-3.279-0.787c41.905 10.765 78.701 27.235 111.837 48.847l-1.43-0.874c36.083 21.249 60.743 58.557 64.17 101.842l0.029 0.452v14.11l-7.76 11.64c-30.361 44.179-69.906 79.888-116.069 104.954l-1.746 0.867c-45.302 26.395-99.714 41.976-157.766 41.976-0.216 0-0.432-0-0.647-0.001l0.034 0zM668.44 732.285c20.395 25.788 45.387 46.952 73.878 62.512l1.255 0.628c32.961 19.472 72.633 30.977 114.993 30.977s82.032-11.505 116.063-31.56l-1.070 0.583c30.104-16.116 55.357-37.427 75.454-62.985l0.385-0.508c-6.195-8.301-13.548-15.318-21.905-20.962l-0.317-0.202c-24.040-15.188-51.903-27.302-81.591-34.842l-2.008-0.432c-25.288-7.562-54.443-12.277-84.58-13.043l-0.43-0.009c-30.68 0.741-59.961 5.458-87.75 13.655l2.388-0.604c-31.307 7.51-58.871 19.666-83.527 35.883l0.986-0.609c-8.795 5.806-16.176 12.963-22.051 21.262l-0.172 0.255zM858.918 350.622c-13.073 0.255-25.214 4.027-35.58 10.404l0.306-0.175c-11.849 6.663-21.421 16.122-28.030 27.513l-0.189 0.353c-6.084 10.087-9.737 22.239-9.876 35.235l-0 0.039c0.261 13.030 3.896 25.158 10.063 35.615l-0.186-0.341c6.998 11.592 16.519 21.001 27.849 27.665l0.37 0.201c10.45 6.46 23.121 10.288 36.685 10.288s26.234-3.828 36.989-10.463l-0.304 0.175c11.7-6.866 21.221-16.274 28.021-27.513l0.198-0.353c6.084-10.095 9.835-22.207 10.227-35.164l0.003-0.11c-0.255-13.073-4.027-25.214-10.404-35.58l0.175 0.306c-6.798-11.745-16.37-21.203-27.85-27.675l-0.369-0.191c-10.434-6.433-23.079-10.245-36.614-10.245-0.521 0-1.041 0.006-1.559 0.017l0.077-0.001z","M0 211.643h646.922l-82.541 105.822h-564.382v-105.822z","M0 634.929h465.615l55.027 105.822h-520.642v-105.822z","M0 423.286h493.834v105.822h-493.834v-105.822z","M0 0h987.668v105.822h-987.668v-105.822z"],attrs:[{},{},{},{},{}],width:1299,isMulticolor:false,isMulticolor2:false,grid:16,tags:["TODO_icon"]},attrs:[{},{},{},{},{}],properties:{order:60,id:19,name:"MyToDo",prevSize:32,code:59658},setIdx:0,setId:1,iconIdx:0},{icon:{paths:["M331.787 80.566h-241.42c-12.86 0-23.426 10.566-23.426 23.426v847.436c0 12.86 10.566 23.426 23.426 23.426h241.42c12.86 0 23.426-10.566 23.426-23.426v-847.436c0-12.86-10.566-23.426-23.426-23.426zM277.080 923.623h-132.006c-9.662 0-17.517-7.855-17.517-17.517s7.855-17.517 17.517-17.517h132.006c9.662 0 17.517 7.855 17.517 17.517s-7.925 17.517-17.517 17.517zM289.731 260.466h-166.971c-9.662 0-17.517-7.855-17.517-17.517s7.855-17.517 17.517-17.517h166.971c9.662 0 17.517 7.855 17.517 17.517s-7.855 17.517-17.517 17.517zM289.731 195.819h-166.971c-9.662 0-17.517-7.855-17.517-17.517s7.855-17.517 17.517-17.517h166.971c9.662 0 17.517 7.855 17.517 17.517s-7.855 17.517-17.517 17.517zM660.654 80.566h-241.42c-12.86 0-23.426 10.566-23.426 23.426v847.436c0 12.86 10.566 23.426 23.426 23.426h241.42c12.86 0 23.426-10.566 23.426-23.426v-847.436c0-12.86-10.566-23.426-23.426-23.426zM605.947 923.623h-132.006c-9.662 0-17.517-7.855-17.517-17.517s7.855-17.517 17.517-17.517h132.006c9.662 0 17.517 7.855 17.517 17.517s-7.925 17.517-17.517 17.517zM618.599 260.466h-166.971c-9.662 0-17.517-7.855-17.517-17.517s7.855-17.517 17.517-17.517h166.971c9.662 0 17.517 7.855 17.517 17.517s-7.855 17.517-17.517 17.517zM618.599 195.819h-166.971c-9.662 0-17.517-7.855-17.517-17.517s7.855-17.517 17.517-17.517h166.971c9.662 0 17.517 7.855 17.517 17.517s-7.855 17.517-17.517 17.517zM1329.719 840.276l-347.010-773.127c-5.283-11.748-19.186-17.031-30.933-11.748l-220.218 98.848c-11.748 5.283-17.031 19.186-11.748 30.933l347.010 773.127c5.283 11.748 19.186 17.031 30.933 11.748l220.218-98.848c11.748-5.283 17.031-19.186 11.748-30.933zM785.152 237.318c-3.962-8.759 0-19.186 8.828-23.148l152.373-68.401c8.759-3.962 19.186 0 23.148 8.828 3.962 8.759 0 19.186-8.828 23.148l-152.373 68.401c-8.759 3.962-19.186 0-23.148-8.828zM987.158 236.762l-152.373 68.401c-8.759 3.962-19.186 0-23.148-8.828-3.962-8.759 0-19.186 8.828-23.148l152.373-68.401c8.759-3.962 19.186 0 23.148 8.828 3.893 8.759-0.070 19.186-8.828 23.148zM1247.138 846.95l-120.397 54.012c-8.759 3.962-19.186 0-23.148-8.828-3.962-8.759 0-19.186 8.828-23.148l120.397-54.012c8.759-3.962 19.186 0 23.148 8.828 3.893 8.759-0.070 19.186-8.828 23.148z"],width:1360,attrs:[],isMulticolor:false,isMulticolor2:false,tags:["Library"],defaultCode:59648,grid:16},attrs:[],properties:{id:0,order:35,ligatures:"",prevSize:32,code:59648,name:"Library"},setIdx:0,setId:1,iconIdx:1},{icon:{paths:["M462.721 424.894c56.002 0 103.878-19.8 143.552-59.475s59.475-87.476 59.475-143.552-19.874-103.878-59.475-143.552c-39.674-39.674-87.476-59.475-143.552-59.475s-103.878 19.8-143.552 59.475-59.475 87.476-59.475 143.552 19.8 103.878 59.475 143.552 87.476 59.475 143.552 59.475zM793.489 550.64c8.718 0 17.362 0.443 25.932 1.33-2.364-9.605-4.95-18.84-7.758-27.706-5.615-17.584-13.225-34.798-22.756-51.569s-20.465-31.030-32.803-42.851c-12.338-11.821-27.41-21.204-45.216-28.297-17.805-7.019-37.458-10.565-58.958-10.565-3.177 0-10.565 3.768-22.238 11.378-11.599 7.61-24.75 16.032-39.379 25.341s-33.69 17.805-57.111 25.341c-23.42 7.61-46.989 11.378-70.557 11.378-23.642 0-47.137-3.768-70.557-11.378s-42.482-16.032-57.111-25.341c-14.629-9.309-27.78-17.805-39.379-25.341-11.599-7.61-19.061-11.378-22.238-11.378-21.5 0-41.152 3.546-58.958 10.565-17.805 7.093-32.877 16.476-45.216 28.297s-23.273 26.080-32.803 42.851c-9.531 16.771-17.067 33.912-22.756 51.569-5.615 17.658-10.343 36.719-14.038 57.332s-6.132 39.822-7.388 57.628c-1.256 17.805-1.847 36.054-1.847 54.746 0 42.334 12.855 75.655 38.566 100.184 25.711 24.455 59.918 36.719 102.548 36.719h310.229c-0.96-8.94-1.478-17.953-1.478-27.188 0.222-139.71 113.482-253.045 253.266-253.045zM981.814 769.921c-1.33-1.773-3.103-2.808-5.246-3.177l-45.954-7.019c-2.512-8.053-5.911-16.254-10.27-24.603 3.029-4.211 7.536-10.048 13.52-17.658 6.058-7.61 10.27-13.151 12.782-16.697 1.33-1.847 1.995-3.768 1.995-5.763 0-2.364-0.591-4.211-1.773-5.541-6.058-8.57-19.8-22.756-41.448-42.704-1.995-1.699-4.137-2.512-6.28-2.512-2.512 0-4.507 0.739-6.058 2.29l-35.611 26.893c-6.871-3.546-14.407-6.575-22.608-9.309l-7.019-46.176c-0.148-2.143-1.108-3.99-2.881-5.393s-3.842-2.143-6.132-2.143h-55.633c-4.876 0-7.905 2.364-9.014 7.019-2.143 8.349-4.581 23.938-7.24 46.693-7.831 2.512-15.515 5.689-22.829 9.531l-34.651-26.893c-2.143-1.699-4.359-2.512-6.502-2.512-3.694 0-11.599 5.984-23.716 17.953s-20.391 20.982-24.75 26.967c-1.478 2.143-2.29 4.137-2.29 5.763 0 1.995 0.813 3.99 2.512 6.058 11.23 13.52 20.17 25.12 26.819 34.651-4.211 7.684-7.462 15.367-9.752 23.125l-46.693 7.019c-1.847 0.369-3.399 1.404-4.802 3.251-1.33 1.847-1.995 3.768-1.995 5.763v55.707c0 2.143 0.665 4.137 1.995 5.911s3.103 2.808 5.246 3.103l45.954 6.797c2.364 8.201 5.763 16.476 10.27 24.824-3.029 4.211-7.536 10.048-13.52 17.732-6.058 7.61-10.27 13.151-12.782 16.697-1.33 1.847-1.995 3.768-1.995 5.763 0 2.143 0.591 4.137 1.773 5.763 6.502 9.014 20.317 23.125 41.448 42.186 1.847 1.847 3.916 2.734 6.28 2.734 2.512 0 4.581-0.739 6.28-2.29l35.389-26.819c6.871 3.546 14.407 6.575 22.608 9.309l7.019 46.176c0.148 2.143 1.108 3.99 2.881 5.393s3.768 2.143 6.132 2.143h55.707c4.876 0 7.831-2.364 9.014-7.019 2.143-8.349 4.581-23.938 7.314-46.693 7.831-2.512 15.441-5.689 22.829-9.531l34.651 27.115c2.364 1.478 4.507 2.29 6.502 2.29 3.694 0 11.526-5.911 23.568-17.805s20.317-20.909 24.824-27.115c1.478-1.699 2.29-3.62 2.29-5.763s-0.813-4.285-2.512-6.28c-12.043-14.702-20.982-26.302-26.819-34.651 3.325-6.206 6.575-13.816 9.752-22.829l46.472-7.019c1.995-0.369 3.694-1.404 5.024-3.251s1.995-3.768 1.995-5.763v-55.707c-0.074-2.29-0.739-4.285-2.069-5.984zM836.488 848.605c-12.56 12.56-27.706 18.84-45.437 18.84s-32.877-6.28-45.437-18.84c-12.56-12.56-18.84-27.706-18.84-45.437s6.28-32.877 18.84-45.437c12.56-12.56 27.706-18.84 45.437-18.84s32.877 6.28 45.437 18.84c12.56 12.56 18.84 27.706 18.84 45.437s-6.28 32.877-18.84 45.437z"],width:993,attrs:[],isMulticolor:false,isMulticolor2:false,tags:["Admin"],defaultCode:59649,grid:16},attrs:[],properties:{id:1,order:36,ligatures:"",prevSize:32,code:59649,name:"Admin"},setIdx:0,setId:1,iconIdx:2},{icon:{paths:["M529.067 392.533c26.809 0 51.307 6.471 73.493 19.413s39.751 30.507 52.693 52.693c12.942 22.187 19.413 46.684 19.413 73.493s-6.471 51.307-19.413 73.493c-12.942 22.187-30.507 39.751-52.693 52.693s-46.684 19.413-73.493 19.413c-26.809 0-51.307-6.471-73.493-19.413s-39.751-30.507-52.693-52.693c-12.942-22.187-19.413-46.684-19.413-73.493s6.471-51.307 19.413-73.493c12.942-22.187 30.507-39.751 52.693-52.693s46.684-19.413 73.493-19.413zM685.76 693.44c23.111 5.547 41.6 17.333 55.467 35.36s20.8 38.596 20.8 61.707v84.587c0 13.867-4.853 25.653-14.56 35.36s-21.493 14.56-35.36 14.56h-366.080c-13.867 0-25.653-4.853-35.36-14.56s-14.56-21.493-14.56-35.36v-84.587c0-23.111 6.933-43.68 20.8-61.707s32.356-29.813 55.467-35.36l55.467-13.867c27.733 20.338 59.627 31.431 95.68 33.28 38.827 1.849 74.418-9.244 106.773-33.28l55.467 13.867zM817.493 719.787c-26.809 0-49.689-9.476-68.64-28.427s-28.427-41.831-28.427-68.64c0-26.809 9.476-49.689 28.427-68.64s41.831-28.427 68.64-28.427c26.809 0 49.689 9.476 68.64 28.427s28.427 41.831 28.427 68.64c0 26.809-9.476 49.689-28.427 68.64s-41.831 28.427-68.64 28.427zM240.64 719.787c-26.809 0-49.689-9.476-68.64-28.427s-28.427-41.831-28.427-68.64c0-26.809 9.476-49.689 28.427-68.64s41.831-28.427 68.64-28.427c26.809 0 49.689 9.476 68.64 28.427s28.427 41.831 28.427 68.64c0 26.809-9.476 49.689-28.427 68.64s-41.831 28.427-68.64 28.427zM273.92 790.507v90.133h-155.307c-9.244 0-17.102-3.236-23.573-9.707s-9.707-14.329-9.707-23.573v-56.853c0-14.791 4.622-28.196 13.867-40.213s21.262-19.876 36.053-23.573l37.44-9.707c16.64 12.018 35.591 19.182 56.853 21.493s42.062-1.156 62.4-10.4c-12.018 19.413-18.027 40.213-18.027 62.4zM922.88 726.72c14.791 3.698 26.809 11.556 36.053 23.573s13.867 25.422 13.867 40.213v56.853c0 9.244-3.236 17.102-9.707 23.573s-14.329 9.707-23.573 9.707h-155.307v-90.133c0-22.187-6.009-43.449-18.027-63.787 18.489 9.244 37.902 13.404 58.24 12.48 22.187-0.924 42.524-8.32 61.013-22.187l37.44 9.707zM930.133 85.333c51.841 0 93.867 43.051 93.867 96.156v524.488c0 50.153-37.483 91.338-85.317 95.763l-0.009-52.931c19.471-4.053 34.126-21.689 34.126-42.831v-524.488c0-24.139-19.103-43.707-42.667-43.707h-819.2c-23.564 0-42.667 19.568-42.667 43.707v524.488c0 21.149 14.663 38.789 34.143 42.835l-0.009 52.929c-47.843-4.416-85.334-45.605-85.334-95.764v-524.488c0-53.106 42.026-96.156 93.867-96.156h819.2z"],width:1041,attrs:[],isMulticolor:false,isMulticolor2:false,tags:["ILT-Class"],defaultCode:59650,grid:16},attrs:[],properties:{id:2,order:37,ligatures:"",prevSize:32,code:59650,name:"ILT-Class"},setIdx:0,setId:1,iconIdx:3},{icon:{paths:["M832.001 160c141.389 0 256 114.614 256 256v192c0 141.389-114.614 256-256 256h-576.002c-141.389 0-256-114.614-256-256v-192c0-141.389 114.614-256 256-256h576.002zM832.001 224.003h-576.002c-106.038 0-192 85.959-192 192v0 192c0 106.038 85.959 192 192 192v0h576.002c106.038 0 192-85.959 192-192v0-192c0-106.038-85.959-192-192-192v0zM215.359 607.999l36.262-112.293c3.504-11.094 7.593-26.861 12.261-47.299v0h1.403c6.073 24.409 10.219 40.057 12.436 46.95v0l35.213 112.645h34.513l53.081-192h-30.133c-22.306 85.487-34.48 132.612-36.526 141.374s-3.299 15.241-3.768 19.443v0h-1.403c-2.338-13.666-6.772-30.542-13.316-50.628v0l-34.337-110.192h-31.532l-35.213 110.192c-2.104 6.188-4.582 14.57-7.443 25.141l-1.997 7.563c-1.852 7.193-3.259 13.285-4.219 18.277v0h-1.403c-0.934-8.762-4.642-25.753-11.127-50.98s-15.912-61.958-28.292-110.192v0h-30.483l52.377 192h33.633zM494.424 607.999l36.262-112.293c3.504-11.094 7.593-26.861 12.261-47.299v0h1.403c6.073 24.409 10.219 40.057 12.436 46.95v0l35.213 112.645h34.513l53.081-192h-30.133c-22.306 85.487-34.48 132.612-36.526 141.374s-3.299 15.241-3.768 19.443v0h-1.403c-2.338-13.666-6.772-30.542-13.316-50.628v0l-34.337-110.192h-31.532l-35.213 110.192c-2.104 6.188-4.582 14.57-7.443 25.141l-1.997 7.563c-1.852 7.193-3.259 13.285-4.219 18.277v0h-1.403c-0.934-8.762-4.642-25.753-11.127-50.98s-15.912-61.958-28.292-110.192v0h-30.483l52.377 192h33.633zM773.494 607.999l36.262-112.293c3.504-11.094 7.593-26.861 12.261-47.299v0h1.403c6.073 24.409 10.219 40.057 12.436 46.95v0l35.213 112.645h34.513l53.081-192h-30.133c-22.306 85.487-34.48 132.612-36.526 141.374s-3.299 15.241-3.768 19.443v0h-1.403c-2.338-13.666-6.772-30.542-13.316-50.628v0l-34.337-110.192h-31.532l-35.213 110.192c-2.104 6.188-4.582 14.57-7.443 25.141l-1.997 7.563c-1.852 7.193-3.259 13.285-4.219 18.277v0h-1.403c-0.934-8.762-4.642-25.753-11.127-50.98s-15.912-61.958-28.292-110.192v0h-30.483l52.377 192h33.633z"],width:1088,attrs:[],isMulticolor:false,isMulticolor2:false,tags:["URL"],defaultCode:59651,grid:16},attrs:[],properties:{id:3,order:38,ligatures:"",prevSize:32,code:59651,name:"URL"},setIdx:0,setId:1,iconIdx:4},{icon:{paths:["M89.043 0h578.783c49.177 0 89.043 39.866 89.043 89.043v178.087c0 49.177-39.866 89.043-89.043 89.043h-578.783c-49.177 0-89.043-39.866-89.043-89.043v-178.087c0-49.177 39.866-89.043 89.043-89.043zM89.043 489.739h89.043c49.177 0 89.043 39.866 89.043 89.043v356.174c0 49.177-39.866 89.043-89.043 89.043h-89.043c-49.177 0-89.043-39.866-89.043-89.043v-356.174c0-49.177 39.866-89.043 89.043-89.043zM934.957 0h133.565c49.177 0 89.043 39.866 89.043 89.043v178.087c0 49.177-39.866 89.043-89.043 89.043h-133.565c-49.177 0-89.043-39.866-89.043-89.043v-178.087c0-49.177 39.866-89.043 89.043-89.043zM445.217 489.739h623.304c49.177 0 89.043 39.866 89.043 89.043v356.174c0 49.177-39.866 89.043-89.043 89.043h-623.304c-49.177 0-89.043-39.866-89.043-89.043v-356.174c0-49.177 39.866-89.043 89.043-89.043z"],width:1158,attrs:[],isMulticolor:false,isMulticolor2:false,tags:["Workspace"],defaultCode:59652,grid:16},attrs:[],properties:{id:4,order:39,ligatures:"",prevSize:32,code:59652,name:"Workspace"},setIdx:0,setId:1,iconIdx:5},{icon:{paths:["M938.667 93.867c51.841 0 93.867 42.026 93.867 93.867v512c0 51.841-42.026 93.867-93.867 93.867h-819.2c-51.841 0-93.867-42.026-93.867-93.867v-512c0-51.841 42.026-93.867 93.867-93.867h819.2zM938.667 145.067h-819.2c-23.564 0-42.667 19.103-42.667 42.667v512c0 23.564 19.103 42.667 42.667 42.667h819.2c23.564 0 42.667-19.103 42.667-42.667v-512c0-23.564-19.103-42.667-42.667-42.667zM529.066 315.735c34.4 0 66.4 8.6 96 25.8s53 40.6 70.2 70.2c17.2 29.6 25.8 61.6 25.8 96s-8.6 66.4-25.8 96c-17.2 29.6-40.6 53-70.2 70.2s-61.6 25.8-96 25.8c-34.4 0-66.4-8.6-96-25.8s-53-40.6-70.2-70.2c-17.2-29.6-25.8-61.6-25.8-96s8.6-66.4 25.8-96c17.2-29.6 40.6-53 70.2-70.2s61.6-25.8 96-25.8zM748.665 716.534c25.6 6.4 46.6 20 63 40.8s24.6 44.4 24.6 70.8v44.4c0 16-5.6 29.6-16.8 40.8s-24.8 16.8-40.8 16.8h-499.199c-16 0-29.6-5.6-40.8-16.8s-16.8-24.8-16.8-40.8v-44.4c0-26.4 8.2-50 24.6-70.8s37.4-34.4 63-40.8l85.2-21.6c37.6 27.2 80 41.6 127.2 43.2 52 1.6 99.2-12.8 141.6-43.2l85.2 21.6z"],width:1041,attrs:[],isMulticolor:false,isMulticolor2:false,tags:["ILT-Course"],defaultCode:59653,grid:16},attrs:[],properties:{id:5,order:40,ligatures:"",prevSize:32,code:59653,name:"ILT-Course"},setIdx:0,setId:1,iconIdx:6},{icon:{paths:["M422.091 629.902l167.422 167.422-50.867 50.867-167.422-168.096v-26.612l-9.769-8.759c-18.865 16.842-40.424 29.645-65.016 38.402s-49.857 13.476-76.468 13.476c-39.751 0-76.805-9.769-110.491-28.971s-60.299-45.477-79.499-78.488c-19.875-34.024-29.981-70.742-29.981-110.829 0-39.751 9.769-76.805 29.645-110.491s46.487-60.299 80.175-79.499 70.069-29.645 110.154-29.645 76.805 10.106 110.829 29.981c33.012 19.539 58.951 45.814 78.152 79.162s28.634 70.069 28.634 109.816c0 26.948-4.38 52.55-13.476 77.142-8.759 24.592-21.559 46.15-38.402 65.016l8.759 9.769h27.622zM219.973 629.902c27.622 0 52.887-6.736 76.132-20.549s41.434-32.338 54.91-55.246c13.476-23.244 20.212-48.508 20.212-76.132s-6.736-52.887-20.212-76.132c-13.476-23.244-32.001-41.434-54.91-54.91-23.244-13.476-48.508-20.212-76.132-20.212s-52.887 6.736-76.132 20.212c-22.906 13.476-41.434 31.665-55.246 54.91s-20.549 48.508-20.549 76.132c0 27.622 6.736 52.887 20.549 76.132s32.338 41.771 55.246 55.246 48.508 20.549 76.132 20.549zM983.304 148.187c-13.476-13.476-29.308-20.212-47.834-20.212h-470.261c-18.191 0-34.361 6.736-47.834 20.212s-20.212 29.308-20.212 47.834v113.859c12.801 13.812 24.255 28.634 33.687 45.477 21.895 38.402 33.012 81.185 33.012 126.662 0 30.655-5.053 60.636-15.496 88.594-4.38 11.789-9.433 23.244-15.496 34.024l129.692 129.692h372.571c18.191 0 34.361-6.736 47.834-20.212s20.212-29.308 20.212-47.834v-470.261c0.337-18.529-6.4-34.361-19.875-47.834zM599.281 600.258h-68.046v-237.151h68.046v237.151zM733.689 600.258h-66.362v-338.211h66.362v338.211zM869.445 600.258h-68.046v-135.755h68.046v135.755z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["advancedreporting"],defaultCode:59654,grid:16},attrs:[],properties:{id:6,order:41,ligatures:"",prevSize:32,code:59654,name:"advancedreporting"},setIdx:0,setId:1,iconIdx:7},{icon:{paths:["M422.034 629.887h-27.619l-8.756-9.768c16.842-18.862 29.64-40.418 38.398-65.007s13.473-50.187 13.473-77.133c0-39.745-9.43-76.459-28.629-109.804s-45.134-59.954-78.143-79.153c-34.018-19.872-70.733-29.978-110.814-29.978-39.745 0-76.796 9.768-110.478 28.966s-60.29 45.808-79.826 79.489c-19.536 33.682-29.64 70.396-29.64 110.478s10.105 76.796 29.978 110.814c19.536 33.008 45.808 58.944 79.489 78.479s70.396 28.966 110.478 28.966c26.272 0 51.871-4.38 76.459-13.473 24.589-8.756 46.144-21.556 65.007-38.398l9.768 8.756v26.609l167.4 168.074 50.861-50.861-167.4-167.062zM350.964 553.765c-13.473 23.241-31.662 41.765-54.901 55.238-23.241 13.809-48.501 20.546-76.122 20.546s-52.881-6.736-76.122-20.546c-23.241-13.809-41.765-32.335-55.238-55.238s-20.546-48.501-20.546-76.122 6.736-52.881 20.546-76.122c13.809-22.904 32.335-41.091 55.238-54.564 23.241-13.473 48.501-20.209 76.122-20.209s52.881 6.736 76.122 20.209 41.428 31.662 54.901 54.901c13.473 23.241 20.209 48.501 20.209 76.122s-6.736 52.544-20.209 75.785zM984.861 148.234c-13.473-13.473-29.303-20.209-47.828-20.209h-470.203c-18.862 0-35.028 6.736-48.164 20.209s-19.872 29.303-19.872 47.828v113.844c12.799 13.809 24.252 28.629 33.682 45.471 21.892 38.398 33.008 81.173 33.008 126.644 0 30.652-5.053 60.627-15.493 88.584-4.38 11.789-9.43 23.241-15.493 34.018l129.677 129.677h372.524c18.189 0 34.355-6.736 47.828-20.209s20.209-29.303 20.209-47.828v-470.203c0.337-18.526-6.4-34.355-19.872-47.828zM614.694 279.932c9.093-15.493 21.556-27.955 37.051-37.051 15.83-9.093 32.335-13.809 50.187-13.809s34.355 4.716 50.187 13.809c15.493 9.093 27.955 21.556 37.051 37.051 9.093 15.83 13.809 32.335 13.809 50.187s-4.716 34.355-13.809 50.187c-9.093 15.493-21.556 27.955-37.051 37.051-15.83 9.093-32.335 13.809-50.187 13.809s-34.355-4.716-50.187-13.809c-15.493-9.093-27.955-21.556-37.051-37.051-9.093-15.83-13.809-32.335-13.809-50.187s4.716-34.355 13.809-50.187zM904.023 633.255h-404.185v-33.008c0-20.882 12.463-40.081 37.051-57.26 20.882-14.483 48.501-26.272 82.522-34.692 30.315-8.083 57.597-12.126 82.522-12.126s52.207 4.043 82.522 12.126c34.018 8.756 61.3 20.209 82.522 34.692 24.925 17.179 37.051 36.377 37.051 57.26v33.008z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["talentsearch"],defaultCode:59655,grid:16},attrs:[],properties:{id:7,order:42,ligatures:"",prevSize:32,code:59655,name:"talentsearch"},setIdx:0,setId:1,iconIdx:8},{icon:{paths:["M969.6 300.8c-9.6-9.6-20.8-14.4-33.92-14.4h-335.36c-13.12 0-24.32 4.8-33.92 14.4s-14.4 20.8-14.4 33.92v335.36c0 13.12 4.8 24.32 14.4 33.92s20.8 14.4 33.92 14.4h335.36c13.12 0 24.32-4.8 33.92-14.4s14.4-20.8 14.4-33.92v-335.36c0-13.12-4.8-24.32-14.4-33.92zM696 622.72h-48.32v-168.64h48.32v168.64zM791.68 622.72h-47.36v-240.64h47.36v240.64zM888.32 622.72h-48.32v-96.64h48.32v96.64zM480 352c0 88.366-71.634 160-160 160s-160-71.634-160-160c0-88.366 71.634-160 160-160s160 71.634 160 160zM521.28 749.44c-21.76-21.76-33.28-48.96-33.28-79.36v-63.36c-58.88-20.48-122.88-30.72-168-30.72-106.88 0-320 57.28-320 170.56v42.56c0 23.68 17.92 42.88 40 42.88h560c22.080 0 40-19.2 40-42.56v-7.040h-39.68c-30.080 0-57.6-11.52-79.040-32.96z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["talentreports"],defaultCode:59656,grid:16},attrs:[],properties:{id:8,order:43,ligatures:"",prevSize:32,code:59656,name:"talentreports"},setIdx:0,setId:1,iconIdx:9},{icon:{paths:["M132.449 304.068h532.645v99.124l65.512-65.512v-33.61c0-17.946-6.266-33.895-19.084-46.998-12.818-13.388-28.199-19.939-46.143-19.939h-532.93c-17.946 0-33.61 6.551-46.143 19.939-12.818 13.103-19.369 29.053-19.369 46.998v331.836c0 17.946 6.266 33.895 19.084 46.998 12.818 13.388 28.199 19.939 46.143 19.939h-132.164v66.937h427.255v-129.032l5.128-5.128h-299.934v-331.55zM672.784 769.777h124.759v-66.937h-57.822zM484.224 664.673v106.529h106.529l315.314-315.030-106.814-106.814zM988.669 333.123l-66.367-66.367c-5.412-5.412-11.962-8.26-19.939-8.26s-14.811 2.849-20.224 8.26l-51.841 51.841 106.529 106.529 51.841-51.841c5.412-5.412 8.26-12.247 8.26-20.224s-2.849-14.526-8.26-19.939zM199.386 383.823h398.771v56.967h-398.771v-56.967zM199.386 554.726h305.63l61.239-56.967h-366.869z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["learningactivity"],defaultCode:59657,grid:16},attrs:[],properties:{id:9,order:44,ligatures:"",prevSize:32,code:59657,name:"learningactivity"},setIdx:0,setId:1,iconIdx:10},{icon:{paths:["M188.071 641.428h97.972c35.742 0 64.714 28.973 64.714 64.714v148.505c0 35.742-28.973 64.714-64.714 64.714h-97.972c-35.742 0-64.714-28.973-64.714-64.714v-148.505c0-35.742 28.973-64.714 64.714-64.714zM479.285 414.928h97.972c35.742 0 64.714 28.973 64.714 64.714v375.904c0 35.742-28.973 64.714-64.714 64.714h-97.972c-35.742 0-64.714-28.973-64.714-64.714v-375.904c0-35.742 28.973-64.714 64.714-64.714zM770.499 544.358h97.972c35.742 0 64.714 28.973 64.714 64.714v249.571c0 35.742-28.973 64.714-64.714 64.714h-97.972c-35.742 0-64.714-28.973-64.714-64.714v-249.571c0-35.742 28.973-64.714 64.714-64.714zM237.252 537.24l-85.966 45.195 16.418-95.726-69.548-67.793 96.115-13.967 42.985-87.094 42.985 87.094 96.115 13.967-69.548 67.793 16.418 95.726zM528.468 310.74l-85.966 45.195 16.418-95.726-69.548-67.793 96.115-13.967 42.985-87.094 42.985 87.094 96.115 13.967-69.548 67.793 16.418 95.726zM819.682 440.168l-85.966 45.195 16.418-95.726-69.548-67.793 96.115-13.967 42.985-87.094 42.985 87.094 96.115 13.967-69.548 67.793 16.418 95.726z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["leaderboard"],defaultCode:59664,grid:16},attrs:[],properties:{id:10,order:45,ligatures:"",prevSize:32,code:59664,name:"leaderboard"},setIdx:0,setId:1,iconIdx:11},{icon:{paths:["M366.251 916.858c-17.815 0-32.389-14.574-32.389-32.389s14.574-32.389 32.389-32.389h485.829v-485.829c0-17.815 14.574-32.389 32.389-32.389s32.389 14.574 32.389 32.389v518.218c0 16.519-12.632 30.444-28.503 32.064l-3.886 0.323h-518.218zM767.871 210.785c-12.955-12.955-28.177-19.434-45.992-19.434h-452.144c-17.815 0-33.037 6.479-45.992 19.434s-19.434 28.177-19.434 45.992v452.469c0 17.489 6.479 32.712 19.434 45.667s28.177 19.434 45.992 19.434h452.469c17.489 0 33.037-6.479 45.992-19.434s19.434-28.177 19.434-45.992v-452.144c-0.323-17.815-6.802-33.037-19.757-45.992zM398.64 645.442h-65.426v-228.016h65.426v228.016zM527.547 645.442h-63.805v-325.18h63.805v325.18zM658.397 645.442h-65.426v-130.527h65.426v130.527z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["reportingworkspace"],defaultCode:59665,grid:16},attrs:[],properties:{id:11,order:46,ligatures:"",prevSize:32,code:59665,name:"reportingworkspace"},setIdx:0,setId:1,iconIdx:12},{icon:{paths:["M913.554 288.914c-16.457-17.189-36.206-25.6-59.246-25.6h-342.309l-85.943-85.943h-256c-23.040 0-43.154 8.411-59.246 25.6-16.457 16.823-24.869 37.303-24.869 60.343v512c0 23.040 8.046 43.52 24.503 60.343 16.457 17.189 36.206 25.6 59.246 25.6h683.886c23.040 0 43.154-8.411 59.246-25.6 16.457-17.189 24.503-37.303 24.503-60.343v-426.057c0.731-23.040-7.68-43.154-23.771-60.343zM583.68 434.469c6.949-11.703 16.091-21.211 27.794-28.16s24.503-10.606 38.034-10.606 26.331 3.657 37.669 10.606 20.48 16.457 27.429 28.16 10.24 24.503 10.24 38.034-3.291 26.331-10.24 37.669-16.091 20.846-27.794 27.794c-11.703 6.949-24.137 10.606-37.303 10.606-13.531 0-26.331-3.291-38.034-10.24s-20.846-16.091-27.794-27.794-10.24-24.503-10.24-38.034 3.291-26.331 10.24-38.034zM341.577 381.806c8.411-14.263 19.383-25.234 33.646-33.646s29.257-12.434 45.349-12.434 31.086 4.023 45.349 12.434c14.263 8.411 25.234 19.383 33.646 33.646s12.434 29.257 12.434 45.349c0 16.091-4.023 31.086-12.434 45.349s-19.383 25.234-33.646 33.646c-14.263 8.411-29.257 12.434-45.349 12.434s-31.086-4.023-45.349-12.434-25.234-19.383-33.646-33.646-12.434-29.257-12.434-45.349c0-16.091 4.023-31.086 12.434-45.349zM433.737 642.926c-8.777 16.091-13.166 32.549-13.166 49.737v68.754h-212.846v-76.069c0-21.943 13.166-41.691 39.497-59.246 21.943-14.629 50.834-26.697 86.309-35.84 31.817-7.68 60.709-11.703 87.040-11.703 21.943 0 46.446 2.926 73.143 8.777-27.794 14.994-47.909 33.646-59.977 55.589zM816.274 761.417h-334.263v-68.754c0-17.189 10.24-32.549 30.72-46.080 17.554-11.337 40.229-20.48 68.023-27.794 24.869-5.851 47.909-8.777 68.754-8.777 20.48 0 43.154 2.926 68.023 8.777 27.794 7.314 50.469 16.457 68.023 27.794 20.48 13.531 30.72 28.891 30.72 46.080v68.754z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["myteamdevplan"],defaultCode:59666,grid:16},attrs:[],properties:{id:12,order:47,ligatures:"",prevSize:32,code:59666,name:"myteamdevplan"},setIdx:0,setId:1,iconIdx:13},{icon:{paths:["M132.812 296.181c0-18.26 14.94-33.204 33.204-33.204h531.25c18.26 0 33.204-14.94 33.204-33.204s-14.94-33.204-33.204-33.204h-564.455c-36.525 0-66.405 29.882-66.405 66.405v365.235h-16.603c-27.557 0-49.803 22.244-49.803 49.803s22.244 49.803 49.803 49.803h365.235c27.557 0 49.803-22.244 49.803-49.803s-22.244-49.803-49.803-49.803h-282.227v-332.032zM827.891 342.016h-207.762c-28.568 0-51.681 23.799-51.681 52.883l-0.262 423.077c0 29.085 23.114 52.883 51.681 52.883h311.9c28.568 0 51.94-23.799 51.94-52.883v-317.306l-155.818-158.655zM879.832 765.091h-207.762v-52.883h207.762v52.883zM879.832 659.318h-207.762v-52.883h207.762v52.883zM801.921 527.112v-145.433l142.834 145.433h-142.834z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["trainingtranscript"],defaultCode:59667,grid:16},attrs:[],properties:{id:13,order:48,ligatures:"",prevSize:32,code:59667,name:"trainingtranscript"},setIdx:0,setId:1,iconIdx:14},{icon:{paths:["M132.128 297.291c0-18.167 14.864-33.034 33.034-33.034h528.518c18.167 0 33.034-14.864 33.034-33.034s-14.864-33.034-33.034-33.034h-561.552c-36.337 0-66.063 29.729-66.063 66.063v363.356h-16.517c-27.416 0-49.548 22.13-49.548 49.548s22.13 49.548 49.548 49.548h363.356c27.416 0 49.548-22.13 49.548-49.548s-22.13-49.548-49.548-49.548h-280.775v-330.324zM940.618 363.355h-359.687c-28.26 0-51.382 23.122-51.382 51.382v359.687c0 28.26 23.122 51.382 51.382 51.382h359.687c28.26 0 51.382-23.122 51.382-51.382v-359.687c0-28.26-23.122-51.382-51.382-51.382zM694.711 726.709h-66.063v-165.163h66.063v165.163zM793.81 726.709h-66.063v-264.261h66.063v264.261zM892.906 726.709h-66.063v-99.098h66.063v99.098z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["traininganalysis"],defaultCode:59668,grid:16},attrs:[],properties:{id:14,order:49,ligatures:"",prevSize:32,code:59668,name:"traininganalysis"},setIdx:0,setId:1,iconIdx:15},{icon:{paths:["M764.351 299.33c-141.699 0-256.511 116.489-256.511 260.26s114.807 260.26 256.511 260.26c141.699 0 256.511-116.489 256.511-260.26s-114.807-260.26-256.511-260.26zM862.729 632.172v0l-24.046 25.418c-3.186 3.369-7.826 5.53-12.901 6.008s-10.158-0.769-14.144-3.466v0l-80.558-50.544c-11.402-7.719-18.035-19.397-18.034-31.751v-158.133c0-8.986 8.613-16.265 19.239-16.265h38.478c10.626 0 19.239 7.284 19.239 16.265v146.391l69.736 43.206c3.988 2.696 6.54 6.623 7.101 10.909s-0.914 8.593-4.11 11.963zM130.877 299.33c0-17.995 14.724-32.717 32.717-32.717h523.491c17.995 0 32.717-14.724 32.717-32.717s-14.724-32.717-32.717-32.717h-556.208c-35.991 0-65.439 29.449-65.439 65.439v359.897h-16.361c-27.159 0-49.077 21.92-49.077 49.077s21.92 49.077 49.077 49.077h359.897c27.159 0 49.077-21.92 49.077-49.077s-21.92-49.077-49.077-49.077h-278.107v-327.184z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["trainingschedule"],defaultCode:59669,grid:16},attrs:[],properties:{id:15,order:50,ligatures:"",prevSize:32,code:59669,name:"trainingschedule"},setIdx:0,setId:1,iconIdx:16},{icon:{paths:["M402.982 596.652h-259.303v-305.092c0-16.782 13.693-30.482 30.482-30.482h488.124c16.782 0 30.482-13.693 30.482-30.482s-13.693-30.482-30.482-30.482h-518.599c-33.571 0-61.034 27.462-61.034 61.034v335.574h-15.245c-25.352 0-45.789 20.436-45.789 45.789s20.436 45.789 45.789 45.789h335.574c25.352 0 45.789-20.436 45.789-45.789s-20.505-45.865-45.789-45.865zM944.754 337.349h-371.607c-23.67 0-42.983 19.32-42.983 42.983v325.88c0 23.67 19.32 42.983 42.983 42.983h371.607c23.67 0 42.983-19.32 42.983-42.983v-325.88c0-23.594-19.32-42.983-42.983-42.983zM714.534 657.051h-114.414v-45.789h114.414v45.789zM714.534 565.535h-114.414v-45.789h114.414v45.789zM714.534 474.019h-114.414v-45.789h114.414v45.789zM824.797 611.324l-64.543-64.971 32.241-32.241 32.241 32.516 72.548-72.548 32.516 32.516-104.995 104.72z"],attrs:[],isMulticolor:false,isMulticolor2:false,tags:["trainingplans"],defaultCode:59670,grid:16},attrs:[],properties:{id:16,order:51,ligatures:"",prevSize:32,code:59670,name:"trainingplans"},setIdx:0,setId:1,iconIdx:17},{icon:{paths:["M1517.382 1024h-1368.436c-83.782 0-148.945-65.164-148.945-158.255v-623.709c0-83.782 65.164-148.945 148.945-148.945h1368.436c93.091 0 158.255 65.164 158.255 148.945v623.709c0 93.091-65.164 158.255-158.255 158.255zM148.945 214.109c-18.618 0-37.236 18.618-37.236 37.236v623.709c0 18.618 18.618 27.927 37.236 27.927h1368.436c18.618 0 27.927-18.618 27.927-27.927v-633.018c0-18.618-18.618-37.236-27.927-37.236h-1368.436zM921.6 837.818h-111.709v-437.527h-139.636v-93.091h400.291v93.091h-148.945v437.527z"],width:1676,attrs:[],isMulticolor:false,isMulticolor2:false,tags:["Token"],defaultCode:59680,grid:16},attrs:[],properties:{id:17,order:52,ligatures:"",prevSize:32,code:59680,name:"Token"},setIdx:0,setId:1,iconIdx:18},{icon:{paths:["M40 459.556h419.556v-419.556h-419.556v419.556zM144.887 144.887h209.776v209.776h-209.776v-209.776z","M40 984h419.556v-419.556h-419.556v419.556zM144.887 669.332h209.776v209.776h-209.776v-209.776z","M564.444 40v419.556h419.556v-419.556h-419.556zM879.113 354.668h-209.776v-209.776h209.776v209.776z","M879.113 879.113h104.887v104.887h-104.887v-104.887z","M564.444 564.444h104.887v104.887h-104.887v-104.887z","M669.332 669.332h104.887v104.887h-104.887v-104.887z","M564.444 774.224h104.887v104.887h-104.887v-104.887z","M669.332 879.113h104.887v104.887h-104.887v-104.887z","M774.224 774.224h104.887v104.887h-104.887v-104.887z","M774.224 564.444h104.887v104.887h-104.887v-104.887z","M879.113 669.332h104.887v104.887h-104.887v-104.887z"],attrs:[{},{},{},{},{},{},{},{},{},{},{}],isMulticolor:false,isMulticolor2:false,tags:["qrcode"],grid:16},attrs:[{},{},{},{},{},{},{},{},{},{},{}],properties:{order:53,id:18,name:"qrcode",prevSize:32,code:59681},setIdx:0,setId:1,iconIdx:19},{icon:{paths:["M0 1024v-1024h48v1024h-48zM71.619 1023.275v-1023.275h24.381v1023.275h-24.381zM144 1023.275v-1023.275h23.619v1023.275h-23.619zM263.619 1023.275v-1023.275h23.619v1023.275h-23.619zM359.619 1023.275v-1023.275h47.237v1023.275h-47.237zM479.237 1023.275v-1023.275h23.619v1023.275h-23.619zM527.237 1023.275v-1023.275h23.619v1023.275h-23.619zM575.237 1023.275v-1023.275h23.619v1023.275h-23.619zM670.478 1023.275v-1023.275h48v1023.275h-48zM790.096 1023.275v-1023.275h48v1023.275h-48zM886.093 1023.275v-1023.275h48v1023.275h-48zM982.093 1023.275v-1023.275h48.009v1023.275h-48.009zM1053.713 1023.275v-1023.275h48v1023.275h-48zM1174.093 1023.275v-1023.275h71.62v1023.275h-71.62zM1269.333 1023.275v-1023.275h24.38v1023.275h-24.38zM1317.333 1024v-1024h48v1024h-48z"],attrs:[{}],width:1365,isMulticolor:false,isMulticolor2:false,grid:16,tags:["barcode"]},attrs:[{}],properties:{order:87,id:21,name:"barcode",prevSize:32,code:59660},setIdx:0,setId:1,iconIdx:0},{icon:{paths:["M308.924 325.304c-43.383-0.647-43.626-64.987 0-65.684h441.319c43.329 0.762 43.582 64.872 0 65.684h-441.319z","M1058.133 0h-1024c-18.784-0.050-34.061 14.385-34.133 32.254v671.275c0.055 17.911 15.305 32.419 34.133 32.471h456.706c-30.245-25.434-52.617-58.768-46.195-97.412h-308.111c-18.829-0.052-34.079-14.559-34.133-32.471v-476.235c-0.013-8.615 3.579-16.881 9.983-22.974s15.093-9.509 24.15-9.497h819.2c18.829 0.051 34.079 14.559 34.133 32.471v350.898c8.655 18.328 5.767 52.543 6.372 72.517l30.039 28.79c48.005 48.172 33.444 114.065-17.978 153.913h49.833c18.796-0.128 34-14.591 34.134-32.471v-671.275c-0.153-17.837-15.382-32.228-34.133-32.254z","M928.298 864l-91.639 0.759-42.283 47.484 32.933 103.444c1.529 4.8 5.441 8.076 9.912 8.302s8.622-2.645 10.515-7.272l30.755-75.174 65.623 35.043c4.056 2.165 8.856 1.327 12.16-2.122s4.46-8.831 2.929-13.633l-30.906-96.83z","M561.158 864l-30.906 96.816c-1.531 4.801-0.375 10.181 2.929 13.63s8.104 4.287 12.16 2.122l65.622-35.037 30.767 75.187c1.892 4.625 6.039 7.495 10.508 7.271s8.38-3.498 9.909-8.294l32.933-103.206-42.504-47.729-91.418-0.758z","M902.234 570.309l-0.498-66.247c-0.135-17.54-14.808-31.726-32.95-31.856l-68.521-0.481-48.788-46.489c-12.922-12.314-33.677-12.314-46.599 0l-48.781 46.489-68.521 0.481c-18.143 0.124-32.82 14.313-32.95 31.854l-0.504 66.249-48.082 47.162c-12.739 12.493-12.739 32.562 0 45.055l48.083 47.166 0.498 66.246c0.134 17.54 14.808 31.727 32.95 31.856l68.521 0.482 48.788 46.489c12.922 12.314 33.677 12.314 46.599 0l48.781-46.489 68.521-0.482c18.142-0.128 32.816-14.314 32.95-31.854l0.503-66.249 48.083-47.164c12.739-12.492 12.739-32.56 0-45.052l-48.083-47.165zM728.181 725.76c-117.248-3.497-117.226-168.039 0-171.52 117.248 3.502 117.22 168.037-0 171.52h0z"],attrs:[{},{},{},{},{}],width:1092,isMulticolor:false,isMulticolor2:false,grid:16,tags:["certification"],colorPermutations:{"114110381220424212552552551511201861":[{},{},{},{},{}]}},attrs:[{},{},{},{},{}],properties:{order:26,id:25,name:"certification",prevSize:32,code:59662},setIdx:0,setId:1,iconIdx:0},{icon:{paths:["M540.269 216.662c-37.586-0.693-37.796-69.628 0-70.376h382.351c37.54 0.816 37.759 69.505 0 70.376h-382.351z","M677.131 362.947c-25.058-0.693-25.198-69.628 0-70.376h254.901c25.026 0.816 25.173 69.505 0 70.376h-254.901z","M18.644 0v73.289h1015.442v707.803h-234.569l-38.839 74.971h337.042v-856.064z","M293.157 684.829c-26.331 0-50.615-7.022-72.85-20.992-22.235-14.043-39.936-32.841-53.102-56.539-13.166-23.625-19.749-49.445-19.749-77.458s6.583-54.199 19.749-78.482c13.166-24.283 30.866-43.447 53.102-57.417 22.235-14.043 46.519-20.992 72.85-20.992s50.615 6.949 72.85 20.992c22.235 13.97 39.936 33.134 53.102 57.417s19.749 50.469 19.749 78.482c0 28.014-6.583 53.833-19.749 77.458-13.166 23.698-30.866 42.496-53.102 56.539-22.235 13.97-46.519 20.992-72.85 20.992z","M173.787 780.061c43.301-11.191 83.090-16.823 119.369-16.823s76.069 5.632 119.369 16.823c49.152 13.093 88.942 30.501 119.369 52.297 36.279 25.527 54.418 54.199 54.418 85.943v78.409h-586.313v-78.409c0-31.744 18.139-60.416 54.418-85.943 30.427-21.797 70.217-39.205 119.369-52.297z","M748.983 550.166l-101.742 190.464c-40.521 54.565-70.802 93.111-90.99 115.419v0c-1.975 2.121-4.242 4.535-6.875 7.241v0c-14.775 14.629-23.113 35.182-23.113 56.759v0c0 42.935 32.768 77.751 73.143 77.751v0h16.603c34.085-42.423 60.928-116.955 83.749-154.112v0c26.258-42.715 64.293-123.026 113.883-241.006v0c9.289-22.162 3.145-48.201-14.848-63.049v0c-1.243-1.097-2.56-2.048-3.95-2.853v0c-5.266-3.218-10.971-4.681-16.603-4.681v0c-11.63 0-23.040 6.51-29.257 18.066v0z"],attrs:[{},{},{},{},{},{}],width:1170,isMulticolor:false,isMulticolor2:false,grid:16,tags:["instructor"],colorPermutations:{"114110381220424212552552551511201861":[{},{},{},{},{},{}]}},attrs:[{},{},{},{},{},{}],properties:{order:27,id:24,name:"instructor",prevSize:32,code:59661},setIdx:0,setId:1,iconIdx:1},{icon:{paths:["M928.914 131.657c7.314 14.629 7.314 36.571-7.314 43.886l-321.829 321.829v482.743c0 14.629-7.314 29.257-21.943 36.571-7.314 0-14.629 0-14.629 0-14.629 0-21.943-7.314-29.257-14.629l-168.229-160.914c-7.314-7.314-14.629-14.629-14.629-29.257v-314.514l-321.829-321.829c-14.629-14.629-14.629-29.257-7.314-43.886s21.943-21.943 36.571-21.943h833.829c21.943-7.314 29.257 0 36.571 21.943z"],attrs:[{}],width:951,isMulticolor:false,isMulticolor2:false,grid:16,tags:["filter"],colorPermutations:{"114110381220424212552552551511201861":[{}]}},attrs:[{}],properties:{order:55,id:28,name:"filter",prevSize:32,code:59672},setIdx:0,setId:1,iconIdx:0},{icon:{paths:["M507.611 640v-14.629c0-134.583 0.731-269.166-0.366-403.749 0-33.28 24.137-52.297 53.029-51.931 122.88 0.731 245.394 0.731 368.274 0 27.794 0 52.297 19.749 51.931 50.834-1.097 92.16-1.097 184.32 0 276.846 0 28.16-21.943 51.2-50.469 50.834-105.691-1.097-211.383-0.366-317.074-0.731-8.411 0-14.629 2.56-20.48 8.411-24.137 24.869-48.64 49.006-73.143 73.509-2.926 2.926-5.851 5.486-10.971 10.606zM742.4 312.686c44.983 0 89.966 0 134.949 0 7.68 0 10.606-2.194 10.24-9.874-0.731-9.143-0.731-18.651 0-27.794 0.731-10.24-2.56-13.531-12.8-13.166-50.469 0.366-100.937 0-151.771 0-37.669 0-74.971 0-112.64 0-8.046 0-11.337 2.56-10.971 10.971 0.731 9.509 0.731 19.383 0 28.891-0.731 8.777 2.56 11.337 11.337 11.337 43.886-0.366 87.771 0 131.657 0zM742.4 384c44.983 0 89.966 0 134.949 0 7.68 0 10.606-2.194 10.24-9.874-0.731-9.143-0.731-18.651 0-27.794 0.731-10.24-2.56-13.531-12.8-13.166-50.469 0.366-100.937 0-151.771 0-37.669 0-74.971 0-112.64 0-8.046 0-11.337 2.56-10.971 10.971 0.731 9.509 0.731 19.383 0 28.891-0.731 8.777 2.56 11.337 11.337 11.337 43.886-0.366 87.771 0 131.657 0zM695.589 455.314c28.891 0 58.149 0 87.040 0 8.411 0 11.337-2.926 10.971-10.971-0.366-9.874 0-20.114 0-29.989 0-6.949-2.56-9.874-9.874-9.874-58.149 0-115.931 0-174.080 0-8.046 0-10.24 3.291-9.874 10.606 0.366 9.509 0.731 19.383 0 28.891-0.731 8.777 2.194 11.703 11.337 11.337 28.16-0.366 56.686 0 84.846 0z","M43.886 854.309c1.829-35.474 20.846-59.977 46.446-80.091 38.4-29.989 83.383-44.983 130.56-53.029 11.703-2.194 23.406-3.291 36.571-5.486 0-9.509 0.366-18.651 0-27.794 0-2.56-3.291-5.486-5.851-7.314-42.057-31.086-63.269-73.874-64.731-125.074-0.731-31.451 1.097-63.269 6.583-93.989 7.314-42.057 35.109-63.634 77.531-66.56 17.189-1.097 35.109-1.463 51.931 0.731 40.229 5.851 64.366 30.72 70.217 70.217 5.851 39.863 9.874 80.823 1.097 120.686-7.68 35.109-24.869 65.463-53.394 87.771-10.24 8.046-15.726 15.726-13.531 28.526 0.731 4.023 0.366 8.046 0.731 11.703 23.040 4.389 45.349 7.68 67.291 13.166 36.206 9.143 70.583 23.040 100.206 46.811 24.869 20.114 43.52 44.251 45.714 79.36h-497.371z"],attrs:[{fill:"rgb(0, 123, 190)"},{fill:"rgb(0, 123, 190)"}],grid:0,tags:["Expressed Interest"]},attrs:[{}],properties:{order:7,id:20,name:"Expressed Interest",prevSize:32,code:59663},setIdx:0,setId:1,iconIdx:0},{icon:{paths:["M512 48.274c-192 0-365.714 149.211-365.714 380.343 0 153.966 122.149 336.091 365.714 547.109 243.566-211.017 365.714-393.143 365.714-547.109 0-230.766-173.714-380.343-365.714-380.343zM512 851.749c-185.051-171.52-274.286-314.88-274.286-423.863 0-167.863 121.051-287.086 274.286-287.086s274.286 119.223 274.286 287.451c0 108.617-89.234 252.343-274.286 423.497z","M487.131 408.869h155.429v205.897c-25.234 8.411-49.006 14.263-71.314 17.554s-44.983 5.12-68.023 5.12c-59.246 0-104.229-17.554-135.314-53.029-31.086-35.109-46.811-85.943-46.811-151.771s17.92-114.103 54.126-149.943c36.206-35.84 86.309-53.76 150.309-53.76 40.229 0 78.994 8.046 116.297 24.503l-27.429 67.291c-28.526-14.629-58.149-21.577-89.234-21.577-35.84 0-64.731 12.069-86.309 36.571s-32.549 57.417-32.549 98.743 8.777 76.069 25.966 98.743 42.789 34.011 76.069 34.011c17.189 0 34.743-1.829 52.663-5.486v-83.017h-74.24v-70.217z"],attrs:[{}],width:951,isMulticolor:false,isMulticolor2:false,grid:0,tags:["filter"],colorPermutations:{"114110381220424212552552551511201861":[{}]}},attrs:[{}],properties:{order:6,id:30,name:"My Guide",prevSize:32,code:59672},setIdx:0,setId:1,iconIdx:0}];var height=1024;var metadata={name:"icomoon"};var preferences={showGlyphs:true,showCodes:true,showQuickUse:true,showQuickUse2:true,showSVGs:true,fontPref:{prefix:"icon-",metadata:{fontFamily:"icomoon"},metrics:{emSize:1024,baseline:6.25,whitespace:50},embed:false},imagePref:{prefix:"icon-",png:true,useClassSelector:true,color:0,bgColor:16777215},historySize:50,gridSize:16,showGrid:true};var iconSet = {IcoMoonType:IcoMoonType,icons:icons,height:height,metadata:metadata,preferences:preferences};

// /**
//  * Component to render Icomoon icon.
//  * NOTE: Update selection.json when ever you get new Icomoon icon from UX.
//  */
// function IcomoonIcon(_ref) {
//   var iconName = _ref.iconName,
//     size = _ref.size,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(IconContainer$1, {
//     className: className
//   }, /*#__PURE__*/React__default.createElement(IcomoonReact, {
//     iconSet: iconSet,
//     size: "".concat(size, "rem"),
//     icon: iconName
//   }));
// }
// // PropType check
// IcomoonIcon.propTypes = {
//   /**
//    * Name of the icon
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * size of the icon in rem
//    */
//   size: PropTypes__default.number,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// IcomoonIcon.defaultProps = {
//   iconName: undefined,
//   size: 2,
//   className: undefined
// };

// var iconComponents = {
//   MaterialIcon: MaterialIcon,
//   IcomoonIcon: IcomoonIcon
// };

// /**
//  * Component for reneder Icons.
//  */

// function Icon(_ref) {
//   var iconType = _ref.iconType,
//     iconName = _ref.iconName,
//     size = _ref.size,
//     className = _ref.className;
//   var IconComponent = iconComponents[iconType];
//   return /*#__PURE__*/React__default.createElement(IconComponent, {
//     iconName: iconName,
//     size: size,
//     className: className
//   });
// }

// // PropType check
// Icon.propTypes = {
//   /**
//    * Type of the icon
//    */
//   iconType: PropTypes__default.oneOf(['MaterialIcon', 'IcomoonIcon']),
//   /**
//    * Name of the icon
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * Size of the icon in rem
//    */
//   size: PropTypes__default.number,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Icon.defaultProps = {
//   iconType: 'MaterialIcon',
//   iconName: undefined,
//   size: 1.5,
//   className: undefined
// };

// var _excluded$k = ["open", "anchorEl", "onClose", "children", "className"];

// /**
//  Menu is generally used to render menu items.
// * */

// function Menu(_ref) {
//   var open = _ref.open,
//     anchorEl = _ref.anchorEl,
//     onClose = _ref.onClose,
//     children = _ref.children,
//     className = _ref.className,
//     otherProps = _objectWithoutProperties$j(_ref, _excluded$k);
//   // These are not exposed in material documentation directly, but these are needed to support custom alignment for popper.
//   var getContentAnchorEl = otherProps.getContentAnchorEl,
//     anchorOrigin = otherProps.anchorOrigin,
//     transformOrigin = otherProps.transformOrigin;
//   return /*#__PURE__*/React__default.createElement(MuiMenu, {
//     open: open,
//     anchorEl: anchorEl,
//     getcontentanchorel: getContentAnchorEl,
//     onClose: onClose,
//     className: className,
//     anchorOrigin: anchorOrigin,
//     transformOrigin: transformOrigin
//   }, children);
// }

// // PropType check
// Menu.propTypes = {
//   /**
//    * Menu contents are normally MenuItems.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Flag to control the visibility of menu.
//    */
//   open: PropTypes__default.bool.isRequired,
//   /**
//    * anchorEl: element to which Popper Div attaches
//    */
//   anchorEl: PropTypes__default.oneOfType([PropTypes__default.object]),
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Menu.defaultProps = {
//   children: undefined,
//   anchorEl: null,
//   onClose: undefined,
//   className: ''
// };

// var _templateObject$11, _templateObject2$L;
// var StyledIconButton$6 = styled(IconButton)(_templateObject$11 || (_templateObject$11 = _taggedTemplateLiteral$1(["\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.textColor;
// });
// var StyledMenu = styled(Menu)(_templateObject2$L || (_templateObject2$L = _taggedTemplateLiteral$1(["\n  .MuiList-padding {\n    padding: 0;\n  }\n"])));

// /**
//  * This component is to show an icon button which opens a drop down menu on click.
//  * It is widely used for action menus/kebab menus in the application.
//  */
// function IconMenu(_ref) {
//   var idProp = _ref.id,
//     label = _ref.label,
//     iconType = _ref.iconType,
//     iconName = _ref.iconName,
//     children = _ref.children,
//     size = _ref.size,
//     className = _ref.className,
//     icon = _ref.icon,
//     component = _ref.component;
//   var id = useId(idProp);
//   var _useState = useState$1(null),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     popperAnchor = _useState2[0],
//     setPopperAnchor = _useState2[1];
//   var open = Boolean(popperAnchor);
//   var _useState3 = useState$1(false),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     isMenuOpen = _useState4[0],
//     setIsMenuOpen = _useState4[1];
//   var PanelComponent = component === 'menu' ? StyledMenu : Popover;
//   var handleMenuClick = function handleMenuClick(event) {
//     if (isMenuOpen) {
//       handleMenuClose();
//     } else {
//       setPopperAnchor(event.currentTarget);
//       setIsMenuOpen(true);
//     }
//   };
//   var handleMenuClose = function handleMenuClose() {
//     setPopperAnchor(null);
//     setIsMenuOpen(false);
//   };
//   var handleMenuCloseOnKeyEvent = function handleMenuCloseOnKeyEvent(event, reason) {
//     if (reason !== 'tabKeyDown') {
//       handleMenuClose();
//     }
//   };
//   // This is required to handle menu close along with the onclick configured for each menuitem.
//   var handleItemOnClick = function handleItemOnClick(onClickFn) {
//     if (onClickFn) return function (event) {
//       var preventClose = false;
//       preventClose = onClickFn(event);
//       if (!preventClose) {
//         handleMenuClose();
//       }
//     };
//     return handleMenuClose;
//   };
//   var handleKeyClick = function handleKeyClick(onKeyDown) {
//     if (onKeyDown) {
//       return function (event) {
//         var preventClose = false;
//         preventClose = onKeyDown(event);
//         // Enter Key: 13, Space Key: 32
//         if (!preventClose && (event.keyCode === 13 || event.keyCode === 32)) {
//           handleMenuClose();
//           event.preventDefault();
//         }
//       };
//     }
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(CloseOnEscape, {
//     close: handleMenuClose
//   }, /*#__PURE__*/React__default.createElement(CloseOnClickAway, {
//     close: handleMenuClose
//   }, /*#__PURE__*/React__default.createElement("div", {
//     className: className
//   }, /*#__PURE__*/React__default.createElement(StyledIconButton$6, {
//     id: id,
//     label: label,
//     ariaExpanded: isMenuOpen,
//     ariaHasPopUp: true,
//     size: size,
//     onClick: function onClick(e) {
//       return handleMenuClick(e);
//     }
//   }, icon != null ? icon : /*#__PURE__*/React__default.createElement(Icon, {
//     iconType: iconType,
//     iconName: iconName,
//     size: 1.25
//   })), component !== 'popper' ? /*#__PURE__*/React__default.createElement(PanelComponent, {
//     open: open,
//     anchorEl: popperAnchor,
//     onClose: component === 'menu' ? handleMenuClose : handleMenuCloseOnKeyEvent,
//     getContentAnchorEl: null,
//     anchorOrigin: {
//       vertical: 'bottom',
//       horizontal: 'right'
//     },
//     transformOrigin: {
//       vertical: 'top',
//       horizontal: 'right'
//     }
//   }, React__default.Children.map(children, function (child) {
//     if (child) {
//       return /*#__PURE__*/React__default.cloneElement(child, {
//         onClick: handleItemOnClick(child.props.onClick),
//         onKeyDown: handleKeyClick(child.props.onKeyDown)
//       });
//     }
//   })) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Popper, {
//     toggle: open,
//     anchorEl: popperAnchor,
//     placement: "bottom-end",
//     transition: true,
//     disablePortal: true
//   }, function (_ref2) {
//     var TransitionProps = _ref2.TransitionProps;
//       _ref2.placement;
//     return /*#__PURE__*/React__default.createElement(Grow, TransitionProps, /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(Paper, null, React__default.Children.map(children, function (child) {
//       if (child) {
//         var _child$props = child.props,
//           onClick = _child$props.onClick,
//           onKeyDown = _child$props.onKeyDown;
//         return /*#__PURE__*/React__default.cloneElement(child, {
//           onClick: handleItemOnClick(onClick),
//           onKeyDown: handleKeyClick(onKeyDown)
//         });
//       }
//     }))));
//   }))))));
// }
// // PropType check
// IconMenu.propTypes = {
//   /**
//    * Id of the menu
//    */
//   id: PropTypes__default.string,
//   /**
//    * Label to be used for icon button.
//    */
//   label: PropTypes__default.string,
//   /**
//    * Icon Type for the icon button.
//    */
//   iconType: PropTypes__default.oneOf(['MaterialIcon', 'IcomoonIcon']),
//   /**
//    * Icon Name for the icon button.
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * Icon for the icon button.
//    */
//   icon: PropTypes__default.element,
//   /**
//    * MenuItems for the menu.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Size of the Icon  button
//    */
//   size: PropTypes__default.oneOf(['small', 'medium']),
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Component
//    */
//   component: PropTypes__default.oneOf(['menu', 'popover', 'popper'])
// };
// IconMenu.defaultProps = {
//   id: null,
//   label: 'Icon Menu',
//   iconType: 'MaterialIcon',
//   iconName: 'MoreVert',
//   size: 'small',
//   className: undefined,
//   icon: null,
//   component: 'menu'
// };

// /**
//  * This component used to render kebab with actions menu as cell content in Datagrid.
//  */
// function ActionsCell(_ref) {
//   var className = _ref.className,
//     actionCallBack = _ref.actionCallBack,
//     actionsData = _ref.actionsData,
//     getFromFieldData = _ref.getFromFieldData;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue,
//     cell = _useContext.cell;
//   var ActionsList = getFromFieldData ? cellValue : actionsData;
//   var handleAction = function handleAction(event, actionId) {
//     actionCallBack(cell.props.row.id, actionId);
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, ActionsList && /*#__PURE__*/React__default.createElement(IconMenu, {
//     className: className
//   }, ActionsList.map(function (action) {
//     return /*#__PURE__*/React__default.createElement(MenuItem, {
//       key: action.id,
//       onClick: function onClick(e) {
//         return handleAction(e, action.id);
//       }
//     }, action.label);
//   })));
// }
// ActionsCell.propTypes = {
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Actions for the Data Item
//    */
//   actionsData: PropTypes__default.arrayOf(PropTypes__default.shape({
//     id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//     label: PropTypes__default.string.isRequired
//   })),
//   /**
//    * Callback function for Actions menu
//    */
//   actionCallBack: PropTypes__default.func,
//   /**
//    * To get actions dynamically from data
//    */
//   getFromFieldData: PropTypes__default.bool
// };
// ActionsCell.defaultProps = {
//   className: undefined,
//   actionsData: null,
//   actionCallBack: undefined,
//   getFromFieldData: false
// };

// /**
//  * A simple wrapper to apply `List` styles to an `Icon` or `SvgIcon`.
//  *
//  */
// function ListItemIcon(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiListItemIcon, {
//     className: className
//   }, children);
// }
// ListItemIcon.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string
// };
// ListItemIcon.defaultProps = {
//   children: undefined,
//   className: ''
// };

// /**
//  * A simple wrapper to apply `List` styles to 'Text'.
//  *
//  */
// function ListItemText(_ref) {
//   var className = _ref.className,
//     primary = _ref.primary,
//     secondary = _ref.secondary,
//     inset = _ref.inset,
//     primaryTypographyProps = _ref.primaryTypographyProps;
//   return /*#__PURE__*/React__default.createElement(MuiListItemText, {
//     className: className,
//     primary: primary,
//     secondary: secondary,
//     inset: inset,
//     primaryTypographyProps: primaryTypographyProps
//   });
// }
// ListItemText.propTypes = {
//   /**
//    * Not to manually set any value to className and is internally used by Styled-Components.
//    */
//   className: PropTypes__default.string,
//   /**
//    * The main content element.
//    */
//   primary: PropTypes__default.node,
//   /**
//    * The secondary content element.
//    */
//   secondary: PropTypes__default.node,
//   /**
//    * Props to be applied for the primary element
//    */
//   primaryTypographyProps: PropTypes__default.oneOfType([PropTypes__default.object]),
//   /**
//    * If true, the children will be indented.
//    */
//   inset: PropTypes__default.bool
// };
// ListItemText.defaultProps = {
//   className: '',
//   primary: '',
//   secondary: '',
//   primaryTypographyProps: {},
//   inset: false
// };

// var _templateObject$10, _templateObject2$K, _templateObject3$t, _templateObject4$g, _templateObject5$a, _templateObject6$8, _templateObject7$8;
// var ActionMenuItem$1 = styled(MenuItem)(_templateObject$10 || (_templateObject$10 = _taggedTemplateLiteral$1(["\n  margin: 0rem;\n  padding: 0rem;\n  &:focus {\n    background-color: ", ";\n    color: ", ";\n  }\n  &:active {\n    background-color: ", ";\n    color: ", ";\n  }\n  &:hover {\n    background-color: ", ";\n    color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });
// var NavigationMenuItem = styled(MenuItem)(_templateObject2$K || (_templateObject2$K = _taggedTemplateLiteral$1(["\n  margin: 0rem;\n  padding: 0rem;\n"])));
// var ActionListItemIcon$1 = styled(ListItemIcon)(_templateObject3$t || (_templateObject3$t = _taggedTemplateLiteral$1(["\n  min-width: auto !important;\n  color: inherit;\n  padding-right: 0.5rem;\n"])));
// var ActionListItemText = styled(ListItemText)(_templateObject4$g || (_templateObject4$g = _taggedTemplateLiteral$1(["\n  padding-top: 0.375rem;\n  padding-bottom: 0.375rem;\n"])));
// var NavigateLink = styled(RouteLink)(_templateObject5$a || (_templateObject5$a = _taggedTemplateLiteral$1(["\n  display: flex;\n  font-size: 12px;\n  width: 100%;\n  margin: 0;\n  padding: 0.625rem 0.75rem 0.375rem 0.75rem;\n  text-decoration: none;\n  color: ", ";\n  &:focus,\n  &:hover,\n  &:active {\n    background-color: ", ";\n    color: ", ";\n    text-decoration: none;\n    outline: none;\n  }\n"])), function (props) {
//   return props.theme.variables.headerBarColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });
// var NavigateItemText = styled(ListItemText)(_templateObject6$8 || (_templateObject6$8 = _taggedTemplateLiteral$1(["\n  margin-top: 0rem;\n"])));
// var StyledButton$5 = styled(SumtButtonWrapper)(_templateObject7$8 || (_templateObject7$8 = _taggedTemplateLiteral$1(["\n  padding: 0.375rem 0.75rem;\n  text-transform: capitalize;\n  font-weight: 400;\n  font-size: 12px;\n  border: none;\n  box-shadow: none;\n  width: 100%;\n  text-align: left;\n  &:focus {\n    background-color: ", ";\n    color: ", ";\n    border: none;\n    box-shadow: none;\n    border-radius: inherit;\n  }\n  &:active {\n    background-color: ", ";\n    color: ", ";\n    border: none;\n    box-shadow: none;\n    border-radius: inherit;\n  }\n  &:hover {\n    background-color: ", ";\n    color: ", ";\n    border-radius: inherit;\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });

// /**
//  * Component for Listing actions that shows icon and name.
//  */
// function ActionsList(_ref) {
//   var itemList = _ref.itemList,
//     onItemClick = _ref.onItemClick;
//   var textSize = {
//     fontSize: 12,
//     margin: 0
//   };
//   return itemList.map(function (item) {
//     return item.actionType === 'NAVIGATE' ? /*#__PURE__*/React__default.createElement(NavigationMenuItem, {
//       key: item.key,
//       tabIndex: -1
//     }, /*#__PURE__*/React__default.createElement(NavigateLink, {
//       id: "navigateElement",
//       role: "none",
//       to: item.url,
//       onClick: function onClick() {
//         return onItemClick(item.key, item.actionType, item.url, item.rpKey);
//       }
//     }, /*#__PURE__*/React__default.createElement(ActionListItemIcon$1, null, /*#__PURE__*/React__default.createElement(Icon, {
//       iconName: item.iconName,
//       iconType: item.iconType,
//       size: 1
//     })), /*#__PURE__*/React__default.createElement(NavigateItemText, {
//       primary: item.name,
//       primaryTypographyProps: {
//         style: textSize
//       }
//     }))) : /*#__PURE__*/React__default.createElement(ActionMenuItem$1, {
//       key: item.key,
//       onClick: function onClick() {
//         return onItemClick(item.key, item.actionType, item.url, item.rpKey);
//       },
//       path: item.url,
//       "aria-label": item.ariaLabel,
//       role: "menuitem",
//       tabIndex: -1
//     }, /*#__PURE__*/React__default.createElement(StyledButton$5, {
//       disableFocusRipple: true,
//       tabIndex: -1,
//       role: "none"
//     }, /*#__PURE__*/React__default.createElement(ActionListItemIcon$1, null, /*#__PURE__*/React__default.createElement(Icon, {
//       iconName: item.iconName,
//       iconType: item.iconType,
//       size: 1
//     })), /*#__PURE__*/React__default.createElement(ActionListItemText, {
//       primary: item.name,
//       primaryTypographyProps: {
//         style: textSize
//       }
//     })));
//   });
// }

// // PropType check
// ActionsList.propTypes = {
//   /**
//    * action list
//    */
//   itemList: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * callback method for action click
//    */
//   onItemClick: PropTypes__default.func
// };

// // DefaultPropType check
// ActionsList.defaultProps = {
//   itemList: [],
//   onItemClick: undefined
// };

// var _templateObject$$;
// var StyledHighlighter = styled(Highlighter)(_templateObject$$ || (_templateObject$$ = _taggedTemplateLiteral$1(["\n  .markstyles {\n    background-color: transparent;\n    color: ", ";\n    text-decoration: none;\n    font-style: normal;\n    font-weight: bold;\n  }\n"])), function (props) {
//   return props.theme.variables.textColor;
// });

// /**
//  * The Autosuggest input allows you to search through a list of options.
//  */
// function AutoComplete(_ref) {
//   var multiple = _ref.multiple,
//     limitTags = _ref.limitTags,
//     onChange = _ref.onChange,
//     filterOptions = _ref.filterOptions,
//     onSearch = _ref.onSearch,
//     showIcon = _ref.showIcon,
//     getOptionLabel = _ref.getOptionLabel,
//     data = _ref.data,
//     label = _ref.label,
//     required = _ref.required,
//     inputProps = _ref.inputProps,
//     value = _ref.value,
//     variant = _ref.variant,
//     disabled = _ref.disabled,
//     getOptionSelected = _ref.getOptionSelected,
//     error = _ref.error,
//     helperText = _ref.helperText,
//     isLoading = _ref.isLoading,
//     loadingText = _ref.loadingText,
//     className = _ref.className,
//     renderOption = _ref.renderOption,
//     highlightFieldName = _ref.highlightFieldName,
//     paperComponent = _ref.paperComponent,
//     renderInput = _ref.renderInput,
//     open = _ref.open,
//     freeSolo = _ref.freeSolo,
//     disableClearable = _ref.disableClearable,
//     idProp = _ref.id;
//   var id = useId(idProp);
//   var handleSearch = function handleSearch(e, inputValue) {
//     onSearch(inputValue, e);
//   };
//   var customRenderInput;
//   var cutomRenderOption;
//   var renderOptionsText;
//   if (!renderOption && highlightFieldName && highlightFieldName !== '') {
//     cutomRenderOption = function cutomRenderOption(props, option, _ref2) {
//       var inputValue = _ref2.inputValue;
//       renderOptionsText = /*#__PURE__*/React__default.createElement("li", props, /*#__PURE__*/React__default.createElement(StyledHighlighter, {
//         highlightClassName: "markstyles",
//         textToHighlight: option[highlightFieldName],
//         searchText: inputValue
//       }));
//       return renderOptionsText;
//     };
//   } else {
//     cutomRenderOption = renderOption;
//   }
//   if (!renderInput) {
//     customRenderInput = function customRenderInput(params) {
//       var baseInputprops = params.inputProps,
//         elementInputProps = params.InputProps;
//       return /*#__PURE__*/React__default.createElement(TextField, _extends$v({}, params, {
//         inputProps: _objectSpread2$1(_objectSpread2$1({}, baseInputprops), inputProps),
//         InputProps: _objectSpread2$1(_objectSpread2$1({}, elementInputProps), {}, {
//           endAdornment: /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isLoading ? /*#__PURE__*/React__default.createElement(Loader, {
//             size: 1.25,
//             inheritColor: true
//           }) : null, elementInputProps.endAdornment)
//         }),
//         label: label,
//         required: required,
//         variant: variant,
//         error: error,
//         helperText: helperText,
//         className: className
//       }));
//     };
//   } else {
//     customRenderInput = renderInput;
//   }
//   return /*#__PURE__*/React__default.createElement(MuiAutoComplete, {
//     id: id,
//     disableClearable: disableClearable,
//     multiple: multiple,
//     limitTags: limitTags,
//     getOptionLabel: getOptionLabel,
//     options: data,
//     forcePopupIcon: showIcon,
//     onChange: onChange,
//     onInputChange: handleSearch,
//     value: value,
//     disabled: disabled,
//     open: open,
//     freeSolo: freeSolo,
//     isOptionEqualToValue: getOptionSelected,
//     renderOption: cutomRenderOption,
//     filterOptions: filterOptions,
//     PaperComponent: paperComponent,
//     loading: isLoading,
//     loadingText: loadingText,
//     renderInput: customRenderInput
//   });
// }
// AutoComplete.propTypes = {
//   /**
//    * If `true`, value must be an array and the menu will support multiple selections
//    */
//   multiple: PropTypes__default.bool,
//   /**
//    * The maximum number of tags that will be visible when not focused. Set -1 to disable the limit.
//    */
//   limitTags: PropTypes__default.number,
//   /**
//    * Callback fired when the value changes.
//    */
//   onChange: PropTypes__default.func,
//   filterOptions: PropTypes__default.func,
//   /**
//    * Callback fired when the search item changes.
//    */
//   onSearch: PropTypes__default.func,
//   /**
//    * Force the visibility display of the popup icon.
//    */
//   showIcon: PropTypes__default.bool,
//   /**
//    * Used to determine the string value for a given option. It's used to fill the input (and the list box options if renderOption is not provided).
//    */
//   getOptionLabel: PropTypes__default.func.isRequired,
//   /**
//    * Data for the combobox
//    */
//   data: PropTypes__default.arrayOf(PropTypes__default.shape({
//     name: PropTypes__default.string
//   })),
//   /**
//    * label for textfield
//    */
//   label: PropTypes__default.string,
//   /**
//    * Label is displayed as required
//    */
//   required: PropTypes__default.bool,
//   /**
//    * disable Clearable the autocomplete
//    */
//   disableClearable: PropTypes__default.bool,
//   /**
//    * id the autocomplete
//    */
//   id: PropTypes__default.string,
//   /**
//    * Props for input base
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * Value of the autocomplete
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.arrayOf(PropTypes__default.objectOf(PropTypes__default.any)), PropTypes__default.objectOf(PropTypes__default.any)]),
//   /**
//    * variant of the MUI text input
//    */
//   variant: PropTypes__default.oneOf(['standard', 'filled', 'outlined']),
//   /**
//    * disable the autocomplete
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Used to determine if an option is selected, considering the current value. Uses strict equality by default.
//    */
//   getOptionSelected: PropTypes__default.func,
//   /**
//    * Display label in error state
//    */
//   error: PropTypes__default.bool,
//   /**
//    * Content for helper text
//    */
//   helperText: PropTypes__default.node,
//   /**
//    * Display loading
//    */
//   isLoading: PropTypes__default.bool,
//   /**
//    * Display loading text
//    */
//   loadingText: PropTypes__default.node,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * Used to render custom elements for options.
//    */
//   renderOption: PropTypes__default.func,
//   /**
//    * Used to render highlight field for options.
//    */
//   highlightFieldName: PropTypes__default.string,
//   /**
//    * The component used to render the paper.
//    */
//   paperComponent: PropTypes__default.elementType,
//   /**
//    * Used to render custom elements for input.
//    */
//   renderInput: PropTypes__default.func,
//   /**
//    * Control the popup open state..
//    */
//   open: PropTypes__default.bool,
//   /**
//    * If `true`, the Autocomplete is free solo, meaning that the user input is not bound to provided options.
//    */
//   freeSolo: PropTypes__default.bool
// };
// AutoComplete.defaultProps = {
//   multiple: false,
//   limitTags: -1,
//   onChange: undefined,
//   filterOptions: undefined,
//   onSearch: function onSearch() {
//     return null;
//   },
//   showIcon: true,
//   data: undefined,
//   label: undefined,
//   required: false,
//   inputProps: {},
//   value: undefined,
//   variant: 'outlined',
//   getOptionSelected: function getOptionSelected() {
//     return null;
//   },
//   disabled: false,
//   error: false,
//   helperText: '',
//   isLoading: false,
//   loadingText: '...',
//   className: '',
//   renderOption: undefined,
//   highlightFieldName: '',
//   paperComponent: undefined,
//   renderInput: undefined,
//   open: undefined,
//   freeSolo: false,
//   disableClearable: false,
//   id: undefined
// };

// /**
//  *This component used to render avatar element as table cell content.
//  */
// function AvatarCell(_ref) {
//   var className = _ref.className,
//     height = _ref.height,
//     width = _ref.width,
//     alt = _ref.alt,
//     variant = _ref.variant,
//     ariaLabel = _ref.ariaLabel;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue;
//   return /*#__PURE__*/React__default.createElement(Avatar, {
//     src: cellValue,
//     className: className,
//     height: height,
//     width: width,
//     alt: alt,
//     variant: variant,
//     ariaLabel: ariaLabel
//   });
// }
// AvatarCell.propTypes = {
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * height of the image
//    */

//   height: PropTypes__default.number,
//   /**
//    * width of the image
//    */

//   width: PropTypes__default.number,
//   /**
//    * Base Avatar Variant
//    */
//   variant: PropTypes__default.oneOf(['circular', 'rounded', 'square']),
//   /**
//    * alternate text of profile image
//    */
//   alt: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for avatar
//    */
//   ariaLabel: PropTypes__default.string
// };
// AvatarCell.defaultProps = {
//   className: undefined,
//   height: 2,
//   width: 2,
//   variant: 'circular',
//   alt: 'profile image',
//   ariaLabel: null
// };

// var _templateObject$_, _templateObject2$J;
// var DonutContainerTop = styled.div(_templateObject$_ || (_templateObject$_ = _taggedTemplateLiteral$1(["\n  position: absolute;\n  .brandDanger {\n    color: ", ";\n  }\n  .brandWarning {\n    color: ", ";\n  }\n  .brandInfo {\n    color: ", ";\n  }\n  .brandSuccess {\n    color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.brandDanger;
// }, function (props) {
//   return props.theme.variables.brandWarning;
// }, function (props) {
//   return props.theme.variables.brandInfo;
// }, function (props) {
//   return props.theme.variables.brandSuccess;
// });
// var DonutContainerBottom = styled.div(_templateObject2$J || (_templateObject2$J = _taggedTemplateLiteral$1(["\n  position: absolute;\n  .MuiCircularProgress-colorPrimary {\n    color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.dropdownDividerBg;
// });

// /**
//  * Donut displays the percentage of completion.
//  */
// function Donut(_ref) {
//   var value = _ref.value,
//     size = _ref.size,
//     thickness = _ref.thickness,
//     donutVariant = _ref.donutVariant,
//     label = _ref.label;
//   var donutVal = value;
//   if (value > 0 && value < 100) {
//     donutVal = value;
//   } else if (value >= 100) {
//     donutVal = 99;
//   } else {
//     donutVal = 0;
//   }
//   var classname = '';
//   if (donutVariant === 'Info') {
//     classname = 'brandInfo';
//   } else if (donutVariant === 'Danger') {
//     classname = 'brandDanger';
//   } else if (donutVariant === 'Warning') {
//     classname = 'brandWarning';
//   } else {
//     classname = 'brandSuccess';
//   }
//   return /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(DonutContainerBottom, null, /*#__PURE__*/React__default.createElement(CircularProgress, {
//     value: 100,
//     size: size,
//     thickness: thickness,
//     variant: "determinate",
//     "aria-label": label
//   })), /*#__PURE__*/React__default.createElement(DonutContainerTop, null, /*#__PURE__*/React__default.createElement(CircularProgress, {
//     variant: "determinate",
//     size: size,
//     thickness: thickness,
//     value: donutVal,
//     className: classname,
//     "aria-label": label
//   })));
// }
// // PropType check
// Donut.propTypes = {
//   /**
//    * Percentage value completed
//    */
//   value: PropTypes$1.number.isRequired,
//   /**
//    * Size of the donut
//    */
//   size: PropTypes$1.number,
//   /**
//    * Thickness of the donut
//    */
//   thickness: PropTypes$1.number,
//   /**
//    * Variant used to track the color as the value increases
//    */
//   donutVariant: PropTypes$1.oneOf(['Info', 'Warning', 'Success', 'Danger']),
//   /**
//    * aria-label
//    */
//   label: PropTypes$1.string
// };
// Donut.defaultProps = {
//   size: 60,
//   thickness: 4,
//   donutVariant: 'Danger',
//   label: undefined
// };

// var _templateObject$Z, _templateObject2$I;
// var OuterBox = styled(Box)(_templateObject$Z || (_templateObject$Z = _taggedTemplateLiteral$1(["\n  position: relative;\n  display: inline-flex;\n"])));
// var InnerBox = styled(Box)(_templateObject2$I || (_templateObject2$I = _taggedTemplateLiteral$1(["\n  position: relative;\n  top: ", "px;\n  left: ", "px;\n"])), function (props) {
//   return props.top;
// }, function (props) {
//   return props.left;
// });

// /**
//  * Displays the percentage of completion around a avatar.
//  */
// function AvatarDonut(_ref) {
//   var value = _ref.value,
//     size = _ref.size,
//     thickness = _ref.thickness,
//     alt = _ref.alt,
//     imageUrl = _ref.imageUrl,
//     donutVariant = _ref.donutVariant,
//     label = _ref.label,
//     insideLabel = _ref.insideLabel;
//   return /*#__PURE__*/React__default.createElement(OuterBox, null, /*#__PURE__*/React__default.createElement(Donut, {
//     value: value,
//     thickness: thickness,
//     size: size,
//     donutVariant: donutVariant,
//     label: label
//   }), /*#__PURE__*/React__default.createElement(InnerBox, {
//     top: thickness + 4,
//     left: thickness + 4
//   }, insideLabel === '' ? /*#__PURE__*/React__default.createElement(Avatar, {
//     height: (size - thickness * 2 - 8) * 0.0625,
//     width: (size - thickness * 2 - 8) * 0.0625,
//     alt: alt,
//     src: imageUrl
//   }) : /*#__PURE__*/React__default.createElement(Avatar, {
//     height: (size - thickness * 2 - 8) * 0.0625,
//     width: (size - thickness * 2 - 8) * 0.0625,
//     alt: alt,
//     src: imageUrl
//   }, insideLabel)));
// }
// // PropType check
// AvatarDonut.propTypes = {
//   /**
//    * Percentage value completed
//    */
//   value: PropTypes$1.number.isRequired,
//   /**
//    * Image path for the avatar
//    */
//   imageUrl: PropTypes$1.string,
//   /**
//    * alternate text for the image in the avatar
//    */
//   alt: PropTypes$1.string,
//   /**
//    * size of the donut
//    */
//   size: PropTypes$1.number,
//   /**
//    * Thickness of the donut
//    */
//   thickness: PropTypes$1.number,
//   /**
//    * Variant used to track the color as the value increases
//    */
//   donutVariant: PropTypes$1.oneOf(['Info', 'Warning', 'Success', 'Danger']),
//   /**
//    * aria-label
//    */
//   label: PropTypes$1.string,
//   /**
//    * The content of the component.
//    */
//   insideLabel: PropTypes$1.string
// };
// AvatarDonut.defaultProps = {
//   imageUrl: '',
//   alt: '',
//   size: 60,
//   thickness: 4,
//   donutVariant: 'Danger',
//   label: undefined,
//   insideLabel: ''
// };

// /**
//  * This component is used to render link as table cell content in DataGrid.
//  */
// function ButtonCell(_ref) {
//   var className = _ref.className,
//     variant = _ref.variant,
//     onClick = _ref.onClick,
//     disabled = _ref.disabled,
//     size = _ref.size,
//     emptyLabel = _ref.emptyLabel,
//     startIcon = _ref.startIcon;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue,
//     cell = _useContext.cell;
//   var handleClick = function handleClick(event) {
//     onClick(cell.props.row.id);
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, cellValue ? /*#__PURE__*/React__default.createElement(Button$1, {
//     variant: variant,
//     onClick: function onClick(e) {
//       return handleClick();
//     },
//     disabled: disabled,
//     size: size,
//     className: className,
//     startIcon: startIcon
//   }, cellValue) : emptyLabel);
// }
// ButtonCell.propTypes = {
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Button variant
//    */
//   variant: PropTypes__default.string,
//   /**
//    * Button click action
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Button disable
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Button size
//    */
//   size: PropTypes__default.number,
//   /**
//    * If there is no button to be rendered in the cell then use this emptyLabel to show custom text.
//    */
//   emptyLabel: PropTypes__default.string,
//   /**
//    * Start icon node
//    */
//   startIcon: PropTypes__default.node
// };
// ButtonCell.defaultProps = {
//   className: '',
//   variant: 'primary',
//   onClick: undefined,
//   disabled: false,
//   size: undefined,
//   emptyLabel: '',
//   startIcon: undefined
// };

// var _templateObject$Y, _templateObject2$H;
// var DivContainer = styled.div(_templateObject$Y || (_templateObject$Y = _taggedTemplateLiteral$1(["\n  width: ", ";\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n"])), function (props) {
//   return props.containerWidth;
// });
// var StyledIconButton$5 = styled(IconButton)(_templateObject2$H || (_templateObject2$H = _taggedTemplateLiteral$1(["\n  font-size: 0.75rem;\n  font-weight: bold;\n  cursor: pointer;\n  line-height: 0.875rem;\n  text-transform: uppercase;\n"])));

// /* We can use this component to get Previous , Current and Next stage */
// function ButtonGroup(_ref) {
//   var color = _ref.color,
//     prevLabel = _ref.prevLabel,
//     currLabel = _ref.currLabel,
//     nextLabel = _ref.nextLabel,
//     prevHandler = _ref.prevHandler,
//     currHandler = _ref.currHandler,
//     nextHandler = _ref.nextHandler,
//     selectedLink = _ref.selectedLink,
//     containerWidth = _ref.containerWidth;
//   return /*#__PURE__*/React__default.createElement(DivContainer, {
//     containerWidth: containerWidth
//   }, /*#__PURE__*/React__default.createElement(StyledIconButton$5, {
//     onClick: prevHandler,
//     label: "left icon",
//     color: selectedLink === 'Previous' ? 'inherit' : color
//   }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//     iconName: "NavigateBefore"
//   }), prevLabel), /*#__PURE__*/React__default.createElement(StyledIconButton$5, {
//     label: "middle icon",
//     color: selectedLink === 'Current' ? 'inherit' : color,
//     onClick: currHandler
//   }, currLabel), /*#__PURE__*/React__default.createElement(StyledIconButton$5, {
//     label: "right icon",
//     color: selectedLink === 'Next' ? 'inherit' : color,
//     onClick: nextHandler
//   }, nextLabel, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//     iconName: "NavigateNext"
//   })));
// }
// ButtonGroup.propTypes = {
//   /**
//    * Child elements for the component
//    */
//   color: PropTypes__default.node,
//   /**
//    * Label for previous link button
//    */
//   prevLabel: PropTypes__default.string,
//   /**
//    * Label for Currnet link button
//    */
//   currLabel: PropTypes__default.string,
//   /**
//    * selected Link to set the click of selectd link button
//    */
//   selectedLink: PropTypes__default.string,
//   /**
//    * Label for Next link button
//    */
//   nextLabel: PropTypes__default.string,
//   /**
//    * Event for Previous link button
//    */
//   prevHandler: PropTypes__default.func,
//   /**
//    * Event for current link button
//    */
//   currHandler: PropTypes__default.func,
//   /**
//    * Event for next link button
//    */
//   nextHandler: PropTypes__default.func,
//   /**
//    * Div container width
//    */
//   containerWidth: PropTypes__default.string
// };
// ButtonGroup.defaultProps = {
//   color: 'primary',
//   prevLabel: 'PREV',
//   currLabel: 'CURRENT',
//   nextLabel: 'NEXT',
//   prevHandler: undefined,
//   nextHandler: undefined,
//   currHandler: undefined,
//   selectedLink: 'Previous',
//   containerWidth: '22rem'
// };

// /**
//  * Component for Calendar to show data day/week/month wise as passing day/week/month as data
//  */

// function CalendarContainer(_ref) {
//   var prevLabel = _ref.prevLabel,
//     currLabel = _ref.currLabel,
//     nextLabel = _ref.nextLabel,
//     prevHandler = _ref.prevHandler,
//     currHandler = _ref.currHandler,
//     nextHandler = _ref.nextHandler,
//     containerWidth = _ref.containerWidth,
//     selectedLink = _ref.selectedLink,
//     calendarComponent = _ref.calendarComponent;
//     _ref.onDayClick;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(ButtonGroup, {
//     prevLabel: prevLabel,
//     currLabel: currLabel,
//     nextLabel: nextLabel,
//     prevHandler: prevHandler,
//     currHandler: currHandler,
//     nextHandler: nextHandler,
//     selectedLink: selectedLink,
//     containerWidth: containerWidth
//   })), /*#__PURE__*/React__default.createElement("div", null, calendarComponent));
// }
// CalendarContainer.propTypes = {
//   /**
//    * Label for Prev link button
//    */
//   prevLabel: PropTypes__default.string,
//   /**
//    * Label for Currnet link button
//    */
//   currLabel: PropTypes__default.string,
//   /**
//    * Label for Next link button
//    */
//   nextLabel: PropTypes__default.string,
//   /**
//    * Event for Previous link button
//    */
//   prevHandler: PropTypes__default.func,
//   /**
//    * Event for Current link button
//    */
//   currHandler: PropTypes__default.func,
//   /**
//    * Event for Next link button
//    */
//   nextHandler: PropTypes__default.func,
//   /**
//    * selected Link
//    */
//   selectedLink: PropTypes__default.string,
//   /**
//    * calender component to be rendered
//    */
//   calendarComponent: PropTypes__default.node,
//   /**
//    * Div container width
//    */
//   containerWidth: PropTypes__default.string,
//   /**
//    * onDayClick event
//    */
//   onDayClick: PropTypes__default.func
// };
// CalendarContainer.defaultProps = {
//   prevLabel: 'PREV',
//   currLabel: 'CURRENT',
//   nextLabel: 'NEXT',
//   prevHandler: undefined,
//   nextHandler: undefined,
//   currHandler: undefined,
//   selectedLink: 'Previous',
//   calendarComponent: null,
//   containerWidth: '24rem',
//   onDayClick: undefined
// };

// function CardContent(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiCardContent, {
//     className: className
//   }, " ", children, " ");
// }
// // PropType check
// CardContent.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string
// };
// CardContent.defaultProps = {
//   children: undefined,
//   className: undefined
// };

// var _templateObject$X, _templateObject2$G;
// var DefaultContent$1 = styled(CardContent)(_templateObject$X || (_templateObject$X = _taggedTemplateLiteral$1(["\n  flex-grow: 1;\n  line-height: 1.25rem;\n  padding: 0rem 1rem;\n  text-align: left;\n"])));
// var DescriptionContainer = styled(Card)(_templateObject2$G || (_templateObject2$G = _taggedTemplateLiteral$1(["\n  min-width: ", ";\n  max-width: 25.625rem;\n  height: ", ";\n  border: none;\n  flex-grow: 1;\n  flex-basis: 100%;\n  padding: 1rem 0rem;\n"])), function (props) {
//   return props.width;
// }, function (props) {
//   return props.height;
// });

// function CardDescription(_ref) {
//   var description = _ref.description,
//     cardHeight = _ref.cardHeight,
//     cardWidth = _ref.cardWidth;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(DescriptionContainer, {
//     variant: "outlined",
//     height: cardHeight,
//     width: cardWidth
//   }, /*#__PURE__*/React__default.createElement(DefaultContent$1, null, /*#__PURE__*/React__default.createElement(LineClampText, {
//     maxLines: 4
//   }, description))));
// }
// // PropType check
// CardDescription.propTypes = {
//   /**
//    * Description of card
//    */
//   description: PropTypes__default.string,
//   /**
//    * Description of card
//    */
//   cardHeight: PropTypes__default.string,
//   /**
//    * Description of card
//    */
//   cardWidth: PropTypes__default.string
// };
// CardDescription.defaultProps = {
//   description: null,
//   cardHeight: '9.375rem',
//   cardWidth: '13.75rem'
// };

// var _templateObject$W, _templateObject2$F, _templateObject3$s;
// var NameContent$1 = styled(CardContent)(_templateObject$W || (_templateObject$W = _taggedTemplateLiteral$1(["\n  padding: 0rem;\n  flex-grow: 1;\n  align-self: center;\n  text-align: center;\n  margin-bottom: -1.5rem;\n"])));
// var NameCard$1 = styled(Card)(_templateObject2$F || (_templateObject2$F = _taggedTemplateLiteral$1(["\n  width: ", ";\n  height: ", ";\n  background-color: ", ";\n  color: ", ";\n  display: flex;\n  border-color: ", ";\n  flex-shrink: 0;\n  &.inactivecard{\n    background-color: ", ";\n    color: ", ";\n  }\n}\n"])), function (props) {
//   return props.width;
// }, function (props) {
//   return props.height;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var Name = styled.div(_templateObject3$s || (_templateObject3$s = _taggedTemplateLiteral$1(["\n  font-size: 1.375rem;\n  line-height: 1.7rem;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-line-clamp: 3;\n  -webkit-box-orient: vertical;\n"])));

// function CardName(_ref) {
//   var name = _ref.name,
//     variant = _ref.variant,
//     cardHeight = _ref.cardHeight,
//     cardWidth = _ref.cardWidth;
//   return /*#__PURE__*/React__default.createElement(NameCard$1, {
//     variant: "outlined",
//     height: cardHeight,
//     width: cardWidth,
//     className: variant === 'inactive' ? 'inactivecard' : ''
//   }, /*#__PURE__*/React__default.createElement(NameContent$1, null, /*#__PURE__*/React__default.createElement(Name, null, name)));
// }

// // PropType check
// CardName.propTypes = {
//   /**
//    * Card name
//    */
//   name: PropTypes__default.string,
//   /**
//    * Card variant
//    */
//   variant: PropTypes__default.oneOf(['active', 'inactive']),
//   /**
//    * Card height
//    */
//   cardHeight: PropTypes__default.string,
//   /**
//    * Card width
//    */
//   cardWidth: PropTypes__default.string
// };
// CardName.defaultProps = {
//   name: null,
//   variant: 'active',
//   cardHeight: '9.25rem',
//   cardWidth: '10.625rem'
// };

// var _templateObject$V, _templateObject2$E, _templateObject3$r, _templateObject4$f;
// var PreviewContainer = styled(Card)(_templateObject$V || (_templateObject$V = _taggedTemplateLiteral$1(["\n  border-color: ", ";\n  margin: 0.5rem;\n  border-radius: 0.625rem;\n  &:focus {\n    box-shadow: 0 0 0.625rem 0 ", ";\n    margin: 0.5rem 1.25rem;\n  }\n  color: ", ";\n  background-color: ", ";\n  &.activeCard {\n    color: ", ";\n    background-color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.grayBase;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var Content = styled(CardContent)(_templateObject2$E || (_templateObject2$E = _taggedTemplateLiteral$1(["\n  padding: 0rem;\n  height: inherit;\n  display: flex;\n  flex-wrap: wrap;\n  text-align: center;\n"])));
// var Count = styled.div(_templateObject3$r || (_templateObject3$r = _taggedTemplateLiteral$1(["\n  font-size: 3.75rem;\n  flex-basis: 100%;\n  margin: 2rem 2rem 1.3rem;\n"])));
// var Clamp$1 = styled(LineClampText)(_templateObject4$f || (_templateObject4$f = _taggedTemplateLiteral$1(["\n  text-align: center;\n  font-size: 1.1rem;\n  width: inherit;\n  padding: 1.5rem 1rem 0rem;\n  flex-grow: 1;\n  line-height: 1.5rem;\n"])));

// function CardPreview(_ref) {
//   var id = _ref.id,
//     name = _ref.name,
//     objectCount = _ref.objectCount,
//     cardHeight = _ref.cardHeight,
//     cardWidth = _ref.cardWidth,
//     variant = _ref.variant;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(PreviewContainer, {
//     id: id,
//     variant: "outlined",
//     height: cardHeight,
//     width: cardWidth,
//     className: variant === 'active' ? 'activeCard' : ''
//   }, /*#__PURE__*/React__default.createElement(Content, null, /*#__PURE__*/React__default.createElement(Count, null, objectCount), /*#__PURE__*/React__default.createElement(Clamp$1, {
//     maxLines: 2
//   }, name))));
// }

// // PropType check
// CardPreview.propTypes = {
//   /**
//    * Card id
//    */
//   id: PropTypes__default.string,
//   /**
//    * Card name
//    */
//   name: PropTypes__default.string,
//   /**
//    *  The count of tasks and activities for given card
//    */
//   objectCount: PropTypes__default.string,
//   /**
//    * Height of card
//    */
//   cardHeight: PropTypes__default.string,
//   /**
//    * Width of card
//    */
//   cardWidth: PropTypes__default.string,
//   /**
//    * Variant: Active/Inactive
//    */
//   variant: PropTypes__default.oneOf(['active', 'inactive'])
// };
// CardPreview.defaultProps = {
//   id: null,
//   name: null,
//   objectCount: '0',
//   cardHeight: '9.375rem',
//   cardWidth: '10.625rem',
//   variant: 'inactive'
// };

// function _extends$q() {
//   _extends$q = Object.assign || function (target) {
//     for (var i = 1; i < arguments.length; i++) {
//       var source = arguments[i];

//       for (var key in source) {
//         if (Object.prototype.hasOwnProperty.call(source, key)) {
//           target[key] = source[key];
//         }
//       }
//     }

//     return target;
//   };

//   return _extends$q.apply(this, arguments);
// }

// function _inheritsLoose(subClass, superClass) {
//   subClass.prototype = Object.create(superClass.prototype);
//   subClass.prototype.constructor = subClass;
//   subClass.__proto__ = superClass;
// }

// var defaultProps$4 = {
//   preventDefaultTouchmoveEvent: false,
//   delta: 10,
//   rotationAngle: 0,
//   trackMouse: false,
//   trackTouch: true
// };
// var initialState = {
//   xy: [0, 0],
//   swiping: false,
//   eventData: undefined,
//   start: undefined
// };
// var LEFT = 'Left';
// var RIGHT = 'Right';
// var UP = 'Up';
// var DOWN = 'Down';
// var touchStart = 'touchstart';
// var touchMove = 'touchmove';
// var touchEnd = 'touchend';
// var mouseMove = 'mousemove';
// var mouseUp = 'mouseup';

// function getDirection(absX, absY, deltaX, deltaY) {
//   if (absX > absY) {
//     if (deltaX > 0) {
//       return LEFT;
//     }

//     return RIGHT;
//   } else if (deltaY > 0) {
//     return UP;
//   }

//   return DOWN;
// }

// function rotateXYByAngle(pos, angle) {
//   if (angle === 0) return pos;
//   var angleInRadians = Math.PI / 180 * angle;
//   var x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);
//   var y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);
//   return [x, y];
// }

// function getHandlers(set, handlerProps) {
//   var onStart = function onStart(event) {
//     // if more than a single touch don't track, for now...
//     if (event.touches && event.touches.length > 1) return;
//     set(function (state, props) {
//       // setup mouse listeners on document to track swipe since swipe can leave container
//       if (props.trackMouse) {
//         document.addEventListener(mouseMove, onMove);
//         document.addEventListener(mouseUp, onUp);
//       }

//       var _ref = event.touches ? event.touches[0] : event,
//           clientX = _ref.clientX,
//           clientY = _ref.clientY;

//       var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);
//       return _extends$q({}, state, initialState, {
//         eventData: {
//           initial: [].concat(xy),
//           first: true
//         },
//         xy: xy,
//         start: event.timeStamp || 0
//       });
//     });
//   };

//   var onMove = function onMove(event) {
//     set(function (state, props) {
//       if (!state.xy[0] || !state.xy[1] || event.touches && event.touches.length > 1) {
//         return state;
//       }

//       var _ref2 = event.touches ? event.touches[0] : event,
//           clientX = _ref2.clientX,
//           clientY = _ref2.clientY;

//       var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle),
//           x = _rotateXYByAngle[0],
//           y = _rotateXYByAngle[1];

//       var deltaX = state.xy[0] - x;
//       var deltaY = state.xy[1] - y;
//       var absX = Math.abs(deltaX);
//       var absY = Math.abs(deltaY);
//       var time = (event.timeStamp || 0) - state.start;
//       var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1); // if swipe is under delta and we have not started to track a swipe: skip update

//       if (absX < props.delta && absY < props.delta && !state.swiping) return state;
//       var dir = getDirection(absX, absY, deltaX, deltaY);

//       var eventData = _extends$q({}, state.eventData, {
//         event: event,
//         absX: absX,
//         absY: absY,
//         deltaX: deltaX,
//         deltaY: deltaY,
//         velocity: velocity,
//         dir: dir
//       });

//       props.onSwiping && props.onSwiping(eventData); // track if a swipe is cancelable(handler for swiping or swiped(dir) exists)
//       // so we can call preventDefault if needed

//       var cancelablePageSwipe = false;

//       if (props.onSwiping || props.onSwiped || props["onSwiped" + dir]) {
//         cancelablePageSwipe = true;
//       }

//       if (cancelablePageSwipe && props.preventDefaultTouchmoveEvent && props.trackTouch && event.cancelable) event.preventDefault(); // first is now always false

//       return _extends$q({}, state, {
//         eventData: _extends$q({}, eventData, {
//           first: false
//         }),
//         swiping: true
//       });
//     });
//   };

//   var onEnd = function onEnd(event) {
//     set(function (state, props) {
//       var eventData;

//       if (state.swiping) {
//         eventData = _extends$q({}, state.eventData, {
//           event: event
//         });
//         props.onSwiped && props.onSwiped(eventData);
//         props["onSwiped" + eventData.dir] && props["onSwiped" + eventData.dir](eventData);
//       }

//       return _extends$q({}, state, initialState, {
//         eventData: eventData
//       });
//     });
//   };

//   var cleanUpMouse = function cleanUpMouse() {
//     // safe to just call removeEventListener
//     document.removeEventListener(mouseMove, onMove);
//     document.removeEventListener(mouseUp, onUp);
//   };

//   var onUp = function onUp(e) {
//     cleanUpMouse();
//     onEnd(e);
//   };

//   var attachTouch = function attachTouch(el) {
//     if (el && el.addEventListener) {
//       // attach touch event listeners and handlers
//       var tls = [[touchStart, onStart], [touchMove, onMove], [touchEnd, onEnd]];
//       tls.forEach(function (_ref3) {
//         var e = _ref3[0],
//             h = _ref3[1];
//         return el.addEventListener(e, h);
//       }); // return properly scoped cleanup method for removing listeners

//       return function () {
//         return tls.forEach(function (_ref4) {
//           var e = _ref4[0],
//               h = _ref4[1];
//           return el.removeEventListener(e, h);
//         });
//       };
//     }
//   };

//   var onRef = function onRef(el) {
//     // "inline" ref functions are called twice on render, once with null then again with DOM element
//     // ignore null here
//     if (el === null) return;
//     set(function (state, props) {
//       // if the same DOM el as previous just return state
//       if (state.el === el) return state;
//       var addState = {}; // if new DOM el clean up old DOM and reset cleanUpTouch

//       if (state.el && state.el !== el && state.cleanUpTouch) {
//         state.cleanUpTouch();
//         addState.cleanUpTouch = null;
//       } // only attach if we want to track touch


//       if (props.trackTouch && el) {
//         addState.cleanUpTouch = attachTouch(el);
//       } // store event attached DOM el for comparison, clean up, and re-attachment


//       return _extends$q({}, state, {
//         el: el
//       }, addState);
//     });
//   }; // set ref callback to attach touch event listeners


//   var output = {
//     ref: onRef // if track mouse attach mouse down listener

//   };

//   if (handlerProps.trackMouse) {
//     output.onMouseDown = onStart;
//   }

//   return [output, attachTouch];
// }

// function updateTransientState(state, props, attachTouch) {
//   var addState = {}; // clean up touch handlers if no longer tracking touches

//   if (!props.trackTouch && state.cleanUpTouch) {
//     state.cleanUpTouch();
//     addState.cleanUpTouch = null;
//   } else if (props.trackTouch && !state.cleanUpTouch) {
//     // attach/re-attach touch handlers
//     if (state.el) {
//       addState.cleanUpTouch = attachTouch(state.el);
//     }
//   }

//   return _extends$q({}, state, addState);
// }
// var Swipeable =
// /*#__PURE__*/
// function (_React$PureComponent) {
//   _inheritsLoose(Swipeable, _React$PureComponent);

//   function Swipeable(props) {
//     var _this;

//     _this = _React$PureComponent.call(this, props) || this;

//     _this._set = function (cb) {
//       _this.transientState = cb(_this.transientState, _this.props);
//     };

//     _this.transientState = _extends$q({}, initialState, {
//       type: 'class'
//     });
//     return _this;
//   }

//   var _proto = Swipeable.prototype;

//   _proto.render = function render() {
//     var _this$props = this.props,
//         className = _this$props.className,
//         style = _this$props.style,
//         _this$props$nodeName = _this$props.nodeName,
//         nodeName = _this$props$nodeName === void 0 ? 'div' : _this$props$nodeName,
//         innerRef = _this$props.innerRef,
//         children = _this$props.children,
//         trackMouse = _this$props.trackMouse;

//     var _getHandlers = getHandlers(this._set, {
//       trackMouse: trackMouse
//     }),
//         handlers = _getHandlers[0],
//         attachTouch = _getHandlers[1];

//     this.transientState = updateTransientState(this.transientState, this.props, attachTouch);
//     var ref = innerRef ? function (el) {
//       return innerRef(el), handlers.ref(el);
//     } : handlers.ref;
//     return React__default.createElement(nodeName, _extends$q({}, handlers, {
//       className: className,
//       style: style,
//       ref: ref
//     }), children);
//   };

//   return Swipeable;
// }(React__default.PureComponent);
// Swipeable.propTypes = {
//   onSwiped: PropTypes__default.func,
//   onSwiping: PropTypes__default.func,
//   onSwipedUp: PropTypes__default.func,
//   onSwipedRight: PropTypes__default.func,
//   onSwipedDown: PropTypes__default.func,
//   onSwipedLeft: PropTypes__default.func,
//   delta: PropTypes__default.number,
//   preventDefaultTouchmoveEvent: PropTypes__default.bool,
//   nodeName: PropTypes__default.string,
//   trackMouse: PropTypes__default.bool,
//   trackTouch: PropTypes__default.bool,
//   innerRef: PropTypes__default.func,
//   rotationAngle: PropTypes__default.number
// };
// Swipeable.defaultProps = defaultProps$4;

// /**
//  * A collection of shims that provide minimal functionality of the ES6 collections.
//  *
//  * These implementations are not meant to be used outside of the ResizeObserver
//  * modules as they cover only a limited range of use cases.
//  */
// /* eslint-disable require-jsdoc, valid-jsdoc */
// var MapShim = (function () {
//     if (typeof Map !== 'undefined') {
//         return Map;
//     }

//     /**
//      * Returns index in provided array that matches the specified key.
//      *
//      * @param {Array<Array>} arr
//      * @param {*} key
//      * @returns {number}
//      */
//     function getIndex(arr, key) {
//         var result = -1;

//         arr.some(function (entry, index) {
//             if (entry[0] === key) {
//                 result = index;

//                 return true;
//             }

//             return false;
//         });

//         return result;
//     }

//     return (function () {
//         function anonymous() {
//             this.__entries__ = [];
//         }

//         var prototypeAccessors = { size: { configurable: true } };

//         /**
//          * @returns {boolean}
//          */
//         prototypeAccessors.size.get = function () {
//             return this.__entries__.length;
//         };

//         /**
//          * @param {*} key
//          * @returns {*}
//          */
//         anonymous.prototype.get = function (key) {
//             var index = getIndex(this.__entries__, key);
//             var entry = this.__entries__[index];

//             return entry && entry[1];
//         };

//         /**
//          * @param {*} key
//          * @param {*} value
//          * @returns {void}
//          */
//         anonymous.prototype.set = function (key, value) {
//             var index = getIndex(this.__entries__, key);

//             if (~index) {
//                 this.__entries__[index][1] = value;
//             } else {
//                 this.__entries__.push([key, value]);
//             }
//         };

//         /**
//          * @param {*} key
//          * @returns {void}
//          */
//         anonymous.prototype.delete = function (key) {
//             var entries = this.__entries__;
//             var index = getIndex(entries, key);

//             if (~index) {
//                 entries.splice(index, 1);
//             }
//         };

//         /**
//          * @param {*} key
//          * @returns {void}
//          */
//         anonymous.prototype.has = function (key) {
//             return !!~getIndex(this.__entries__, key);
//         };

//         /**
//          * @returns {void}
//          */
//         anonymous.prototype.clear = function () {
//             this.__entries__.splice(0);
//         };

//         /**
//          * @param {Function} callback
//          * @param {*} [ctx=null]
//          * @returns {void}
//          */
//         anonymous.prototype.forEach = function (callback, ctx) {
//             var this$1$1 = this;
//             if ( ctx === void 0 ) ctx = null;

//             for (var i = 0, list = this$1$1.__entries__; i < list.length; i += 1) {
//                 var entry = list[i];

//                 callback.call(ctx, entry[1], entry[0]);
//             }
//         };

//         Object.defineProperties( anonymous.prototype, prototypeAccessors );

//         return anonymous;
//     }());
// })();

// /**
//  * Detects whether window and document objects are available in current environment.
//  */
// var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// // Returns global object of a current environment.
// var global$1 = (function () {
//     if (typeof global !== 'undefined' && global.Math === Math) {
//         return global;
//     }

//     if (typeof self !== 'undefined' && self.Math === Math) {
//         return self;
//     }

//     if (typeof window !== 'undefined' && window.Math === Math) {
//         return window;
//     }

//     // eslint-disable-next-line no-new-func
//     return Function('return this')();
// })();

// /**
//  * A shim for the requestAnimationFrame which falls back to the setTimeout if
//  * first one is not supported.
//  *
//  * @returns {number} Requests' identifier.
//  */
// var requestAnimationFrame$1 = (function () {
//     if (typeof requestAnimationFrame === 'function') {
//         // It's required to use a bounded function because IE sometimes throws
//         // an "Invalid calling object" error if rAF is invoked without the global
//         // object on the left hand side.
//         return requestAnimationFrame.bind(global$1);
//     }

//     return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
// })();

// // Defines minimum timeout before adding a trailing call.
// var trailingTimeout = 2;

// /**
//  * Creates a wrapper function which ensures that provided callback will be
//  * invoked only once during the specified delay period.
//  *
//  * @param {Function} callback - Function to be invoked after the delay period.
//  * @param {number} delay - Delay after which to invoke callback.
//  * @returns {Function}
//  */
// var throttle = function (callback, delay) {
//     var leadingCall = false,
//         trailingCall = false,
//         lastCallTime = 0;

//     /**
//      * Invokes the original callback function and schedules new invocation if
//      * the "proxy" was called during current request.
//      *
//      * @returns {void}
//      */
//     function resolvePending() {
//         if (leadingCall) {
//             leadingCall = false;

//             callback();
//         }

//         if (trailingCall) {
//             proxy();
//         }
//     }

//     /**
//      * Callback invoked after the specified delay. It will further postpone
//      * invocation of the original function delegating it to the
//      * requestAnimationFrame.
//      *
//      * @returns {void}
//      */
//     function timeoutCallback() {
//         requestAnimationFrame$1(resolvePending);
//     }

//     /**
//      * Schedules invocation of the original function.
//      *
//      * @returns {void}
//      */
//     function proxy() {
//         var timeStamp = Date.now();

//         if (leadingCall) {
//             // Reject immediately following calls.
//             if (timeStamp - lastCallTime < trailingTimeout) {
//                 return;
//             }

//             // Schedule new call to be in invoked when the pending one is resolved.
//             // This is important for "transitions" which never actually start
//             // immediately so there is a chance that we might miss one if change
//             // happens amids the pending invocation.
//             trailingCall = true;
//         } else {
//             leadingCall = true;
//             trailingCall = false;

//             setTimeout(timeoutCallback, delay);
//         }

//         lastCallTime = timeStamp;
//     }

//     return proxy;
// };

// // Minimum delay before invoking the update of observers.
// var REFRESH_DELAY = 20;

// // A list of substrings of CSS properties used to find transition events that
// // might affect dimensions of observed elements.
// var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];

// // Check if MutationObserver is available.
// var mutationObserverSupported = typeof MutationObserver !== 'undefined';

// /**
//  * Singleton controller class which handles updates of ResizeObserver instances.
//  */
// var ResizeObserverController = function() {
//     this.connected_ = false;
//     this.mutationEventsAdded_ = false;
//     this.mutationsObserver_ = null;
//     this.observers_ = [];

//     this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
//     this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
// };

// /**
//  * Adds observer to observers list.
//  *
//  * @param {ResizeObserverSPI} observer - Observer to be added.
//  * @returns {void}
//  */


// /**
//  * Holds reference to the controller's instance.
//  *
//  * @private {ResizeObserverController}
//  */


// /**
//  * Keeps reference to the instance of MutationObserver.
//  *
//  * @private {MutationObserver}
//  */

// /**
//  * Indicates whether DOM listeners have been added.
//  *
//  * @private {boolean}
//  */
// ResizeObserverController.prototype.addObserver = function (observer) {
//     if (!~this.observers_.indexOf(observer)) {
//         this.observers_.push(observer);
//     }

//     // Add listeners if they haven't been added yet.
//     if (!this.connected_) {
//         this.connect_();
//     }
// };

// /**
//  * Removes observer from observers list.
//  *
//  * @param {ResizeObserverSPI} observer - Observer to be removed.
//  * @returns {void}
//  */
// ResizeObserverController.prototype.removeObserver = function (observer) {
//     var observers = this.observers_;
//     var index = observers.indexOf(observer);

//     // Remove observer if it's present in registry.
//     if (~index) {
//         observers.splice(index, 1);
//     }

//     // Remove listeners if controller has no connected observers.
//     if (!observers.length && this.connected_) {
//         this.disconnect_();
//     }
// };

// /**
//  * Invokes the update of observers. It will continue running updates insofar
//  * it detects changes.
//  *
//  * @returns {void}
//  */
// ResizeObserverController.prototype.refresh = function () {
//     var changesDetected = this.updateObservers_();

//     // Continue running updates if changes have been detected as there might
//     // be future ones caused by CSS transitions.
//     if (changesDetected) {
//         this.refresh();
//     }
// };

// /**
//  * Updates every observer from observers list and notifies them of queued
//  * entries.
//  *
//  * @private
//  * @returns {boolean} Returns "true" if any observer has detected changes in
//  *  dimensions of it's elements.
//  */
// ResizeObserverController.prototype.updateObservers_ = function () {
//     // Collect observers that have active observations.
//     var activeObservers = this.observers_.filter(function (observer) {
//         return observer.gatherActive(), observer.hasActive();
//     });

//     // Deliver notifications in a separate cycle in order to avoid any
//     // collisions between observers, e.g. when multiple instances of
//     // ResizeObserver are tracking the same element and the callback of one
//     // of them changes content dimensions of the observed target. Sometimes
//     // this may result in notifications being blocked for the rest of observers.
//     activeObservers.forEach(function (observer) { return observer.broadcastActive(); });

//     return activeObservers.length > 0;
// };

// /**
//  * Initializes DOM listeners.
//  *
//  * @private
//  * @returns {void}
//  */
// ResizeObserverController.prototype.connect_ = function () {
//     // Do nothing if running in a non-browser environment or if listeners
//     // have been already added.
//     if (!isBrowser || this.connected_) {
//         return;
//     }

//     // Subscription to the "Transitionend" event is used as a workaround for
//     // delayed transitions. This way it's possible to capture at least the
//     // final state of an element.
//     document.addEventListener('transitionend', this.onTransitionEnd_);

//     window.addEventListener('resize', this.refresh);

//     if (mutationObserverSupported) {
//         this.mutationsObserver_ = new MutationObserver(this.refresh);

//         this.mutationsObserver_.observe(document, {
//             attributes: true,
//             childList: true,
//             characterData: true,
//             subtree: true
//         });
//     } else {
//         document.addEventListener('DOMSubtreeModified', this.refresh);

//         this.mutationEventsAdded_ = true;
//     }

//     this.connected_ = true;
// };

// /**
//  * Removes DOM listeners.
//  *
//  * @private
//  * @returns {void}
//  */
// ResizeObserverController.prototype.disconnect_ = function () {
//     // Do nothing if running in a non-browser environment or if listeners
//     // have been already removed.
//     if (!isBrowser || !this.connected_) {
//         return;
//     }

//     document.removeEventListener('transitionend', this.onTransitionEnd_);
//     window.removeEventListener('resize', this.refresh);

//     if (this.mutationsObserver_) {
//         this.mutationsObserver_.disconnect();
//     }

//     if (this.mutationEventsAdded_) {
//         document.removeEventListener('DOMSubtreeModified', this.refresh);
//     }

//     this.mutationsObserver_ = null;
//     this.mutationEventsAdded_ = false;
//     this.connected_ = false;
// };

// /**
//  * "Transitionend" event handler.
//  *
//  * @private
//  * @param {TransitionEvent} event
//  * @returns {void}
//  */
// ResizeObserverController.prototype.onTransitionEnd_ = function (ref) {
//         var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';

//     // Detect whether transition may affect dimensions of an element.
//     var isReflowProperty = transitionKeys.some(function (key) {
//         return !!~propertyName.indexOf(key);
//     });

//     if (isReflowProperty) {
//         this.refresh();
//     }
// };

// /**
//  * Returns instance of the ResizeObserverController.
//  *
//  * @returns {ResizeObserverController}
//  */
// ResizeObserverController.getInstance = function () {
//     if (!this.instance_) {
//         this.instance_ = new ResizeObserverController();
//     }

//     return this.instance_;
// };

// ResizeObserverController.instance_ = null;

// /**
//  * Defines non-writable/enumerable properties of the provided target object.
//  *
//  * @param {Object} target - Object for which to define properties.
//  * @param {Object} props - Properties to be defined.
//  * @returns {Object} Target object.
//  */
// var defineConfigurable = (function (target, props) {
//     for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {
//         var key = list[i];

//         Object.defineProperty(target, key, {
//             value: props[key],
//             enumerable: false,
//             writable: false,
//             configurable: true
//         });
//     }

//     return target;
// });

// /**
//  * Returns the global object associated with provided element.
//  *
//  * @param {Object} target
//  * @returns {Object}
//  */
// var getWindowOf = (function (target) {
//     // Assume that the element is an instance of Node, which means that it
//     // has the "ownerDocument" property from which we can retrieve a
//     // corresponding global object.
//     var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;

//     // Return the local global object if it's not possible extract one from
//     // provided element.
//     return ownerGlobal || global$1;
// });

// // Placeholder of an empty content rectangle.
// var emptyRect = createRectInit(0, 0, 0, 0);

// /**
//  * Converts provided string to a number.
//  *
//  * @param {number|string} value
//  * @returns {number}
//  */
// function toFloat(value) {
//     return parseFloat(value) || 0;
// }

// /**
//  * Extracts borders size from provided styles.
//  *
//  * @param {CSSStyleDeclaration} styles
//  * @param {...string} positions - Borders positions (top, right, ...)
//  * @returns {number}
//  */
// function getBordersSize(styles) {
//     var positions = [], len = arguments.length - 1;
//     while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];

//     return positions.reduce(function (size, position) {
//         var value = styles['border-' + position + '-width'];

//         return size + toFloat(value);
//     }, 0);
// }

// /**
//  * Extracts paddings sizes from provided styles.
//  *
//  * @param {CSSStyleDeclaration} styles
//  * @returns {Object} Paddings box.
//  */
// function getPaddings(styles) {
//     var positions = ['top', 'right', 'bottom', 'left'];
//     var paddings = {};

//     for (var i = 0, list = positions; i < list.length; i += 1) {
//         var position = list[i];

//         var value = styles['padding-' + position];

//         paddings[position] = toFloat(value);
//     }

//     return paddings;
// }

// /**
//  * Calculates content rectangle of provided SVG element.
//  *
//  * @param {SVGGraphicsElement} target - Element content rectangle of which needs
//  *      to be calculated.
//  * @returns {DOMRectInit}
//  */
// function getSVGContentRect(target) {
//     var bbox = target.getBBox();

//     return createRectInit(0, 0, bbox.width, bbox.height);
// }

// /**
//  * Calculates content rectangle of provided HTMLElement.
//  *
//  * @param {HTMLElement} target - Element for which to calculate the content rectangle.
//  * @returns {DOMRectInit}
//  */
// function getHTMLElementContentRect(target) {
//     // Client width & height properties can't be
//     // used exclusively as they provide rounded values.
//     var clientWidth = target.clientWidth;
//     var clientHeight = target.clientHeight;

//     // By this condition we can catch all non-replaced inline, hidden and
//     // detached elements. Though elements with width & height properties less
//     // than 0.5 will be discarded as well.
//     //
//     // Without it we would need to implement separate methods for each of
//     // those cases and it's not possible to perform a precise and performance
//     // effective test for hidden elements. E.g. even jQuery's ':visible' filter
//     // gives wrong results for elements with width & height less than 0.5.
//     if (!clientWidth && !clientHeight) {
//         return emptyRect;
//     }

//     var styles = getWindowOf(target).getComputedStyle(target);
//     var paddings = getPaddings(styles);
//     var horizPad = paddings.left + paddings.right;
//     var vertPad = paddings.top + paddings.bottom;

//     // Computed styles of width & height are being used because they are the
//     // only dimensions available to JS that contain non-rounded values. It could
//     // be possible to utilize the getBoundingClientRect if only it's data wasn't
//     // affected by CSS transformations let alone paddings, borders and scroll bars.
//     var width = toFloat(styles.width),
//         height = toFloat(styles.height);

//     // Width & height include paddings and borders when the 'border-box' box
//     // model is applied (except for IE).
//     if (styles.boxSizing === 'border-box') {
//         // Following conditions are required to handle Internet Explorer which
//         // doesn't include paddings and borders to computed CSS dimensions.
//         //
//         // We can say that if CSS dimensions + paddings are equal to the "client"
//         // properties then it's either IE, and thus we don't need to subtract
//         // anything, or an element merely doesn't have paddings/borders styles.
//         if (Math.round(width + horizPad) !== clientWidth) {
//             width -= getBordersSize(styles, 'left', 'right') + horizPad;
//         }

//         if (Math.round(height + vertPad) !== clientHeight) {
//             height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
//         }
//     }

//     // Following steps can't be applied to the document's root element as its
//     // client[Width/Height] properties represent viewport area of the window.
//     // Besides, it's as well not necessary as the <html> itself neither has
//     // rendered scroll bars nor it can be clipped.
//     if (!isDocumentElement(target)) {
//         // In some browsers (only in Firefox, actually) CSS width & height
//         // include scroll bars size which can be removed at this step as scroll
//         // bars are the only difference between rounded dimensions + paddings
//         // and "client" properties, though that is not always true in Chrome.
//         var vertScrollbar = Math.round(width + horizPad) - clientWidth;
//         var horizScrollbar = Math.round(height + vertPad) - clientHeight;

//         // Chrome has a rather weird rounding of "client" properties.
//         // E.g. for an element with content width of 314.2px it sometimes gives
//         // the client width of 315px and for the width of 314.7px it may give
//         // 314px. And it doesn't happen all the time. So just ignore this delta
//         // as a non-relevant.
//         if (Math.abs(vertScrollbar) !== 1) {
//             width -= vertScrollbar;
//         }

//         if (Math.abs(horizScrollbar) !== 1) {
//             height -= horizScrollbar;
//         }
//     }

//     return createRectInit(paddings.left, paddings.top, width, height);
// }

// /**
//  * Checks whether provided element is an instance of the SVGGraphicsElement.
//  *
//  * @param {Element} target - Element to be checked.
//  * @returns {boolean}
//  */
// var isSVGGraphicsElement = (function () {
//     // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
//     // interface.
//     if (typeof SVGGraphicsElement !== 'undefined') {
//         return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
//     }

//     // If it's so, then check that element is at least an instance of the
//     // SVGElement and that it has the "getBBox" method.
//     // eslint-disable-next-line no-extra-parens
//     return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };
// })();

// /**
//  * Checks whether provided element is a document element (<html>).
//  *
//  * @param {Element} target - Element to be checked.
//  * @returns {boolean}
//  */
// function isDocumentElement(target) {
//     return target === getWindowOf(target).document.documentElement;
// }

// /**
//  * Calculates an appropriate content rectangle for provided html or svg element.
//  *
//  * @param {Element} target - Element content rectangle of which needs to be calculated.
//  * @returns {DOMRectInit}
//  */
// function getContentRect(target) {
//     if (!isBrowser) {
//         return emptyRect;
//     }

//     if (isSVGGraphicsElement(target)) {
//         return getSVGContentRect(target);
//     }

//     return getHTMLElementContentRect(target);
// }

// /**
//  * Creates rectangle with an interface of the DOMRectReadOnly.
//  * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
//  *
//  * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
//  * @returns {DOMRectReadOnly}
//  */
// function createReadOnlyRect(ref) {
//     var x = ref.x;
//     var y = ref.y;
//     var width = ref.width;
//     var height = ref.height;

//     // If DOMRectReadOnly is available use it as a prototype for the rectangle.
//     var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
//     var rect = Object.create(Constr.prototype);

//     // Rectangle's properties are not writable and non-enumerable.
//     defineConfigurable(rect, {
//         x: x, y: y, width: width, height: height,
//         top: y,
//         right: x + width,
//         bottom: height + y,
//         left: x
//     });

//     return rect;
// }

// /**
//  * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
//  * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
//  *
//  * @param {number} x - X coordinate.
//  * @param {number} y - Y coordinate.
//  * @param {number} width - Rectangle's width.
//  * @param {number} height - Rectangle's height.
//  * @returns {DOMRectInit}
//  */
// function createRectInit(x, y, width, height) {
//     return { x: x, y: y, width: width, height: height };
// }

// /**
//  * Class that is responsible for computations of the content rectangle of
//  * provided DOM element and for keeping track of it's changes.
//  */
// var ResizeObservation = function(target) {
//     this.broadcastWidth = 0;
//     this.broadcastHeight = 0;
//     this.contentRect_ = createRectInit(0, 0, 0, 0);

//     this.target = target;
// };

// /**
//  * Updates content rectangle and tells whether it's width or height properties
//  * have changed since the last broadcast.
//  *
//  * @returns {boolean}
//  */


// /**
//  * Reference to the last observed content rectangle.
//  *
//  * @private {DOMRectInit}
//  */


// /**
//  * Broadcasted width of content rectangle.
//  *
//  * @type {number}
//  */
// ResizeObservation.prototype.isActive = function () {
//     var rect = getContentRect(this.target);

//     this.contentRect_ = rect;

//     return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
// };

// /**
//  * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
//  * from the corresponding properties of the last observed content rectangle.
//  *
//  * @returns {DOMRectInit} Last observed content rectangle.
//  */
// ResizeObservation.prototype.broadcastRect = function () {
//     var rect = this.contentRect_;

//     this.broadcastWidth = rect.width;
//     this.broadcastHeight = rect.height;

//     return rect;
// };

// var ResizeObserverEntry = function(target, rectInit) {
//     var contentRect = createReadOnlyRect(rectInit);

//     // According to the specification following properties are not writable
//     // and are also not enumerable in the native implementation.
//     //
//     // Property accessors are not being used as they'd require to define a
//     // private WeakMap storage which may cause memory leaks in browsers that
//     // don't support this type of collections.
//     defineConfigurable(this, { target: target, contentRect: contentRect });
// };

// var ResizeObserverSPI = function(callback, controller, callbackCtx) {
//     this.activeObservations_ = [];
//     this.observations_ = new MapShim();

//     if (typeof callback !== 'function') {
//         throw new TypeError('The callback provided as parameter 1 is not a function.');
//     }

//     this.callback_ = callback;
//     this.controller_ = controller;
//     this.callbackCtx_ = callbackCtx;
// };

// /**
//  * Starts observing provided element.
//  *
//  * @param {Element} target - Element to be observed.
//  * @returns {void}
//  */


// /**
//  * Registry of the ResizeObservation instances.
//  *
//  * @private {Map<Element, ResizeObservation>}
//  */


// /**
//  * Public ResizeObserver instance which will be passed to the callback
//  * function and used as a value of it's "this" binding.
//  *
//  * @private {ResizeObserver}
//  */

// /**
//  * Collection of resize observations that have detected changes in dimensions
//  * of elements.
//  *
//  * @private {Array<ResizeObservation>}
//  */
// ResizeObserverSPI.prototype.observe = function (target) {
//     if (!arguments.length) {
//         throw new TypeError('1 argument required, but only 0 present.');
//     }

//     // Do nothing if current environment doesn't have the Element interface.
//     if (typeof Element === 'undefined' || !(Element instanceof Object)) {
//         return;
//     }

//     if (!(target instanceof getWindowOf(target).Element)) {
//         throw new TypeError('parameter 1 is not of type "Element".');
//     }

//     var observations = this.observations_;

//     // Do nothing if element is already being observed.
//     if (observations.has(target)) {
//         return;
//     }

//     observations.set(target, new ResizeObservation(target));

//     this.controller_.addObserver(this);

//     // Force the update of observations.
//     this.controller_.refresh();
// };

// /**
//  * Stops observing provided element.
//  *
//  * @param {Element} target - Element to stop observing.
//  * @returns {void}
//  */
// ResizeObserverSPI.prototype.unobserve = function (target) {
//     if (!arguments.length) {
//         throw new TypeError('1 argument required, but only 0 present.');
//     }

//     // Do nothing if current environment doesn't have the Element interface.
//     if (typeof Element === 'undefined' || !(Element instanceof Object)) {
//         return;
//     }

//     if (!(target instanceof getWindowOf(target).Element)) {
//         throw new TypeError('parameter 1 is not of type "Element".');
//     }

//     var observations = this.observations_;

//     // Do nothing if element is not being observed.
//     if (!observations.has(target)) {
//         return;
//     }

//     observations.delete(target);

//     if (!observations.size) {
//         this.controller_.removeObserver(this);
//     }
// };

// /**
//  * Stops observing all elements.
//  *
//  * @returns {void}
//  */
// ResizeObserverSPI.prototype.disconnect = function () {
//     this.clearActive();
//     this.observations_.clear();
//     this.controller_.removeObserver(this);
// };

// /**
//  * Collects observation instances the associated element of which has changed
//  * it's content rectangle.
//  *
//  * @returns {void}
//  */
// ResizeObserverSPI.prototype.gatherActive = function () {
//         var this$1$1 = this;

//     this.clearActive();

//     this.observations_.forEach(function (observation) {
//         if (observation.isActive()) {
//             this$1$1.activeObservations_.push(observation);
//         }
//     });
// };

// /**
//  * Invokes initial callback function with a list of ResizeObserverEntry
//  * instances collected from active resize observations.
//  *
//  * @returns {void}
//  */
// ResizeObserverSPI.prototype.broadcastActive = function () {
//     // Do nothing if observer doesn't have active observations.
//     if (!this.hasActive()) {
//         return;
//     }

//     var ctx = this.callbackCtx_;

//     // Create ResizeObserverEntry instance for every active observation.
//     var entries = this.activeObservations_.map(function (observation) {
//         return new ResizeObserverEntry(observation.target, observation.broadcastRect());
//     });

//     this.callback_.call(ctx, entries, ctx);
//     this.clearActive();
// };

// /**
//  * Clears the collection of active observations.
//  *
//  * @returns {void}
//  */
// ResizeObserverSPI.prototype.clearActive = function () {
//     this.activeObservations_.splice(0);
// };

// /**
//  * Tells whether observer has active observations.
//  *
//  * @returns {boolean}
//  */
// ResizeObserverSPI.prototype.hasActive = function () {
//     return this.activeObservations_.length > 0;
// };

// // Registry of internal observers. If WeakMap is not available use current shim
// // for the Map collection as it has all required methods and because WeakMap
// // can't be fully polyfilled anyway.
// var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();

// /**
//  * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
//  * exposing only those methods and properties that are defined in the spec.
//  */
// var ResizeObserver = function(callback) {
//     if (!(this instanceof ResizeObserver)) {
//         throw new TypeError('Cannot call a class as a function.');
//     }
//     if (!arguments.length) {
//         throw new TypeError('1 argument required, but only 0 present.');
//     }

//     var controller = ResizeObserverController.getInstance();
//     var observer = new ResizeObserverSPI(callback, controller, this);

//     observers.set(this, observer);
// };

// // Expose public methods of ResizeObserver.
// ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
//     ResizeObserver.prototype[method] = function () {
//         return (ref = observers.get(this))[method].apply(ref, arguments);
//         var ref;
//     };
// });

// var index = (function () {
//     // Export existing implementation if available.
//     if (typeof global$1.ResizeObserver !== 'undefined') {
//         return global$1.ResizeObserver;
//     }

//     return ResizeObserver;
// })();

// var classCallCheck = function (instance, Constructor) {
//   if (!(instance instanceof Constructor)) {
//     throw new TypeError("Cannot call a class as a function");
//   }
// };

// var createClass = function () {
//   function defineProperties(target, props) {
//     for (var i = 0; i < props.length; i++) {
//       var descriptor = props[i];
//       descriptor.enumerable = descriptor.enumerable || false;
//       descriptor.configurable = true;
//       if ("value" in descriptor) descriptor.writable = true;
//       Object.defineProperty(target, descriptor.key, descriptor);
//     }
//   }

//   return function (Constructor, protoProps, staticProps) {
//     if (protoProps) defineProperties(Constructor.prototype, protoProps);
//     if (staticProps) defineProperties(Constructor, staticProps);
//     return Constructor;
//   };
// }();

// var _extends$p = Object.assign || function (target) {
//   for (var i = 1; i < arguments.length; i++) {
//     var source = arguments[i];

//     for (var key in source) {
//       if (Object.prototype.hasOwnProperty.call(source, key)) {
//         target[key] = source[key];
//       }
//     }
//   }

//   return target;
// };

// var inherits = function (subClass, superClass) {
//   if (typeof superClass !== "function" && superClass !== null) {
//     throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
//   }

//   subClass.prototype = Object.create(superClass && superClass.prototype, {
//     constructor: {
//       value: subClass,
//       enumerable: false,
//       writable: true,
//       configurable: true
//     }
//   });
//   if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
// };

// var objectWithoutProperties$1 = function (obj, keys) {
//   var target = {};

//   for (var i in obj) {
//     if (keys.indexOf(i) >= 0) continue;
//     if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
//     target[i] = obj[i];
//   }

//   return target;
// };

// var possibleConstructorReturn = function (self, call) {
//   if (!self) {
//     throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
//   }

//   return call && (typeof call === "object" || typeof call === "function") ? call : self;
// };

// var Only = function (_Component) {
//   inherits(Only, _Component);

//   function Only() {
//     classCallCheck(this, Only);
//     return possibleConstructorReturn(this, (Only.__proto__ || Object.getPrototypeOf(Only)).apply(this, arguments));
//   }

//   createClass(Only, [{
//     key: 'render',
//     value: function render() {
//       var _props = this.props,
//           children = _props.children,
//           when = _props.when,
//           hiddenMode = _props.hiddenMode,
//           className = _props.className;

//       var singleChild = React__default.Children.only(children);
//       var _singleChild$props = singleChild.props,
//           style = _singleChild$props.style,
//           restOfChildProps = objectWithoutProperties$1(_singleChild$props, ['style']);

//       var extendedProps = _extends$p({}, restOfChildProps);

//       var keepNode = hiddenMode && hiddenMode !== "withNull";

//       if (keepNode) {
//         if (hiddenMode === "withCss") {
//           extendedProps.className = extendedProps.className + ' ' + className;
//         } else {
//           extendedProps.style = _extends$p({}, style, hiddenMode === "withDisplay" && { display: "none" }, hiddenMode === "withVisibility" && { visibility: "hidden" });
//         }
//       }
//       var cloned = React__default.cloneElement(singleChild, extendedProps);
//       var toHide = keepNode ? cloned : null;

//       return when ? singleChild : toHide;
//     }
//   }]);
//   return Only;
// }(Component);

// Only.defaultProps = {
//   hiddenMode: "withNull",
//   className: "r-o_hidden"
// };
// Only.propTypes = {
//   /** A single child element */
//   children: PropTypes__default.element.isRequired,

//   /** When true, children will rendered as is  */
//   when: PropTypes__default.bool.isRequired,

//   /** Determines how "react-only-when" should hide the child element 
//    * "withNull": Will not render the child
//    * "withDisplay": Will render the child with display:none  
//    * "withVisibility": Will render the child with visibility:hidden
//    * "withCss": Will render the child with a CSS class (you can pass it a custom className prop)
//   */
//   hiddenMode: PropTypes__default.oneOf(["withNull", "withDisplay", "withVisibility", "withCss"]),
//   /** This is working in combination with hiddenMode={"withCss"}   */
//   className: PropTypes__default.string
// };

// function _classCallCheck$e(instance, Constructor) {
//   if (!(instance instanceof Constructor)) {
//     throw new TypeError("Cannot call a class as a function");
//   }
// }

// function _defineProperties$e(target, props) {
//   for (var i = 0; i < props.length; i++) {
//     var descriptor = props[i];
//     descriptor.enumerable = descriptor.enumerable || false;
//     descriptor.configurable = true;
//     if ("value" in descriptor) descriptor.writable = true;
//     Object.defineProperty(target, descriptor.key, descriptor);
//   }
// }

// function _createClass$e(Constructor, protoProps, staticProps) {
//   if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
//   if (staticProps) _defineProperties$e(Constructor, staticProps);
//   return Constructor;
// }

// function _defineProperty$A(obj, key, value) {
//   if (key in obj) {
//     Object.defineProperty(obj, key, {
//       value: value,
//       enumerable: true,
//       configurable: true,
//       writable: true
//     });
//   } else {
//     obj[key] = value;
//   }

//   return obj;
// }

// function _extends$o() {
//   _extends$o = Object.assign || function (target) {
//     for (var i = 1; i < arguments.length; i++) {
//       var source = arguments[i];

//       for (var key in source) {
//         if (Object.prototype.hasOwnProperty.call(source, key)) {
//           target[key] = source[key];
//         }
//       }
//     }

//     return target;
//   };

//   return _extends$o.apply(this, arguments);
// }

// function ownKeys$y(object, enumerableOnly) {
//   var keys = Object.keys(object);

//   if (Object.getOwnPropertySymbols) {
//     var symbols = Object.getOwnPropertySymbols(object);
//     if (enumerableOnly) symbols = symbols.filter(function (sym) {
//       return Object.getOwnPropertyDescriptor(object, sym).enumerable;
//     });
//     keys.push.apply(keys, symbols);
//   }

//   return keys;
// }

// function _objectSpread2(target) {
//   for (var i = 1; i < arguments.length; i++) {
//     var source = arguments[i] != null ? arguments[i] : {};

//     if (i % 2) {
//       ownKeys$y(Object(source), true).forEach(function (key) {
//         _defineProperty$A(target, key, source[key]);
//       });
//     } else if (Object.getOwnPropertyDescriptors) {
//       Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
//     } else {
//       ownKeys$y(Object(source)).forEach(function (key) {
//         Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
//       });
//     }
//   }

//   return target;
// }

// function _inherits$b(subClass, superClass) {
//   if (typeof superClass !== "function" && superClass !== null) {
//     throw new TypeError("Super expression must either be null or a function");
//   }

//   subClass.prototype = Object.create(superClass && superClass.prototype, {
//     constructor: {
//       value: subClass,
//       writable: true,
//       configurable: true
//     }
//   });
//   if (superClass) _setPrototypeOf$c(subClass, superClass);
// }

// function _getPrototypeOf$b(o) {
//   _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
//     return o.__proto__ || Object.getPrototypeOf(o);
//   };
//   return _getPrototypeOf$b(o);
// }

// function _setPrototypeOf$c(o, p) {
//   _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
//     o.__proto__ = p;
//     return o;
//   };

//   return _setPrototypeOf$c(o, p);
// }

// function _isNativeReflectConstruct$c() {
//   if (typeof Reflect === "undefined" || !Reflect.construct) return false;
//   if (Reflect.construct.sham) return false;
//   if (typeof Proxy === "function") return true;

//   try {
//     Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
//     return true;
//   } catch (e) {
//     return false;
//   }
// }

// function _objectWithoutPropertiesLoose$i(source, excluded) {
//   if (source == null) return {};
//   var target = {};
//   var sourceKeys = Object.keys(source);
//   var key, i;

//   for (i = 0; i < sourceKeys.length; i++) {
//     key = sourceKeys[i];
//     if (excluded.indexOf(key) >= 0) continue;
//     target[key] = source[key];
//   }

//   return target;
// }

// function _objectWithoutProperties$i(source, excluded) {
//   if (source == null) return {};

//   var target = _objectWithoutPropertiesLoose$i(source, excluded);

//   var key, i;

//   if (Object.getOwnPropertySymbols) {
//     var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

//     for (i = 0; i < sourceSymbolKeys.length; i++) {
//       key = sourceSymbolKeys[i];
//       if (excluded.indexOf(key) >= 0) continue;
//       if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
//       target[key] = source[key];
//     }
//   }

//   return target;
// }

// function _assertThisInitialized$b(self) {
//   if (self === void 0) {
//     throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
//   }

//   return self;
// }

// function _possibleConstructorReturn$b(self, call) {
//   if (call && (typeof call === "object" || typeof call === "function")) {
//     return call;
//   }

//   return _assertThisInitialized$b(self);
// }

// function _createSuper$b(Derived) {
//   var hasNativeReflectConstruct = _isNativeReflectConstruct$c();

//   return function _createSuperInternal() {
//     var Super = _getPrototypeOf$b(Derived),
//         result;

//     if (hasNativeReflectConstruct) {
//       var NewTarget = _getPrototypeOf$b(this).constructor;

//       result = Reflect.construct(Super, arguments, NewTarget);
//     } else {
//       result = Super.apply(this, arguments);
//     }

//     return _possibleConstructorReturn$b(this, result);
//   };
// }

// function _taggedTemplateLiteral(strings, raw) {
//   if (!raw) {
//     raw = strings.slice(0);
//   }

//   return Object.freeze(Object.defineProperties(strings, {
//     raw: {
//       value: Object.freeze(raw)
//     }
//   }));
// }

// function _toConsumableArray$c(arr) {
//   return _arrayWithoutHoles$c(arr) || _iterableToArray$d(arr) || _unsupportedIterableToArray$k(arr) || _nonIterableSpread$c();
// }

// function _arrayWithoutHoles$c(arr) {
//   if (Array.isArray(arr)) return _arrayLikeToArray$k(arr);
// }

// function _iterableToArray$d(iter) {
//   if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
// }

// function _unsupportedIterableToArray$k(o, minLen) {
//   if (!o) return;
//   if (typeof o === "string") return _arrayLikeToArray$k(o, minLen);
//   var n = Object.prototype.toString.call(o).slice(8, -1);
//   if (n === "Object" && o.constructor) n = o.constructor.name;
//   if (n === "Map" || n === "Set") return Array.from(o);
//   if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$k(o, minLen);
// }

// function _arrayLikeToArray$k(arr, len) {
//   if (len == null || len > arr.length) len = arr.length;

//   for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

//   return arr2;
// }

// function _nonIterableSpread$c() {
//   throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
// }

// function _createForOfIteratorHelper(o, allowArrayLike) {
//   var it;

//   if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
//     if (Array.isArray(o) || (it = _unsupportedIterableToArray$k(o)) || allowArrayLike && o && typeof o.length === "number") {
//       if (it) o = it;
//       var i = 0;

//       var F = function () {};

//       return {
//         s: F,
//         n: function () {
//           if (i >= o.length) return {
//             done: true
//           };
//           return {
//             done: false,
//             value: o[i++]
//           };
//         },
//         e: function (e) {
//           throw e;
//         },
//         f: F
//       };
//     }

//     throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
//   }

//   var normalCompletion = true,
//       didErr = false,
//       err;
//   return {
//     s: function () {
//       it = o[Symbol.iterator]();
//     },
//     n: function () {
//       var step = it.next();
//       normalCompletion = step.done;
//       return step;
//     },
//     e: function (e) {
//       didErr = true;
//       err = e;
//     },
//     f: function () {
//       try {
//         if (!normalCompletion && it.return != null) it.return();
//       } finally {
//         if (didErr) throw err;
//       }
//     }
//   };
// }

// var noop$1 = function noop() {};
// var numberToArray = function numberToArray(n) {
//   return _toConsumableArray$c(Array(n).keys());
// };
// var cssPrefix = function cssPrefix() {
//   var prefix = "rec";
//   var space = " ";
//   var result = "".concat(prefix); // initial it with global prefix;
//   // in case of an array we add the class prefix per item;

//   for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {
//     classNames[_key] = arguments[_key];
//   }

//   var chainedClasses = classNames.reduce(function (acc, current) {
//     if (current) {
//       acc += "".concat(space).concat(prefix, "-").concat(current); // we must keep spaces between class names
//     }

//     return acc;
//   }, "");
//   result += chainedClasses;
//   return result;
// };
// var pipe = function pipe() {
//   for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
//     fns[_key2] = arguments[_key2];
//   }

//   return function (x) {
//     return fns.reduce(function (v, f) {
//       return f(v);
//     }, x);
//   };
// };

// function _templateObject$U() {
//   var data = _taggedTemplateLiteral(["\n  box-sizing: border-box;\n  transition: all 0.3s ease;\n  font-size: 1.6em;\n  background-color: rgba(103, 58, 183, 0.1);\n  color: ", ";\n  box-shadow: 0 0 2px 0px #333;\n  border-radius: 50%;\n  border: none;\n  padding: 0;\n  width: 50px;\n  height: 50px;\n  min-width: 50px;\n  line-height: 50px;\n  align-self: center;\n  cursor: pointer;\n  outline: none;\n  &:hover:enabled,\n  &:focus:enabled {\n    color: #fff;\n    background-color: rgba(103, 58, 183, 1);\n    box-shadow: 0 0 2px 0 #333;\n  }\n  &:disabled {\n    cursor: not-allowed;\n  }\n"]);

//   _templateObject$U = function _templateObject() {
//     return data;
//   };

//   return data;
// }
// var Button = styled.button.attrs(function (_ref) {
//   var _ref$type = _ref.type,
//       type = _ref$type === void 0 ? "button" : _ref$type;
//   return {
//     type: type
//   };
// })(_templateObject$U(), function (props) {
//   return props.disabled ? "#999" : "#333";
// });

// var consts = {
//   PREV: "PREV",
//   NEXT: "NEXT",
//   START: "flex-start",
//   CENTER: "center",
//   END: "flex-end"
// };

// function _templateObject$1$1() {
//   var data = _taggedTemplateLiteral(["\n  box-sizing: border-box;\n  display: flex;\n  overflow: hidden;\n  user-select: none;\n  justify-content: ", ";\n"]);

//   _templateObject$1$1 = function _templateObject() {
//     return data;
//   };

//   return data;
// }
// var ItemWrapper = styled.div.attrs(function (_ref) {
//   var style = _ref.style;
//   return {
//     style: style,
//     className: cssPrefix("item-wrapper")
//   };
// })(_templateObject$1$1(), function (_ref2) {
//   var itemPosition = _ref2.itemPosition;
//   return itemPosition;
// });
// ItemWrapper.defaultProps = {
//   style: {},
//   itemPosition: consts.CENTER
// };
// ItemWrapper.propTypes = {
//   children: PropTypes__default.element.isRequired,
//   style: PropTypes__default.object,
//   itemPosition: PropTypes__default.oneOf([consts.START, consts.CENTER, consts.END])
// };

// function _templateObject$2$1() {
//   var data = _taggedTemplateLiteral(["\n  overflow: hidden;\n  position: relative;\n  width: 100%;\n  margin: 0 10px;\n"]);

//   _templateObject$2$1 = function _templateObject() {
//     return data;
//   };

//   return data;
// }
// var SliderContainer = styled.div(_templateObject$2$1());

// function _templateObject$3$1() {
//   var data = _taggedTemplateLiteral(["\n  position: absolute;\n  display: flex;\n  flex-direction: ", ";\n  ", ";\n  ", ";\n"]);

//   _templateObject$3$1 = function _templateObject() {
//     return data;
//   };

//   return data;
// }

// var calcLeft = function calcLeft(_ref) {
//   var isRTL = _ref.isRTL,
//       verticalMode = _ref.verticalMode,
//       isSwiping = _ref.isSwiping,
//       swipedSliderPosition = _ref.swipedSliderPosition,
//       sliderPosition = _ref.sliderPosition;

//   if (verticalMode || isRTL) {
//     return "auto";
//   } else {
//     return "".concat(isSwiping ? swipedSliderPosition : sliderPosition, "px");
//   }
// };

// var calcRight = function calcRight(_ref2) {
//   var isRTL = _ref2.isRTL,
//       verticalMode = _ref2.verticalMode,
//       isSwiping = _ref2.isSwiping,
//       swipedSliderPosition = _ref2.swipedSliderPosition,
//       sliderPosition = _ref2.sliderPosition;

//   if (!verticalMode && isRTL) {
//     return "".concat(isSwiping ? swipedSliderPosition : sliderPosition, "px");
//   } else {
//     return "auto";
//   }
// };

// var calcTop = function calcTop(_ref3) {
//   var verticalMode = _ref3.verticalMode,
//       isSwiping = _ref3.isSwiping,
//       swipedSliderPosition = _ref3.swipedSliderPosition,
//       sliderPosition = _ref3.sliderPosition;

//   if (!verticalMode) {
//     return "auto";
//   } else {
//     return "".concat(isSwiping ? swipedSliderPosition : sliderPosition, "px");
//   }
// };

// var calcTransition = function calcTransition(_ref4) {
//   var isSwiping = _ref4.isSwiping,
//       transitionMs = _ref4.transitionMs,
//       easing = _ref4.easing,
//       tiltEasing = _ref4.tiltEasing;
//   var duration = isSwiping ? 0 : transitionMs;
//   var effectiveEasing = isSwiping ? tiltEasing : easing;
//   return "all ".concat(duration, "ms ").concat(effectiveEasing);
// }; // We use attributes (style) to bypass multiple creation of classes (dynamic styling)


// var Slider$1 = styled.div.attrs(function (props) {
//   return {
//     style: {
//       transition: calcTransition(props),
//       left: calcLeft(props),
//       right: calcRight(props),
//       top: calcTop(props)
//     }
//   };
// })(_templateObject$3$1(), function (_ref5) {
//   var verticalMode = _ref5.verticalMode;
//   return verticalMode ? "column" : "row";
// }, function (_ref6) {
//   var verticalMode = _ref6.verticalMode;
//   return verticalMode ? "min-height: 100%;" : "";
// }, function (_ref7) {
//   var verticalMode = _ref7.verticalMode,
//       outerSpacing = _ref7.outerSpacing;
//   return verticalMode ? "" : "margin: 0 ".concat(outerSpacing, "px;");
// });

// function _templateObject$4$1() {
//   var data = _taggedTemplateLiteral(["\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n"]);

//   _templateObject$4$1 = function _templateObject() {
//     return data;
//   };

//   return data;
// }
// var StyledCarousel = styled.div.attrs(function (props) {
//   return {
//     style: {
//       height: props.size.height
//     }
//   };
// })(_templateObject$4$1());

// function _templateObject$5$1() {
//   var data = _taggedTemplateLiteral(["\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  direction: ", ";\n"]);

//   _templateObject$5$1 = function _templateObject() {
//     return data;
//   };

//   return data;
// }
// var CarouselWrapper = styled.div(_templateObject$5$1(), function (_ref) {
//   var isRTL = _ref.isRTL;
//   return isRTL ? "rtl" : "ltr";
// });

// var ItemWrapperContainer = /*#__PURE__*/function (_React$Component) {
//   _inherits$b(ItemWrapperContainer, _React$Component);

//   var _super = _createSuper$b(ItemWrapperContainer);

//   function ItemWrapperContainer() {
//     var _this;

//     _classCallCheck$e(this, ItemWrapperContainer);

//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }

//     _this = _super.call.apply(_super, [this].concat(args));

//     _defineProperty$A(_assertThisInitialized$b(_this), "onClick", function () {
//       var _this$props = _this.props,
//           onClick = _this$props.onClick,
//           id = _this$props.id;
//       onClick(id);
//     });

//     return _this;
//   }

//   _createClass$e(ItemWrapperContainer, [{
//     key: "render",
//     value: function render() {
//       return /*#__PURE__*/React__default.createElement(ItemWrapper, _extends$o({}, this.props, {
//         onClick: this.onClick
//       }));
//     }
//   }]);

//   return ItemWrapperContainer;
// }(React__default.Component);

// ItemWrapperContainer.defaultProps = {
//   onClick: noop$1
// };
// ItemWrapperContainer.propTypes = {
//   id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   onClick: PropTypes__default.func
// };

// var Track = function Track(_ref) {
//   var children = _ref.children,
//       childWidth = _ref.childWidth,
//       autoTabIndexVisibleItems = _ref.autoTabIndexVisibleItems,
//       enableSwipe = _ref.enableSwipe,
//       enableMouseSwipe = _ref.enableMouseSwipe,
//       preventDefaultTouchmoveEvent = _ref.preventDefaultTouchmoveEvent,
//       itemsToShow = _ref.itemsToShow,
//       itemsToScroll = _ref.itemsToScroll,
//       currentItem = _ref.currentItem,
//       itemPosition = _ref.itemPosition,
//       itemPadding = _ref.itemPadding,
//       onSwiped = _ref.onSwiped,
//       onSwiping = _ref.onSwiping,
//       verticalMode = _ref.verticalMode,
//       onItemClick = _ref.onItemClick;
//   var width = "".concat(childWidth, "px");
//   var paddingStyle = "".concat(itemPadding.join("px "), "px");
//   var minVisibleItem = currentItem;
//   var maxVisibleItem = currentItem + itemsToShow;
//   var prevItem = minVisibleItem - itemsToScroll;
//   var nextItem = maxVisibleItem + itemsToScroll;
//   var originalChildren = React__default.Children.map(children, function (child, idx) {
//     var isVisible = idx >= minVisibleItem && idx < maxVisibleItem;
//     var isPrevItem = !isVisible && idx >= prevItem && idx < currentItem;
//     var isNextItem = !isVisible && idx < nextItem && idx > currentItem;
//     var itemClass = "carousel-item";
//     var childToRender = autoTabIndexVisibleItems ? /*#__PURE__*/React__default.cloneElement(child, {
//       tabIndex: isVisible ? 0 : -1
//     }) : child;
//     return /*#__PURE__*/React__default.createElement("div", {
//       className: cssPrefix(itemClass, "".concat(itemClass, "-").concat(idx), "".concat(itemClass, "-").concat(isVisible ? "visible" : "hidden"), isPrevItem && "".concat(itemClass, "-prev"), isNextItem && "".concat(itemClass, "-next"))
//     }, /*#__PURE__*/React__default.createElement(ItemWrapperContainer, {
//       id: idx,
//       itemPosition: itemPosition,
//       style: {
//         width: width,
//         padding: paddingStyle
//       },
//       key: idx,
//       onClick: onItemClick
//     }, childToRender));
//   });
//   var toRender = enableSwipe ? /*#__PURE__*/React__default.createElement(Swipeable, {
//     style: {
//       display: "flex",
//       flexDirection: verticalMode ? "column" : "row"
//     },
//     stopPropagation: true,
//     preventDefaultTouchmoveEvent: preventDefaultTouchmoveEvent,
//     trackMouse: enableMouseSwipe,
//     onSwiped: onSwiped,
//     onSwiping: onSwiping,
//     className: cssPrefix("swipable")
//   }, originalChildren) : originalChildren;
//   return toRender;
// };

// Track.propTypes = {
//   children: PropTypes__default.array.isRequired,
//   itemsToShow: PropTypes__default.number.isRequired,
//   noAutoTabbedItems: PropTypes__default.bool,
//   currentItem: PropTypes__default.number.isRequired,
//   itemPosition: PropTypes__default.string,
//   itemPadding: PropTypes__default.array,
//   childWidth: PropTypes__default.number,
//   verticalMode: PropTypes__default.bool,
//   enableSwipe: PropTypes__default.bool,
//   enableMouseSwipe: PropTypes__default.bool,
//   preventDefaultTouchmoveEvent: PropTypes__default.bool,
//   onSwiped: PropTypes__default.func,
//   onSwiping: PropTypes__default.func,
//   onItemClick: PropTypes__default.func
// };

// var directionIcons = {
//   left: "❮",
//   right: "❯",
//   up: "❮",
//   down: "❯"
// };
// var arrowClassname = cssPrefix("arrow");

// var rotateStyle = function rotateStyle(direction) {
//   var rotate = {};

//   if (direction === Arrow.up || direction === Arrow.down) {
//     rotate.transform = "rotate(90deg)";
//   }

//   return rotate;
// };

// var Arrow = function Arrow(_ref) {
//   var direction = _ref.direction,
//       onClick = _ref.onClick,
//       icons = _ref.icons,
//       style = _ref.style,
//       rest = _objectWithoutProperties$i(_ref, ["direction", "onClick", "icons", "style"]);

//   var arrows = _objectSpread2(_objectSpread2({}, directionIcons), icons);

//   var styleObj = _objectSpread2(_objectSpread2({}, rotateStyle(direction)), style);

//   return /*#__PURE__*/React__default.createElement(Button, _extends$o({
//     tabIndex: 0,
//     onClick: onClick,
//     className: cx$1(arrowClassname, "".concat(arrowClassname, "-").concat(direction)),
//     style: styleObj
//   }, rest), arrows[direction]);
// };

// Arrow.left = "left";
// Arrow.right = "right";
// Arrow.up = "up";
// Arrow.down = "down";
// Arrow.propTypes = {
//   direction: PropTypes__default.oneOf(["left", "right", "up", "down"]).isRequired,
//   icons: PropTypes__default.object,
//   style: PropTypes__default.object,
//   onClick: PropTypes__default.func
// };

// var NEXT_ITEM = "NEXT_ITEM";
// var PREV_ITEM = "PREV_ITEM";

// var activeIndexReducer = function activeIndexReducer(state, action) {
//   var limit = action.limit,
//       itemsToScroll = action.itemsToScroll,
//       type = action.type;

//   switch (type) {
//     case NEXT_ITEM:
//       {
//         var optimisticNextItem = state + itemsToScroll;
//         var nextItem = limit >= optimisticNextItem ? optimisticNextItem : limit;
//         return nextItem;
//       }

//     case PREV_ITEM:
//       {
//         var optimisticPrevItem = state - itemsToScroll;
//         var prevItem = optimisticPrevItem >= limit ? optimisticPrevItem : limit;
//         return prevItem;
//       }

//     default:
//       return state;
//   }
// };

// var nextItemAction = function nextItemAction(limit, itemsToScroll) {
//   return {
//     type: NEXT_ITEM,
//     limit: limit,
//     itemsToScroll: itemsToScroll
//   };
// };
// var prevItemAction = function prevItemAction(limit, itemsToScroll) {
//   return {
//     type: PREV_ITEM,
//     limit: limit,
//     itemsToScroll: itemsToScroll
//   };
// };

// function _templateObject$6$1() {
//   var data = _taggedTemplateLiteral(["\n  box-sizing: border-box;\n  padding: 0;\n  transition: all 250ms ease;\n  border: none;\n  margin: 5px;\n  background-color: ", ";\n  font-size: 1.3em;\n  content: \"\";\n  height: 10px;\n  width: 10px;\n  box-shadow: ", ";\n  border-radius: 50%;\n  outline: none;\n  &:hover,\n  &:focus {\n    cursor: pointer;\n    box-shadow: ", ";\n  }\n"]);

//   _templateObject$6$1 = function _templateObject() {
//     return data;
//   };

//   return data;
// }
// var boxShadow = "0 0 1px 2px rgba(0, 0, 0, 0.5)";
// var activeBoxShadow = "0 0 1px 3px rgba(103,58,183,1)";
// var hoveredBoxShadow = "0 0 1px 3px rgba(103,58,183,.5)";
// var Dot$1 = styled.button.attrs(function (_ref) {
//   var _ref$type = _ref.type,
//       type = _ref$type === void 0 ? "button" : _ref$type;
//   return {
//     type: type
//   };
// })(_templateObject$6$1(), function (_ref2) {
//   var active = _ref2.active;
//   return active ? "rgba(103,58,183,.5)" : "transparent";
// }, function (_ref3) {
//   var active = _ref3.active;
//   return active ? activeBoxShadow : boxShadow;
// }, function (_ref4) {
//   var active = _ref4.active;
//   return active ? activeBoxShadow : hoveredBoxShadow;
// });

// var DotContainer = /*#__PURE__*/function (_React$Component) {
//   _inherits$b(DotContainer, _React$Component);

//   var _super = _createSuper$b(DotContainer);

//   function DotContainer() {
//     var _this;

//     _classCallCheck$e(this, DotContainer);

//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }

//     _this = _super.call.apply(_super, [this].concat(args));

//     _defineProperty$A(_assertThisInitialized$b(_this), "onClick", function () {
//       var _this$props = _this.props,
//           onClick = _this$props.onClick,
//           id = _this$props.id;
//       onClick(id);
//     });

//     return _this;
//   }

//   _createClass$e(DotContainer, [{
//     key: "render",
//     value: function render() {
//       var active = this.props.active;
//       return /*#__PURE__*/React__default.createElement(Dot$1, {
//         tabIndex: active ? -1 : 0,
//         onClick: this.onClick,
//         active: active,
//         className: "".concat(cssPrefix("dot"), " ").concat(active ? cssPrefix("dot_active") : "")
//       });
//     }
//   }]);

//   return DotContainer;
// }(React__default.Component);

// DotContainer.propTypes = {
//   id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   active: PropTypes__default.bool,
//   onClick: PropTypes__default.func
// };

// function _templateObject$7$1() {
//   var data = _taggedTemplateLiteral(["\n  display: flex;\n  flex-wrap: wrap;\n  margin-top: 15px;\n"]);

//   _templateObject$7$1 = function _templateObject() {
//     return data;
//   };

//   return data;
// }
// var Indicators = styled.div(_templateObject$7$1());

// var Pagination = /*#__PURE__*/function (_React$Component) {
//   _inherits$b(Pagination, _React$Component);

//   var _super = _createSuper$b(Pagination);

//   function Pagination() {
//     _classCallCheck$e(this, Pagination);

//     return _super.apply(this, arguments);
//   }

//   _createClass$e(Pagination, [{
//     key: "render",
//     value: function render() {
//       var _this$props = this.props,
//           numOfPages = _this$props.numOfPages,
//           activePage = _this$props.activePage,
//           onClick = _this$props.onClick;
//       var pages = numberToArray(numOfPages);
//       return /*#__PURE__*/React__default.createElement(Indicators, {
//         className: cssPrefix("pagination")
//       }, pages.map(function (item, i) {
//         return /*#__PURE__*/React__default.createElement(DotContainer, {
//           key: i,
//           id: i,
//           active: i === activePage,
//           onClick: onClick
//         });
//       }));
//     }
//   }]);

//   return Pagination;
// }(React__default.Component);

// Pagination.defaultProps = {
//   onClick: noop$1
// };
// Pagination.propTypes = {
//   numOfPages: PropTypes__default.number.isRequired,
//   activePage: PropTypes__default.number.isRequired,
//   onClick: PropTypes__default.func
// };

// var Carousel$1 = /*#__PURE__*/function (_React$Component) {
//   _inherits$b(Carousel, _React$Component);

//   var _super = _createSuper$b(Carousel);

//   function Carousel() {
//     var _this;

//     _classCallCheck$e(this, Carousel);

//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }

//     _this = _super.call.apply(_super, [this].concat(args));

//     _defineProperty$A(_assertThisInitialized$b(_this), "isComponentMounted", false);

//     _defineProperty$A(_assertThisInitialized$b(_this), "state", {
//       rootHeight: 0,
//       childHeight: 0,
//       sliderPosition: 0,
//       swipedSliderPosition: 0,
//       isSwiping: false,
//       transitioning: false,
//       transitionMs: _this.props.transitionMs,
//       activeIndex: _this.props.initialActiveIndex || _this.props.initialFirstItem,
//       // support deprecated  initialFirstItem
//       pages: [],
//       activePage: 0,
//       sliderContainerWidth: 0
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "setRef", function (name) {
//       return function (ref) {
//         return _this[name] = ref;
//       };
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "initResizeObserver", function () {
//       _this.ro = new index(function (entries, observer) {
//         var _iterator = _createForOfIteratorHelper(entries),
//             _step;

//         try {
//           var _loop = function _loop() {
//             var entry = _step.value;

//             if (entry.target === _this.sliderContainer) {
//               // we are using rAF because it fixes the infinite refresh with gatsby (ssr?).
//               // TBH, I'm not sure i fully understand why.
//               // see https://github.com/sag1v/react-elastic-carousel/issues/107
//               window.requestAnimationFrame(function () {
//                 _this.onContainerResize(entry);
//               });
//             }

//             if (entry.target === _this.slider) {
//               // we are using rAF because it fixes the infinite refresh with gatsby (ssr?).
//               // TBH, I'm not sure i fully understand why
//               // see https://github.com/sag1v/react-elastic-carousel/issues/107
//               window.requestAnimationFrame(function () {
//                 _this.onSliderResize(entry);
//               });
//             }
//           };

//           for (_iterator.s(); !(_step = _iterator.n()).done;) {
//             _loop();
//           }
//         } catch (err) {
//           _iterator.e(err);
//         } finally {
//           _iterator.f();
//         }
//       });

//       _this.ro.observe(_this.sliderContainer);

//       _this.ro.observe(_this.slider);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "unSubscribeObserver", function () {
//       return _this.ro.disconnect();
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "setAutoPlay", function () {
//       var _this$getDerivedProps = _this.getDerivedPropsFromBreakPoint(),
//           autoPlaySpeed = _this$getDerivedProps.autoPlaySpeed;

//       _this.autoPlayIntervalId = setInterval(function () {
//         if (_this.isComponentMounted) {
//           var transitioning = _this.state.transitioning;

//           if (!transitioning) {
//             _this.slideNext();
//           }
//         }
//       }, autoPlaySpeed);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "removeAutoPlay", function () {
//       if (_this.autoPlayIntervalId) {
//         clearInterval(_this.autoPlayIntervalId);
//         _this.autoPlayIntervalId = null;
//       }
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "setPages", function () {
//       var numOfPages = _this.getNumOfPages();

//       var pages = numberToArray(numOfPages);

//       _this.setState({
//         pages: pages
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onSliderTransitionEnd", function (fn) {
//       _this.slider.addEventListener("transitionend", fn);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "removeSliderTransitionHook", function (fn) {
//       _this.slider.removeEventListener("transitionend", fn);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "getDerivedPropsFromBreakPoint", function () {
//       var _this$props = _this.props,
//           breakPoints = _this$props.breakPoints,
//           restOfProps = _objectWithoutProperties$i(_this$props, ["breakPoints"]);

//       var sliderContainerWidth = _this.state.sliderContainerWidth; // default breakpoint from individual props

//       var currentBreakPoint; // if breakpoints were added as props override the individual props

//       if (breakPoints && breakPoints.length > 0) {
//         currentBreakPoint = breakPoints.slice() // no mutations
//         .reverse() // so we can find last match
//         .find(function (bp) {
//           return bp.width <= sliderContainerWidth;
//         });

//         if (!currentBreakPoint) {
//           /* in case we don't have a lower width than sliderContainerWidth
//            * this mostly happens in initilization when sliderContainerWidth is 0
//            */
//           currentBreakPoint = breakPoints[0];
//         }
//       } // merge direct props with current breakpoint Props


//       return _objectSpread2(_objectSpread2({}, restOfProps), currentBreakPoint);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "updateSliderPosition", function () {
//       _this.setState(function (state) {
//         var _this$getDerivedProps2 = _this.getDerivedPropsFromBreakPoint(),
//             children = _this$getDerivedProps2.children,
//             verticalMode = _this$getDerivedProps2.verticalMode,
//             itemsToShow = _this$getDerivedProps2.itemsToShow,
//             transitionMs = _this$getDerivedProps2.transitionMs;

//         var childHeight = state.childHeight,
//             activeIndex = state.activeIndex;

//         var childWidth = _this.calculateChildWidth();

//         var totalItems = Children.toArray(children).length;
//         var hiddenSlots = totalItems - itemsToShow;
//         var moveBy = activeIndex * -1;
//         var emptySlots = itemsToShow - (totalItems - activeIndex);

//         if (emptySlots > 0 && hiddenSlots > 0) {
//           moveBy = emptySlots + activeIndex * -1;
//         }

//         var sliderPosition = (verticalMode ? childHeight : childWidth) * moveBy;
//         var newActiveIndex = emptySlots > 0 ? activeIndex - emptySlots : activeIndex; // go back from 0ms to whatever set by the user
//         // We were at 0ms because we wanted to disable animation on resize
//         // see https://github.com/sag1v/react-elastic-carousel/issues/94

//         window.requestAnimationFrame(function () {
//           if (_this.isComponentMounted) {
//             _this.setState({
//               transitionMs: transitionMs
//             });
//           }
//         });
//         return {
//           sliderPosition: sliderPosition,
//           activeIndex: newActiveIndex < 0 ? 0 : newActiveIndex
//         };
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onSliderResize", function (sliderNode) {
//       if (!_this.isComponentMounted) {
//         return;
//       }

//       var _this$getDerivedProps3 = _this.getDerivedPropsFromBreakPoint(),
//           verticalMode = _this$getDerivedProps3.verticalMode,
//           children = _this$getDerivedProps3.children,
//           itemsToShow = _this$getDerivedProps3.itemsToShow;

//       var sliderHeight = sliderNode.contentRect.height;
//       var nextState = {};
//       var childrenLength = Children.toArray(children).length;

//       if (verticalMode) {
//         var childHeight = sliderHeight / childrenLength; // We use Math.min because we don't want to make the child smaller
//         // if the number of children is smaller than itemsToShow.
//         // (Because we do not want "empty slots")

//         nextState.rootHeight = childHeight * Math.min(childrenLength, itemsToShow);
//         nextState.childHeight = childHeight;
//       } else {
//         nextState.rootHeight = sliderHeight;
//       }

//       _this.setState(nextState);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "calculateChildWidth", function () {
//       var sliderContainerWidth = _this.state.sliderContainerWidth;

//       var _this$getDerivedProps4 = _this.getDerivedPropsFromBreakPoint(),
//           verticalMode = _this$getDerivedProps4.verticalMode,
//           itemsToShow = _this$getDerivedProps4.itemsToShow,
//           showEmptySlots = _this$getDerivedProps4.showEmptySlots,
//           children = _this$getDerivedProps4.children;
//       /* based on slider container's width, get num of items to show
//           * and calculate child's width (and update it in state)
//           */


//       var childrenLength = Children.toArray(children).length || 1;
//       var childWidth = 0;

//       if (verticalMode) {
//         childWidth = sliderContainerWidth;
//       } else {
//         // When "showEmptySlots" is false
//         // We use Math.min because we don't want to make the child smaller
//         // if the number of children is smaller than itemsToShow.
//         // (Because we do not want "empty slots")
//         childWidth = sliderContainerWidth / (showEmptySlots ? itemsToShow : Math.min(childrenLength, itemsToShow));
//       }

//       return childWidth;
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onContainerResize", function (sliderContainerNode) {
//       var newSliderContainerWidth = sliderContainerNode.contentRect.width; // update slider container width
//       // disable animation on resize see https://github.com/sag1v/react-elastic-carousel/issues/94

//       var _this$getDerivedProps5 = _this.getDerivedPropsFromBreakPoint(),
//           outerSpacing = _this$getDerivedProps5.outerSpacing,
//           initialVerticalMode = _this$getDerivedProps5.verticalMode;

//       var containerWidth = newSliderContainerWidth - (initialVerticalMode ? 0 : outerSpacing * 2);

//       if (!_this.isComponentMounted || _this.state.sliderContainerWidth === newSliderContainerWidth) {
//         // prevent infinite loop
//         return;
//       }

//       _this.setState({
//         sliderContainerWidth: containerWidth,
//         transitionMs: 0
//       }, function () {
//         // we must get these props inside setState (get future props because its async)
//         var _this$getDerivedProps6 = _this.getDerivedPropsFromBreakPoint(),
//             onResize = _this$getDerivedProps6.onResize,
//             itemsToShow = _this$getDerivedProps6.itemsToShow,
//             children = _this$getDerivedProps6.children;

//         var childrenLength = Children.toArray(children).length || 1;

//         _this.setState(function (currentState) {
//           // We might need to change the selected index when the size of the container changes
//           // we are making sure the selected index is not out of boundaries and respecting itemsToShow
//           // This usually happens with breakpoints. see https://github.com/sag1v/react-elastic-carousel/issues/122
//           var activeIndex = currentState.activeIndex; // we take the lowest, in case itemsToShow is greater than childrenLength

//           var maxItemsToShow = Math.min(childrenLength, itemsToShow);
//           var endLimit = childrenLength - maxItemsToShow;

//           if (activeIndex > endLimit) {
//             activeIndex = endLimit;
//           }

//           return {
//             activeIndex: activeIndex
//           };
//         }, function () {
//           /* Based on all of the above new data:
//           * update slider position
//           * get the new current breakpoint
//           * pass the current breakpoint to the consumer's callback
//           */
//           _this.updateSliderPosition();

//           var currentBreakPoint = _this.getDerivedPropsFromBreakPoint();

//           onResize(currentBreakPoint);
//         });
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "tiltMovement", function (position) {
//       var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
//       var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 150;

//       _this.setState(function (state) {
//         return {
//           isSwiping: true,
//           swipedSliderPosition: position - distance
//         };
//       });

//       setTimeout(function () {
//         _this.setState({
//           isSwiping: false,
//           swipedSliderPosition: 0
//         });
//       }, duration);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "convertChildToCbObj", function (index) {
//       var _this$getDerivedProps7 = _this.getDerivedPropsFromBreakPoint(),
//           children = _this$getDerivedProps7.children; // support decimal itemsToShow


//       var roundedIdx = Math.round(index);
//       var child = Children.toArray(children)[roundedIdx];
//       return {
//         item: child.props,
//         index: roundedIdx
//       };
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "getNextItemIndex", function (currentIndex, getPrev) {
//       var _this$getDerivedProps8 = _this.getDerivedPropsFromBreakPoint(),
//           children = _this$getDerivedProps8.children,
//           itemsToShow = _this$getDerivedProps8.itemsToShow,
//           itemsToScroll = _this$getDerivedProps8.itemsToScroll;

//       var childrenLength = Children.toArray(children).length || 1;
//       var notEnoughItemsToShow = itemsToShow > childrenLength;
//       var limit = getPrev ? 0 : childrenLength - itemsToShow;

//       if (notEnoughItemsToShow) {
//         limit = 0; // basically don't move
//       }

//       var nextAction = getPrev ? prevItemAction(0, itemsToScroll) : nextItemAction(limit, itemsToScroll);
//       var nextItem = activeIndexReducer(currentIndex, nextAction);
//       return nextItem;
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "getNextItemObj", function (getPrev) {
//       var _this$getDerivedProps9 = _this.getDerivedPropsFromBreakPoint(),
//           children = _this$getDerivedProps9.children;

//       var activeIndex = _this.state.activeIndex;

//       var nextItemIndex = _this.getNextItemIndex(activeIndex, getPrev); // support decimal itemsToShow


//       var roundedIdx = Math.round(nextItemIndex);
//       var asElement = Children.toArray(children)[roundedIdx];
//       var asObj = {
//         item: asElement.props,
//         index: roundedIdx
//       };
//       return asObj;
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "resetSwipe", function () {
//       _this.setState({
//         swipedSliderPosition: 0,
//         transitioning: false,
//         isSwiping: false
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onSwiping", function (data) {
//       var deltaX = data.deltaX,
//           absX = data.absX,
//           deltaY = data.deltaY,
//           absY = data.absY,
//           dir = data.dir;

//       _this.setState(function (state) {
//         var childHeight = state.childHeight,
//             activeIndex = state.activeIndex,
//             sliderPosition = state.sliderPosition;

//         var _this$getDerivedProps10 = _this.getDerivedPropsFromBreakPoint(),
//             itemsToShow = _this$getDerivedProps10.itemsToShow,
//             verticalMode = _this$getDerivedProps10.verticalMode,
//             children = _this$getDerivedProps10.children,
//             isRTL = _this$getDerivedProps10.isRTL;

//         var childWidth = _this.calculateChildWidth(); // determine how far can user swipe


//         var childrenLength = Children.toArray(children).length || 1;
//         var goingNext = !verticalMode && dir === "Left" && !isRTL || !verticalMode && dir === "Right" && isRTL || verticalMode && dir === "Up";
//         var goingBack = !verticalMode && dir === "Right" && !isRTL || !verticalMode && dir === "Left" && isRTL || verticalMode && dir === "Down";
//         var horizontalSwipe = dir === "Left" || dir === "Right";
//         var verticalSwipe = dir === "Up" || dir === "Down";
//         var horizontalMode = !verticalMode;
//         var distanceSwipe = 0;
//         var horizontalEdgeStoppage = childWidth / 2;
//         var verticalEdgeStoppage = childHeight / 2;

//         if (verticalMode) {
//           if (verticalSwipe) {
//             var trackSize = childrenLength * childHeight;

//             if (goingNext) {
//               distanceSwipe = trackSize - childHeight * activeIndex - itemsToShow * childHeight + verticalEdgeStoppage;
//             } else if (goingBack) {
//               distanceSwipe = childHeight * activeIndex + verticalEdgeStoppage;
//             }
//           }
//         } else {
//           if (horizontalSwipe) {
//             var _trackSize = childrenLength * childWidth;

//             if (goingNext) {
//               distanceSwipe = _trackSize - childWidth * activeIndex - itemsToShow * childWidth + horizontalEdgeStoppage;
//             } else if (goingBack) {
//               distanceSwipe = childWidth * activeIndex + horizontalEdgeStoppage;
//             }
//           }
//         }

//         var shouldHorizontalSkipUpdate = horizontalMode && verticalSwipe || horizontalMode && horizontalSwipe && absX > distanceSwipe;
//         var shouldVerticalSkipUpdate = verticalMode && horizontalSwipe || verticalMode && verticalSwipe && absY > distanceSwipe;

//         if (shouldHorizontalSkipUpdate || shouldVerticalSkipUpdate) {
//           // bail out of state update
//           return;
//         }

//         var swipedSliderPosition;

//         if (horizontalSwipe) {
//           if (isRTL) {
//             swipedSliderPosition = sliderPosition + deltaX;
//           } else {
//             swipedSliderPosition = sliderPosition - deltaX;
//           }
//         } else {
//           swipedSliderPosition = sliderPosition - deltaY;
//         }

//         return {
//           swipedSliderPosition: swipedSliderPosition,
//           isSwiping: true,
//           transitioning: true
//         };
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onSwiped", function (data) {
//       // we need to handle all scenarios:
//       // 1. Horizontal mode - swipe left or right
//       // 2. Horizontal mode with RTL - swipe left or right
//       // 3. vertical mode - swipe up or down
//       var absX = data.absX,
//           absY = data.absY,
//           dir = data.dir;
//       var _this$state = _this.state,
//           childHeight = _this$state.childHeight,
//           activeIndex = _this$state.activeIndex;

//       var _this$getDerivedProps11 = _this.getDerivedPropsFromBreakPoint(),
//           verticalMode = _this$getDerivedProps11.verticalMode,
//           isRTL = _this$getDerivedProps11.isRTL,
//           itemsToScroll = _this$getDerivedProps11.itemsToScroll;

//       var childWidth = _this.calculateChildWidth();

//       var func = _this.resetSwipe;
//       var minSwipeDistanceHorizontal = childWidth / 5;
//       var minSwipeDistanceVertical = childHeight / 5;
//       var swipedLeft = dir === "Left";
//       var swipedRight = dir === "Right";
//       var swipedUp = dir === "Up";
//       var swipedDown = dir === "Down";
//       var verticalGoSwipe = verticalMode && (swipedUp || swipedDown) && absY > minSwipeDistanceVertical;
//       var horizontalGoSwipe = !verticalMode && (swipedRight || swipedLeft) && absX > minSwipeDistanceHorizontal;
//       var goodToGo = false;

//       if (verticalGoSwipe || horizontalGoSwipe) {
//         goodToGo = true;
//       }

//       if (goodToGo) {
//         // we should go to a different item
//         // determine what method we need to invoke
//         if (verticalMode) {
//           // get number of slides from user's swiping
//           var numberOfSlidesViaSwipe = Math.ceil((absY - minSwipeDistanceVertical) / childHeight); // if user swipes more than itemsToScroll then we want to bypass itemsToScroll for a smoother scroll

//           var numberOfSlidesTogo = Math.max(itemsToScroll, numberOfSlidesViaSwipe);
//           var backSlidesToGo = activeIndex - numberOfSlidesTogo;
//           var forwardSlideTtoGo = activeIndex + numberOfSlidesTogo; // up or down

//           if (swipedDown) {
//             // func = this.onPrevStart;
//             func = function func() {
//               return _this.goTo(backSlidesToGo);
//             };
//           }

//           if (swipedUp) {
//             // func = this.onNextStart;
//             func = function func() {
//               return _this.goTo(forwardSlideTtoGo);
//             };
//           }
//         } else {
//           // get number of slides from user's swiping
//           var _numberOfSlidesViaSwipe = Math.ceil((absX - minSwipeDistanceHorizontal) / childWidth); // if user swipes more than itemsToScroll then we want to bypass itemsToScroll for a smoother scroll


//           var _numberOfSlidesTogo = Math.max(itemsToScroll, _numberOfSlidesViaSwipe);

//           var _backSlidesToGo = activeIndex - _numberOfSlidesTogo;

//           var _forwardSlideTtoGo = activeIndex + _numberOfSlidesTogo; // horizontal mode


//           if (isRTL) {
//             // flip sides
//             if (swipedLeft) {
//               // func = this.onPrevStart;
//               func = function func() {
//                 return _this.goTo(_backSlidesToGo);
//               };
//             }

//             if (swipedRight) {
//               // func = this.onNextStart;
//               func = function func() {
//                 return _this.goTo(_forwardSlideTtoGo);
//               };
//             }
//           } else {
//             // normal behavior
//             if (swipedLeft) {
//               // func = this.onNextStart;
//               func = function func() {
//                 return _this.goTo(_forwardSlideTtoGo);
//               };
//             }

//             if (swipedRight) {
//               // func = this.onPrevStart;
//               func = function func() {
//                 return _this.goTo(_backSlidesToGo);
//               };
//             }
//           }
//         }
//       } // we are not "tilting" on edges, so we need to reset isSwiping and transitioning.
//       // otherwise we wont slide back to edge


//       _this.setState({
//         isSwiping: false,
//         transitioning: false
//       });

//       func({
//         skipTilt: true
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onNextStart", function (options) {
//       var _this$getDerivedProps12 = _this.getDerivedPropsFromBreakPoint(),
//           onNextStart = _this$getDerivedProps12.onNextStart;

//       var activeIndex = _this.state.activeIndex;

//       var nextItemObj = _this.getNextItemObj();

//       var prevItemObj = _this.convertChildToCbObj(activeIndex);

//       onNextStart(prevItemObj, nextItemObj);

//       _this.slideNext(options);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onPrevStart", function (options) {
//       var _this$getDerivedProps13 = _this.getDerivedPropsFromBreakPoint(),
//           onPrevStart = _this$getDerivedProps13.onPrevStart;

//       var activeIndex = _this.state.activeIndex;

//       var nextItemObj = _this.getNextItemObj(true);

//       var prevItemObj = _this.convertChildToCbObj(activeIndex);

//       onPrevStart(prevItemObj, nextItemObj);

//       _this.slidePrev(options);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "slideNext", function () {
//       var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
//       var skipTilt = options.skipTilt;

//       var _this$getDerivedProps14 = _this.getDerivedPropsFromBreakPoint(),
//           enableTilt = _this$getDerivedProps14.enableTilt;

//       var _this$state2 = _this.state,
//           activeIndex = _this$state2.activeIndex,
//           sliderPosition = _this$state2.sliderPosition;

//       var nextItem = _this.getNextItemIndex(activeIndex, false);

//       if (activeIndex !== nextItem) {
//         _this.goTo(nextItem);
//       } else if (enableTilt && !skipTilt) {
//         _this.tiltMovement(sliderPosition, 20, 150);
//       }
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "slidePrev", function () {
//       var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
//       var skipTilt = options.skipTilt;
//       var activeIndex = _this.state.activeIndex;

//       var _this$getDerivedProps15 = _this.getDerivedPropsFromBreakPoint(),
//           enableTilt = _this$getDerivedProps15.enableTilt;

//       var prevItem = _this.getNextItemIndex(activeIndex, true);

//       if (activeIndex !== prevItem) {
//         _this.goTo(prevItem);
//       } else if (enableTilt && !skipTilt) {
//         _this.tiltMovement(0, -20, 150);
//       }
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onNextEnd", function () {
//       var _this$getDerivedProps16 = _this.getDerivedPropsFromBreakPoint(),
//           onNextEnd = _this$getDerivedProps16.onNextEnd,
//           onChange = _this$getDerivedProps16.onChange;

//       var _this$state3 = _this.state,
//           activeIndex = _this$state3.activeIndex,
//           activePage = _this$state3.activePage;

//       var nextItemObj = _this.convertChildToCbObj(activeIndex);

//       _this.removeSliderTransitionHook(_this.onNextEnd);

//       _this.setState({
//         transitioning: false
//       });

//       onChange && onChange(nextItemObj, activePage);
//       onNextEnd(nextItemObj, activePage);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onPrevEnd", function () {
//       var _this$getDerivedProps17 = _this.getDerivedPropsFromBreakPoint(),
//           onPrevEnd = _this$getDerivedProps17.onPrevEnd,
//           onChange = _this$getDerivedProps17.onChange;

//       var _this$state4 = _this.state,
//           activeIndex = _this$state4.activeIndex,
//           activePage = _this$state4.activePage;

//       var nextItemObj = _this.convertChildToCbObj(activeIndex);

//       _this.removeSliderTransitionHook(_this.onPrevEnd);

//       _this.setState({
//         transitioning: false
//       });

//       onChange && onChange(nextItemObj, activePage);
//       onPrevEnd(nextItemObj, activePage);
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "generatePositionUpdater", function (direction, nextItemId, verticalMode, rest) {
//       return function (state) {
//         var sliderPosition = state.sliderPosition,
//             childHeight = state.childHeight,
//             activeIndex = state.activeIndex;

//         var childWidth = _this.calculateChildWidth();

//         var newSliderPosition = 0;
//         var childSize = verticalMode ? childHeight : childWidth;

//         if (direction === consts.NEXT) {
//           newSliderPosition = sliderPosition - childSize * (nextItemId - activeIndex);
//         } else {
//           newSliderPosition = sliderPosition + childSize * (activeIndex - nextItemId);
//         }

//         return _objectSpread2({
//           sliderPosition: newSliderPosition,
//           activeIndex: nextItemId,
//           swipedSliderPosition: 0,
//           isSwiping: false
//         }, rest);
//       };
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "goTo", function (nextItemId) {
//       var _this$getDerivedProps18 = _this.getDerivedPropsFromBreakPoint(),
//           children = _this$getDerivedProps18.children,
//           verticalMode = _this$getDerivedProps18.verticalMode,
//           itemsToShow = _this$getDerivedProps18.itemsToShow;

//       var activeIndex = _this.state.activeIndex;
//       var childrenLength = Children.toArray(children).length;
//       var safeNextItemId = Math.max(0, nextItemId); // don't allow negative numbers

//       var isPrev = activeIndex > safeNextItemId;

//       var nextAvailableItem = _this.getNextItemIndex(activeIndex, isPrev);

//       var noChange = nextAvailableItem === activeIndex;
//       var outOfBoundary = safeNextItemId + itemsToShow >= childrenLength;

//       if (noChange) {
//         return;
//       }

//       if (outOfBoundary) {
//         // Either go to last index (respect itemsToShow) or 0 index if we can't fill the slider
//         safeNextItemId = Math.max(0, childrenLength - itemsToShow);
//       }

//       var direction = consts.NEXT;
//       var positionEndCb = _this.onNextEnd;

//       if (isPrev) {
//         direction = consts.PREV;
//         positionEndCb = _this.onPrevEnd;
//       }

//       var stateUpdater = _this.generatePositionUpdater(direction, safeNextItemId, verticalMode, {
//         transitioning: true
//       });

//       _this.setState(stateUpdater, function () {
//         // callback
//         pipe(_this.updateActivePage(), _this.onSliderTransitionEnd(positionEndCb));
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "getNumOfPages", function () {
//       var _this$getDerivedProps19 = _this.getDerivedPropsFromBreakPoint(),
//           children = _this$getDerivedProps19.children,
//           itemsToShow = _this$getDerivedProps19.itemsToShow;

//       var childrenLength = Children.toArray(children).length;
//       var safeItemsToShow = Math.max(itemsToShow, 1);
//       var numOfPages = Math.ceil(childrenLength / safeItemsToShow);
//       return numOfPages || 1;
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "updateActivePage", function () {
//       _this.setState(function (state) {
//         var _this$getDerivedProps20 = _this.getDerivedPropsFromBreakPoint(),
//             itemsToShow = _this$getDerivedProps20.itemsToShow,
//             children = _this$getDerivedProps20.children;

//         var activeIndex = state.activeIndex,
//             activePage = state.activePage;

//         var numOfPages = _this.getNumOfPages();

//         var childrenLength = Children.toArray(children).length;
//         var inRangeItemsToShow = Math.min(childrenLength, itemsToShow); // watch out from 0 (so we wont divide by zero)

//         var safeItemsToShow = Math.max(inRangeItemsToShow, 1);
//         var newActivePage = Math.ceil(activeIndex / safeItemsToShow);
//         var inRangeActivePageIndex = Math.min(numOfPages - 1, newActivePage);

//         if (activePage !== inRangeActivePageIndex) {
//           return {
//             activePage: inRangeActivePageIndex
//           };
//         }
//       });
//     });

//     _defineProperty$A(_assertThisInitialized$b(_this), "onIndicatorClick", function (indicatorId) {
//       var _this$getDerivedProps21 = _this.getDerivedPropsFromBreakPoint(),
//           itemsToShow = _this$getDerivedProps21.itemsToShow;

//       var gotoIndex = indicatorId * itemsToShow;

//       _this.setState({
//         activePage: indicatorId
//       });

//       _this.goTo(gotoIndex);
//     });

//     return _this;
//   }

//   _createClass$e(Carousel, [{
//     key: "componentDidMount",
//     value: function componentDidMount() {
//       this.isComponentMounted = true;
//       this.initResizeObserver();
//       this.updateActivePage();
//       this.setPages();
//     }
//   }, {
//     key: "componentDidUpdate",
//     value: function componentDidUpdate(prevProps, prevState) {
//       var _this$props2 = this.props,
//           enableAutoPlay = _this$props2.enableAutoPlay,
//           children = _this$props2.children,
//           itemsToShow = _this$props2.itemsToShow,
//           itemsToScroll = _this$props2.itemsToScroll,
//           breakPoints = _this$props2.breakPoints;
//       var _this$state5 = this.state,
//           activeIndex = _this$state5.activeIndex,
//           sliderContainerWidth = _this$state5.sliderContainerWidth;
//       var nextItem = this.getNextItemIndex(activeIndex, false);
//       var currentChildrenLength = Children.toArray(children).length;
//       var prevChildrenLength = Children.toArray(prevProps.children).length; // update pages (for pagination)

//       if (prevChildrenLength !== currentChildrenLength || prevProps.itemsToShow !== itemsToShow || prevProps.itemsToScroll !== itemsToScroll || prevProps.breakPoints !== breakPoints || sliderContainerWidth !== prevState.sliderContainerWidth) {
//         // we mimic a container resize to recalculate item width when itemsToShow are updated
//         this.onContainerResize({
//           contentRect: {
//             width: sliderContainerWidth
//           }
//         });
//         this.setPages();
//         this.updateActivePage();
//       } // autoplay update


//       if (activeIndex === nextItem) {
//         this.removeAutoPlay();
//       } else if (enableAutoPlay && !this.autoPlayIntervalId) {
//         this.setAutoPlay();
//       } else if (!enableAutoPlay && this.autoPlayIntervalId) {
//         this.removeAutoPlay();
//       }

//       if (prevChildrenLength !== currentChildrenLength) {
//         var _this$getDerivedProps22 = this.getDerivedPropsFromBreakPoint(),
//             calculatedItemsToShow = _this$getDerivedProps22.itemsToShow; // number of items is reduced (we don't care if number of items is increased)
//         // we need to check if our current index is not out of boundaries
//         // we need to include itemsToShow so we can fill up the slots


//         var lastIndex = currentChildrenLength - 1;
//         var isOutOfRange = activeIndex + calculatedItemsToShow > lastIndex;

//         if (isOutOfRange) {
//           // we are out of boundaries, go "back" to last item of the list (respect itemsToShow)
//           this.goTo(Math.max(0, currentChildrenLength - calculatedItemsToShow));
//         }
//       }
//     }
//   }, {
//     key: "componentWillUnmount",
//     value: function componentWillUnmount() {
//       this.isComponentMounted = false;
//       this.removeAutoPlay();
//       this.unSubscribeObserver();
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this$state6 = this.state,
//           activePage = _this$state6.activePage,
//           isSwiping = _this$state6.isSwiping,
//           sliderPosition = _this$state6.sliderPosition,
//           swipedSliderPosition = _this$state6.swipedSliderPosition,
//           rootHeight = _this$state6.rootHeight,
//           pages = _this$state6.pages,
//           activeIndex = _this$state6.activeIndex,
//           transitionMs = _this$state6.transitionMs;

//       var _this$getDerivedProps23 = this.getDerivedPropsFromBreakPoint(),
//           className = _this$getDerivedProps23.className,
//           style = _this$getDerivedProps23.style,
//           itemsToShow = _this$getDerivedProps23.itemsToShow,
//           itemsToScroll = _this$getDerivedProps23.itemsToScroll,
//           verticalMode = _this$getDerivedProps23.verticalMode,
//           isRTL = _this$getDerivedProps23.isRTL,
//           easing = _this$getDerivedProps23.easing,
//           tiltEasing = _this$getDerivedProps23.tiltEasing,
//           children = _this$getDerivedProps23.children,
//           focusOnSelect = _this$getDerivedProps23.focusOnSelect,
//           autoTabIndexVisibleItems = _this$getDerivedProps23.autoTabIndexVisibleItems,
//           itemPosition = _this$getDerivedProps23.itemPosition,
//           itemPadding = _this$getDerivedProps23.itemPadding,
//           outerSpacing = _this$getDerivedProps23.outerSpacing,
//           enableSwipe = _this$getDerivedProps23.enableSwipe,
//           enableMouseSwipe = _this$getDerivedProps23.enableMouseSwipe,
//           pagination = _this$getDerivedProps23.pagination,
//           showArrows = _this$getDerivedProps23.showArrows,
//           disableArrowsOnEnd = _this$getDerivedProps23.disableArrowsOnEnd,
//           preventDefaultTouchmoveEvent = _this$getDerivedProps23.preventDefaultTouchmoveEvent,
//           renderArrow = _this$getDerivedProps23.renderArrow,
//           renderPagination = _this$getDerivedProps23.renderPagination;

//       var childWidth = this.calculateChildWidth();
//       var numOfPages = this.getNumOfPages();
//       /** Determine if arrows should be disabled */

//       var canSlidePrev = activeIndex !== this.getNextItemIndex(activeIndex, true);
//       var canSlideNext = activeIndex !== this.getNextItemIndex(activeIndex, false);
//       var disabledPrevArrow = !canSlidePrev && disableArrowsOnEnd;
//       var disabledNextArrow = !canSlideNext && disableArrowsOnEnd;
//       return /*#__PURE__*/React__default.createElement(CarouselWrapper, {
//         isRTL: isRTL,
//         className: "".concat(cssPrefix("carousel-wrapper"), " ").concat(className),
//         style: style
//       }, /*#__PURE__*/React__default.createElement(StyledCarousel, {
//         className: cssPrefix("carousel"),
//         size: {
//           height: rootHeight
//         }
//       }, /*#__PURE__*/React__default.createElement(Only, {
//         when: showArrows
//       }, renderArrow ? renderArrow({
//         type: consts.PREV,
//         onClick: this.onPrevStart,
//         isEdge: !canSlidePrev
//       }) : /*#__PURE__*/React__default.createElement(Arrow, {
//         onClick: this.onPrevStart,
//         direction: verticalMode ? Arrow.up : Arrow.left,
//         disabled: disabledPrevArrow
//       })), /*#__PURE__*/React__default.createElement(SliderContainer, {
//         className: cssPrefix("slider-container"),
//         ref: this.setRef("sliderContainer")
//       }, /*#__PURE__*/React__default.createElement(Slider$1, {
//         verticalMode: verticalMode,
//         isRTL: isRTL,
//         easing: easing,
//         sliderPosition: sliderPosition,
//         swipedSliderPosition: swipedSliderPosition,
//         isSwiping: isSwiping,
//         transitionMs: transitionMs,
//         tiltEasing: tiltEasing,
//         className: cssPrefix("slider"),
//         ref: this.setRef("slider"),
//         outerSpacing: outerSpacing
//       }, /*#__PURE__*/React__default.createElement(Track, {
//         verticalMode: verticalMode,
//         children: Children.toArray(children),
//         childWidth: childWidth,
//         currentItem: activeIndex,
//         autoTabIndexVisibleItems: autoTabIndexVisibleItems,
//         itemsToShow: itemsToShow,
//         itemsToScroll: itemsToScroll,
//         itemPosition: itemPosition,
//         itemPadding: itemPadding,
//         enableSwipe: enableSwipe,
//         enableMouseSwipe: enableMouseSwipe,
//         preventDefaultTouchmoveEvent: preventDefaultTouchmoveEvent,
//         onSwiped: this.onSwiped,
//         onSwiping: this.onSwiping,
//         onItemClick: focusOnSelect ? this.goTo : undefined
//       }))), /*#__PURE__*/React__default.createElement(Only, {
//         when: showArrows
//       }, renderArrow ? renderArrow({
//         type: consts.NEXT,
//         onClick: this.onNextStart,
//         isEdge: !canSlideNext
//       }) : /*#__PURE__*/React__default.createElement(Arrow, {
//         onClick: this.onNextStart,
//         direction: verticalMode ? Arrow.down : Arrow.right,
//         disabled: disabledNextArrow
//       }))), /*#__PURE__*/React__default.createElement(Only, {
//         when: pagination
//       }, renderPagination ? renderPagination({
//         pages: pages,
//         activePage: activePage,
//         onClick: this.onIndicatorClick
//       }) : /*#__PURE__*/React__default.createElement(Pagination, {
//         numOfPages: numOfPages,
//         activePage: activePage,
//         onClick: this.onIndicatorClick
//       })));
//     }
//   }]);

//   return Carousel;
// }(React__default.Component);

// Carousel$1.defaultProps = {
//   className: "",
//   style: {},
//   verticalMode: false,
//   isRTL: false,
//   initialFirstItem: 0,
//   initialActiveIndex: 0,
//   showArrows: true,
//   showEmptySlots: false,
//   disableArrowsOnEnd: true,
//   pagination: true,
//   easing: "ease",
//   tiltEasing: "ease",
//   transitionMs: 500,
//   enableTilt: true,
//   enableSwipe: true,
//   enableMouseSwipe: true,
//   preventDefaultTouchmoveEvent: false,
//   focusOnSelect: false,
//   autoTabIndexVisibleItems: true,
//   itemsToShow: 1,
//   itemsToScroll: 1,
//   itemPosition: consts.CENTER,
//   itemPadding: [0, 0, 0, 0],
//   outerSpacing: 0,
//   enableAutoPlay: false,
//   autoPlaySpeed: 2000,
//   // callbacks
//   onChange: noop$1,
//   onNextEnd: noop$1,
//   onPrevEnd: noop$1,
//   onNextStart: noop$1,
//   onPrevStart: noop$1,
//   onResize: noop$1
// };
// Carousel$1.propTypes = {
//   /** Items to render */
//   children: PropTypes__default.node.isRequired,

//   /** The css class for the root element */
//   className: PropTypes__default.string,

//   /** The style object for the root element */
//   style: PropTypes__default.object,

//   /** Display the Carousel in a vertical layout */
//   verticalMode: PropTypes__default.bool,

//   /** Flip right to left */
//   isRTL: PropTypes__default.bool,

//   /** Show dots for paging */
//   pagination: PropTypes__default.bool,

//   /** Animation speed */
//   transitionMs: PropTypes__default.number,

//   /** transition easing pattern */
//   easing: PropTypes__default.string,

//   /** transition easing pattern for the tilt */
//   tiltEasing: PropTypes__default.string,

//   /** The "bump" animation when reaching the last item */
//   enableTilt: PropTypes__default.bool,

//   /** Number of visible items  */
//   itemsToShow: PropTypes__default.number,

//   /** Number of items to scroll */
//   itemsToScroll: PropTypes__default.number,

//   /** Collection of objects with a width, itemsToShow and itemsToScroll  */
//   breakPoints: PropTypes__default.arrayOf(PropTypes__default.shape({
//     width: PropTypes__default.number.isRequired,
//     itemsToShow: PropTypes__default.number,
//     itemsToScroll: PropTypes__default.number
//   })),

//   /** The initial active index when the component mounts */
//   initialActiveIndex: PropTypes__default.number,

//   /** **DEPRECATED - use initialActiveIndex instead** The first items when the component mounts */
//   initialFirstItem: PropTypes__default.number,

//   /** Show the arrow buttons */
//   showArrows: PropTypes__default.bool,

//   /** Show empty slots when children.length < itemsToShow (not compatible with verticalMode yet !) */
//   showEmptySlots: PropTypes__default.bool,

//   /** Disables the arrow button when there are no more items */
//   disableArrowsOnEnd: PropTypes__default.bool,

//   /** Go to item on click */
//   focusOnSelect: PropTypes__default.bool,

//   /** Automatically inject `tabIndex:0` to visible items */
//   autoTabIndexVisibleItems: PropTypes__default.bool,

//   /** A render prop for the arrow component
//    * - ({type, onClick}) => <div onClick={onClick}>{type === 'prev' ? '<-' : '->'}</div>
//    */
//   renderArrow: PropTypes__default.func,

//   /** A render prop for the pagination component
//    * - ({ pages, activePage, onClick }) =>  <YourComponent/>
//    */
//   renderPagination: PropTypes__default.func,

//   /** Position the element relative to it's wrapper (use the consts object) - consts.START | consts.CENTER | consts.END */
//   itemPosition: PropTypes__default.oneOf([consts.START, consts.CENTER, consts.END]),

//   /** A padding for each element  */
//   itemPadding: PropTypes__default.array,

//   /** A margin at the beginning and at the end of the carousel (not compatible with verticalMode yet !) */
//   outerSpacing: PropTypes__default.number,
//   // swipe

//   /** Enable or disable swipe */
//   enableSwipe: PropTypes__default.bool,

//   /** Enable or disable mouse swipe */
//   enableMouseSwipe: PropTypes__default.bool,

//   /** Prevent page scroll on touchmove.
//    * Use this to stop the browser from scrolling while a user swipes.
//    * More details: https://github.com/FormidableLabs/react-swipeable#preventdefaulttouchmoveevent-details
//    */
//   preventDefaultTouchmoveEvent: PropTypes__default.bool,
//   // auto play

//   /** Enable or disable auto play */
//   enableAutoPlay: PropTypes__default.bool,

//   /** Set auto play speed (ms) */
//   autoPlaySpeed: PropTypes__default.number,
//   // callbacks

//   /** A callback for the change of an item
//    * - onChange(currentItemObject, currentPageIndex) => {} */
//   onChange: PropTypes__default.func,

//   /** A callback for the beginning of the next transition
//    * - onNextStart(prevItemObject, nextItemObject) => {} */
//   onNextStart: PropTypes__default.func,

//   /** A callback for the beginning of the prev transition
//    * - onPrevStart(prevItemObject, nextItemObject) => {} */
//   onPrevStart: PropTypes__default.func,

//   /** A callback for the end of the next transition
//    * - onNextEnd(nextItemObject, currentPageIndex) => {} */
//   onNextEnd: PropTypes__default.func,

//   /** A callback for the end of the prev transition
//    * - onPrevEnd(nextItemObject, currentPageIndex) => {} */
//   onPrevEnd: PropTypes__default.func,

//   /** A callback for the "slider-container" resize
//    * - onResize(currentBreakPoint) => {} */
//   onResize: PropTypes__default.func
// };

// function SumtElasticCarouselWrapper(_ref) {
//   var children = _ref.children,
//     pagination = _ref.pagination,
//     itemsToScroll = _ref.itemsToScroll,
//     cardSize = _ref.cardSize,
//     nextArrow = _ref.nextArrow,
//     previousArrow = _ref.previousArrow,
//     initialActiveIndex = _ref.initialActiveIndex;
//   var breakPoints = [];
//   if (cardSize !== null) {
//     var remWidth = cardSize * 16;
//     breakPoints = [{
//       width: 1,
//       itemsToShow: 1
//     }, {
//       width: remWidth * 2,
//       itemsToShow: 2
//     }, {
//       width: remWidth * 3,
//       itemsToShow: 3
//     }, {
//       width: remWidth * 4,
//       itemsToShow: 4
//     }, {
//       width: remWidth * 5,
//       itemsToShow: 5
//     }, {
//       width: remWidth * 6,
//       itemsToShow: 6
//     }, {
//       width: remWidth * 7,
//       itemsToShow: 7
//     }, {
//       width: remWidth * 8,
//       itemsToShow: 8
//     }, {
//       width: remWidth * 9,
//       itemsToShow: 9
//     }, {
//       width: remWidth * 10,
//       itemsToShow: 10
//     }, {
//       width: remWidth * 11,
//       itemsToShow: 11
//     }, {
//       width: remWidth * 12,
//       itemsToShow: 12
//     }, {
//       width: remWidth * 13,
//       itemsToShow: 13
//     }, {
//       width: remWidth * 14,
//       itemsToShow: 14
//     }, {
//       width: remWidth * 15,
//       itemsToShow: 15
//     }];
//   }
//   var arrows = function arrows(_ref2) {
//     var type = _ref2.type,
//       onClick = _ref2.onClick,
//       isEdge = _ref2.isEdge;
//     var pointer = type === consts.PREV ? previousArrow(onClick, isEdge) : nextArrow(onClick, isEdge);
//     return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, pointer);
//   };
//   return /*#__PURE__*/React__default.createElement(Carousel$1, {
//     initialActiveIndex: initialActiveIndex,
//     breakPoints: breakPoints,
//     pagination: pagination,
//     autoTabIndexVisibleItems: true,
//     itemsToScroll: itemsToScroll,
//     renderArrow: arrows,
//     showEmptySlots: true
//   }, children);
// }

// // PropType check
// SumtElasticCarouselWrapper.propTypes = {
//   /**
//    * Carousel items
//    */
//   children: PropTypes__default.node,
//   /**
//    * Pagination hidden or visible
//    */
//   pagination: PropTypes__default.bool,
//   /**
//    * Number of slides to scroll at once
//    */
//   itemsToScroll: PropTypes__default.number,
//   /**
//    * Card size usage: Pass the width of card in rems
//    */
//   cardSize: PropTypes__default.number,
//   /**
//    * Custom component for rendering next arrow
//    */
//   nextArrow: PropTypes__default.func,
//   /**
//    * Custom component for rendering previous arrow
//    */
//   previousArrow: PropTypes__default.func,
//   /**
//    * Make carousel item active based passed index
//    */
//   initialActiveIndex: PropTypes__default.number
// };
// SumtElasticCarouselWrapper.defaultProps = {
//   children: null,
//   pagination: false,
//   itemsToScroll: 1,
//   cardSize: null,
//   nextArrow: function nextArrow() {},
//   previousArrow: function previousArrow() {},
//   initialActiveIndex: 0
// };

// var _templateObject$T;
// var Container$1 = styled.div(_templateObject$T || (_templateObject$T = _taggedTemplateLiteral$1(["\n  width: 100%;\n  .rec.rec-carousel {\n    align-items: center;\n  }\n  .rec.rec-slider-container {\n    align-self: normal;\n  }\n  .MuiButtonBase-root.Mui-disabled {\n    opacity: 50%;\n    cursor: not-allowed;\n    pointer-events: initial;\n    ", "\n  }\n  .MuiIconButton-colorPrimary {\n    color: ", ";\n  }\n  .rec.rec-dot {\n    background-color: inherit;\n    box-shadow: 0 0 0.0625rem 0.1875rem\n      ", ";\n  }\n  .rec.rec-dot_active {\n    background-color: ", ";\n  }\n"])), function (props) {
//   return !props.children.props.arrowsOnEnd && "\n    visibility: hidden;\n  ";
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });

// var previousArrow = function previousArrow(onClick, isEdge) {
//   return /*#__PURE__*/React__default.createElement(IconButton, {
//     onClick: onClick,
//     size: "small",
//     label: "previous",
//     color: "primary",
//     disabled: isEdge
//   }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//     iconName: "NavigateBefore",
//     size: 2.5
//   }));
// };
// var nextArrow = function nextArrow(onClick, isEdge) {
//   return /*#__PURE__*/React__default.createElement(IconButton, {
//     onClick: onClick,
//     size: "small",
//     label: "next",
//     color: "primary",
//     disabled: isEdge
//   }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//     iconName: "NavigateNext",
//     size: 2.5
//   }));
// };

// /**
//  * Carousels show a collection of items that can be scrolled on and off the screen
//  */
// function Carousel(_ref) {
//   var children = _ref.children,
//     pagination = _ref.pagination,
//     arrowsOnEnd = _ref.arrowsOnEnd,
//     itemsToScroll = _ref.itemsToScroll,
//     cardSize = _ref.cardSize,
//     customNextArrow = _ref.customNextArrow,
//     customPreviousArrow = _ref.customPreviousArrow,
//     initialActiveIndex = _ref.initialActiveIndex;
//   return /*#__PURE__*/React__default.createElement(Container$1, null, /*#__PURE__*/React__default.createElement(SumtElasticCarouselWrapper, {
//     initialActiveIndex: initialActiveIndex,
//     pagination: pagination,
//     arrowsOnEnd: arrowsOnEnd,
//     itemsToScroll: itemsToScroll,
//     cardSize: cardSize,
//     nextArrow: customNextArrow === undefined ? nextArrow : customNextArrow,
//     previousArrow: customPreviousArrow === undefined ? previousArrow : customPreviousArrow
//   }, children));
// }

// // PropType check
// Carousel.propTypes = {
//   /**
//    * Carousel items
//    */
//   children: PropTypes__default.node,
//   /**
//    * Pagination hidden or visible
//    */
//   pagination: PropTypes__default.bool,
//   /**
//    * Hide or Show arrows at end
//    */
//   arrowsOnEnd: PropTypes__default.bool,
//   /**
//    * Number of slides to scroll at once
//    */
//   itemsToScroll: PropTypes__default.number,
//   /**
//    * Card size usage: Pass the width of card in rems
//    */
//   cardSize: PropTypes__default.number,
//   /**
//    * Custom component for rendering next arrow, should take in parameters: onClick, isEdge
//    */
//   customNextArrow: PropTypes__default.func,
//   /**
//    * Custom component for rendering previous arrow, should take in parameters: onClick, isEdge
//    */
//   customPreviousArrow: PropTypes__default.func,
//   /**
//    * Make carousel item active based passed index
//    */
//   initialActiveIndex: PropTypes__default.number
// };
// Carousel.defaultProps = {
//   children: null,
//   pagination: false,
//   arrowsOnEnd: true,
//   itemsToScroll: 1,
//   cardSize: null,
//   customNextArrow: undefined,
//   customPreviousArrow: undefined,
//   initialActiveIndex: 0
// };

// /**
//  * The component used to pass table instance across child components of DataGrid.
//  */
// function TableRowContextProvider(_ref) {
//   var row = _ref.row,
//     cellValue = _ref.cellValue,
//     cell = _ref.cell,
//     children = _ref.children;
//   var value = {
//     row: row,
//     cellValue: cellValue,
//     cell: cell
//   };
//   return /*#__PURE__*/React__default.createElement(TableRowContext.Provider, {
//     value: value
//   }, children);
// }
// TableRowContextProvider.propTypes = {
//   /**
//    * Row item in table instance.
//    */
//   row: PropTypes__default.shape({}),
//   /**
//    * Cell in table row instance.
//    */
//   cellValue: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.objectOf(PropTypes__default.any), PropTypes__default.arrayOf(PropTypes__default.any), PropTypes__default.any]),
//   /**
//    * Cell in table row isntance.
//    */
//   cell: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.objectOf(PropTypes__default.any)]),
//   /**
//    * child nodes.
//    */
//   children: PropTypes__default.node.isRequired
// };
// TableRowContextProvider.defaultProps = {
//   row: {},
//   cellValue: '',
//   cell: ''
// };

// function CellRenderer(_ref) {
//   var property = _ref.property,
//     children = _ref.children,
//     className = _ref.className,
//     valueGetter = _ref.valueGetter,
//     includeCellinUseEffect = _ref.includeCellinUseEffect,
//     align = _ref.align;
//   var _useContext = useContext(TableRowContext),
//     row = _useContext.row;
//   var rowCell = row.cells.find(function (obj) {
//     return obj.column.id === property;
//   });
//   var cell = rowCell.render('Cell');
//   var _useState = useState$1(cell ? cell.props.value : null),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     cellValue = _useState2[0],
//     setValue = _useState2[1];
//   useEffect$2(function () {
//     if (valueGetter) {
//       setValue(valueGetter(cell));
//     } else {
//       setValue(cell ? cell.props.value : null);
//     }
//   },
//   // eslint-disable-next-line react-hooks/exhaustive-deps
//   includeCellinUseEffect ? [cell, valueGetter] : [valueGetter]);
//   return /*#__PURE__*/React__default.createElement(TableRowContextProvider, {
//     cellValue: cellValue,
//     row: row,
//     cell: cell
//   }, /*#__PURE__*/React__default.createElement(BasicTableCell, _extends$v({}, rowCell.getCellProps(), {
//     className: className,
//     id: "".concat(row.index, "_").concat(rowCell.column.id),
//     align: align
//   }), children));
// }
// CellRenderer.propTypes = {
//   /**
//    * Table column data accessor.
//    */
//   property: PropTypes__default.string.isRequired,
//   /**
//    * Table cell content.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * To get cell value
//    */
//   valueGetter: PropTypes__default.func,
//   /**
//    * To pass cell in useEffect
//    */
//   includeCellinUseEffect: PropTypes__default.bool,
//   /**
//    * TableCell align
//    */
//   align: PropTypes__default.oneOf(['center', 'inherit', 'justify', 'left', 'right'])
// };
// CellRenderer.defaultProps = {
//   className: undefined,
//   valueGetter: undefined,
//   includeCellinUseEffect: true,
//   align: 'left'
// };

// /**
//  * Component for Checkbox with a label
//  */
// function CheckboxWithLabel(_ref) {
//   var label = _ref.label,
//     checked = _ref.checked,
//     disabled = _ref.disabled,
//     onChange = _ref.onChange,
//     ariaLabel = _ref.ariaLabel,
//     inputProps = _ref.inputProps,
//     disableRipple = _ref.disableRipple,
//     tabIndex = _ref.tabIndex,
//     id = _ref.id;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Label$8, {
//     label: label
//   }, /*#__PURE__*/React__default.createElement(Checkbox, {
//     checked: checked,
//     disabled: disabled,
//     onChange: onChange,
//     ariaLabel: ariaLabel,
//     inputProps: inputProps,
//     disableRipple: disableRipple,
//     tabIndex: tabIndex,
//     id: id
//   })));
// }
// CheckboxWithLabel.propTypes = {
//   /**
//    * Label text to be used for the input field
//    */
//   label: PropTypes__default.node.isRequired,
//   /**
//    * If `true`, the component is checked.
//    */
//   checked: PropTypes__default.bool,
//   /**
//    * If `true`, the switch will be disabled. Keep this undefined to control from FormGroup
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for input field
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * If true, the  ripple effect will be disabled
//    */
//   disableRipple: PropTypes__default.bool,
//   /**
//    * To set tabindex
//    */
//   tabIndex: PropTypes__default.number,
//   /**
//    * The id of the input element.
//    */
//   id: PropTypes__default.string
// };
// CheckboxWithLabel.defaultProps = {
//   checked: false,
//   disabled: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   ariaLabel: null,
//   inputProps: undefined,
//   disableRipple: false,
//   tabIndex: undefined,
//   id: undefined
// };

// var _templateObject$S, _templateObject2$D, _templateObject3$q, _templateObject4$e, _templateObject5$9, _templateObject6$7, _templateObject7$7, _templateObject8$5, _templateObject9$3;
// var StyledIcon$2 = styled(Icon)(_templateObject$S || (_templateObject$S = _taggedTemplateLiteral$1(["\n  color: ", ";\n  .MuiIconButton-root {\n    color: ", ";\n  }\n  .MuiIconButton-label {\n    margin: 0rem;\n  }\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var StyledDiv$4 = styled.div(_templateObject2$D || (_templateObject2$D = _taggedTemplateLiteral$1(["\n  border: none;\n  &:focus-visible {\n    outline: none !important;\n  }\n"])));
// var FilterSection$1 = styled.div(_templateObject3$q || (_templateObject3$q = _taggedTemplateLiteral$1(["\n  margin-top: 0.5rem;\n"])));
// var StyledIconMenu = styled(IconMenu)(_templateObject4$e || (_templateObject4$e = _taggedTemplateLiteral$1(["\n  .MuiIconButton-root {\n    color: ", ";\n    width: 2rem;\n    height: 2rem;\n  }\n  .MuiIconButton-label {\n    margin: 0.125rem;\n  }\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var StyledIcon1 = styled(Icon)(_templateObject5$9 || (_templateObject5$9 = _taggedTemplateLiteral$1(["\n  margin-left: -0.3rem;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var StyledIcon2 = styled(Icon)(_templateObject6$7 || (_templateObject6$7 = _taggedTemplateLiteral$1(["\n  margin-left: -0.3rem;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var StyledIconAdvancedSort = styled(Icon)(_templateObject7$7 || (_templateObject7$7 = _taggedTemplateLiteral$1(["\n  margin-left: -0.3rem;\n  padding-right: 0.4rem;\n  font-weight: 600;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.textColor;
// });
// var Styledspan = styled.span(_templateObject8$5 || (_templateObject8$5 = _taggedTemplateLiteral$1(["\n  font-size: 0.875rem;\n  font-weight: 600;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.textColor;
// });
// var StyledBadge$1 = styled(Badge)(_templateObject9$3 || (_templateObject9$3 = _taggedTemplateLiteral$1(["\n.MuiBadge-dot {\n  height: 0.625rem;\n  min-width: 0.625rem;\n  border-radius: 0.313rem;\n"])));

// /**
//  * The component used to render the sort and filter panel in DataGrid.
//  */
// function SortAndFilterPanel(_ref) {
//   var sortSection = _ref.sortSection,
//     className = _ref.className,
//     sortDirection = _ref.sortDirection,
//     filterSection = _ref.filterSection,
//     translations = _ref.translations,
//     isFiltered = _ref.isFiltered,
//     label = _ref.label,
//     isAdvancedSort = _ref.isAdvancedSort,
//     selectedSortOption = _ref.selectedSortOption,
//     advancedSortIcon = _ref.advancedSortIcon,
//     showDropdownIcon = _ref.showDropdownIcon,
//     iconType = _ref.iconType,
//     iconSize = _ref.iconSize,
//     closeOnApply = _ref.closeOnApply;
//   var iconName;
//   var sortText;
//   if (sortDirection === 'asc') {
//     iconName = 'ArrowUpward';
//   } else if (sortDirection === 'desc') {
//     iconName = 'ArrowDownward';
//   }
//   if (isAdvancedSort) {
//     sortText = "".concat(translations.SORT_BY_TEXT, " ").concat(selectedSortOption);
//   }
//   var filterIcon = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isFiltered ? /*#__PURE__*/React__default.createElement(StyledBadge$1, {
//     anchorOrigin: {
//       horizontal: 'right',
//       vertical: 'top'
//     },
//     variant: "dot"
//   }, /*#__PURE__*/React__default.createElement(StyledIcon1, {
//     iconName: "FilterIcon",
//     size: 1
//   }), /*#__PURE__*/React__default.createElement(Styledspan, {
//     style: {
//       marginRight: '0.4rem'
//     }
//   }, translations.FILTER_TEXT)) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(StyledIcon$2, {
//     iconName: "FilterIcon",
//     size: 1
//   }), /*#__PURE__*/React__default.createElement(Styledspan, {
//     style: {
//       marginRight: '0.4rem'
//     }
//   }, translations.FILTER_TEXT)));
//   var icon = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isAdvancedSort ? /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(StyledIconAdvancedSort, {
//     iconName: advancedSortIcon,
//     iconType: iconType,
//     size: iconSize
//   }), /*#__PURE__*/React__default.createElement(Styledspan, {
//     style: {
//       marginRight: '0.4rem'
//     }
//   }, translations.SORT_BY_TEXT, ": ", selectedSortOption), showDropdownIcon && /*#__PURE__*/React__default.createElement(StyledIconAdvancedSort, {
//     iconType: "MaterialIcon",
//     iconName: "ArrowDropDown",
//     size: 1
//   })) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, iconName ? /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(StyledIcon2, {
//     iconName: iconName,
//     size: 1
//   }), isFiltered ? filterIcon : /*#__PURE__*/React__default.createElement(StyledIcon1, {
//     iconName: "FilterIcon",
//     size: 1
//   })) : filterIcon));
//   var handleKeyEventClick = function handleKeyEventClick(event) {
//     // Enter Key: 13 Space Key: 32
//     var KEYCODE_ENTER = 13;
//     var KEYCODE_SPACE = 32;
//     if (event.keyCode === KEYCODE_ENTER && event.target.id.includes('filter_Id')) {
//       return true;
//     }
//     if (event.keyCode === KEYCODE_ENTER || event.keyCode === KEYCODE_SPACE) {
//       return !!filterSection;
//     }
//     return true;
//   };
//   return /*#__PURE__*/React__default.createElement(StyledIconMenu, {
//     icon: icon,
//     className: className,
//     component: "popover",
//     label: isAdvancedSort ? sortText.toString() : label
//   }, /*#__PURE__*/React__default.createElement(StyledDiv$4, {
//     className: "panel",
//     onClick: function onClick(event) {
//       if (event && (event.target.id.includes('reset') || event.target.id.includes('apply'))) {
//         if (closeOnApply) return false;
//         return true;
//       }
//       return !!filterSection;
//     },
//     onKeyDown: function onKeyDown(e) {
//       return handleKeyEventClick(e);
//     },
//     tabIndex: -1
//   }, sortSection, /*#__PURE__*/React__default.createElement(FilterSection$1, null, filterSection && sortSection && /*#__PURE__*/React__default.createElement(Divider, null), filterSection)));
// }
// SortAndFilterPanel.propTypes = {
//   /**
//    * Class name.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Sort elements.
//    */
//   sortSection: PropTypes__default.node,
//   /**
//    * Filter elements.
//    */
//   filterSection: PropTypes__default.node,
//   /**
//    * Filter applied or not.
//    */
//   isFiltered: PropTypes__default.bool,
//   /**
//   /**
//    * To indicate sort direction.
//    */
//   sortDirection: PropTypes__default.oneOf(['asc', 'desc', 'none']),
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Label to be used for sort and filter icon button.
//    */
//   label: PropTypes__default.string,
//   /**
//    * flag which needs to be sent in order to enable Advanced Sorting.
//    */
//   isAdvancedSort: PropTypes__default.bool,
//   /**
//    * Label to be used for advanced sorting.
//    */
//   selectedSortOption: PropTypes__default.string,
//   /**
//    * Icone name for advanced sorting.
//    */
//   advancedSortIcon: PropTypes__default.string,
//   /**
//    * Display Dropdown Icon.
//    */
//   showDropdownIcon: PropTypes__default.bool,
//   /**
//    * Specifies which type of icon.
//    */
//   iconType: PropTypes__default.string,
//   /**
//    * Specifies size of the icon.
//    */
//   iconSize: PropTypes__default.number,
//   /**
//    * Close the panel after clicking Apply or Reset
//    */
//   closeOnApply: PropTypes__default.bool
// };
// SortAndFilterPanel.defaultProps = {
//   className: undefined,
//   sortSection: undefined,
//   sortDirection: 'none',
//   filterSection: undefined,
//   translations: {},
//   isFiltered: false,
//   label: undefined,
//   isAdvancedSort: false,
//   selectedSortOption: undefined,
//   advancedSortIcon: 'FilterIcon',
//   showDropdownIcon: true,
//   iconType: 'MaterialIcon',
//   iconSize: 1,
//   closeOnApply: false
// };

// var TableContext = /*#__PURE__*/createContext({});

// var _templateObject$R, _templateObject2$C;
// var StyledSpan$2 = styled.span(_templateObject$R || (_templateObject$R = _taggedTemplateLiteral$1(["\n  position: absolute;\n  width: 0.06rem;\n  height: 0.06rem;\n  margin: -0.06rem;\n  padding: 0;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n"])));
// var StyledFlexGrid$1 = styled(FlexGrid)(_templateObject2$C || (_templateObject2$C = _taggedTemplateLiteral$1(["\n  display: flex;\n"])));

// /**
//  * The component used to render and to customize the table column header in DataGrid.
//  */

// function Column(_ref) {
//   var label = _ref.label,
//     property = _ref.property,
//     className = _ref.className;
//     _ref.ariaLabel;
//     var component = _ref.component,
//     role = _ref.role,
//     sortElement = _ref.sortElement,
//     defaultSort = _ref.defaultSort;
//     _ref.columnType;
//     var sortType = _ref.sortType,
//     translations = _ref.translations,
//     filterElement = _ref.filterElement,
//     filterType = _ref.filterType,
//     defaultFilter = _ref.defaultFilter,
//     hideHeader = _ref.hideHeader,
//     align = _ref.align;
//   var _useContext = useContext(TableContext),
//     tableInstance = _useContext.tableInstance;
//   var column = tableInstance.headers.find(function (obj) {
//     return obj.id === property;
//   });
//   column.sortType = sortType;
//   column.filter = filterType;
//   var defaultSelectedItem = sortElement ? sortElement.props.actionItemList.find(function (x) {
//     return x.key === defaultSort;
//   }) : null;
//   var _useState = useState$1(defaultSelectedItem),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     sortItemSelected = _useState2[0],
//     setSortItemSelected = _useState2[1];
//   var _useState3 = useState$1(false),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     columnIsSorted = _useState4[0],
//     setColumnIsSorted = _useState4[1];
//   var _useState5 = useState$1(false),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     isFilterApplied = _useState6[0],
//     setisFilterApplied = _useState6[1];
//   useEffect$2(function () {
//     if (defaultSelectedItem) {
//       column.toggleSortBy((defaultSelectedItem === null || defaultSelectedItem === void 0 ? void 0 : defaultSelectedItem.sortDirection) === 'desc');
//     }
//     if (defaultFilter && !isFilterApplied) {
//       column.setFilter(defaultFilter);
//       setisFilterApplied(true);
//     }
//   }, [column, defaultSelectedItem, defaultFilter, isFilterApplied]);
//   var sortComponent;
//   if (sortElement) {
//     sortComponent = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.cloneElement(sortElement, {
//       onItemClick: function onItemClick(selectedItem) {
//         handleSortOnItemClick(sortElement.props.onItemClick, selectedItem);
//       },
//       selectedAction: sortItemSelected && column.isSorted ? sortItemSelected.key : 'none'
//     }));
//   }
//   var filterComponent;
//   if (filterElement) {
//     filterComponent = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.cloneElement(filterElement, {
//       column: column
//     }));
//   }
//   var handleSortOnItemClick = function handleSortOnItemClick(onItemClick, selectedItem) {
//     setColumnIsSorted(onItemClick(selectedItem, column.id, columnIsSorted));
//     if (sortItemSelected && sortItemSelected.key === selectedItem.key) {
//       if (column.isSorted) {
//         column.clearSortBy();
//         setSortItemSelected(null);
//       } else {
//         column.toggleSortBy(selectedItem.sortDirection === 'desc');
//         setSortItemSelected(selectedItem);
//       }
//     } else if (sortItemSelected && sortItemSelected.key !== selectedItem.key) {
//       column.clearSortBy();
//       column.toggleSortBy(selectedItem.sortDirection === 'desc');
//       setSortItemSelected(selectedItem);
//     } else if (sortItemSelected === null || sortItemSelected === undefined) {
//       column.toggleSortBy(selectedItem.sortDirection === 'desc');
//       setSortItemSelected(selectedItem);
//     }
//   };
//   var ariaSortLabel = sortElement ? 'none' : undefined;
//   if (sortItemSelected && column.isSorted) {
//     ariaSortLabel = sortItemSelected.sortDirection === 'desc' ? translations.RCORE_LABEL_FOR_DESCENDING || 'descending' : translations.RCORE_LABEL_FOR_ASCENDING || 'ascending';
//   }
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(BasicTableCell, _extends$v({
//     component: component,
//     key: column.id
//   }, column.getHeaderProps(), {
//     className: className,
//     role: role,
//     ariaSort: ariaSortLabel,
//     align: align
//   }), /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(StyledFlexGrid$1, {
//     item: true
//   }, (sortComponent || filterComponent) && /*#__PURE__*/React__default.createElement(SortAndFilterPanel, {
//     sortDirection: sortItemSelected && column.isSorted ? sortItemSelected.sortDirection : 'none',
//     sortSection: sortComponent,
//     filterSection: filterComponent,
//     translations: translations,
//     isFiltered: !!column.filterValue,
//     label: label
//   }), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     ariaHidden: !!(sortComponent || filterComponent)
//   }, hideHeader ? /*#__PURE__*/React__default.createElement(StyledSpan$2, null, " ", column.render('Header')) : column.render('Header'))))));
// }
// Column.propTypes = {
//   /**
//    * Table column header text.
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * Table column data accessor.
//    */
//   property: PropTypes__default.string.isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * To set cell type
//    */
//   component: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for column header.
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * Role of cell
//    */
//   role: PropTypes__default.string,
//   /**
//    * Sort ui component
//    */
//   sortElement: PropTypes__default.node,
//   /**
//    * Set default sorting direction.
//    */
//   defaultSort: PropTypes__default.string,
//   /**
//    * Renders header based on the type. For eg. renders checkbox for type 'checkbox'
//    */
//   columnType: PropTypes__default.string,
//   /**
//    * Used to compare 2 rows of data and order them correctly.
//    * Built-in sorting String options: string, number, basic, datetime, alphanumeric. Defaults to alphanumeric.
//    * If a function is passed, The sortType function should return 1 if rowA is larger, and -1 if rowB is larger.
//    */
//   sortType: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.func]),
//   /**
//    * Filter ui component
//    */
//   filterElement: PropTypes__default.node,
//   /**
//    * Filter type
//    */
//   filterType: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.func]),
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Set default filtering value.
//    */
//   defaultFilter: PropTypes__default.string,
//   /**
//    * To show /hide column header.
//    */
//   hideHeader: PropTypes__default.bool,
//   /**
//    * TableCell align
//    */
//   align: PropTypes__default.oneOf(['center', 'inherit', 'justify', 'left', 'right'])
// };
// Column.defaultProps = {
//   className: undefined,
//   ariaLabel: null,
//   component: 'th',
//   role: 'columnheader',
//   sortElement: undefined,
//   filterElement: undefined,
//   defaultSort: 'none',
//   columnType: undefined,
//   sortType: 'alphanumeric',
//   translations: {},
//   filterType: 'equals',
//   defaultFilter: undefined,
//   hideHeader: false,
//   align: 'left'
// };

// var _excluded$j = ["className", "onChange", "children"];
// /**
//  * This component is used to render ComboBox as table cell content in DataGrid.
//  */
// function ComboBoxRenderer(_ref) {
//   var className = _ref.className,
//     onChange = _ref.onChange,
//     children = _ref.children,
//     rest = _objectWithoutProperties$j(_ref, _excluded$j);
//   var _useContext = useContext(TableRowContext),
//     row = _useContext.row,
//     cellValue = _useContext.cellValue;
//   var _useState = useState$1(cellValue),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     comboValue = _useState2[0],
//     setValue = _useState2[1];
//   var handleComboChange = function handleComboChange(event) {
//     setValue(event.target.value);
//     onChange(event, row);
//   };
//   return /*#__PURE__*/React__default.createElement(ComboBox, _extends$v({
//     className: className,
//     onChange: handleComboChange,
//     value: comboValue
//   }, rest), children);
// }
// ComboBoxRenderer.propTypes = {
//   /**
//    * On change handler
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Table cell content.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string
// };
// ComboBoxRenderer.defaultProps = {
//   className: undefined,
//   onChange: function onChange() {
//     return null;
//   }
// };

// var _templateObject$Q, _templateObject2$B, _templateObject3$p, _templateObject4$d;
// var ControlPanelButton = styled(SumtButtonWrapper)(_templateObject$Q || (_templateObject$Q = _taggedTemplateLiteral$1(["\n  margin-bottom: 0.09375rem;\n  color: ", ";\n  background-color: ", ";\n  min-height: 3.563rem;\n  border: 0;\n  border-radius: 0rem;\n  padding: 0.5rem 0.375rem;\n  box-shadow: none;\n  font-weight: 500;\n  text-transform: capitalize;\n  width: inherit;\n  display: block;\n  &:hover {\n    background-color: ", ";\n    color: ", ";\n  }\n  &:active {\n    background-color: ", ";\n    color: ", ";\n  }\n  &:focus {\n    background-color: ", ";\n    color: ", ";\n  }\n  &:focus-visible {\n    border: 2px solid ", ";\n  }\n"])), function (props) {
//   return props.active ? props.theme.variables.topbarNavActiveStateTextColor : props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.active ? props.theme.variables.topbarNavActiveStateBackground : 'inherit';
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateTextColor;
// }, function (p) {
//   return p.active ? p.theme.variables.topbarNavActiveStateBackground : p.theme.variables.topbarNavHoverStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavTabOutlineColor;
// });
// var ControlPanelIcon = styled(Icon)(_templateObject2$B || (_templateObject2$B = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: center;\n"])));
// var StyledText = styled.p(_templateObject3$p || (_templateObject3$p = _taggedTemplateLiteral$1(["\n  font-size: 0.725rem;\n  margin: 0rem;\n  word-break: break-word;\n  word-wrap: break-word;\n  line-height: 0.9rem;\n  text-align: center;\n  overflow: hidden;\n"])));
// var BadgeIcon = styled(Badge)(_templateObject4$d || (_templateObject4$d = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: center;\n  & .MuiBadge-badge {\n    height: 1rem;\n    width: 1.2rem;\n    min-width: 1.2rem;\n    font-size: 0.7rem;\n    font-weight: bold;\n  }\n  & .MuiBadge-anchorOriginTopLeftCircular {\n    left: 34%;\n  }\n"])));

// var SOFT_HYPHEN = "\xAD";
// var formatPanelName = function formatPanelName(name) {
//   var nameArray = name.split(' ');
//   var formattedPanelName = '';
//   nameArray.forEach(function (wordParam) {
//     if (wordParam.length > 9) {
//       var chararr = wordParam.split('');
//       var word = '';
//       chararr.forEach(function (param, charIndex) {
//         if (charIndex >= 9) {
//           word = "".concat(word + param + SOFT_HYPHEN);
//         } else {
//           word += param;
//         }
//       });
//       formattedPanelName = "".concat(formattedPanelName, " ").concat(word.slice(0, -1));
//     } else {
//       formattedPanelName = "".concat(formattedPanelName, " ").concat(wordParam);
//     }
//   });
//   return formattedPanelName.trim(' ');
// };

// /**
//  * Component to create item to place on control panel.
//  */
// function ControlPanelItem(_ref) {
//   var iconType = _ref.iconType,
//     iconName = _ref.iconName,
//     iconSize = _ref.iconSize,
//     btnSize = _ref.btnSize,
//     name = _ref.name,
//     showBadgeIcon = _ref.showBadgeIcon,
//     notificationCount = _ref.notificationCount,
//     badgeHorizontalAlign = _ref.badgeHorizontalAlign,
//     badgeVerticalAlign = _ref.badgeVerticalAlign,
//     navigatioUrl = _ref.navigatioUrl,
//     actionType = _ref.actionType,
//     onItemClick = _ref.onItemClick,
//     isDisabled = _ref.isDisabled,
//     ariaLabel = _ref.ariaLabel,
//     role = _ref.role,
//     _onKeyDown = _ref.onKeyDown,
//     _onMouseDown = _ref.onMouseDown,
//     highlightControlPanelItem = _ref.highlightControlPanelItem,
//     nodeKey = _ref.nodeKey,
//     className = _ref.className,
//     id = _ref.id;
//   return /*#__PURE__*/React__default.createElement(ControlPanelButton, {
//     id: id,
//     size: btnSize,
//     onKeyDown: function onKeyDown(e) {
//       return _onKeyDown ? _onKeyDown(e, nodeKey, actionType, navigatioUrl) : null;
//     },
//     onClick: function onClick(e) {
//       return onItemClick ? onItemClick(e, nodeKey, actionType, navigatioUrl) : null;
//     },
//     onMouseDown: function onMouseDown(e) {
//       return _onMouseDown ? _onMouseDown(e, nodeKey, actionType, navigatioUrl) : null;
//     },
//     component: "button",
//     disabled: isDisabled,
//     ariaLabel: ariaLabel,
//     role: role,
//     disableFocusRipple: true,
//     active: highlightControlPanelItem,
//     className: className
//   }, showBadgeIcon ? /*#__PURE__*/React__default.createElement(BadgeIcon, {
//     anchorOrigin: {
//       horizontal: badgeHorizontalAlign,
//       vertical: badgeVerticalAlign
//     },
//     badgeContent: notificationCount
//   }, /*#__PURE__*/React__default.createElement(ControlPanelIcon, {
//     iconType: iconType,
//     iconName: iconName,
//     size: iconSize
//   })) : /*#__PURE__*/React__default.createElement(ControlPanelIcon, {
//     iconType: iconType,
//     iconName: iconName,
//     size: iconSize
//   }), /*#__PURE__*/React__default.createElement(StyledText, {
//     "aria-label": name
//   }, formatPanelName(name)));
// }
// // PropType check
// ControlPanelItem.propTypes = {
//   /**
//    * Icon name
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * Type of the icon
//    */
//   iconType: PropTypes__default.oneOf(['MaterialIcon', 'IcomoonIcon']),
//   /**
//    * Size of the icon
//    */
//   iconSize: PropTypes__default.number,
//   /**
//    * Size of the button
//    */
//   btnSize: PropTypes__default.oneOf(['large', 'medium', 'small']),
//   /**
//    * Name of the controlPanelItem
//    */
//   name: PropTypes__default.string,
//   /**
//    * controlPanelItem with Badge
//    */
//   showBadgeIcon: PropTypes__default.bool,
//   /**
//    * Count of the badge icon
//    */
//   notificationCount: PropTypes__default.number,
//   /**
//    * Horizontal Alignment of the badge icon
//    */
//   badgeHorizontalAlign: PropTypes__default.oneOf(['left', 'right']),
//   /**
//    * Vertical Alignment of the badge icon
//    */
//   badgeVerticalAlign: PropTypes__default.oneOf(['top', 'bottom']),
//   /**
//    * navigation url
//    */
//   navigatioUrl: PropTypes__default.string,
//   /**
//    *  To identify navigation or slideout
//    */
//   actionType: PropTypes__default.string,
//   /**
//    * callback method for action click
//    */
//   onItemClick: PropTypes__default.func,
//   /**
//    * to disable/enable button
//    */
//   isDisabled: PropTypes__default.bool,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * Role for button
//    */
//   role: PropTypes__default.string,
//   /**
//    * callback method for onKeyDown handler
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * callback method for onMouseDown handler
//    */
//   onMouseDown: PropTypes__default.func,
//   /**
//    * Highlight control panel item.
//    */
//   highlightControlPanelItem: PropTypes__default.bool,
//   /**
//    * Control panel item key.
//    */
//   nodeKey: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * id property of the button
//    */
//   id: PropTypes__default.string
// };
// ControlPanelItem.defaultProps = {
//   iconName: '',
//   iconType: 'MaterialIcon',
//   iconSize: 1.75,
//   btnSize: 'large',
//   name: '',
//   showBadgeIcon: false,
//   notificationCount: undefined,
//   badgeHorizontalAlign: 'left',
//   badgeVerticalAlign: 'top',
//   navigatioUrl: '',
//   actionType: '',
//   onItemClick: undefined,
//   isDisabled: false,
//   ariaLabel: null,
//   role: undefined,
//   onKeyDown: undefined,
//   onMouseDown: undefined,
//   highlightControlPanelItem: false,
//   nodeKey: '',
//   className: '',
//   id: undefined
// };

// var _templateObject$P, _templateObject2$A, _templateObject3$o;
// var StyledListItem$3 = styled(ListItem)(_templateObject$P || (_templateObject$P = _taggedTemplateLiteral$1(["\ncolor:  ", ";\nbackground-color:", ";\nbox-shadow: none;\nfont-weight:600;\ntext-transform: capitalize ;\nwidth: 4.8125rem;\npadding: 0;\nopacity: ", ";\nheight: 3.75rem;\nborder-style: dashed;\nborder: 0.0625rem dashed ", ";\nmargin: 1rem 1rem;\njustify-content: center;\n\n", ";\n\n.preview-icon {\n  display: flex;\n  justify-content: center;\n  fill: ", ";\n}\n.preview-text{\n  font-size: 0.625rem;\n  margin: 0rem;\n  line-height: 0.75rem;\n  text-align: center;\n  overflow: hidden;\n  max-width: 4.688rem;\n  max-height: 1.5rem;\n  text-overflow: ellipsis;\n  padding: 0 0.188rem 0 0.188rem;\n}\n}\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return !props.disabled ? 'inherit' : 'transparent';
// }, function (props) {
//   return props.disabled ? 0.5 : 1;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return !props.disabled && css(_templateObject2$A || (_templateObject2$A = _taggedTemplateLiteral$1(["\n    &:hover {\n      font-weight: 700;\n      background-color: ", ";\n      color: ", ";\n    }\n    &:active {\n      background-color: ", ";\n      color: ", ";\n      font-weight: 600;\n    }\n    &:focus {\n      background-color: ", ";\n      color: ", ";\n      font-weight: 700;\n    }\n  "])), function (p) {
//     return p.theme.variables.topbarNavHoverStateBackground;
//   }, function (p) {
//     return p.theme.variables.topbarNavHoverStateTextColor;
//   }, function (p) {
//     return p.theme.variables.topbarNavActiveStateBackground;
//   }, function (p) {
//     return p.theme.variables.topbarNavActiveStateTextColor;
//   }, function (p) {
//     return p.theme.variables.topbarNavHoverStateBackground;
//   }, function (p) {
//     return p.theme.variables.topbarNavHoverStateTextColor;
//   });
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });
// var StyledEndIcon = styled(ListItemIcon)(_templateObject3$o || (_templateObject3$o = _taggedTemplateLiteral$1(["\n  color: ", ";\n  position: absolute;\n  align-self: baseline;\n  margin-left: 3.6875rem;\n  margin-top: 0.125rem;\n  top: 0rem;\n  left: 0rem;\n  margin-right: -0.25rem;\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// });

// /**
//  * Component to show Control Panel Preview item.
//  * This is used in Control Panel configuration builder page.
//  */
// function ControlPanelPreviewItem(_ref) {
//   var name = _ref.name,
//     iconName = _ref.iconName,
//     iconType = _ref.iconType,
//     disabled = _ref.disabled,
//     component = _ref.component,
//     role = _ref.role,
//     innerRef = _ref.innerRef,
//     dragProviderProps = _ref.dragProviderProps;
//   var endIcon = 'Lock';
//   if (!disabled) endIcon = 'OpenWith';
//   return /*#__PURE__*/React__default.createElement(StyledListItem$3, {
//     component: component,
//     size: "large",
//     disabled: disabled,
//     role: role,
//     innerRef: innerRef,
//     dragProviderProps: dragProviderProps,
//     className: !disabled ? 'activeItem' : ''
//   }, /*#__PURE__*/React__default.createElement(StyledEndIcon, null, /*#__PURE__*/React__default.createElement(Icon, {
//     iconType: "MaterialIcon",
//     iconName: endIcon,
//     size: 0.875
//   })), /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(Icon, {
//     className: "preview-icon",
//     iconType: iconType,
//     iconName: iconName,
//     size: 1.75
//   }), /*#__PURE__*/React__default.createElement("p", {
//     className: "preview-text"
//   }, name)));
// }

// // PropType check
// ControlPanelPreviewItem.propTypes = {
//   /**
//    * Name of the controlPanelPreviewItem
//    */
//   name: PropTypes__default.string,
//   /**
//    * Icon name
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * Type of the icon
//    */
//   iconType: PropTypes__default.oneOf(['MaterialIcon', 'IcomoonIcon']),
//   /**
//    * Preview item is disabled or not.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Override component.
//    */
//   component: PropTypes__default.string,
//   /**
//    * role attribute for the component
//    */
//   role: PropTypes__default.string,
//   /**
//    * Element reference
//    */
//   innerRef: PropTypes__default.func,
//   /**
//    * Props applied to the container component if used
//    */
//   dragProviderProps: PropTypes__default.shape({})
// };
// ControlPanelPreviewItem.defaultProps = {
//   name: '',
//   iconName: '',
//   iconType: 'MaterialIcon',
//   disabled: false,
//   component: undefined,
//   role: undefined,
//   dragProviderProps: {},
//   innerRef: undefined
// };

// var _templateObject$O, _templateObject2$z, _templateObject3$n, _templateObject4$c, _templateObject5$8, _templateObject6$6, _templateObject7$6, _templateObject8$4, _templateObject9$2, _templateObject10$1;
// var DataAttributeRow = styled(FlexGrid)(_templateObject$O || (_templateObject$O = _taggedTemplateLiteral$1(["\n  padding-top: 1rem;\n  word-break: break-word;\n"])));
// var DataAttributeLabel = styled.span(_templateObject2$z || (_templateObject2$z = _taggedTemplateLiteral$1(["\n  font-size: 1.125rem;\n  margin-top: 0;\n  margin-bottom: 0;\n  margin-right: 0.5rem;\n  &:after {\n    content: ':';\n  }\n"])));
// var DataAttributeValue = styled.div(_templateObject3$n || (_templateObject3$n = _taggedTemplateLiteral$1(["\n  font-size: 1.125rem;\n  margin-top: 0;\n  margin-bottom: 0;\n  font-weight: bold;\n  display: inline-block;\n"])));
// var DataPrimaryText = styled.div(_templateObject4$c || (_templateObject4$c = _taggedTemplateLiteral$1(["\n  color: ", ";\n  font-weight: 600;\n  font-size: 1.3125rem;\n  line-height: 1.5rem;\n  word-break: break-word;\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return theme.variables.brandInfo;
// });
// var StyledContainerRow = styled(FlexGrid)(_templateObject5$8 || (_templateObject5$8 = _taggedTemplateLiteral$1(["\n  border-color: #ddd;\n  border-style: solid none;\n  border-width: 0.0625rem;\n  padding: 1rem;\n  .MuiCheckbox-root {\n    margin-top: -0.5rem;\n    margin-left: -0.5625rem;\n    margin-right: 0.4375rem;\n  }\n"])));
// var StyledAdditionalRow = styled(FlexGrid)(_templateObject6$6 || (_templateObject6$6 = _taggedTemplateLiteral$1(["\n  height: 100%;\n"])));
// var StyledFlexAttributes = styled(FlexGrid)(_templateObject7$6 || (_templateObject7$6 = _taggedTemplateLiteral$1(["\n  border-color: #ddd;\n  border-left-style: solid;\n  border-width: 0.0625rem;\n  padding: 0 1rem;\n  font-weight: 600;\n  font-size: 0.825rem;\n  text-align: center;\n  height: 100%;\n"])));
// var AdditionalDataLabel = styled.span(_templateObject8$4 || (_templateObject8$4 = _taggedTemplateLiteral$1(["\n  font-size: 0.875rem;\n  text-transform: uppercase;\n"])));
// var AdditionalDataValue = styled.p(_templateObject9$2 || (_templateObject9$2 = _taggedTemplateLiteral$1(["\n  color: ", ";\n  text-transform: uppercase;\n  margin-top: 0.75rem;\n  margin-bottom: 0.75rem;\n"])), function (_ref2) {
//   var theme = _ref2.theme;
//   return theme.variables.brandInfo;
// });
// var DataStatusLabel = styled.div(_templateObject10$1 || (_templateObject10$1 = _taggedTemplateLiteral$1(["\n  margin-right: 0.75rem;\n  text-transform: uppercase;\n"])));

// /**
//  * Component for DataListItem.
//  * DataListItem could be used with List to create a list of data items
//  */

// function DataListItem(_ref) {
//   var id = _ref.id,
//     buttonId = _ref.buttonId,
//     name = _ref.name,
//     statusLabel = _ref.statusLabel,
//     status = _ref.status,
//     childNodes = _ref.childNodes,
//     additionalNodes = _ref.additionalNodes,
//     actionsData = _ref.actionsData,
//     actionCallBack = _ref.actionCallBack,
//     checkboxCallBack = _ref.checkboxCallBack,
//     showCheckbox = _ref.showCheckbox;
//   var _useState = useState$1(null),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     popperAnchor = _useState2[0],
//     setPopperAnchor = _useState2[1];
//   var open = Boolean(popperAnchor);
//   var _useState3 = useState$1(false),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     isMenuOpen = _useState4[0],
//     setIsMenuOpen = _useState4[1];
//   var handleClick = function handleClick(event) {
//     if (isMenuOpen) {
//       handleClose();
//     } else {
//       setPopperAnchor(event.currentTarget);
//       setIsMenuOpen(true);
//     }
//   };
//   var handleClose = function handleClose() {
//     setPopperAnchor(null);
//     setIsMenuOpen(false);
//   };
//   var handleAction = function handleAction(event, actionId) {
//     actionCallBack({
//       id: id,
//       action: actionId
//     });
//     handleClose();
//   };
//   var handleCheckboxOnChange = function handleCheckboxOnChange(event) {
//     checkboxCallBack({
//       id: id,
//       checked: event.target.checked
//     });
//   };
//   return /*#__PURE__*/React__default.createElement(StyledContainerRow, {
//     container: true,
//     wrap: "nowrap",
//     direction: "row"
//   }, showCheckbox && /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     container: true,
//     direction: "column",
//     sm: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Checkbox, {
//     onChange: function onChange(e) {
//       return handleCheckboxOnChange(e);
//     },
//     ariaLabel: name
//   }))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     container: true,
//     direction: "column",
//     sm: 12
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     wrap: "nowrap",
//     direction: "row"
//   }, statusLabel && statusLabel.length > 0 && /*#__PURE__*/React__default.createElement(DataStatusLabel, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(StatusLabel, {
//     label: statusLabel,
//     status: status
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(DataPrimaryText, null, name))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     wrap: "nowrap",
//     direction: "row"
//   }, childNodes && childNodes.map(function (child) {
//     return /*#__PURE__*/React__default.createElement(DataAttributeRow, {
//       item: true,
//       sm: 4,
//       key: child.id
//     }, child.label && child.label.length > 0 && /*#__PURE__*/React__default.createElement(DataAttributeLabel, null, child.label), /*#__PURE__*/React__default.createElement(DataAttributeValue, null, child.value));
//   })))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(StyledAdditionalRow, {
//     container: true,
//     direction: "row",
//     justify: "flex-end",
//     key: id,
//     wrap: "nowrap"
//   }, additionalNodes && additionalNodes.map(function (additional) {
//     return /*#__PURE__*/React__default.createElement(StyledFlexAttributes, {
//       item: true,
//       key: additional.id
//     }, additional.label && additional.label.length > 0 && /*#__PURE__*/React__default.createElement(AdditionalDataLabel, null, additional.label), /*#__PURE__*/React__default.createElement(AdditionalDataValue, null, additional.value), additional.statusLabel && additional.statusLabel.length > 0 && /*#__PURE__*/React__default.createElement(StatusLabel, {
//       label: additional.statusLabel,
//       status: additional.status
//     }));
//   }), actionsData && /*#__PURE__*/React__default.createElement(CloseOnEscape, {
//     close: handleClose
//   }, /*#__PURE__*/React__default.createElement(CloseOnClickAway, {
//     close: handleClose
//   }, /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(IconButton, {
//     id: buttonId,
//     color: "primary",
//     size: "small",
//     onClick: function onClick(e) {
//       return handleClick(e);
//     },
//     label: "Actions"
//   }, /*#__PURE__*/React__default.createElement(Icon, {
//     iconName: "MoreVert"
//   })), /*#__PURE__*/React__default.createElement(MuiMenu, {
//     anchorEl: popperAnchor,
//     open: open,
//     onClose: handleClose,
//     placement: "bottom-end"
//   }, actionsData.map(function (action) {
//     return /*#__PURE__*/React__default.createElement(MenuItem, {
//       key: action.id,
//       onClick: function onClick(e) {
//         return handleAction(e, action.id);
//       }
//     }, action.label);
//   }))))))));
// }
// DataListItem.propTypes = {
//   /**
//    * Key Data Identifier
//    */
//   id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//   /**
//    * Id passed to the icon button for focus management
//    */
//   buttonId: PropTypes__default.string,
//   /**
//    * Primary Data Text
//    */
//   name: PropTypes__default.string.isRequired,
//   statusLabel: PropTypes__default.string,
//   status: PropTypes__default.oneOf(['inactive', 'active', 'info', 'warning', 'error']),
//   /**
//    * Child Data Points
//    */
//   childNodes: PropTypes__default.arrayOf(PropTypes__default.shape({
//     id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//     label: PropTypes__default.string.isRequired,
//     value: PropTypes__default.string.isRequired
//   })),
//   /**
//    * Right Side Data Columns
//    */
//   additionalNodes: PropTypes__default.arrayOf(PropTypes__default.shape({
//     id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//     label: PropTypes__default.string.isRequired,
//     value: PropTypes__default.string.isRequired,
//     statusLabel: PropTypes__default.string,
//     status: PropTypes__default.oneOf(['inactive', 'active', 'info', 'warning', 'error'])
//   })),
//   /**
//    * Actions for the Data Item
//    */
//   actionsData: PropTypes__default.arrayOf(PropTypes__default.shape({
//     id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//     label: PropTypes__default.string.isRequired
//   })),
//   /**
//    * Callback function for Actions menu
//    */
//   actionCallBack: PropTypes__default.func,
//   /**
//    * Callback function for checkbox change
//    */
//   checkboxCallBack: PropTypes__default.func,
//   /**
//    * Show checkbox flag
//    */
//   showCheckbox: PropTypes__default.bool
// };

// // DefaultPropType check
// DataListItem.defaultProps = {
//   buttonId: undefined,
//   childNodes: null,
//   additionalNodes: null,
//   actionsData: null,
//   actionCallBack: undefined,
//   checkboxCallBack: undefined,
//   showCheckbox: false,
//   status: null,
//   statusLabel: null
// };

// function EditableTableCellContainer(_ref) {
//   var rowEdit = _ref.rowEdit,
//     editableRowId = _ref.editableRowId,
//     actionMode = _ref.actionMode,
//     children = _ref.children,
//     valueGetter = _ref.valueGetter,
//     defaultComponent = _ref.defaultComponent;
//   var _useContext = useContext(TableContext),
//     tableInstance = _useContext.tableInstance;
//   var _useContext2 = useContext(TableRowContext),
//     cellValue = _useContext2.cellValue,
//     cell = _useContext2.cell;
//   useEffect$2(function () {
//     if (valueGetter) {
//       if (cell.props.row.id === editableRowId) {
//         valueGetter(cell, cellValue);
//       }
//     }
//   }, [cell, cellValue, editableRowId, valueGetter]);
//   if (rowEdit && cell.props.row.id === editableRowId && tableInstance.rows[cell.props.row.id].isSelected || actionMode === 1 && cell.props.row.original.id === 'id_add') {
//     return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children);
//   }
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, defaultComponent);
// }
// EditableTableCellContainer.propTypes = {
//   /**
//    * RowEdit flag
//    */
//   rowEdit: PropTypes__default.bool,
//   /**
//    * Ediable Row Id
//    */
//   editableRowId: PropTypes__default.number,
//   /**
//    * Type of Action like Add Edit
//    */
//   actionMode: PropTypes__default.number,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * To get cell value
//    */
//   valueGetter: PropTypes__default.func,
//   /**
//    * The default component.
//    */
//   defaultComponent: PropTypes__default.node
// };
// EditableTableCellContainer.defaultProps = {
//   editableRowId: null,
//   rowEdit: false,
//   actionMode: null,
//   children: undefined,
//   valueGetter: undefined,
//   defaultComponent: undefined
// };

// /**
//  * Switches toggle the state of a single setting on or off.
//  */
// function ToggleSwitch(_ref) {
//   var checked = _ref.checked,
//     disabled = _ref.disabled,
//     onChange = _ref.onChange,
//     ariaLabel = _ref.ariaLabel,
//     inputProps = _ref.inputProps;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Switch, {
//     checked: checked,
//     disabled: disabled,
//     onChange: onChange,
//     color: "primary",
//     inputProps: _objectSpread2$1(_objectSpread2$1({}, inputProps), {}, {
//       'aria-label': ariaLabel
//     })
//   }));
// }
// ToggleSwitch.propTypes = {
//   /**
//    * If `true`, the component is checked.
//    */
//   checked: PropTypes__default.bool,
//   /**
//    * If `true`, the switch will be disabled. Keep this undefined to control from FormGroup
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for input field
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
//    */
//   inputProps: PropTypes__default.shape({})
// };
// ToggleSwitch.defaultProps = {
//   checked: false,
//   disabled: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   ariaLabel: null,
//   inputProps: undefined
// };

// /**
//  * Component to show switch button with label.
//  */
// function SwitchWithLabel(_ref) {
//   var label = _ref.label,
//     checked = _ref.checked,
//     disabled = _ref.disabled,
//     onChange = _ref.onChange,
//     ariaLabel = _ref.ariaLabel,
//     inputProps = _ref.inputProps;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Label$8, {
//     label: label
//   }, /*#__PURE__*/React__default.createElement(ToggleSwitch, {
//     checked: checked,
//     disabled: disabled,
//     onChange: onChange,
//     ariaLabel: ariaLabel || label,
//     inputProps: inputProps
//   })));
// }
// SwitchWithLabel.propTypes = {
//   /**
//    * Label text to be used for the input field
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * If `true`, the component is checked.
//    */
//   checked: PropTypes__default.bool,
//   /**
//    * If `true`, the switch will be disabled.  Keep this undefined to control from FormGroup
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for input field
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
//    */
//   inputProps: PropTypes__default.shape({})
// };
// SwitchWithLabel.defaultProps = {
//   checked: false,
//   disabled: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   ariaLabel: null,
//   inputProps: undefined
// };

// var _templateObject$N, _templateObject2$y, _templateObject3$m, _templateObject4$b, _templateObject5$7, _templateObject6$5, _templateObject7$5;
// var ParentContainer$1 = styled(Card)(_templateObject$N || (_templateObject$N = _taggedTemplateLiteral$1(["\n  min-width: ", "rem;\n  max-width: 36.25rem;\n  height: ", "rem;\n  margin: 0.5rem;\n  display: flex;\n  flex-wrap: nowrap;\n}\n"])), function (props) {
//   return props.width;
// }, function (props) {
//   return props.height;
// });
// var MenuContainer = styled.div(_templateObject2$y || (_templateObject2$y = _taggedTemplateLiteral$1(["\n  display: flex;\n"])));
// var StyledMenuItem$1 = styled(MenuItem)(_templateObject3$m || (_templateObject3$m = _taggedTemplateLiteral$1(["\n  width: 11.25rem;\n  height: 1.875rem;\n  padding: 1rem;\n  color: ", ";\n  text-align: left;\n  &:focus,\n  &:hover {\n    background-color: ", " 50%;\n  }\n"])), function (props) {
//   return props.theme.variables.textColor;
// }, function (props) {
//   return props.theme.variables.grayBase;
// });
// var FlexyDiv$1 = styled.div(_templateObject4$b || (_templateObject4$b = _taggedTemplateLiteral$1(["\n  display: flex;\n  flex-grow: 1;\n}\n"])));
// var FlexWrap = styled.div(_templateObject5$7 || (_templateObject5$7 = _taggedTemplateLiteral$1(["\n  display: flex;\n  flex-wrap: wrap;\n  flex-grow: 1;\n}\n"])));
// var ActionButtons = styled.div(_templateObject6$5 || (_templateObject6$5 = _taggedTemplateLiteral$1(["\n  display: flex;\n  flex-grow: 1;\n  margin: 0.5rem;\n  label {\n    flex-basis: 100%;\n  }\n  .MuiFormControlLabel-root {\n    margin-left: 0rem;\n  }\n}\n"])));
// var StyledIconButton$4 = styled(IconButton)(_templateObject7$5 || (_templateObject7$5 = _taggedTemplateLiteral$1(["\n color: ", ";\n}\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });

// function FilterCard(_ref) {
//   var id = _ref.id,
//     name = _ref.name,
//     description = _ref.description,
//     checked = _ref.checked,
//     disabled = _ref.disabled,
//     toggleLabel = _ref.toggleLabel,
//     data = _ref.data,
//     kebabLabel = _ref.kebabLabel,
//     height = _ref.height,
//     width = _ref.width,
//     onChange = _ref.onChange,
//     onItemClick = _ref.onItemClick,
//     ariaLabel = _ref.ariaLabel;
//   var _useState = useState$1(null),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     popperAnchor = _useState2[0],
//     setPopperAnchor = _useState2[1];
//   var open = Boolean(popperAnchor);
//   var _useState3 = useState$1(false),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     isMenuOpen = _useState4[0],
//     setIsMenuOpen = _useState4[1];
//   var handleMenuClick = function handleMenuClick(event) {
//     if (isMenuOpen) {
//       handleMenuClose();
//     } else {
//       setPopperAnchor(event.currentTarget);
//       setIsMenuOpen(true);
//     }
//   };
//   var handleMenuClose = function handleMenuClose() {
//     setPopperAnchor(null);
//     setIsMenuOpen(false);
//   };
//   return /*#__PURE__*/React__default.createElement(ParentContainer$1, {
//     height: height,
//     width: width
//   }, /*#__PURE__*/React__default.createElement(FlexyDiv$1, null, /*#__PURE__*/React__default.createElement(CardName, {
//     name: name,
//     variant: checked ? 'active' : 'inactive',
//     cardHeight: "9.7rem"
//   }), /*#__PURE__*/React__default.createElement(FlexWrap, null, /*#__PURE__*/React__default.createElement(CardDescription, {
//     description: description,
//     cardHeight: "6rem"
//   }), /*#__PURE__*/React__default.createElement(ActionButtons, null, /*#__PURE__*/React__default.createElement(SwitchWithLabel, {
//     label: toggleLabel,
//     checked: checked,
//     disabled: disabled,
//     onChange: onChange,
//     ariaLabel: ariaLabel
//   }), /*#__PURE__*/React__default.createElement(CloseOnEscape, {
//     close: handleMenuClose
//   }, /*#__PURE__*/React__default.createElement(CloseOnClickAway, {
//     close: handleMenuClose
//   }, /*#__PURE__*/React__default.createElement(MenuContainer, null, /*#__PURE__*/React__default.createElement(StyledIconButton$4, {
//     id: "kebabMenu_".concat(id),
//     label: kebabLabel,
//     size: "medium",
//     onClick: function onClick(e) {
//       return handleMenuClick(e);
//     }
//   }, /*#__PURE__*/React__default.createElement(Icon, {
//     iconType: "MaterialIcon",
//     iconName: "MoreVert",
//     size: 1.75
//   })), /*#__PURE__*/React__default.createElement(Menu, {
//     open: open,
//     anchorEl: popperAnchor,
//     onClose: handleMenuClose,
//     getContentAnchorEl: null,
//     anchorOrigin: {
//       vertical: 'bottom',
//       horizontal: 'center'
//     },
//     transformOrigin: {
//       vertical: 'top',
//       horizontal: 'right'
//     }
//   }, data && data.map(function (option) {
//     return /*#__PURE__*/React__default.createElement(StyledMenuItem$1, {
//       tabIndex: 0,
//       key: option.id,
//       onClick: function onClick() {
//         onItemClick(option.action);
//       },
//       value: option.id
//     }, /*#__PURE__*/React__default.createElement(BodyText, {
//       text: option.label
//     }));
//   })))))))));
// }
// // PropType check
// FilterCard.propTypes = {
//   /**
//    * Id of the card
//    */
//   id: PropTypes__default.number,
//   /**
//    * Name to be displyed on the card
//    */
//   name: PropTypes__default.string,
//   /**
//    * description to be displyed of the card
//    */
//   description: PropTypes__default.string,
//   /**
//    * if true switch the toggle
//    */
//   checked: PropTypes__default.bool,
//   /**
//    *disabled the toggle if its true
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    *Label to be displyed
//    */
//   toggleLabel: PropTypes__default.string,
//   /**
//    * List data to be displayed
//    */
//   data: PropTypes__default.arrayOf(PropTypes__default.shape({
//     id: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]).isRequired,
//     label: PropTypes__default.string.isRequired,
//     value: PropTypes__default.string.isRequired,
//     action: PropTypes__default.string.isRequired
//   })),
//   /**
//    *Label to be displyed on buttonicon
//    */
//   kebabLabel: PropTypes__default.string,
//   /**
//    * Height of card
//    */
//   height: PropTypes__default.number,
//   /**
//    * Width of card
//    */
//   width: PropTypes__default.number,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Callback fired when buton is expanded.
//    */
//   onItemClick: PropTypes__default.func,
//   /**
//    * Label to read for accessbility support.
//    */
//   ariaLabel: PropTypes__default.string
// };
// FilterCard.defaultProps = {
//   id: null,
//   name: null,
//   description: null,
//   checked: true,
//   disabled: false,
//   toggleLabel: '',
//   data: null,
//   kebabLabel: '',
//   height: 9.688,
//   width: 24.375,
//   onChange: undefined,
//   onItemClick: undefined,
//   ariaLabel: null
// };

// var _templateObject$M, _templateObject2$x;
// var StyledDiv$3 = styled.div(_templateObject$M || (_templateObject$M = _taggedTemplateLiteral$1(["\n  margin-left: 4.8125rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n"])));
// var FilterSection = styled.div(_templateObject2$x || (_templateObject2$x = _taggedTemplateLiteral$1(["\n  margin: 0.5rem;\n  }\n"])));

// function FilterSectionContainer(_ref) {
//   var className = _ref.className,
//     filterSection = _ref.filterSection,
//     resetButtonName = _ref.resetButtonName,
//     applyButtonName = _ref.applyButtonName,
//     onResetButtonClick = _ref.onResetButtonClick,
//     onApplyButtonClick = _ref.onApplyButtonClick,
//     column = _ref.column,
//     setFilterselection = _ref.setFilterselection,
//     nonGridFilterValue = _ref.nonGridFilterValue;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     filtered = _useState2[0],
//     setFiltered = _useState2[1];
//   var _useState3 = useState$1(false),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     initialFilterValue = _useState4[0],
//     setInitialFilterValue = _useState4[1];
//   useEffect$2(function () {
//     if (filtered && column) {
//       column.setFilter(filtered);
//     }
//     if (column && !initialFilterValue && setFilterselection) {
//       setFilterselection(column.filterValue);
//       setInitialFilterValue(true);
//     }
//     if (nonGridFilterValue && !initialFilterValue && setFilterselection) {
//       setFilterselection(nonGridFilterValue);
//       setInitialFilterValue(true);
//     }
//   }, [column, filtered, setFilterselection, initialFilterValue, nonGridFilterValue]);
//   var handleResetClick = function handleResetClick() {
//     var resetFilterValue = onResetButtonClick();
//     setFiltered(resetFilterValue);
//     if (column) {
//       column.setFilter(resetFilterValue);
//     }
//   };
//   var handleApplyClick = function handleApplyClick() {
//     var filterValue = onApplyButtonClick();
//     setFiltered(filterValue);
//     if (column) {
//       column.setFilter(filterValue);
//     }
//   };
//   var handleKeyClick = function handleKeyClick(event, keyDownEvent) {
//     if (event.keyCode === 13 && keyDownEvent) {
//       var filterValue = keyDownEvent(event);
//       setFiltered(filterValue);
//       if (column) {
//         column.setFilter(filterValue);
//       }
//     }
//   };
//   var filterComponent;
//   if (filterSection) {
//     filterComponent = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.cloneElement(filterSection, {
//       onKeyDown: function onKeyDown(event) {
//         handleKeyClick(event, filterSection.props.onKeyDown);
//       },
//       id: 'filter_Id'
//     }));
//   }
//   return /*#__PURE__*/React__default.createElement("div", {
//     className: className
//   }, /*#__PURE__*/React__default.createElement(FilterSection, null, filterComponent), /*#__PURE__*/React__default.createElement(Divider, null), /*#__PURE__*/React__default.createElement(StyledDiv$3, {
//     className: "filterFooter"
//   }, /*#__PURE__*/React__default.createElement(Button$1, {
//     id: "reset",
//     variant: "text",
//     onClick: handleResetClick
//   }, /*#__PURE__*/React__default.createElement("span", {
//     id: "resetLabel"
//   }, resetButtonName)), /*#__PURE__*/React__default.createElement(Button$1, {
//     id: "apply",
//     variant: "text",
//     onClick: handleApplyClick
//   }, /*#__PURE__*/React__default.createElement("span", {
//     id: "applyLabel"
//   }, applyButtonName))));
// }
// FilterSectionContainer.propTypes = {
//   /**
//    * Class name.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Sort elements.
//    */
//   filterSection: PropTypes__default.node,
//   /**
//    * Reset button name.
//    */
//   resetButtonName: PropTypes__default.string,
//   /**
//    * Reset button name.
//    */
//   applyButtonName: PropTypes__default.string,
//   /**
//    * On rest button click.
//    */
//   onResetButtonClick: PropTypes__default.func,
//   /**
//    * On apply button click.
//    */
//   onApplyButtonClick: PropTypes__default.func,
//   /**
//    * Column to filter
//    */
//   // eslint-disable-next-line react/forbid-prop-types
//   column: PropTypes__default.objectOf(PropTypes__default.any),
//   /**
//    * To handle keyDown events
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * To set filter option
//    */
//   setFilterselection: PropTypes__default.func,
//   /**
//    * Data for the non grid items
//    */
//   nonGridFilterValue: PropTypes__default.shape({})
// };
// FilterSectionContainer.defaultProps = {
//   className: undefined,
//   filterSection: undefined,
//   resetButtonName: '',
//   applyButtonName: '',
//   onApplyButtonClick: undefined,
//   onResetButtonClick: undefined,
//   column: undefined,
//   onKeyDown: undefined,
//   setFilterselection: undefined,
//   nonGridFilterValue: undefined
// };

// /**
//  * Snackbar component is used to display notifications. Handling the Open
//  * & Close logic of Snackbar should be maintained in parent component state.
//  * And closeHandler should be passed from parent.
//  * Refer storybook component for example.
//  * (background-color and text-color of snackbar are taken from theme colors[leftNavHeaderBackground,leftNavParentColor] in storybook).
//  */
// function Snackbar(_ref) {
//   var open = _ref.open,
//     closeHandler = _ref.closeHandler,
//     autoHideDuration = _ref.autoHideDuration,
//     message = _ref.message,
//     verticalAlign = _ref.verticalAlign,
//     horizontalAlign = _ref.horizontalAlign,
//     closeOnClickAway = _ref.closeOnClickAway,
//     children = _ref.children;
//   var anchor = {
//     vertical: verticalAlign,
//     horizontal: horizontalAlign
//   };
//   var handleClose = function handleClose(event, reason) {
//     if (!closeOnClickAway && reason === 'clickaway') {
//       return;
//     }
//     closeHandler();
//   };
//   return /*#__PURE__*/React__default.createElement(MuiSnackbar, {
//     anchorOrigin: anchor,
//     open: open,
//     autoHideDuration: autoHideDuration,
//     onClose: handleClose,
//     message: message,
//     action: /*#__PURE__*/React__default.createElement(IconButton, {
//       label: "Close",
//       size: "small",
//       color: "inherit",
//       onClick: handleClose
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Close"
//     }))
//   }, children);
// }

// // PropType check
// Snackbar.propTypes = {
//   /**
//    * open snackbar
//    */
//   open: PropTypes__default.bool,
//   /**
//    * alter the open state in this handler to hide the Snackbar.
//    * (This handler is required for the snackbar to work as expected)
//    */
//   closeHandler: PropTypes__default.func,
//   /**
//    * duration after which autohide occurs,
//    * when passed null, snackbar won't hide
//    */
//   autoHideDuration: PropTypes__default.number,
//   /**
//    * message to be shown in snackbar
//    */
//   message: PropTypes__default.string,
//   /**
//    * vertical align of snackbar (top/bottom)
//    */
//   verticalAlign: PropTypes__default.oneOf(['top', 'bottom']),
//   /**
//    * horizontal align of snackbar (right/left)
//    */
//   horizontalAlign: PropTypes__default.oneOf(['right', 'left', 'center']),
//   /**
//    * closes the snackbar on clickaway
//    */
//   closeOnClickAway: PropTypes__default.bool,
//   /**
//    * children to which badge is attached
//    */
//   children: PropTypes__default.node
// };
// Snackbar.defaultProps = {
//   open: false,
//   closeHandler: undefined,
//   autoHideDuration: null,
//   message: '',
//   verticalAlign: 'top',
//   horizontalAlign: 'center',
//   closeOnClickAway: false,
//   children: null
// };

// /**
//  * Floating Alert component is used to display notifications.
//  * It can be closed using close icon.
//  * This component also support autohiding.
//  */
// function FloatingAlert(_ref) {
//   var open = _ref.open,
//     closeHandler = _ref.closeHandler,
//     autoHideDuration = _ref.autoHideDuration,
//     verticalAlign = _ref.verticalAlign,
//     horizontalAlign = _ref.horizontalAlign,
//     closeOnClickAway = _ref.closeOnClickAway,
//     severity = _ref.severity,
//     variant = _ref.variant,
//     message = _ref.message,
//     closeText = _ref.closeText;
//   var closeLable;
//   if (!closeText) {
//     closeLable = "close ".concat(severity, " notification");
//   } else {
//     closeLable = closeText;
//   }
//   return /*#__PURE__*/React__default.createElement(Snackbar, {
//     open: open,
//     autoHideDuration: autoHideDuration,
//     verticalAlign: verticalAlign,
//     horizontalAlign: horizontalAlign,
//     closeOnClickAway: closeOnClickAway,
//     closeHandler: closeHandler
//   }, /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(BaseAlert, {
//     severity: severity,
//     variant: variant,
//     elevation: 6,
//     closeText: closeLable,
//     onClose: closeHandler
//   }, message)));
// }

// // PropType check
// FloatingAlert.propTypes = {
//   /**
//    * The severity of the alert.
//    */
//   severity: PropTypes__default.oneOf(['error', 'info', 'success', 'warning']),
//   /**
//    *The variant to use.
//    */

//   variant: PropTypes__default.oneOf(['filled', 'outlined', 'standard']),
//   /**
//    * The content of the component.
//    */
//   message: PropTypes__default.node,
//   /**
//    * open snackbar
//    */
//   open: PropTypes__default.bool,
//   /**
//    * alter the open state in this handler to hide the Notification
//    */
//   closeHandler: PropTypes__default.func,
//   /**
//    * duration after which autohide occurs,
//    * when passed null, snackbar won't hide
//    */
//   autoHideDuration: PropTypes__default.number,
//   /**
//    * vertical align of snackbar (top/bottom)
//    */
//   verticalAlign: PropTypes__default.oneOf(['top', 'bottom']),
//   /**
//    * horizontal align of snackbar (right/left)
//    */
//   horizontalAlign: PropTypes__default.oneOf(['right', 'left', 'center']),
//   /**
//    * closes the snackbar on clickaway
//    */
//   closeOnClickAway: PropTypes__default.bool,
//   /**
//    * Override the default label for the close icon button
//    */
//   closeText: PropTypes__default.string
// };
// FloatingAlert.defaultProps = {
//   severity: 'success',
//   variant: 'outlined',
//   message: '',
//   open: false,
//   closeHandler: undefined,
//   autoHideDuration: null,
//   verticalAlign: 'top',
//   horizontalAlign: 'center',
//   closeOnClickAway: false,
//   closeText: undefined
// };

// /**
//  * SumTotal wrapper for Material-UI Floating Action Button(FAB) component
//  *
//  */
// function SumtFabWrapper(_ref) {
//   var idProp = _ref.id,
//     children = _ref.children,
//     label = _ref.label,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     onClick = _ref.onClick,
//     ariaLabel = _ref.ariaLabel;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(MuiFab, {
//     id: id,
//     color: "primary",
//     variant: "circular",
//     className: className,
//     disabled: disabled,
//     onClick: onClick,
//     "aria-label": ariaLabel
//   }, children, label);
// }
// SumtFabWrapper.propTypes = {
//   /**
//    * Id of the button
//    */
//   id: PropTypes__default.string,
//   /**
//    * aria-label of the IconButton
//    */
//   label: PropTypes__default.string,
//   /**
//    * Text on the button
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * disabled
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * aria-label on the button if label is not available
//    */
//   ariaLabel: PropTypes__default.string
// };
// SumtFabWrapper.defaultProps = {
//   id: undefined,
//   label: undefined,
//   className: '',
//   disabled: false,
//   onClick: undefined,
//   ariaLabel: undefined
// };

// var _templateObject$L, _templateObject2$w;
// var StyledFab = styled(SumtFabWrapper)(_templateObject$L || (_templateObject$L = _taggedTemplateLiteral$1(["\n  &.labelled-fab {\n    margin-top: 1.67rem;\n  }\n"])));
// var ButtonLabel = styled.span(_templateObject2$w || (_templateObject2$w = _taggedTemplateLiteral$1(["\n  position: absolute;\n  top: -1.67rem;\n  white-space: nowrap;\n  font-size: 0.875rem;\n  .MuiFab-primary & {\n    color: ", ";\n  }\n  .MuiFab-root.Mui-disabled & {\n    color: rgba(0, 0, 0, 0.26);\n  }\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return theme.variables.btnPrimaryBg;
// });

// /**
//  * A floating button is a circular icon button that hovers over content to promote a primary action in the application.
//  */
// function FloatingButton(_ref) {
//   var idProp = _ref.id,
//     children = _ref.children,
//     label = _ref.label,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     onClick = _ref.onClick,
//     ariaLabel = _ref.ariaLabel;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(StyledFab, {
//     id: id,
//     color: "primary",
//     variant: "round",
//     className: "".concat(className, " ").concat(label ? 'labelled-fab' : ''),
//     disabled: disabled,
//     onClick: onClick,
//     ariaLabel: label || ariaLabel || ''
//   }, children, label && /*#__PURE__*/React__default.createElement(ButtonLabel, null, label));
// }
// FloatingButton.propTypes = {
//   /**
//    * Id of the button
//    */
//   id: PropTypes__default.string,
//   /**
//    * aria-label of the IconButton
//    */
//   label: PropTypes__default.string,
//   /**
//    * Text on the button
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * disabled
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * aria-label on button
//    */
//   ariaLabel: PropTypes__default.string
// };
// FloatingButton.defaultProps = {
//   id: undefined,
//   label: undefined,
//   className: '',
//   disabled: false,
//   onClick: undefined,
//   ariaLabel: undefined
// };

// function FormControl(_ref) {
//   var required = _ref.required,
//     component = _ref.component,
//     variant = _ref.variant,
//     children = _ref.children,
//     error = _ref.error,
//     disabled = _ref.disabled,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiFormControl, {
//     required: required,
//     component: component,
//     variant: variant,
//     disabled: disabled,
//     error: error,
//     className: className
//   }, children);
// }
// FormControl.propTypes = {
//   /**
//    * The contents of the form control.
//    */
//   children: PropTypes__default.node,
//   /**
//    * The component used for the root node. Either a string to use a HTML element or a component.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * If `true`, the label will indicate that the input is required.
//    */
//   required: PropTypes__default.bool,
//   /**
//    * The variant to use.
//    */
//   variant: PropTypes__default.oneOf(['filled', 'outlined', 'standard']),
//   /**
//    * If `true`, the label, input and helper text will be displayed in a disabled state.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * If `true`, the label will be displayed in an error state.
//    */
//   error: PropTypes__default.bool,
//   /**
//    * Class name.
//    */
//   className: PropTypes__default.string
// };
// FormControl.defaultProps = {
//   required: false,
//   component: 'fieldset',
//   variant: 'outlined',
//   children: undefined,
//   error: false,
//   disabled: false,
//   className: ''
// };

// /**
//  * FormGroup wraps Atoms (Checkbox and Switch) and Molecules (CheckboxWithLabel and SwitchWithLabel).
//  * For the Radio, you should be using the RadioGroup component instead of this one
//  */
// var FormGroup = function FormGroup(_ref) {
//   var children = _ref.children,
//     label = _ref.label,
//     className = _ref.className,
//     disabled = _ref.disabled;
//   return /*#__PURE__*/React__default.createElement(FormControl, {
//     className: className,
//     disabled: disabled
//   }, label && /*#__PURE__*/React__default.createElement(FormLabel, null, label), children);
// };
// FormGroup.propTypes = {
//   /**
//    * The content of the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * Form Group Label.
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * disables all the controls in the group
//    */
//   disabled: PropTypes__default.bool
// };
// FormGroup.defaultProps = {
//   children: undefined,
//   className: undefined,
//   disabled: undefined
// };

// var GridContext = /*#__PURE__*/createContext();

// var useGridContext = function useGridContext() {
//   var context = useContext(GridContext);
//   if (!context) {
//     throw new Error('useGridContext must be used within GridContextProvider!');
//   }
//   return context;
// };

// var _templateObject$K;
// var StyledContainer = styled.div(_templateObject$K || (_templateObject$K = _taggedTemplateLiteral$1(["\n  .grid-stack-item.grid-stack-placeholder {\n    cursor: move;\n  }\n  .grid-stack-item > .ui-resizable-se {\n    width: 1.788rem !important;\n    height: 1.788rem !important;\n    right: 0.813rem !important;\n    bottom: 0.813rem !important;\n    transform: rotate(0deg) !important;\n    background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzBweCIgaGVpZ2h0PSIzMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHZlcnNpb249IjEuMSI+CjxnIGlkPSJzdXJmYWNlMSI+CjxwYXRoIHN0eWxlPSJmaWxsLXJ1bGU6bm9uemVybztmaWxsOnJnYigwJSwwJSwwJSk7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlLXdpZHRoOjAuMDAwMjQ7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlOnJnYigwJSwwJSwwJSk7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtbWl0ZXJsaW1pdDo0OyIgZD0iTSAyMi4zNTMxMjUgOS4zNTMxMjUgTCAyMS42NDY4NzUgOC42NDY4NzUgTCA4LjY0Njg3NSAyMS42NDY4NzUgTCA5LjM1MzEyNSAyMi4zNTMxMjUgWiBNIDIyLjM1MzEyNSAxNi4zNTMxMjUgTCAyMS42NDY4NzUgMTUuNjQ2ODc1IEwgMTUuNjQ2ODc1IDIxLjY0Njg3NSBMIDE2LjM1MzEyNSAyMi4zNTMxMjUgWiBNIDIyLjM1MzEyNSAxNi4zNTMxMjUgIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjI1LDAsMCwxLjI1LDAsMCkiLz4KPHBhdGggc3R5bGU9ImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MC4wMDAyNDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2U6cmdiKDAlLDAlLDAlKTtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS1taXRlcmxpbWl0OjQ7IiBkPSJNIDAgMCBMIDI0IDAgTCAyNCAyNCBMIDAgMjQgWiBNIDAgMCAiIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLDEuMjUsMCwwKSIvPgo8L2c+Cjwvc3ZnPgo=) !important;\n    mask-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzBweCIgaGVpZ2h0PSIzMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHZlcnNpb249IjEuMSI+CjxnIGlkPSJzdXJmYWNlMSI+CjxwYXRoIHN0eWxlPSJmaWxsLXJ1bGU6bm9uemVybztmaWxsOnJnYigwJSwwJSwwJSk7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlLXdpZHRoOjAuMDAwMjQ7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlOnJnYigwJSwwJSwwJSk7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtbWl0ZXJsaW1pdDo0OyIgZD0iTSAyMi4zNTMxMjUgOS4zNTMxMjUgTCAyMS42NDY4NzUgOC42NDY4NzUgTCA4LjY0Njg3NSAyMS42NDY4NzUgTCA5LjM1MzEyNSAyMi4zNTMxMjUgWiBNIDIyLjM1MzEyNSAxNi4zNTMxMjUgTCAyMS42NDY4NzUgMTUuNjQ2ODc1IEwgMTUuNjQ2ODc1IDIxLjY0Njg3NSBMIDE2LjM1MzEyNSAyMi4zNTMxMjUgWiBNIDIyLjM1MzEyNSAxNi4zNTMxMjUgIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjI1LDAsMCwxLjI1LDAsMCkiLz4KPHBhdGggc3R5bGU9ImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MC4wMDAyNDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2U6cmdiKDAlLDAlLDAlKTtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS1taXRlcmxpbWl0OjQ7IiBkPSJNIDAgMCBMIDI0IDAgTCAyNCAyNCBMIDAgMjQgWiBNIDAgMCAiIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLDEuMjUsMCwwKSIvPgo8L2c+Cjwvc3ZnPgo=) !important;\n    -webkit-mask-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzBweCIgaGVpZ2h0PSIzMHB4IiB2aWV3Qm94PSIwIDAgMzAgMzAiIHZlcnNpb249IjEuMSI+CjxnIGlkPSJzdXJmYWNlMSI+CjxwYXRoIHN0eWxlPSJmaWxsLXJ1bGU6bm9uemVybztmaWxsOnJnYigwJSwwJSwwJSk7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlLXdpZHRoOjAuMDAwMjQ7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlOnJnYigwJSwwJSwwJSk7c3Ryb2tlLW9wYWNpdHk6MTtzdHJva2UtbWl0ZXJsaW1pdDo0OyIgZD0iTSAyMi4zNTMxMjUgOS4zNTMxMjUgTCAyMS42NDY4NzUgOC42NDY4NzUgTCA4LjY0Njg3NSAyMS42NDY4NzUgTCA5LjM1MzEyNSAyMi4zNTMxMjUgWiBNIDIyLjM1MzEyNSAxNi4zNTMxMjUgTCAyMS42NDY4NzUgMTUuNjQ2ODc1IEwgMTUuNjQ2ODc1IDIxLjY0Njg3NSBMIDE2LjM1MzEyNSAyMi4zNTMxMjUgWiBNIDIyLjM1MzEyNSAxNi4zNTMxMjUgIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjI1LDAsMCwxLjI1LDAsMCkiLz4KPHBhdGggc3R5bGU9ImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MC4wMDAyNDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2U6cmdiKDAlLDAlLDAlKTtzdHJva2Utb3BhY2l0eToxO3N0cm9rZS1taXRlcmxpbWl0OjQ7IiBkPSJNIDAgMCBMIDI0IDAgTCAyNCAyNCBMIDAgMjQgWiBNIDAgMCAiIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLDEuMjUsMCwwKSIvPgo8L2c+Cjwvc3ZnPgo=) !important;\n    background-color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.sumtWebpartHeaderText;
// });

// function GridStackContainer(_ref) {
//   var acceptWidgets = _ref.acceptWidgets,
//     disableResize = _ref.disableResize,
//     disableDrag = _ref.disableDrag,
//     resizableHandles = _ref.resizableHandles,
//     isCustomDropItem = _ref.isCustomDropItem,
//     onWidgetDrop = _ref.onWidgetDrop,
//     onWidgetsChange = _ref.onWidgetsChange,
//     onWidgetsResizeStop = _ref.onWidgetsResizeStop,
//     onWidgetsDragStop = _ref.onWidgetsDragStop,
//     children = _ref.children,
//     minRows = _ref.minRows;
//   var gridData = useGridContext();
//   var gridContext = gridData.gridContext;
//   var gridRef = useRef$2();
//   var onWidgetDropHandler = function onWidgetDropHandler(event, previousWidget, newWidget) {
//     var grid = gridRef.current;
//     if (isCustomDropItem) {
//       grid.removeWidget(newWidget.el, true, true);
//       var addedItem = {
//         x: newWidget.x,
//         y: newWidget.y,
//         w: newWidget.w,
//         h: newWidget.h,
//         key: newWidget.id
//       };
//       onWidgetDrop(addedItem);
//     }
//   };
//   var onWidgetsChangeHandler = function onWidgetsChangeHandler(event, modifiedWidgets) {
//     if (!modifiedWidgets) return;
//     onWidgetsChange(modifiedWidgets);
//   };
//   var onWidgetResizeStopHandler = function onWidgetResizeStopHandler(event, resizedWidget) {
//     onWidgetsResizeStop(resizedWidget);
//   };
//   var onWidgetDragStopHandler = function onWidgetDragStopHandler(event, draggedWidget) {
//     onWidgetsDragStop(draggedWidget);
//   };
//   useEffect$2(function () {
//     gridRef.current = gridRef.current || GridStack.init({
//       "float": true,
//       cellHeight: '5rem',
//       minRow: minRows,
//       acceptWidgets: acceptWidgets,
//       resizable: {
//         handles: resizableHandles
//       },
//       disableResize: disableResize,
//       disableDrag: disableDrag,
//       styleInHead: true
//     });
//     GridStack.setupDragIn('.grid-stack-item', {
//       appendTo: 'body',
//       helper: 'clone',
//       handle: '.grid-stack-item-content'
//     });
//     var grid = gridRef.current;
//     grid.on('dropped', onWidgetDropHandler);
//     grid.on('change', onWidgetsChangeHandler);
//     grid.on('resizestop', onWidgetResizeStopHandler);
//     grid.on('dragstop', onWidgetDragStopHandler);
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, []);
//   useEffect$2(function () {
//     if (Object.keys(gridContext.itemRefs).length !== 0) {
//       var grid = gridRef.current;
//       grid.batchUpdate();
//       grid.removeAll(false);
//       gridContext.itemRefs.forEach(function (refItem) {
//         if (refItem.ref.current) {
//           grid.makeWidget(refItem.ref.current);
//         }
//       });
//       grid.commit();
//     }
//   }, [gridContext.itemRefs]);
//   return /*#__PURE__*/React__default.createElement(StyledContainer, {
//     className: "grid-stack"
//   }, children);
// }
// GridStackContainer.propTypes = {
//   /**
//    *  Accept widgets dragged from other grids or from outside
//    */
//   acceptWidgets: PropTypes__default.bool,
//   /**
//    *  disallows resizing of widgets
//    */
//   disableResize: PropTypes__default.bool,
//   /**
//    *  disallows dragging of widgets within the grid
//    */
//   disableDrag: PropTypes__default.bool,
//   /**
//    *  Comma seperated list of resizabl handles. Ex:n,ne,e,se,s,sw,w,nw
//    */
//   resizableHandles: PropTypes__default.string,
//   /** Flag to figure out if custom drop item needs to be shown on dropping an item on to grid.
//    *  If so, dropped item will be removed from Grid and consumer needs to handle rendering the custom item on callback.
//    */
//   isCustomDropItem: PropTypes__default.bool,
//   /**
//    *  Callback method to be called on dropping a new item on to the grid.
//    */
//   onWidgetDrop: PropTypes__default.func,
//   /**
//    *  Callback method to be called on any change in the grid.
//    */
//   onWidgetsChange: PropTypes__default.func,
//   /**
//    *  Callback method to be called on resize stop of widget in the grid.
//    */
//   onWidgetsResizeStop: PropTypes__default.func,
//   /**
//    *  Callback method to be called on drag stop of widget in the grid.
//    */
//   onWidgetsDragStop: PropTypes__default.func,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Minimum number of rows of the droppable area.
//    */
//   minRows: PropTypes__default.number
// };
// GridStackContainer.defaultProps = {
//   disableResize: false,
//   disableDrag: false,
//   acceptWidgets: false,
//   resizableHandles: 'se',
//   isCustomDropItem: false,
//   onWidgetDrop: undefined,
//   onWidgetsChange: undefined,
//   onWidgetsResizeStop: undefined,
//   onWidgetsDragStop: undefined,
//   children: undefined,
//   minRows: 1
// };

// /* eslint-disable react/no-unknown-property */
// function GridStackDraggableContainer(_ref) {
//   var itemKey = _ref.itemKey,
//     height = _ref.height,
//     width = _ref.width,
//     children = _ref.children;
//   useEffect$2(function () {
//     GridStack.setupDragIn('.grid-stack-item', {
//       appendTo: 'body',
//       helper: 'clone',
//       handle: '.grid-stack-item-content'
//     });
//   });
//   return /*#__PURE__*/React__default.createElement("div", {
//     "gs-w": width,
//     "gs-h": height,
//     "gs-id": itemKey,
//     className: "grid-stack-item",
//     id: itemKey,
//     draggable: true
//   }, /*#__PURE__*/React__default.createElement("div", {
//     className: "grid-stack-item-content"
//   }, children));
// }

// // PropType check
// GridStackDraggableContainer.propTypes = {
//   /**
//    * Widget key of the widget.
//    */
//   itemKey: PropTypes__default.string,
//   /**
//    * Height of the widget.
//    */
//   height: PropTypes__default.string,
//   /**
//    * Width of the widget.
//    */
//   width: PropTypes__default.string,
//   /**
//    * Components containing the DnD container.
//    */
//   children: PropTypes__default.node
// };
// GridStackDraggableContainer.defaultProps = {
//   itemKey: undefined,
//   height: '3',
//   width: '2',
//   children: undefined
// };

// function GridStackItem(_ref) {
//   var item = _ref.item,
//     gridElement = _ref.gridElement,
//     className = _ref.className;
//   var gridData = useGridContext();
//   var setGridContext = gridData.setGridContext;
//   var elementRef = useRef$2();
//   useEffect$2(function () {
//     if (elementRef.current !== null) {
//       setGridContext(function (state) {
//         return {
//           itemRefs: [].concat(_toConsumableArray$d(state.itemRefs), [{
//             key: item.key,
//             ref: elementRef
//           }])
//         };
//       });
//     }
//   }, [elementRef, item.key, setGridContext]);
//   return /*#__PURE__*/React__default.createElement("div", {
//     className: "grid-stack-item ui-resizable ".concat(className),
//     key: item.key,
//     ref: elementRef,
//     "gs-id": item.key,
//     "gs-x": item.x,
//     "gs-y": item.y,
//     "gs-w": item.w,
//     "gs-h": item.h,
//     "gs-min-w": item.minW,
//     "gs-min-h": item.minH,
//     "gs-max-w": item.maxW,
//     "gs-max-h": item.maxH
//   }, /*#__PURE__*/React__default.createElement("div", {
//     className: "grid-stack-item-content"
//   }, gridElement));
// }

// // PropType check
// GridStackItem.propTypes = {
//   /**
//    * Grid item data used for layout
//    */
//   item: PropTypes__default.shape({
//     key: PropTypes__default.number,
//     x: PropTypes__default.number,
//     y: PropTypes__default.number,
//     w: PropTypes__default.number,
//     h: PropTypes__default.number,
//     minW: PropTypes__default.number,
//     minH: PropTypes__default.number,
//     maxW: PropTypes__default.number,
//     maxH: PropTypes__default.number
//   }),
//   /**
//    * Grid Element to be shown within the grid item
//    */
//   gridElement: PropTypes__default.node,
//   /**
//    * class Name
//    */
//   className: PropTypes__default.string
// };
// GridStackItem.defaultProps = {
//   item: undefined,
//   gridElement: undefined,
//   className: ''
// };

// var _templateObject$J, _templateObject2$v, _templateObject3$l, _templateObject4$a, _templateObject5$6;
// var ActionMenuItem = styled(MenuItem)(_templateObject$J || (_templateObject$J = _taggedTemplateLiteral$1(["\n  margin: 0rem;\n  padding: 0rem;\n  &:focus {\n    background-color: ", ";\n  }\n  &:active {\n    background-color: ", ";\n  &:hover {\n    background-color: ", ";\n  }\n"])), function (props) {
//   return curriedLighten$1(0.65, props.theme.variables.textColor);
// }, function (props) {
//   return curriedLighten$1(0.65, props.theme.variables.textColor);
// }, function (props) {
//   return curriedLighten$1(0.75, props.theme.variables.textColor);
// });
// var StyledMenuList$1 = styled(MenuList)(_templateObject2$v || (_templateObject2$v = _taggedTemplateLiteral$1(["\n  padding-top: 0;\n  padding-bottom: 0;\n  &:focus {\n    outline: none;\n  }\n  & .MuiListItemIcon-root {\n    min-width: 1.75rem;\n  }\n  & .MuiListItemText-root {\n    margin-top: 0.375rem;\n    margin-bottom: 0.375rem;\n  }\n"])));
// var StyledButton$4 = styled(SumtButtonWrapper)(_templateObject3$l || (_templateObject3$l = _taggedTemplateLiteral$1(["\n  padding: 0.375rem 0.75rem;\n  text-transform: capitalize;\n  font-weight: 400;\n  font-size: 0.75rem;\n  border: none;\n  box-shadow: none;\n  width: 100%;\n  text-align: left;\n  &:focus {\n    border: none;\n    box-shadow: none;\n    border-radius: inherit;\n  }\n  &:active {\n    border: none;\n    box-shadow: none;\n    border-radius: inherit;\n  }\n  &:hover {\n    border-radius: inherit;\n  }\n"])));
// var ActionListItemIcon = styled(ListItemIcon)(_templateObject4$a || (_templateObject4$a = _taggedTemplateLiteral$1(["\n  min-width: auto;\n  padding-right: 0.5rem;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var StyledListItemText$1 = styled(ListItemText)(_templateObject5$6 || (_templateObject5$6 = _taggedTemplateLiteral$1(["\n  word-break: break-all;\n"])));

// /**
//  * The component is for to render actions menu list with check icon toggle feature.
//  */
// function IconActionList(_ref) {
//   var actionItemList = _ref.actionItemList,
//     onItemClick = _ref.onItemClick,
//     className = _ref.className,
//     selectedAction = _ref.selectedAction;
//   var selectedIndex = actionItemList.findIndex(function (x) {
//     return x.key === selectedAction;
//   });
//   var _useState = useState$1(selectedIndex),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     iconVisible = _useState2[0],
//     setIconVisible = _useState2[1];
//   var toggleCheck = function toggleCheck(index, item) {
//     setIconVisible(iconVisible === index ? -1 : index);
//     onItemClick(item);
//   };
//   return /*#__PURE__*/React__default.createElement(StyledMenuList$1, {
//     tabIndex: 0,
//     autoFocusItem: true,
//     className: className
//   }, actionItemList.map(function (item, index) {
//     return /*#__PURE__*/React__default.createElement(ActionMenuItem, {
//       key: item.key,
//       onClick: function onClick() {
//         return toggleCheck(index, item);
//       },
//       "aria-label": item.ariaLabel,
//       tabIndex: index === 0 ? 0 : -1
//     }, /*#__PURE__*/React__default.createElement(StyledButton$4, {
//       disableFocusRipple: true,
//       tabIndex: -1
//     }, /*#__PURE__*/React__default.createElement("div", {
//       style: {
//         visibility: iconVisible === index ? 'visible' : 'hidden'
//       }
//     }, /*#__PURE__*/React__default.createElement(ActionListItemIcon, null, /*#__PURE__*/React__default.createElement(Icon, {
//       iconName: item.iconName,
//       iconType: item.iconType,
//       size: 1.25
//     }))), /*#__PURE__*/React__default.createElement(StyledListItemText$1, {
//       primary: item.name
//     })));
//   }));
// }
// IconActionList.propTypes = {
//   /**
//    * List of sort options.
//    */
//   actionItemList: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * Class name.
//    */
//   className: PropTypes__default.string,
//   /**
//    * callback method for action click.
//    */
//   onItemClick: PropTypes__default.func,
//   /**
//    *To set selected action.
//    */
//   selectedAction: PropTypes__default.string
// };
// IconActionList.defaultProps = {
//   actionItemList: [],
//   className: undefined,
//   onItemClick: undefined,
//   selectedAction: undefined
// };

// /**
//  *This component used to render Icon element as table cell content.
//  */
// function IconCell(_ref) {
//   var iconType = _ref.iconType;
//     _ref.iconName;
//     var size = _ref.size,
//     className = _ref.className;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue;
//   return cellValue !== null ? /*#__PURE__*/React__default.createElement(Icon, {
//     iconType: iconType,
//     iconName: cellValue,
//     size: size,
//     className: className
//   }) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null);
// }

// // PropType check
// IconCell.propTypes = {
//   /**
//    * Type of the icon
//    */
//   iconType: PropTypes__default.oneOf(['MaterialIcon', 'IcomoonIcon']),
//   /**
//    * Name of the icon
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * Size of the icon in rem
//    */
//   size: PropTypes__default.number,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// IconCell.defaultProps = {
//   iconType: 'MaterialIcon',
//   iconName: undefined,
//   size: 1.5,
//   className: undefined
// };

// var _templateObject$I, _templateObject2$u;
// var StyledIcon$1 = styled(Icon)(_templateObject$I || (_templateObject$I = _taggedTemplateLiteral$1(["\n  order: ", ";\n  svg.MuiSvgIcon-root {\n    margin: ", ";\n  }\n"])), function (props) {
//   return props.endIcon ? '1' : '0';
// }, function (props) {
//   return props.endIcon ? '0 0 0 0.75rem' : '0 0.75rem 0 0';
// });
// var StyledLabel = styled(Label$8)(_templateObject2$u || (_templateObject2$u = _taggedTemplateLiteral$1(["\n  order: ", ";\n  &.MuiFormControlLabel-root {\n    color: ", "\n"])), function (props) {
//   return props.endIcon ? '0' : '1';
// }, function (props) {
//   if (props.severity === 'link') return props.theme.variables.sumtBtnDefaultColor;
//   if (props.severity === 'default') return props.theme.variables.textColor;
//   return props.severity === 'error' ? props.theme.variables.brandDanger : props.theme.variables["brand".concat(props.severity.charAt(0).toUpperCase()).concat(props.severity.slice(1))];
// });

// /**
//  * The componet will be used to show icon and label based on severity. Default will
//  * be black color (textColor of theme).
//  */
// function IconWithLabel(_ref) {
//   var label = _ref.label,
//     iconName = _ref.iconName,
//     size = _ref.size,
//     endIcon = _ref.endIcon,
//     severity = _ref.severity;
//   return /*#__PURE__*/React__default.createElement(StyledLabel, {
//     label: label,
//     endIcon: endIcon,
//     severity: severity
//   }, /*#__PURE__*/React__default.createElement(StyledIcon$1, {
//     iconName: iconName,
//     size: size,
//     endIcon: endIcon
//   }));
// }
// IconWithLabel.propTypes = {
//   /**
//    * Label text to be used for the input field
//    */
//   label: PropTypes__default.node.isRequired,
//   /**
//    * Name of the icon
//    */
//   iconName: PropTypes__default.string.isRequired,
//   /**
//    * Size of the icon in rem
//    */
//   size: PropTypes__default.number,
//   /**
//    * " Severity of icon and label. The 'default' option will render TextColor."
//    */
//   severity: PropTypes__default.oneOf(['default', 'error', 'info', 'success', 'warning', 'link']),
//   /**
//    * If true, icon will be placed at right end
//    */
//   endIcon: PropTypes__default.bool
// };
// IconWithLabel.defaultProps = {
//   size: 1.5,
//   severity: 'default',
//   endIcon: false
// };

// var _templateObject$H;
// var StyledDiv$2 = styled.div(_templateObject$H || (_templateObject$H = _taggedTemplateLiteral$1(["\n  width: 11.25rem;\n  height: 100%;\n  position: relative;\n  display: inline-block;\n  min-height: 7.4375rem;\n\ndiv.border-wrapper {\n  border: 1px solid #EAEAEA;\n  height: inherit;\n  > :first-child {\n    height: inherit;\n    width: 11.125rem;\n  }\n}\n\ndiv.label-wrapper {\n  height: 1rem;\n  width: 11.125rem;\n  color: #fff;\n  background-color: rgba(0, 0, 0, .75);\n  font-weight: bold;\n  position: absolute;\n  bottom: 0.0625rem;\n}\n\nspan.left-span {\n  float: left;\n  width: 60%;\n  padding-left: 0.375rem;\n  text-transform: uppercase;\n}\n\nspan.right-span {\n  float: right;\n  width: 40%;\n  text-align: right;\n  padding-right: 0.375rem;\n}\n"])));

// /**
//  * Component for LabelledImage.
//  */
// function LabelledImage(_ref) {
//   var src = _ref.src,
//     defaultImage = _ref["default"],
//     leftLabel = _ref.leftLabel,
//     rightLabel = _ref.rightLabel;
//   return /*#__PURE__*/React__default.createElement(StyledDiv$2, null, /*#__PURE__*/React__default.createElement("div", {
//     className: "border-wrapper"
//   }, /*#__PURE__*/React__default.createElement(CardImage, {
//     src: src,
//     defaultImage: defaultImage,
//     size: "medium"
//   }), (leftLabel || rightLabel) && /*#__PURE__*/React__default.createElement("div", {
//     className: "body2 label-wrapper"
//   }, leftLabel && /*#__PURE__*/React__default.createElement("span", {
//     className: "left-span"
//   }, leftLabel, " "), rightLabel && /*#__PURE__*/React__default.createElement("span", {
//     className: "right-span"
//   }, rightLabel))));
// }
// LabelledImage.propTypes = {
//   /**
//    * source url of the image
//    */
//   src: PropTypes__default.string.isRequired,
//   /**
//    * default image src if actual `src` has failed to load or invalid
//    */
//   "default": PropTypes__default.string,
//   /**
//    * left label of image.
//    */
//   leftLabel: PropTypes__default.node,
//   /**
//    * right label of image
//    */
//   rightLabel: PropTypes__default.node
// };
// LabelledImage.defaultProps = {
//   "default": undefined,
//   leftLabel: '',
//   rightLabel: ''
// };

// var mathSign = function mathSign(value) {
//   if (value === 0) {
//     return 0;
//   }
//   if (value > 0) {
//     return 1;
//   }
//   return -1;
// };
// var isPercent = function isPercent(value) {
//   return isString(value) && value.indexOf('%') === value.length - 1;
// };
// var isNumber = function isNumber(value) {
//   return lodashIsNumber(value) && !isNan(value);
// };
// var isNumOrStr = function isNumOrStr(value) {
//   return isNumber(value) || isString(value);
// };
// var idCounter = 0;
// var uniqueId = function uniqueId(prefix) {
//   var id = ++idCounter;
//   return "".concat(prefix || '').concat(id);
// };

// /**
//  * Get percent value of a total value
//  * @param {number|string} percent A percent
//  * @param {number} totalValue     Total value
//  * @param {number} defaultValue   The value returned when percent is undefined or invalid
//  * @param {boolean} validate      If set to be true, the result will be validated
//  * @return {number} value
//  */
// var getPercentValue = function getPercentValue(percent, totalValue) {
//   var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
//   var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
//   if (!isNumber(percent) && !isString(percent)) {
//     return defaultValue;
//   }
//   var value;
//   if (isPercent(percent)) {
//     var index = percent.indexOf('%');
//     value = totalValue * parseFloat(percent.slice(0, index)) / 100;
//   } else {
//     value = +percent;
//   }
//   if (isNan(value)) {
//     value = defaultValue;
//   }
//   if (validate && value > totalValue) {
//     value = totalValue;
//   }
//   return value;
// };
// var getAnyElementOfObject = function getAnyElementOfObject(obj) {
//   if (!obj) {
//     return null;
//   }
//   var keys = Object.keys(obj);
//   if (keys && keys.length) {
//     return obj[keys[0]];
//   }
//   return null;
// };
// var hasDuplicate = function hasDuplicate(ary) {
//   if (!Array.isArray(ary)) {
//     return false;
//   }
//   var len = ary.length;
//   var cache = {};
//   for (var i = 0; i < len; i++) {
//     if (!cache[ary[i]]) {
//       cache[ary[i]] = true;
//     } else {
//       return true;
//     }
//   }
//   return false;
// };

// /* @todo consider to rename this function into `getInterpolator` */
// var interpolateNumber$1 = function interpolateNumber(numberA, numberB) {
//   if (isNumber(numberA) && isNumber(numberB)) {
//     return function (t) {
//       return numberA + t * (numberB - numberA);
//     };
//   }
//   return function () {
//     return numberB;
//   };
// };
// function findEntryInArray(ary, specifiedKey, specifiedValue) {
//   if (!ary || !ary.length) {
//     return null;
//   }
//   return ary.find(function (entry) {
//     return entry && (typeof specifiedKey === 'function' ? specifiedKey(entry) : get(entry, specifiedKey)) === specifiedValue;
//   });
// }

// function shallowEqual(a, b) {
//   /* eslint-disable no-restricted-syntax */
//   for (var key in a) {
//     if ({}.hasOwnProperty.call(a, key) && (!{}.hasOwnProperty.call(b, key) || a[key] !== b[key])) {
//       return false;
//     }
//   }
//   for (var _key in b) {
//     if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a, _key)) {
//       return false;
//     }
//   }
//   return true;
// }

// function _typeof$E(o) { "@babel/helpers - typeof"; return _typeof$E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$E(o); }

// /**
//  * Determines how values are stacked:
//  *
//  * - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.
//  * - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.
//  * - `wiggle` and `silhouette` tries to keep the chart centered.
//  * - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.
//  * - `positive` ignores all negative values, and then behaves like \`none\`.
//  *
//  * Also see https://d3js.org/d3-shape/stack#stack-offsets
//  * (note that the `diverging` offset in d3 is named `sign` in recharts)
//  */

// //
// // Event Handler Types -- Copied from @types/react/index.d.ts and adapted for Props.
// //
// var SVGContainerPropKeys = ['viewBox', 'children'];
// var SVGElementPropKeys = ['aria-activedescendant', 'aria-atomic', 'aria-autocomplete', 'aria-busy', 'aria-checked', 'aria-colcount', 'aria-colindex', 'aria-colspan', 'aria-controls', 'aria-current', 'aria-describedby', 'aria-details', 'aria-disabled', 'aria-errormessage', 'aria-expanded', 'aria-flowto', 'aria-haspopup', 'aria-hidden', 'aria-invalid', 'aria-keyshortcuts', 'aria-label', 'aria-labelledby', 'aria-level', 'aria-live', 'aria-modal', 'aria-multiline', 'aria-multiselectable', 'aria-orientation', 'aria-owns', 'aria-placeholder', 'aria-posinset', 'aria-pressed', 'aria-readonly', 'aria-relevant', 'aria-required', 'aria-roledescription', 'aria-rowcount', 'aria-rowindex', 'aria-rowspan', 'aria-selected', 'aria-setsize', 'aria-sort', 'aria-valuemax', 'aria-valuemin', 'aria-valuenow', 'aria-valuetext', 'className', 'color', 'height', 'id', 'lang', 'max', 'media', 'method', 'min', 'name', 'style',
// /*
//  * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
//  * that can use it and it conflicts with the recharts prop 'type'
//  * https://github.com/recharts/recharts/pull/3327
//  * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
//  */
// // 'type',
// 'target', 'width', 'role', 'tabIndex', 'accentHeight', 'accumulate', 'additive', 'alignmentBaseline', 'allowReorder', 'alphabetic', 'amplitude', 'arabicForm', 'ascent', 'attributeName', 'attributeType', 'autoReverse', 'azimuth', 'baseFrequency', 'baselineShift', 'baseProfile', 'bbox', 'begin', 'bias', 'by', 'calcMode', 'capHeight', 'clip', 'clipPath', 'clipPathUnits', 'clipRule', 'colorInterpolation', 'colorInterpolationFilters', 'colorProfile', 'colorRendering', 'contentScriptType', 'contentStyleType', 'cursor', 'cx', 'cy', 'd', 'decelerate', 'descent', 'diffuseConstant', 'direction', 'display', 'divisor', 'dominantBaseline', 'dur', 'dx', 'dy', 'edgeMode', 'elevation', 'enableBackground', 'end', 'exponent', 'externalResourcesRequired', 'fill', 'fillOpacity', 'fillRule', 'filter', 'filterRes', 'filterUnits', 'floodColor', 'floodOpacity', 'focusable', 'fontFamily', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontWeight', 'format', 'from', 'fx', 'fy', 'g1', 'g2', 'glyphName', 'glyphOrientationHorizontal', 'glyphOrientationVertical', 'glyphRef', 'gradientTransform', 'gradientUnits', 'hanging', 'horizAdvX', 'horizOriginX', 'href', 'ideographic', 'imageRendering', 'in2', 'in', 'intercept', 'k1', 'k2', 'k3', 'k4', 'k', 'kernelMatrix', 'kernelUnitLength', 'kerning', 'keyPoints', 'keySplines', 'keyTimes', 'lengthAdjust', 'letterSpacing', 'lightingColor', 'limitingConeAngle', 'local', 'markerEnd', 'markerHeight', 'markerMid', 'markerStart', 'markerUnits', 'markerWidth', 'mask', 'maskContentUnits', 'maskUnits', 'mathematical', 'mode', 'numOctaves', 'offset', 'opacity', 'operator', 'order', 'orient', 'orientation', 'origin', 'overflow', 'overlinePosition', 'overlineThickness', 'paintOrder', 'panose1', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointerEvents', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'r', 'radius', 'refX', 'refY', 'renderingIntent', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'result', 'rotate', 'rx', 'ry', 'seed', 'shapeRendering', 'slope', 'spacing', 'specularConstant', 'specularExponent', 'speed', 'spreadMethod', 'startOffset', 'stdDeviation', 'stemh', 'stemv', 'stitchTiles', 'stopColor', 'stopOpacity', 'strikethroughPosition', 'strikethroughThickness', 'string', 'stroke', 'strokeDasharray', 'strokeDashoffset', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity', 'strokeWidth', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textAnchor', 'textDecoration', 'textLength', 'textRendering', 'to', 'transform', 'u1', 'u2', 'underlinePosition', 'underlineThickness', 'unicode', 'unicodeBidi', 'unicodeRange', 'unitsPerEm', 'vAlphabetic', 'values', 'vectorEffect', 'version', 'vertAdvY', 'vertOriginX', 'vertOriginY', 'vHanging', 'vIdeographic', 'viewTarget', 'visibility', 'vMathematical', 'widths', 'wordSpacing', 'writingMode', 'x1', 'x2', 'x', 'xChannelSelector', 'xHeight', 'xlinkActuate', 'xlinkArcrole', 'xlinkHref', 'xlinkRole', 'xlinkShow', 'xlinkTitle', 'xlinkType', 'xmlBase', 'xmlLang', 'xmlns', 'xmlnsXlink', 'xmlSpace', 'y1', 'y2', 'y', 'yChannelSelector', 'z', 'zoomAndPan', 'ref', 'key', 'angle'];
// var PolyElementKeys = ['points', 'pathLength'];

// /** svg element types that have specific attribute filtration requirements */

// /** map of svg element types to unique svg attributes that belong to that element */
// var FilteredElementKeyMap = {
//   svg: SVGContainerPropKeys,
//   polygon: PolyElementKeys,
//   polyline: PolyElementKeys
// };
// var EventKeys = ['dangerouslySetInnerHTML', 'onCopy', 'onCopyCapture', 'onCut', 'onCutCapture', 'onPaste', 'onPasteCapture', 'onCompositionEnd', 'onCompositionEndCapture', 'onCompositionStart', 'onCompositionStartCapture', 'onCompositionUpdate', 'onCompositionUpdateCapture', 'onFocus', 'onFocusCapture', 'onBlur', 'onBlurCapture', 'onChange', 'onChangeCapture', 'onBeforeInput', 'onBeforeInputCapture', 'onInput', 'onInputCapture', 'onReset', 'onResetCapture', 'onSubmit', 'onSubmitCapture', 'onInvalid', 'onInvalidCapture', 'onLoad', 'onLoadCapture', 'onError', 'onErrorCapture', 'onKeyDown', 'onKeyDownCapture', 'onKeyPress', 'onKeyPressCapture', 'onKeyUp', 'onKeyUpCapture', 'onAbort', 'onAbortCapture', 'onCanPlay', 'onCanPlayCapture', 'onCanPlayThrough', 'onCanPlayThroughCapture', 'onDurationChange', 'onDurationChangeCapture', 'onEmptied', 'onEmptiedCapture', 'onEncrypted', 'onEncryptedCapture', 'onEnded', 'onEndedCapture', 'onLoadedData', 'onLoadedDataCapture', 'onLoadedMetadata', 'onLoadedMetadataCapture', 'onLoadStart', 'onLoadStartCapture', 'onPause', 'onPauseCapture', 'onPlay', 'onPlayCapture', 'onPlaying', 'onPlayingCapture', 'onProgress', 'onProgressCapture', 'onRateChange', 'onRateChangeCapture', 'onSeeked', 'onSeekedCapture', 'onSeeking', 'onSeekingCapture', 'onStalled', 'onStalledCapture', 'onSuspend', 'onSuspendCapture', 'onTimeUpdate', 'onTimeUpdateCapture', 'onVolumeChange', 'onVolumeChangeCapture', 'onWaiting', 'onWaitingCapture', 'onAuxClick', 'onAuxClickCapture', 'onClick', 'onClickCapture', 'onContextMenu', 'onContextMenuCapture', 'onDoubleClick', 'onDoubleClickCapture', 'onDrag', 'onDragCapture', 'onDragEnd', 'onDragEndCapture', 'onDragEnter', 'onDragEnterCapture', 'onDragExit', 'onDragExitCapture', 'onDragLeave', 'onDragLeaveCapture', 'onDragOver', 'onDragOverCapture', 'onDragStart', 'onDragStartCapture', 'onDrop', 'onDropCapture', 'onMouseDown', 'onMouseDownCapture', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseMoveCapture', 'onMouseOut', 'onMouseOutCapture', 'onMouseOver', 'onMouseOverCapture', 'onMouseUp', 'onMouseUpCapture', 'onSelect', 'onSelectCapture', 'onTouchCancel', 'onTouchCancelCapture', 'onTouchEnd', 'onTouchEndCapture', 'onTouchMove', 'onTouchMoveCapture', 'onTouchStart', 'onTouchStartCapture', 'onPointerDown', 'onPointerDownCapture', 'onPointerMove', 'onPointerMoveCapture', 'onPointerUp', 'onPointerUpCapture', 'onPointerCancel', 'onPointerCancelCapture', 'onPointerEnter', 'onPointerEnterCapture', 'onPointerLeave', 'onPointerLeaveCapture', 'onPointerOver', 'onPointerOverCapture', 'onPointerOut', 'onPointerOutCapture', 'onGotPointerCapture', 'onGotPointerCaptureCapture', 'onLostPointerCapture', 'onLostPointerCaptureCapture', 'onScroll', 'onScrollCapture', 'onWheel', 'onWheelCapture', 'onAnimationStart', 'onAnimationStartCapture', 'onAnimationEnd', 'onAnimationEndCapture', 'onAnimationIteration', 'onAnimationIterationCapture', 'onTransitionEnd', 'onTransitionEndCapture'];

// /** The type of easing function to use for animations */

// /** Specifies the duration of animation, the unit of this option is ms. */

// /** the offset of a chart, which define the blank space all around */

// /**
//  * The domain of axis.
//  * This is the definition
//  *
//  * Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.
//  * Categorical domain is defined as array of all possible values.
//  *
//  * Can be specified in many ways:
//  * - array of numbers
//  * - with special strings like 'dataMin' and 'dataMax'
//  * - with special string math like 'dataMin - 100'
//  * - with keyword 'auto'
//  * - or a function
//  * - array of functions
//  * - or a combination of the above
//  */

// /**
//  * NumberDomain is an evaluated {@link AxisDomain}.
//  * Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.
//  * This is after all the keywords and functions were evaluated and what is left is [min, max].
//  *
//  * Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.
//  *
//  * There are also `category` axes that have different things than numbers in their domain.
//  */

// /** The props definition of base axis */

// /** Defines how ticks are placed and whether / how tick collisions are handled.
//  * 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.
//  * 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.
//  * 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks are always shown.
//  * 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.
//  */

// var adaptEventHandlers = function adaptEventHandlers(props, newHandler) {
//   if (!props || typeof props === 'function' || typeof props === 'boolean') {
//     return null;
//   }
//   var inputProps = props;
//   if ( /*#__PURE__*/isValidElement(props)) {
//     inputProps = props.props;
//   }
//   if (!isObject(inputProps)) {
//     return null;
//   }
//   var out = {};
//   Object.keys(inputProps).forEach(function (key) {
//     if (EventKeys.includes(key)) {
//       out[key] = newHandler || function (e) {
//         return inputProps[key](inputProps, e);
//       };
//     }
//   });
//   return out;
// };
// var getEventHandlerOfChild = function getEventHandlerOfChild(originalHandler, data, index) {
//   return function (e) {
//     originalHandler(data, index, e);
//     return null;
//   };
// };
// var adaptEventsOfChild = function adaptEventsOfChild(props, data, index) {
//   if (!isObject(props) || _typeof$E(props) !== 'object') {
//     return null;
//   }
//   var out = null;
//   Object.keys(props).forEach(function (key) {
//     var item = props[key];
//     if (EventKeys.includes(key) && typeof item === 'function') {
//       if (!out) out = {};
//       out[key] = getEventHandlerOfChild(item, data, index);
//     }
//   });
//   return out;
// };

// var _excluded$i = ["children"],
//   _excluded2$5 = ["children"];
// function _objectWithoutProperties$h(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$h(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$h(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function _typeof$D(o) { "@babel/helpers - typeof"; return _typeof$D = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$D(o); }
// var REACT_BROWSER_EVENT_MAP = {
//   click: 'onClick',
//   mousedown: 'onMouseDown',
//   mouseup: 'onMouseUp',
//   mouseover: 'onMouseOver',
//   mousemove: 'onMouseMove',
//   mouseout: 'onMouseOut',
//   mouseenter: 'onMouseEnter',
//   mouseleave: 'onMouseLeave',
//   touchcancel: 'onTouchCancel',
//   touchend: 'onTouchEnd',
//   touchmove: 'onTouchMove',
//   touchstart: 'onTouchStart'
// };

// /**
//  * Get the display name of a component
//  * @param  {Object} Comp Specified Component
//  * @return {String}      Display name of Component
//  */
// var getDisplayName = function getDisplayName(Comp) {
//   if (typeof Comp === 'string') {
//     return Comp;
//   }
//   if (!Comp) {
//     return '';
//   }
//   return Comp.displayName || Comp.name || 'Component';
// };

// // `toArray` gets called multiple times during the render
// // so we can memoize last invocation (since reference to `children` is the same)
// var lastChildren = null;
// var lastResult = null;
// var toArray = function toArray(children) {
//   if (children === lastChildren && Array.isArray(lastResult)) {
//     return lastResult;
//   }
//   var result = [];
//   Children.forEach(children, function (child) {
//     if (isNil$1(child)) return;
//     if (isFragment(child)) {
//       result = result.concat(toArray(child.props.children));
//     } else {
//       result.push(child);
//     }
//   });
//   lastResult = result;
//   lastChildren = children;
//   return result;
// };

// /*
//  * Find and return all matched children by type.
//  * `type` must be a React.ComponentType
//  */
// function findAllByType(children, type) {
//   var result = [];
//   var types = [];
//   if (Array.isArray(type)) {
//     types = type.map(function (t) {
//       return getDisplayName(t);
//     });
//   } else {
//     types = [getDisplayName(type)];
//   }
//   toArray(children).forEach(function (child) {
//     var childType = get(child, 'type.displayName') || get(child, 'type.name');
//     if (types.indexOf(childType) !== -1) {
//       result.push(child);
//     }
//   });
//   return result;
// }

// /*
//  * Return the first matched child by type, return null otherwise.
//  * `type` must be a React.ComponentType
//  */
// function findChildByType(children, type) {
//   var result = findAllByType(children, type);
//   return result && result[0];
// }

// /**
//  * validate the width and height props of a chart element
//  * @param  {Object} el A chart element
//  * @return {Boolean}   true If the props width and height are number, and greater than 0
//  */
// var validateWidthHeight = function validateWidthHeight(el) {
//   if (!el || !el.props) {
//     return false;
//   }
//   var _el$props = el.props,
//     width = _el$props.width,
//     height = _el$props.height;
//   if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0) {
//     return false;
//   }
//   return true;
// };
// var SVG_TAGS = ['a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColormatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-url', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'lineGradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script', 'set', 'stop', 'style', 'svg', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'];
// var isSvgElement = function isSvgElement(child) {
//   return child && child.type && isString(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
// };
// var isDotProps = function isDotProps(dot) {
//   return dot && _typeof$D(dot) === 'object' && 'cx' in dot && 'cy' in dot && 'r' in dot;
// };

// /**
//  * Checks if the property is valid to spread onto an SVG element or onto a specific component
//  * @param {unknown} property property value currently being compared
//  * @param {string} key property key currently being compared
//  * @param {boolean} includeEvents if events are included in spreadable props
//  * @param {boolean} svgElementType checks against map of SVG element types to attributes
//  * @returns {boolean} is prop valid
//  */
// var isValidSpreadableProp = function isValidSpreadableProp(property, key, includeEvents, svgElementType) {
//   var _FilteredElementKeyMa;
//   /**
//    * If the svg element type is explicitly included, check against the filtered element key map
//    * to determine if there are attributes that should only exist on that element type.
//    * @todo Add an internal cjs version of https://github.com/wooorm/svg-element-attributes for full coverage.
//    */
//   var matchingElementTypeKeys = (_FilteredElementKeyMa = FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];
//   return !isFunction(property) && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);
// };
// var filterProps = function filterProps(props, includeEvents, svgElementType) {
//   if (!props || typeof props === 'function' || typeof props === 'boolean') {
//     return null;
//   }
//   var inputProps = props;
//   if ( /*#__PURE__*/isValidElement(props)) {
//     inputProps = props.props;
//   }
//   if (!isObject(inputProps)) {
//     return null;
//   }
//   var out = {};

//   /**
//    * Props are blindly spread onto SVG elements. This loop filters out properties that we don't want to spread.
//    * Items filtered out are as follows:
//    *   - functions in properties that are SVG attributes (functions are included when includeEvents is true)
//    *   - props that are SVG attributes but don't matched the passed svgElementType
//    *   - any prop that is not in SVGElementPropKeys (or in EventKeys if includeEvents is true)
//    */
//   Object.keys(inputProps).forEach(function (key) {
//     var _inputProps;
//     if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {
//       out[key] = inputProps[key];
//     }
//   });
//   return out;
// };

// /**
//  * Wether props of children changed
//  * @param  {Object} nextChildren The latest children
//  * @param  {Object} prevChildren The prev children
//  * @return {Boolean}             equal or not
//  */
// var isChildrenEqual = function isChildrenEqual(nextChildren, prevChildren) {
//   if (nextChildren === prevChildren) {
//     return true;
//   }
//   var count = Children.count(nextChildren);
//   if (count !== Children.count(prevChildren)) {
//     return false;
//   }
//   if (count === 0) {
//     return true;
//   }
//   if (count === 1) {
//     // eslint-disable-next-line @typescript-eslint/no-use-before-define
//     return isSingleChildEqual(Array.isArray(nextChildren) ? nextChildren[0] : nextChildren, Array.isArray(prevChildren) ? prevChildren[0] : prevChildren);
//   }
//   for (var i = 0; i < count; i++) {
//     var nextChild = nextChildren[i];
//     var prevChild = prevChildren[i];
//     if (Array.isArray(nextChild) || Array.isArray(prevChild)) {
//       if (!isChildrenEqual(nextChild, prevChild)) {
//         return false;
//       }
//       // eslint-disable-next-line @typescript-eslint/no-use-before-define
//     } else if (!isSingleChildEqual(nextChild, prevChild)) {
//       return false;
//     }
//   }
//   return true;
// };
// var isSingleChildEqual = function isSingleChildEqual(nextChild, prevChild) {
//   if (isNil$1(nextChild) && isNil$1(prevChild)) {
//     return true;
//   }
//   if (!isNil$1(nextChild) && !isNil$1(prevChild)) {
//     var _ref = nextChild.props || {},
//       nextChildren = _ref.children,
//       nextProps = _objectWithoutProperties$h(_ref, _excluded$i);
//     var _ref2 = prevChild.props || {},
//       prevChildren = _ref2.children,
//       prevProps = _objectWithoutProperties$h(_ref2, _excluded2$5);
//     if (nextChildren && prevChildren) {
//       return shallowEqual(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);
//     }
//     if (!nextChildren && !prevChildren) {
//       return shallowEqual(nextProps, prevProps);
//     }
//     return false;
//   }
//   return false;
// };
// var renderByOrder = function renderByOrder(children, renderMap) {
//   var elements = [];
//   var record = {};
//   toArray(children).forEach(function (child, index) {
//     if (isSvgElement(child)) {
//       elements.push(child);
//     } else if (child) {
//       var displayName = getDisplayName(child.type);
//       var _ref3 = renderMap[displayName] || {},
//         handler = _ref3.handler,
//         once = _ref3.once;
//       if (handler && (!once || !record[displayName])) {
//         var results = handler(child, displayName, index);
//         elements.push(results);
//         record[displayName] = true;
//       }
//     }
//   });
//   return elements;
// };
// var getReactEventByType = function getReactEventByType(e) {
//   var type = e && e.type;
//   if (type && REACT_BROWSER_EVENT_MAP[type]) {
//     return REACT_BROWSER_EVENT_MAP[type];
//   }
//   return null;
// };
// var parseChildIndex = function parseChildIndex(child, children) {
//   return toArray(children).indexOf(child);
// };

// var _excluded$h = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
// function _extends$n() { _extends$n = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$n.apply(this, arguments); }
// function _objectWithoutProperties$g(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$g(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$g(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function Surface(props) {
//   var children = props.children,
//     width = props.width,
//     height = props.height,
//     viewBox = props.viewBox,
//     className = props.className,
//     style = props.style,
//     title = props.title,
//     desc = props.desc,
//     others = _objectWithoutProperties$g(props, _excluded$h);
//   var svgView = viewBox || {
//     width: width,
//     height: height,
//     x: 0,
//     y: 0
//   };
//   var layerClass = clsx('recharts-surface', className);
//   return /*#__PURE__*/React__default.createElement("svg", _extends$n({}, filterProps(others, true, 'svg'), {
//     className: layerClass,
//     width: width,
//     height: height,
//     style: style,
//     viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height)
//   }), /*#__PURE__*/React__default.createElement("title", null, title), /*#__PURE__*/React__default.createElement("desc", null, desc), children);
// }

// var _excluded$g = ["children", "className"];
// function _extends$m() { _extends$m = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$m.apply(this, arguments); }
// function _objectWithoutProperties$f(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$f(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$f(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// var Layer = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
//   var children = props.children,
//     className = props.className,
//     others = _objectWithoutProperties$f(props, _excluded$g);
//   var layerClass = clsx('recharts-layer', className);
//   return /*#__PURE__*/React__default.createElement("g", _extends$m({
//     className: layerClass
//   }, filterProps(others, true), {
//     ref: ref
//   }), children);
// });

// /* eslint no-console: 0 */
// var isDev$1 = process.env.NODE_ENV !== 'production';
// var warn$1 = function warn(condition, format) {
//   for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
//     args[_key - 2] = arguments[_key];
//   }
//   if (isDev$1 && typeof console !== 'undefined' && console.warn) {
//     if (format === undefined) {
//       console.warn('LogUtils requires an error message argument');
//     }
//     if (!condition) {
//       if (format === undefined) {
//         console.warn('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
//       } else {
//         var argIndex = 0;
//         console.warn(format.replace(/%s/g, function () {
//           return args[argIndex++];
//         }));
//       }
//     }
//   }
// };

// function _typeof$C(o) { "@babel/helpers - typeof"; return _typeof$C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$C(o); }
// var _excluded$f = ["type", "size", "sizeType"];
// function _extends$l() { _extends$l = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$l.apply(this, arguments); }
// function ownKeys$x(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$x(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$x(Object(t), !0).forEach(function (r) { _defineProperty$z(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$x(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$z(obj, key, value) { key = _toPropertyKey$A(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$A(arg) { var key = _toPrimitive$A(arg, "string"); return _typeof$C(key) === "symbol" ? key : String(key); }
// function _toPrimitive$A(input, hint) { if (_typeof$C(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$C(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _objectWithoutProperties$e(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$e(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$e(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// var symbolFactories = {
//   symbolCircle: symbolCircle,
//   symbolCross: symbolCross,
//   symbolDiamond: symbolDiamond,
//   symbolSquare: symbolSquare,
//   symbolStar: symbolStar,
//   symbolTriangle: symbolTriangle,
//   symbolWye: symbolWye
// };
// var RADIAN$1 = Math.PI / 180;
// var getSymbolFactory = function getSymbolFactory(type) {
//   var name = "symbol".concat(upperFirst(type));
//   return symbolFactories[name] || symbolCircle;
// };
// var calculateAreaSize = function calculateAreaSize(size, sizeType, type) {
//   if (sizeType === 'area') {
//     return size;
//   }
//   switch (type) {
//     case 'cross':
//       return 5 * size * size / 9;
//     case 'diamond':
//       return 0.5 * size * size / Math.sqrt(3);
//     case 'square':
//       return size * size;
//     case 'star':
//       {
//         var angle = 18 * RADIAN$1;
//         return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));
//       }
//     case 'triangle':
//       return Math.sqrt(3) * size * size / 4;
//     case 'wye':
//       return (21 - 10 * Math.sqrt(3)) * size * size / 8;
//     default:
//       return Math.PI * size * size / 4;
//   }
// };
// var registerSymbol = function registerSymbol(key, factory) {
//   symbolFactories["symbol".concat(upperFirst(key))] = factory;
// };
// var Symbols = function Symbols(_ref) {
//   var _ref$type = _ref.type,
//     type = _ref$type === void 0 ? 'circle' : _ref$type,
//     _ref$size = _ref.size,
//     size = _ref$size === void 0 ? 64 : _ref$size,
//     _ref$sizeType = _ref.sizeType,
//     sizeType = _ref$sizeType === void 0 ? 'area' : _ref$sizeType,
//     rest = _objectWithoutProperties$e(_ref, _excluded$f);
//   var props = _objectSpread$x(_objectSpread$x({}, rest), {}, {
//     type: type,
//     size: size,
//     sizeType: sizeType
//   });

//   /**
//    * Calculate the path of curve
//    * @return {String} path
//    */
//   var getPath = function getPath() {
//     var symbolFactory = getSymbolFactory(type);
//     var symbol$1 = symbol().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));
//     return symbol$1();
//   };
//   var className = props.className,
//     cx = props.cx,
//     cy = props.cy;
//   var filteredProps = filterProps(props, true);
//   if (cx === +cx && cy === +cy && size === +size) {
//     return /*#__PURE__*/React__default.createElement("path", _extends$l({}, filteredProps, {
//       className: clsx('recharts-symbols', className),
//       transform: "translate(".concat(cx, ", ").concat(cy, ")"),
//       d: getPath()
//     }));
//   }
//   return null;
// };
// Symbols.registerSymbol = registerSymbol;

// function _typeof$B(o) { "@babel/helpers - typeof"; return _typeof$B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$B(o); }
// function _extends$k() { _extends$k = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$k.apply(this, arguments); }
// function ownKeys$w(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$w(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$w(Object(t), !0).forEach(function (r) { _defineProperty$y(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$w(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$d(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$z(descriptor.key), descriptor); } }
// function _createClass$d(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$d(Constructor.prototype, protoProps); if (staticProps) _defineProperties$d(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$a(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$b(subClass, superClass); }
// function _setPrototypeOf$b(o, p) { _setPrototypeOf$b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$b(o, p); }
// function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf$a(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$a(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$a(this, result); }; }
// function _possibleConstructorReturn$a(self, call) { if (call && (_typeof$B(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$a(self); }
// function _assertThisInitialized$a(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$a(o) { _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$a(o); }
// function _defineProperty$y(obj, key, value) { key = _toPropertyKey$z(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$z(arg) { var key = _toPrimitive$z(arg, "string"); return _typeof$B(key) === "symbol" ? key : String(key); }
// function _toPrimitive$z(input, hint) { if (_typeof$B(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$B(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var SIZE = 32;
// var DefaultLegendContent = /*#__PURE__*/function (_PureComponent) {
//   _inherits$a(DefaultLegendContent, _PureComponent);
//   var _super = _createSuper$a(DefaultLegendContent);
//   function DefaultLegendContent() {
//     _classCallCheck$d(this, DefaultLegendContent);
//     return _super.apply(this, arguments);
//   }
//   _createClass$d(DefaultLegendContent, [{
//     key: "renderIcon",
//     value:
//     /**
//      * Render the path of icon
//      * @param {Object} data Data of each legend item
//      * @return {String} Path element
//      */
//     function renderIcon(data) {
//       var inactiveColor = this.props.inactiveColor;
//       var halfSize = SIZE / 2;
//       var sixthSize = SIZE / 6;
//       var thirdSize = SIZE / 3;
//       var color = data.inactive ? inactiveColor : data.color;
//       if (data.type === 'plainline') {
//         return /*#__PURE__*/React__default.createElement("line", {
//           strokeWidth: 4,
//           fill: "none",
//           stroke: color,
//           strokeDasharray: data.payload.strokeDasharray,
//           x1: 0,
//           y1: halfSize,
//           x2: SIZE,
//           y2: halfSize,
//           className: "recharts-legend-icon"
//         });
//       }
//       if (data.type === 'line') {
//         return /*#__PURE__*/React__default.createElement("path", {
//           strokeWidth: 4,
//           fill: "none",
//           stroke: color,
//           d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
//           className: "recharts-legend-icon"
//         });
//       }
//       if (data.type === 'rect') {
//         return /*#__PURE__*/React__default.createElement("path", {
//           stroke: "none",
//           fill: color,
//           d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
//           className: "recharts-legend-icon"
//         });
//       }
//       if ( /*#__PURE__*/React__default.isValidElement(data.legendIcon)) {
//         var iconProps = _objectSpread$w({}, data);
//         delete iconProps.legendIcon;
//         return /*#__PURE__*/React__default.cloneElement(data.legendIcon, iconProps);
//       }
//       return /*#__PURE__*/React__default.createElement(Symbols, {
//         fill: color,
//         cx: halfSize,
//         cy: halfSize,
//         size: SIZE,
//         sizeType: "diameter",
//         type: data.type
//       });
//     }

//     /**
//      * Draw items of legend
//      * @return {ReactElement} Items
//      */
//   }, {
//     key: "renderItems",
//     value: function renderItems() {
//       var _this = this;
//       var _this$props = this.props,
//         payload = _this$props.payload,
//         iconSize = _this$props.iconSize,
//         layout = _this$props.layout,
//         formatter = _this$props.formatter,
//         inactiveColor = _this$props.inactiveColor;
//       var viewBox = {
//         x: 0,
//         y: 0,
//         width: SIZE,
//         height: SIZE
//       };
//       var itemStyle = {
//         display: layout === 'horizontal' ? 'inline-block' : 'block',
//         marginRight: 10
//       };
//       var svgStyle = {
//         display: 'inline-block',
//         verticalAlign: 'middle',
//         marginRight: 4
//       };
//       return payload.map(function (entry, i) {
//         var _clsx;
//         var finalFormatter = entry.formatter || formatter;
//         var className = clsx((_clsx = {
//           'recharts-legend-item': true
//         }, _defineProperty$y(_clsx, "legend-item-".concat(i), true), _defineProperty$y(_clsx, "inactive", entry.inactive), _clsx));
//         if (entry.type === 'none') {
//           return null;
//         }

//         // Do not render entry.value as functions. Always require static string properties.
//         var entryValue = !isFunction(entry.value) ? entry.value : null;
//         warn$1(!isFunction(entry.value), "The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name=\"Name of my Data\"/>" // eslint-disable-line max-len
//         );
//         var color = entry.inactive ? inactiveColor : entry.color;
//         return /*#__PURE__*/React__default.createElement("li", _extends$k({
//           className: className,
//           style: itemStyle
//           // eslint-disable-next-line react/no-array-index-key
//           ,
//           key: "legend-item-".concat(i)
//         }, adaptEventsOfChild(_this.props, entry, i)), /*#__PURE__*/React__default.createElement(Surface, {
//           width: iconSize,
//           height: iconSize,
//           viewBox: viewBox,
//           style: svgStyle
//         }, _this.renderIcon(entry)), /*#__PURE__*/React__default.createElement("span", {
//           className: "recharts-legend-item-text",
//           style: {
//             color: color
//           }
//         }, finalFormatter ? finalFormatter(entryValue, entry, i) : entryValue));
//       });
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this$props2 = this.props,
//         payload = _this$props2.payload,
//         layout = _this$props2.layout,
//         align = _this$props2.align;
//       if (!payload || !payload.length) {
//         return null;
//       }
//       var finalStyle = {
//         padding: 0,
//         margin: 0,
//         textAlign: layout === 'horizontal' ? align : 'left'
//       };
//       return /*#__PURE__*/React__default.createElement("ul", {
//         className: "recharts-default-legend",
//         style: finalStyle
//       }, this.renderItems());
//     }
//   }]);
//   return DefaultLegendContent;
// }(PureComponent);
// _defineProperty$y(DefaultLegendContent, "displayName", 'Legend');
// _defineProperty$y(DefaultLegendContent, "defaultProps", {
//   iconSize: 14,
//   layout: 'horizontal',
//   align: 'center',
//   verticalAlign: 'middle',
//   inactiveColor: '#ccc'
// });

// /**
//  * This is configuration option that decides how to filter for unique values only:
//  *
//  * - `false` means "no filter"
//  * - `true` means "use recharts default filter"
//  * - function means "use return of this function as the default key"
//  */

// function getUniqPayload(payload, option, defaultUniqBy) {
//   if (option === true) {
//     return uniqBy(payload, defaultUniqBy);
//   }
//   if (isFunction(option)) {
//     return uniqBy(payload, option);
//   }
//   return payload;
// }

// function _typeof$A(o) { "@babel/helpers - typeof"; return _typeof$A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$A(o); }
// var _excluded$e = ["ref"];
// function ownKeys$v(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$v(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$v(Object(t), !0).forEach(function (r) { _defineProperty$x(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$v(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _classCallCheck$c(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$c(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$y(descriptor.key), descriptor); } }
// function _createClass$c(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$c(Constructor.prototype, protoProps); if (staticProps) _defineProperties$c(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$a(subClass, superClass); }
// function _setPrototypeOf$a(o, p) { _setPrototypeOf$a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$a(o, p); }
// function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf$9(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$9(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$9(this, result); }; }
// function _possibleConstructorReturn$9(self, call) { if (call && (_typeof$A(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$9(self); }
// function _assertThisInitialized$9(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$9(o) { _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$9(o); }
// function _defineProperty$x(obj, key, value) { key = _toPropertyKey$y(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$y(arg) { var key = _toPrimitive$y(arg, "string"); return _typeof$A(key) === "symbol" ? key : String(key); }
// function _toPrimitive$y(input, hint) { if (_typeof$A(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$A(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _objectWithoutProperties$d(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$d(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$d(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function defaultUniqBy$1(entry) {
//   return entry.value;
// }
// function renderContent$1(content, props) {
//   if ( /*#__PURE__*/React__default.isValidElement(content)) {
//     return /*#__PURE__*/React__default.cloneElement(content, props);
//   }
//   if (typeof content === 'function') {
//     return /*#__PURE__*/React__default.createElement(content, props);
//   }
//   props.ref;
//     var otherProps = _objectWithoutProperties$d(props, _excluded$e);
//   return /*#__PURE__*/React__default.createElement(DefaultLegendContent, otherProps);
// }
// var EPS$1 = 1;
// var Legend = /*#__PURE__*/function (_PureComponent) {
//   _inherits$9(Legend, _PureComponent);
//   var _super = _createSuper$9(Legend);
//   function Legend() {
//     var _this;
//     _classCallCheck$c(this, Legend);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$x(_assertThisInitialized$9(_this), "lastBoundingBox", {
//       width: -1,
//       height: -1
//     });
//     return _this;
//   }
//   _createClass$c(Legend, [{
//     key: "componentDidMount",
//     value: function componentDidMount() {
//       this.updateBBox();
//     }
//   }, {
//     key: "componentDidUpdate",
//     value: function componentDidUpdate() {
//       this.updateBBox();
//     }
//   }, {
//     key: "getBBox",
//     value: function getBBox() {
//       if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
//         return this.wrapperNode.getBoundingClientRect();
//       }
//       return null;
//     }
//   }, {
//     key: "updateBBox",
//     value: function updateBBox() {
//       var onBBoxUpdate = this.props.onBBoxUpdate;
//       if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
//         var _box = this.wrapperNode.getBoundingClientRect();
//         if (Math.abs(_box.width - this.lastBoundingBox.width) > EPS$1 || Math.abs(_box.height - this.lastBoundingBox.height) > EPS$1) {
//           this.lastBoundingBox.width = _box.width;
//           this.lastBoundingBox.height = _box.height;
//           if (onBBoxUpdate) {
//             onBBoxUpdate(_box);
//           }
//         }
//       } else if (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) {
//         this.lastBoundingBox.width = -1;
//         this.lastBoundingBox.height = -1;
//         if (onBBoxUpdate) {
//           onBBoxUpdate(null);
//         }
//       }
//     }
//   }, {
//     key: "getBBoxSnapshot",
//     value: function getBBoxSnapshot() {
//       if (this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0) {
//         return _objectSpread$v({}, this.lastBoundingBox);
//       }
//       return {
//         width: 0,
//         height: 0
//       };
//     }
//   }, {
//     key: "getDefaultPosition",
//     value: function getDefaultPosition(style) {
//       var _this$props = this.props,
//         layout = _this$props.layout,
//         align = _this$props.align,
//         verticalAlign = _this$props.verticalAlign,
//         margin = _this$props.margin,
//         chartWidth = _this$props.chartWidth,
//         chartHeight = _this$props.chartHeight;
//       var hPos, vPos;
//       if (!style || (style.left === undefined || style.left === null) && (style.right === undefined || style.right === null)) {
//         if (align === 'center' && layout === 'vertical') {
//           var _box2 = this.getBBoxSnapshot();
//           hPos = {
//             left: ((chartWidth || 0) - _box2.width) / 2
//           };
//         } else {
//           hPos = align === 'right' ? {
//             right: margin && margin.right || 0
//           } : {
//             left: margin && margin.left || 0
//           };
//         }
//       }
//       if (!style || (style.top === undefined || style.top === null) && (style.bottom === undefined || style.bottom === null)) {
//         if (verticalAlign === 'middle') {
//           var _box3 = this.getBBoxSnapshot();
//           vPos = {
//             top: ((chartHeight || 0) - _box3.height) / 2
//           };
//         } else {
//           vPos = verticalAlign === 'bottom' ? {
//             bottom: margin && margin.bottom || 0
//           } : {
//             top: margin && margin.top || 0
//           };
//         }
//       }
//       return _objectSpread$v(_objectSpread$v({}, hPos), vPos);
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this2 = this;
//       var _this$props2 = this.props,
//         content = _this$props2.content,
//         width = _this$props2.width,
//         height = _this$props2.height,
//         wrapperStyle = _this$props2.wrapperStyle,
//         payloadUniqBy = _this$props2.payloadUniqBy,
//         payload = _this$props2.payload;
//       var outerStyle = _objectSpread$v(_objectSpread$v({
//         position: 'absolute',
//         width: width || 'auto',
//         height: height || 'auto'
//       }, this.getDefaultPosition(wrapperStyle)), wrapperStyle);
//       return /*#__PURE__*/React__default.createElement("div", {
//         className: "recharts-legend-wrapper",
//         style: outerStyle,
//         ref: function ref(node) {
//           _this2.wrapperNode = node;
//         }
//       }, renderContent$1(content, _objectSpread$v(_objectSpread$v({}, this.props), {}, {
//         payload: getUniqPayload(payload, payloadUniqBy, defaultUniqBy$1)
//       })));
//     }
//   }], [{
//     key: "getWithHeight",
//     value: function getWithHeight(item, chartWidth) {
//       var layout = item.props.layout;
//       if (layout === 'vertical' && isNumber(item.props.height)) {
//         return {
//           height: item.props.height
//         };
//       }
//       if (layout === 'horizontal') {
//         return {
//           width: item.props.width || chartWidth
//         };
//       }
//       return null;
//     }
//   }]);
//   return Legend;
// }(PureComponent);
// _defineProperty$x(Legend, "displayName", 'Legend');
// _defineProperty$x(Legend, "defaultProps", {
//   iconSize: 14,
//   layout: 'horizontal',
//   align: 'center',
//   verticalAlign: 'bottom'
// });

// function _typeof$z(o) { "@babel/helpers - typeof"; return _typeof$z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$z(o); }
// function _slicedToArray$a(arr, i) { return _arrayWithHoles$b(arr) || _iterableToArrayLimit$a(arr, i) || _unsupportedIterableToArray$j(arr, i) || _nonIterableRest$b(); }
// function _nonIterableRest$b() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$j(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$j(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(o, minLen); }
// function _arrayLikeToArray$j(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$a(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles$b(arr) { if (Array.isArray(arr)) return arr; }
// function ownKeys$u(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$u(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$u(Object(t), !0).forEach(function (r) { _defineProperty$w(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$u(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$w(obj, key, value) { key = _toPropertyKey$x(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$x(arg) { var key = _toPrimitive$x(arg, "string"); return _typeof$z(key) === "symbol" ? key : String(key); }
// function _toPrimitive$x(input, hint) { if (_typeof$z(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$z(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function defaultFormatter(value) {
//   return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(' ~ ') : value;
// }
// var DefaultTooltipContent = function DefaultTooltipContent(props) {
//   var _props$separator = props.separator,
//     separator = _props$separator === void 0 ? ' : ' : _props$separator,
//     _props$contentStyle = props.contentStyle,
//     contentStyle = _props$contentStyle === void 0 ? {} : _props$contentStyle,
//     _props$itemStyle = props.itemStyle,
//     itemStyle = _props$itemStyle === void 0 ? {} : _props$itemStyle,
//     _props$labelStyle = props.labelStyle,
//     labelStyle = _props$labelStyle === void 0 ? {} : _props$labelStyle,
//     payload = props.payload,
//     formatter = props.formatter,
//     itemSorter = props.itemSorter,
//     wrapperClassName = props.wrapperClassName,
//     labelClassName = props.labelClassName,
//     label = props.label,
//     labelFormatter = props.labelFormatter;
//   var renderContent = function renderContent() {
//     if (payload && payload.length) {
//       var listStyle = {
//         padding: 0,
//         margin: 0
//       };
//       var items = (itemSorter ? sortBy(payload, itemSorter) : payload).map(function (entry, i) {
//         if (entry.type === 'none') {
//           return null;
//         }
//         var finalItemStyle = _objectSpread$u({
//           display: 'block',
//           paddingTop: 4,
//           paddingBottom: 4,
//           color: entry.color || '#000'
//         }, itemStyle);
//         var finalFormatter = entry.formatter || formatter || defaultFormatter;
//         var value = entry.value,
//           name = entry.name;
//         var finalValue = value;
//         var finalName = name;
//         if (finalFormatter && finalValue != null && finalName != null) {
//           var formatted = finalFormatter(value, name, entry, i, payload);
//           if (Array.isArray(formatted)) {
//             var _formatted = _slicedToArray$a(formatted, 2);
//             finalValue = _formatted[0];
//             finalName = _formatted[1];
//           } else {
//             finalValue = formatted;
//           }
//         }
//         return (
//           /*#__PURE__*/
//           // eslint-disable-next-line react/no-array-index-key
//           React__default.createElement("li", {
//             className: "recharts-tooltip-item",
//             key: "tooltip-item-".concat(i),
//             style: finalItemStyle
//           }, isNumOrStr(finalName) ? /*#__PURE__*/React__default.createElement("span", {
//             className: "recharts-tooltip-item-name"
//           }, finalName) : null, isNumOrStr(finalName) ? /*#__PURE__*/React__default.createElement("span", {
//             className: "recharts-tooltip-item-separator"
//           }, separator) : null, /*#__PURE__*/React__default.createElement("span", {
//             className: "recharts-tooltip-item-value"
//           }, finalValue), /*#__PURE__*/React__default.createElement("span", {
//             className: "recharts-tooltip-item-unit"
//           }, entry.unit || ''))
//         );
//       });
//       return /*#__PURE__*/React__default.createElement("ul", {
//         className: "recharts-tooltip-item-list",
//         style: listStyle
//       }, items);
//     }
//     return null;
//   };
//   var finalStyle = _objectSpread$u({
//     margin: 0,
//     padding: 10,
//     backgroundColor: '#fff',
//     border: '1px solid #ccc',
//     whiteSpace: 'nowrap'
//   }, contentStyle);
//   var finalLabelStyle = _objectSpread$u({
//     margin: 0
//   }, labelStyle);
//   var hasLabel = !isNil$1(label);
//   var finalLabel = hasLabel ? label : '';
//   var wrapperCN = clsx('recharts-default-tooltip', wrapperClassName);
//   var labelCN = clsx('recharts-tooltip-label', labelClassName);
//   if (hasLabel && labelFormatter && payload !== undefined && payload !== null) {
//     finalLabel = labelFormatter(label, payload);
//   }
//   return /*#__PURE__*/React__default.createElement("div", {
//     className: wrapperCN,
//     style: finalStyle
//   }, /*#__PURE__*/React__default.createElement("p", {
//     className: labelCN,
//     style: finalLabelStyle
//   }, /*#__PURE__*/React__default.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent());
// };

// var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
// var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
// /**
//  * Combine two comparators into a single comparators.
//  */
// function combineComparators(comparatorA, comparatorB) {
//     return function isEqual(a, b, state) {
//         return comparatorA(a, b, state) && comparatorB(a, b, state);
//     };
// }
// /**
//  * Wrap the provided `areItemsEqual` method to manage the circular state, allowing
//  * for circular references to be safely included in the comparison without creating
//  * stack overflows.
//  */
// function createIsCircular(areItemsEqual) {
//     return function isCircular(a, b, state) {
//         if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {
//             return areItemsEqual(a, b, state);
//         }
//         var cache = state.cache;
//         var cachedA = cache.get(a);
//         var cachedB = cache.get(b);
//         if (cachedA && cachedB) {
//             return cachedA === b && cachedB === a;
//         }
//         cache.set(a, b);
//         cache.set(b, a);
//         var result = areItemsEqual(a, b, state);
//         cache.delete(a);
//         cache.delete(b);
//         return result;
//     };
// }
// /**
//  * Get the properties to strictly examine, which include both own properties that are
//  * not enumerable and symbol properties.
//  */
// function getStrictProperties(object) {
//     return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
// }
// /**
//  * Whether the object contains the property passed as an own property.
//  */
// var hasOwn = Object.hasOwn ||
//     (function (object, property) {
//         return hasOwnProperty$1.call(object, property);
//     });
// /**
//  * Whether the values passed are strictly equal or both NaN.
//  */
// function sameValueZeroEqual(a, b) {
//     return a || b ? a === b : a === b || (a !== a && b !== b);
// }

// var OWNER = '_owner';
// var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor, keys = Object.keys;
// /**
//  * Whether the arrays are equal in value.
//  */
// function areArraysEqual(a, b, state) {
//     var index = a.length;
//     if (b.length !== index) {
//         return false;
//     }
//     while (index-- > 0) {
//         if (!state.equals(a[index], b[index], index, index, a, b, state)) {
//             return false;
//         }
//     }
//     return true;
// }
// /**
//  * Whether the dates passed are equal in value.
//  */
// function areDatesEqual(a, b) {
//     return sameValueZeroEqual(a.getTime(), b.getTime());
// }
// /**
//  * Whether the `Map`s are equal in value.
//  */
// function areMapsEqual(a, b, state) {
//     if (a.size !== b.size) {
//         return false;
//     }
//     var matchedIndices = {};
//     var aIterable = a.entries();
//     var index = 0;
//     var aResult;
//     var bResult;
//     while ((aResult = aIterable.next())) {
//         if (aResult.done) {
//             break;
//         }
//         var bIterable = b.entries();
//         var hasMatch = false;
//         var matchIndex = 0;
//         while ((bResult = bIterable.next())) {
//             if (bResult.done) {
//                 break;
//             }
//             var _a = aResult.value, aKey = _a[0], aValue = _a[1];
//             var _b = bResult.value, bKey = _b[0], bValue = _b[1];
//             if (!hasMatch &&
//                 !matchedIndices[matchIndex] &&
//                 (hasMatch =
//                     state.equals(aKey, bKey, index, matchIndex, a, b, state) &&
//                         state.equals(aValue, bValue, aKey, bKey, a, b, state))) {
//                 matchedIndices[matchIndex] = true;
//             }
//             matchIndex++;
//         }
//         if (!hasMatch) {
//             return false;
//         }
//         index++;
//     }
//     return true;
// }
// /**
//  * Whether the objects are equal in value.
//  */
// function areObjectsEqual(a, b, state) {
//     var properties = keys(a);
//     var index = properties.length;
//     if (keys(b).length !== index) {
//         return false;
//     }
//     var property;
//     // Decrementing `while` showed faster results than either incrementing or
//     // decrementing `for` loop and than an incrementing `while` loop. Declarative
//     // methods like `some` / `every` were not used to avoid incurring the garbage
//     // cost of anonymous callbacks.
//     while (index-- > 0) {
//         property = properties[index];
//         if (property === OWNER &&
//             (a.$$typeof || b.$$typeof) &&
//             a.$$typeof !== b.$$typeof) {
//             return false;
//         }
//         if (!hasOwn(b, property) ||
//             !state.equals(a[property], b[property], property, property, a, b, state)) {
//             return false;
//         }
//     }
//     return true;
// }
// /**
//  * Whether the objects are equal in value with strict property checking.
//  */
// function areObjectsEqualStrict(a, b, state) {
//     var properties = getStrictProperties(a);
//     var index = properties.length;
//     if (getStrictProperties(b).length !== index) {
//         return false;
//     }
//     var property;
//     var descriptorA;
//     var descriptorB;
//     // Decrementing `while` showed faster results than either incrementing or
//     // decrementing `for` loop and than an incrementing `while` loop. Declarative
//     // methods like `some` / `every` were not used to avoid incurring the garbage
//     // cost of anonymous callbacks.
//     while (index-- > 0) {
//         property = properties[index];
//         if (property === OWNER &&
//             (a.$$typeof || b.$$typeof) &&
//             a.$$typeof !== b.$$typeof) {
//             return false;
//         }
//         if (!hasOwn(b, property)) {
//             return false;
//         }
//         if (!state.equals(a[property], b[property], property, property, a, b, state)) {
//             return false;
//         }
//         descriptorA = getOwnPropertyDescriptor$1(a, property);
//         descriptorB = getOwnPropertyDescriptor$1(b, property);
//         if ((descriptorA || descriptorB) &&
//             (!descriptorA ||
//                 !descriptorB ||
//                 descriptorA.configurable !== descriptorB.configurable ||
//                 descriptorA.enumerable !== descriptorB.enumerable ||
//                 descriptorA.writable !== descriptorB.writable)) {
//             return false;
//         }
//     }
//     return true;
// }
// /**
//  * Whether the primitive wrappers passed are equal in value.
//  */
// function arePrimitiveWrappersEqual(a, b) {
//     return sameValueZeroEqual(a.valueOf(), b.valueOf());
// }
// /**
//  * Whether the regexps passed are equal in value.
//  */
// function areRegExpsEqual(a, b) {
//     return a.source === b.source && a.flags === b.flags;
// }
// /**
//  * Whether the `Set`s are equal in value.
//  */
// function areSetsEqual(a, b, state) {
//     if (a.size !== b.size) {
//         return false;
//     }
//     var matchedIndices = {};
//     var aIterable = a.values();
//     var aResult;
//     var bResult;
//     while ((aResult = aIterable.next())) {
//         if (aResult.done) {
//             break;
//         }
//         var bIterable = b.values();
//         var hasMatch = false;
//         var matchIndex = 0;
//         while ((bResult = bIterable.next())) {
//             if (bResult.done) {
//                 break;
//             }
//             if (!hasMatch &&
//                 !matchedIndices[matchIndex] &&
//                 (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state))) {
//                 matchedIndices[matchIndex] = true;
//             }
//             matchIndex++;
//         }
//         if (!hasMatch) {
//             return false;
//         }
//     }
//     return true;
// }
// /**
//  * Whether the TypedArray instances are equal in value.
//  */
// function areTypedArraysEqual(a, b) {
//     var index = a.length;
//     if (b.length !== index) {
//         return false;
//     }
//     while (index-- > 0) {
//         if (a[index] !== b[index]) {
//             return false;
//         }
//     }
//     return true;
// }

// var ARGUMENTS_TAG = '[object Arguments]';
// var BOOLEAN_TAG = '[object Boolean]';
// var DATE_TAG = '[object Date]';
// var MAP_TAG = '[object Map]';
// var NUMBER_TAG = '[object Number]';
// var OBJECT_TAG = '[object Object]';
// var REG_EXP_TAG = '[object RegExp]';
// var SET_TAG = '[object Set]';
// var STRING_TAG = '[object String]';
// var isArray = Array.isArray;
// var isTypedArray = typeof ArrayBuffer === 'function' && ArrayBuffer.isView
//     ? ArrayBuffer.isView
//     : null;
// var assign = Object.assign;
// var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
// /**
//  * Create a comparator method based on the type-specific equality comparators passed.
//  */
// function createEqualityComparator(_a) {
//     var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, areTypedArraysEqual = _a.areTypedArraysEqual;
//     /**
//      * compare the value of the two objects and return true if they are equivalent in values
//      */
//     return function comparator(a, b, state) {
//         // If the items are strictly equal, no need to do a value comparison.
//         if (a === b) {
//             return true;
//         }
//         // If the items are not non-nullish objects, then the only possibility
//         // of them being equal but not strictly is if they are both `NaN`. Since
//         // `NaN` is uniquely not equal to itself, we can use self-comparison of
//         // both objects, which is faster than `isNaN()`.
//         if (a == null ||
//             b == null ||
//             typeof a !== 'object' ||
//             typeof b !== 'object') {
//             return a !== a && b !== b;
//         }
//         var constructor = a.constructor;
//         // Checks are listed in order of commonality of use-case:
//         //   1. Common complex object types (plain object, array)
//         //   2. Common data values (date, regexp)
//         //   3. Less-common complex object types (map, set)
//         //   4. Less-common data values (promise, primitive wrappers)
//         // Inherently this is both subjective and assumptive, however
//         // when reviewing comparable libraries in the wild this order
//         // appears to be generally consistent.
//         // Constructors should match, otherwise there is potential for false positives
//         // between class and subclass or custom object and POJO.
//         if (constructor !== b.constructor) {
//             return false;
//         }
//         // `isPlainObject` only checks against the object's own realm. Cross-realm
//         // comparisons are rare, and will be handled in the ultimate fallback, so
//         // we can avoid capturing the string tag.
//         if (constructor === Object) {
//             return areObjectsEqual(a, b, state);
//         }
//         // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing
//         // the string tag or doing an `instanceof` check.
//         if (isArray(a)) {
//             return areArraysEqual(a, b, state);
//         }
//         // `isTypedArray()` works on all possible TypedArray classes, so we can avoid
//         // capturing the string tag or comparing against all possible constructors.
//         if (isTypedArray != null && isTypedArray(a)) {
//             return areTypedArraysEqual(a, b, state);
//         }
//         // Try to fast-path equality checks for other complex object types in the
//         // same realm to avoid capturing the string tag. Strict equality is used
//         // instead of `instanceof` because it is more performant for the common
//         // use-case. If someone is subclassing a native class, it will be handled
//         // with the string tag comparison.
//         if (constructor === Date) {
//             return areDatesEqual(a, b, state);
//         }
//         if (constructor === RegExp) {
//             return areRegExpsEqual(a, b, state);
//         }
//         if (constructor === Map) {
//             return areMapsEqual(a, b, state);
//         }
//         if (constructor === Set) {
//             return areSetsEqual(a, b, state);
//         }
//         // Since this is a custom object, capture the string tag to determing its type.
//         // This is reasonably performant in modern environments like v8 and SpiderMonkey.
//         var tag = getTag(a);
//         if (tag === DATE_TAG) {
//             return areDatesEqual(a, b, state);
//         }
//         if (tag === REG_EXP_TAG) {
//             return areRegExpsEqual(a, b, state);
//         }
//         if (tag === MAP_TAG) {
//             return areMapsEqual(a, b, state);
//         }
//         if (tag === SET_TAG) {
//             return areSetsEqual(a, b, state);
//         }
//         if (tag === OBJECT_TAG) {
//             // The exception for value comparison is custom `Promise`-like class instances. These should
//             // be treated the same as standard `Promise` objects, which means strict equality, and if
//             // it reaches this point then that strict equality comparison has already failed.
//             return (typeof a.then !== 'function' &&
//                 typeof b.then !== 'function' &&
//                 areObjectsEqual(a, b, state));
//         }
//         // If an arguments tag, it should be treated as a standard object.
//         if (tag === ARGUMENTS_TAG) {
//             return areObjectsEqual(a, b, state);
//         }
//         // As the penultimate fallback, check if the values passed are primitive wrappers. This
//         // is very rare in modern JS, which is why it is deprioritized compared to all other object
//         // types.
//         if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
//             return arePrimitiveWrappersEqual(a, b, state);
//         }
//         // If not matching any tags that require a specific type of comparison, then we hard-code false because
//         // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:
//         //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only
//         //     comparison that can be made.
//         //   - For types that can be introspected, but rarely have requirements to be compared
//         //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common
//         //     use-cases (may be included in a future release, if requested enough).
//         //   - For types that can be introspected but do not have an objective definition of what
//         //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.
//         // In all cases, these decisions should be reevaluated based on changes to the language and
//         // common development practices.
//         return false;
//     };
// }
// /**
//  * Create the configuration object used for building comparators.
//  */
// function createEqualityComparatorConfig(_a) {
//     var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;
//     var config = {
//         areArraysEqual: strict
//             ? areObjectsEqualStrict
//             : areArraysEqual,
//         areDatesEqual: areDatesEqual,
//         areMapsEqual: strict
//             ? combineComparators(areMapsEqual, areObjectsEqualStrict)
//             : areMapsEqual,
//         areObjectsEqual: strict
//             ? areObjectsEqualStrict
//             : areObjectsEqual,
//         arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,
//         areRegExpsEqual: areRegExpsEqual,
//         areSetsEqual: strict
//             ? combineComparators(areSetsEqual, areObjectsEqualStrict)
//             : areSetsEqual,
//         areTypedArraysEqual: strict
//             ? areObjectsEqualStrict
//             : areTypedArraysEqual,
//     };
//     if (createCustomConfig) {
//         config = assign({}, config, createCustomConfig(config));
//     }
//     if (circular) {
//         var areArraysEqual$1 = createIsCircular(config.areArraysEqual);
//         var areMapsEqual$1 = createIsCircular(config.areMapsEqual);
//         var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
//         var areSetsEqual$1 = createIsCircular(config.areSetsEqual);
//         config = assign({}, config, {
//             areArraysEqual: areArraysEqual$1,
//             areMapsEqual: areMapsEqual$1,
//             areObjectsEqual: areObjectsEqual$1,
//             areSetsEqual: areSetsEqual$1,
//         });
//     }
//     return config;
// }
// /**
//  * Default equality comparator pass-through, used as the standard `isEqual` creator for
//  * use inside the built comparator.
//  */
// function createInternalEqualityComparator(compare) {
//     return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
//         return compare(a, b, state);
//     };
// }
// /**
//  * Create the `isEqual` function used by the consuming application.
//  */
// function createIsEqual(_a) {
//     var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;
//     if (createState) {
//         return function isEqual(a, b) {
//             var _a = createState(), _b = _a.cache, cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b, meta = _a.meta;
//             return comparator(a, b, {
//                 cache: cache,
//                 equals: equals,
//                 meta: meta,
//                 strict: strict,
//             });
//         };
//     }
//     if (circular) {
//         return function isEqual(a, b) {
//             return comparator(a, b, {
//                 cache: new WeakMap(),
//                 equals: equals,
//                 meta: undefined,
//                 strict: strict,
//             });
//         };
//     }
//     var state = {
//         cache: undefined,
//         equals: equals,
//         meta: undefined,
//         strict: strict,
//     };
//     return function isEqual(a, b) {
//         return comparator(a, b, state);
//     };
// }

// /**
//  * Whether the items passed are deeply-equal in value.
//  */
// var deepEqual = createCustomEqual();
// /**
//  * Whether the items passed are deeply-equal in value based on strict comparison.
//  */
// createCustomEqual({ strict: true });
// /**
//  * Whether the items passed are deeply-equal in value, including circular references.
//  */
// createCustomEqual({ circular: true });
// /**
//  * Whether the items passed are deeply-equal in value, including circular references,
//  * based on strict comparison.
//  */
// createCustomEqual({
//     circular: true,
//     strict: true,
// });
// /**
//  * Whether the items passed are shallowly-equal in value.
//  */
// createCustomEqual({
//     createInternalComparator: function () { return sameValueZeroEqual; },
// });
// /**
//  * Whether the items passed are shallowly-equal in value based on strict comparison
//  */
// createCustomEqual({
//     strict: true,
//     createInternalComparator: function () { return sameValueZeroEqual; },
// });
// /**
//  * Whether the items passed are shallowly-equal in value, including circular references.
//  */
// createCustomEqual({
//     circular: true,
//     createInternalComparator: function () { return sameValueZeroEqual; },
// });
// /**
//  * Whether the items passed are shallowly-equal in value, including circular references,
//  * based on strict comparison.
//  */
// createCustomEqual({
//     circular: true,
//     createInternalComparator: function () { return sameValueZeroEqual; },
//     strict: true,
// });
// /**
//  * Create a custom equality comparison method.
//  *
//  * This can be done to create very targeted comparisons in extreme hot-path scenarios
//  * where the standard methods are not performant enough, but can also be used to provide
//  * support for legacy environments that do not support expected features like
//  * `RegExp.prototype.flags` out of the box.
//  */
// function createCustomEqual(options) {
//     if (options === void 0) { options = {}; }
//     var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;
//     var config = createEqualityComparatorConfig(options);
//     var comparator = createEqualityComparator(config);
//     var equals = createCustomInternalComparator
//         ? createCustomInternalComparator(comparator)
//         : createInternalEqualityComparator(comparator);
//     return createIsEqual({ circular: circular, comparator: comparator, createState: createState, equals: equals, strict: strict });
// }

// function safeRequestAnimationFrame(callback) {
//   if (typeof requestAnimationFrame !== 'undefined') requestAnimationFrame(callback);
// }
// function setRafTimeout(callback) {
//   var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
//   var currTime = -1;
//   var shouldUpdate = function shouldUpdate(now) {
//     if (currTime < 0) {
//       currTime = now;
//     }
//     if (now - currTime > timeout) {
//       callback(now);
//       currTime = -1;
//     } else {
//       safeRequestAnimationFrame(shouldUpdate);
//     }
//   };
//   requestAnimationFrame(shouldUpdate);
// }

// function _typeof$y(obj) { "@babel/helpers - typeof"; return _typeof$y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$y(obj); }
// function _toArray(arr) { return _arrayWithHoles$a(arr) || _iterableToArray$c(arr) || _unsupportedIterableToArray$i(arr) || _nonIterableRest$a(); }
// function _nonIterableRest$a() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$i(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$i(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen); }
// function _arrayLikeToArray$i(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArray$c(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithHoles$a(arr) { if (Array.isArray(arr)) return arr; }
// function createAnimateManager() {
//   var currStyle = {};
//   var handleChange = function handleChange() {
//     return null;
//   };
//   var shouldStop = false;
//   var setStyle = function setStyle(_style) {
//     if (shouldStop) {
//       return;
//     }
//     if (Array.isArray(_style)) {
//       if (!_style.length) {
//         return;
//       }
//       var styles = _style;
//       var _styles = _toArray(styles),
//         curr = _styles[0],
//         restStyles = _styles.slice(1);
//       if (typeof curr === 'number') {
//         setRafTimeout(setStyle.bind(null, restStyles), curr);
//         return;
//       }
//       setStyle(curr);
//       setRafTimeout(setStyle.bind(null, restStyles));
//       return;
//     }
//     if (_typeof$y(_style) === 'object') {
//       currStyle = _style;
//       handleChange(currStyle);
//     }
//     if (typeof _style === 'function') {
//       _style();
//     }
//   };
//   return {
//     stop: function stop() {
//       shouldStop = true;
//     },
//     start: function start(style) {
//       shouldStop = false;
//       setStyle(style);
//     },
//     subscribe: function subscribe(_handleChange) {
//       handleChange = _handleChange;
//       return function () {
//         handleChange = function handleChange() {
//           return null;
//         };
//       };
//     }
//   };
// }

// function _typeof$x(obj) { "@babel/helpers - typeof"; return _typeof$x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$x(obj); }
// function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
// function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$t(Object(source), !0).forEach(function (key) { _defineProperty$v(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$t(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// function _defineProperty$v(obj, key, value) { key = _toPropertyKey$w(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$w(arg) { var key = _toPrimitive$w(arg, "string"); return _typeof$x(key) === "symbol" ? key : String(key); }
// function _toPrimitive$w(input, hint) { if (_typeof$x(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$x(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// /* eslint no-console: 0 */
// var PREFIX_LIST$1 = ['Webkit', 'Moz', 'O', 'ms'];
// var IN_LINE_PREFIX_LIST = ['-webkit-', '-moz-', '-o-', '-ms-'];
// var IN_COMPATIBLE_PROPERTY = ['transform', 'transformOrigin', 'transition'];
// var getIntersectionKeys = function getIntersectionKeys(preObj, nextObj) {
//   return [Object.keys(preObj), Object.keys(nextObj)].reduce(function (a, b) {
//     return a.filter(function (c) {
//       return b.includes(c);
//     });
//   });
// };
// var identity$1 = function identity(param) {
//   return param;
// };

// /*
//  * @description: convert camel case to dash case
//  * string => string
//  */
// var getDashCase = function getDashCase(name) {
//   return name.replace(/([A-Z])/g, function (v) {
//     return "-".concat(v.toLowerCase());
//   });
// };

// /*
//  * @description: add compatible style prefix
//  * (string, string) => object
//  */
// var generatePrefixStyle$1 = function generatePrefixStyle(name, value) {
//   if (IN_COMPATIBLE_PROPERTY.indexOf(name) === -1) {
//     return _defineProperty$v({}, name, Number.isNaN(value) ? 0 : value);
//   }
//   var isTransition = name === 'transition';
//   var camelName = name.replace(/(\w)/, function (v) {
//     return v.toUpperCase();
//   });
//   var styleVal = value;
//   return PREFIX_LIST$1.reduce(function (result, property, i) {
//     if (isTransition) {
//       styleVal = value.replace(/(transform|transform-origin)/gim, "".concat(IN_LINE_PREFIX_LIST[i], "$1"));
//     }
//     return _objectSpread$t(_objectSpread$t({}, result), {}, _defineProperty$v({}, property + camelName, styleVal));
//   }, {});
// };

// /*
//  * @description: map object on every element in this object.
//  * (function, object) => object
//  */
// var mapObject = function mapObject(fn, obj) {
//   return Object.keys(obj).reduce(function (res, key) {
//     return _objectSpread$t(_objectSpread$t({}, res), {}, _defineProperty$v({}, key, fn(key, obj[key])));
//   }, {});
// };

// /*
//  * @description: add compatible prefix to style
//  * object => object
//  */
// var translateStyle = function translateStyle(style) {
//   return Object.keys(style).reduce(function (res, key) {
//     return _objectSpread$t(_objectSpread$t({}, res), generatePrefixStyle$1(key, res[key]));
//   }, style);
// };
// var getTransitionVal = function getTransitionVal(props, duration, easing) {
//   return props.map(function (prop) {
//     return "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing);
//   }).join(',');
// };
// var isDev = process.env.NODE_ENV !== 'production';
// var warn = function warn(condition, format, a, b, c, d, e, f) {
//   if (isDev && typeof console !== 'undefined' && console.warn) {
//     if (format === undefined) {
//       console.warn('LogUtils requires an error message argument');
//     }
//     if (!condition) {
//       if (format === undefined) {
//         console.warn('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
//       } else {
//         var args = [a, b, c, d, e, f];
//         var argIndex = 0;
//         console.warn(format.replace(/%s/g, function () {
//           return args[argIndex++];
//         }));
//       }
//     }
//   }
// };

// function _slicedToArray$9(arr, i) { return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$h(arr, i) || _nonIterableRest$9(); }
// function _nonIterableRest$9() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _iterableToArrayLimit$9(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
// function _arrayWithHoles$9(arr) { if (Array.isArray(arr)) return arr; }
// function _toConsumableArray$b(arr) { return _arrayWithoutHoles$b(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$h(arr) || _nonIterableSpread$b(); }
// function _nonIterableSpread$b() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$h(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$h(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen); }
// function _iterableToArray$b(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$b(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$h(arr); }
// function _arrayLikeToArray$h(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// var ACCURACY = 1e-4;
// var cubicBezierFactor = function cubicBezierFactor(c1, c2) {
//   return [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
// };
// var multyTime = function multyTime(params, t) {
//   return params.map(function (param, i) {
//     return param * Math.pow(t, i);
//   }).reduce(function (pre, curr) {
//     return pre + curr;
//   });
// };
// var cubicBezier = function cubicBezier(c1, c2) {
//   return function (t) {
//     var params = cubicBezierFactor(c1, c2);
//     return multyTime(params, t);
//   };
// };
// var derivativeCubicBezier = function derivativeCubicBezier(c1, c2) {
//   return function (t) {
//     var params = cubicBezierFactor(c1, c2);
//     var newParams = [].concat(_toConsumableArray$b(params.map(function (param, i) {
//       return param * i;
//     }).slice(1)), [0]);
//     return multyTime(newParams, t);
//   };
// };

// // calculate cubic-bezier using Newton's method
// var configBezier = function configBezier() {
//   for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//     args[_key] = arguments[_key];
//   }
//   var x1 = args[0],
//     y1 = args[1],
//     x2 = args[2],
//     y2 = args[3];
//   if (args.length === 1) {
//     switch (args[0]) {
//       case 'linear':
//         x1 = 0.0;
//         y1 = 0.0;
//         x2 = 1.0;
//         y2 = 1.0;
//         break;
//       case 'ease':
//         x1 = 0.25;
//         y1 = 0.1;
//         x2 = 0.25;
//         y2 = 1.0;
//         break;
//       case 'ease-in':
//         x1 = 0.42;
//         y1 = 0.0;
//         x2 = 1.0;
//         y2 = 1.0;
//         break;
//       case 'ease-out':
//         x1 = 0.42;
//         y1 = 0.0;
//         x2 = 0.58;
//         y2 = 1.0;
//         break;
//       case 'ease-in-out':
//         x1 = 0.0;
//         y1 = 0.0;
//         x2 = 0.58;
//         y2 = 1.0;
//         break;
//       default:
//         {
//           var easing = args[0].split('(');
//           if (easing[0] === 'cubic-bezier' && easing[1].split(')')[0].split(',').length === 4) {
//             var _easing$1$split$0$spl = easing[1].split(')')[0].split(',').map(function (x) {
//               return parseFloat(x);
//             });
//             var _easing$1$split$0$spl2 = _slicedToArray$9(_easing$1$split$0$spl, 4);
//             x1 = _easing$1$split$0$spl2[0];
//             y1 = _easing$1$split$0$spl2[1];
//             x2 = _easing$1$split$0$spl2[2];
//             y2 = _easing$1$split$0$spl2[3];
//           } else {
//             warn(false, '[configBezier]: arguments should be one of ' + "oneOf 'linear', 'ease', 'ease-in', 'ease-out', " + "'ease-in-out','cubic-bezier(x1,y1,x2,y2)', instead received %s", args);
//           }
//         }
//     }
//   }
//   warn([x1, x2, y1, y2].every(function (num) {
//     return typeof num === 'number' && num >= 0 && num <= 1;
//   }), '[configBezier]: arguments should be x1, y1, x2, y2 of [0, 1] instead received %s', args);
//   var curveX = cubicBezier(x1, x2);
//   var curveY = cubicBezier(y1, y2);
//   var derCurveX = derivativeCubicBezier(x1, x2);
//   var rangeValue = function rangeValue(value) {
//     if (value > 1) {
//       return 1;
//     }
//     if (value < 0) {
//       return 0;
//     }
//     return value;
//   };
//   var bezier = function bezier(_t) {
//     var t = _t > 1 ? 1 : _t;
//     var x = t;
//     for (var i = 0; i < 8; ++i) {
//       var evalT = curveX(x) - t;
//       var derVal = derCurveX(x);
//       if (Math.abs(evalT - t) < ACCURACY || derVal < ACCURACY) {
//         return curveY(x);
//       }
//       x = rangeValue(x - evalT / derVal);
//     }
//     return curveY(x);
//   };
//   bezier.isStepper = false;
//   return bezier;
// };
// var configSpring = function configSpring() {
//   var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
//   var _config$stiff = config.stiff,
//     stiff = _config$stiff === void 0 ? 100 : _config$stiff,
//     _config$damping = config.damping,
//     damping = _config$damping === void 0 ? 8 : _config$damping,
//     _config$dt = config.dt,
//     dt = _config$dt === void 0 ? 17 : _config$dt;
//   var stepper = function stepper(currX, destX, currV) {
//     var FSpring = -(currX - destX) * stiff;
//     var FDamping = currV * damping;
//     var newV = currV + (FSpring - FDamping) * dt / 1000;
//     var newX = currV * dt / 1000 + currX;
//     if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
//       return [destX, 0];
//     }
//     return [newX, newV];
//   };
//   stepper.isStepper = true;
//   stepper.dt = dt;
//   return stepper;
// };
// var configEasing = function configEasing() {
//   for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
//     args[_key2] = arguments[_key2];
//   }
//   var easing = args[0];
//   if (typeof easing === 'string') {
//     switch (easing) {
//       case 'ease':
//       case 'ease-in-out':
//       case 'ease-out':
//       case 'ease-in':
//       case 'linear':
//         return configBezier(easing);
//       case 'spring':
//         return configSpring();
//       default:
//         if (easing.split('(')[0] === 'cubic-bezier') {
//           return configBezier(easing);
//         }
//         warn(false, "[configEasing]: first argument should be one of 'ease', 'ease-in', " + "'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', 'linear' and 'spring', instead  received %s", args);
//     }
//   }
//   if (typeof easing === 'function') {
//     return easing;
//   }
//   warn(false, '[configEasing]: first argument type should be function or string, instead received %s', args);
//   return null;
// };

// function _typeof$w(obj) { "@babel/helpers - typeof"; return _typeof$w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$w(obj); }
// function _toConsumableArray$a(arr) { return _arrayWithoutHoles$a(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$g(arr) || _nonIterableSpread$a(); }
// function _nonIterableSpread$a() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _iterableToArray$a(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$a(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$g(arr); }
// function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
// function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$s(Object(source), !0).forEach(function (key) { _defineProperty$u(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$s(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// function _defineProperty$u(obj, key, value) { key = _toPropertyKey$v(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$v(arg) { var key = _toPrimitive$v(arg, "string"); return _typeof$w(key) === "symbol" ? key : String(key); }
// function _toPrimitive$v(input, hint) { if (_typeof$w(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$w(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _slicedToArray$8(arr, i) { return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$g(arr, i) || _nonIterableRest$8(); }
// function _nonIterableRest$8() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$g(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$g(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen); }
// function _arrayLikeToArray$g(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$8(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
// function _arrayWithHoles$8(arr) { if (Array.isArray(arr)) return arr; }
// var alpha = function alpha(begin, end, k) {
//   return begin + (end - begin) * k;
// };
// var needContinue = function needContinue(_ref) {
//   var from = _ref.from,
//     to = _ref.to;
//   return from !== to;
// };

// /*
//  * @description: cal new from value and velocity in each stepper
//  * @return: { [styleProperty]: { from, to, velocity } }
//  */
// var calStepperVals = function calStepperVals(easing, preVals, steps) {
//   var nextStepVals = mapObject(function (key, val) {
//     if (needContinue(val)) {
//       var _easing = easing(val.from, val.to, val.velocity),
//         _easing2 = _slicedToArray$8(_easing, 2),
//         newX = _easing2[0],
//         newV = _easing2[1];
//       return _objectSpread$s(_objectSpread$s({}, val), {}, {
//         from: newX,
//         velocity: newV
//       });
//     }
//     return val;
//   }, preVals);
//   if (steps < 1) {
//     return mapObject(function (key, val) {
//       if (needContinue(val)) {
//         return _objectSpread$s(_objectSpread$s({}, val), {}, {
//           velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
//           from: alpha(val.from, nextStepVals[key].from, steps)
//         });
//       }
//       return val;
//     }, preVals);
//   }
//   return calStepperVals(easing, nextStepVals, steps - 1);
// };

// // configure update function
// var configUpdate = (function (from, to, easing, duration, render) {
//   var interKeys = getIntersectionKeys(from, to);
//   var timingStyle = interKeys.reduce(function (res, key) {
//     return _objectSpread$s(_objectSpread$s({}, res), {}, _defineProperty$u({}, key, [from[key], to[key]]));
//   }, {});
//   var stepperStyle = interKeys.reduce(function (res, key) {
//     return _objectSpread$s(_objectSpread$s({}, res), {}, _defineProperty$u({}, key, {
//       from: from[key],
//       velocity: 0,
//       to: to[key]
//     }));
//   }, {});
//   var cafId = -1;
//   var preTime;
//   var beginTime;
//   var update = function update() {
//     return null;
//   };
//   var getCurrStyle = function getCurrStyle() {
//     return mapObject(function (key, val) {
//       return val.from;
//     }, stepperStyle);
//   };
//   var shouldStopAnimation = function shouldStopAnimation() {
//     return !Object.values(stepperStyle).filter(needContinue).length;
//   };

//   // stepper timing function like spring
//   var stepperUpdate = function stepperUpdate(now) {
//     if (!preTime) {
//       preTime = now;
//     }
//     var deltaTime = now - preTime;
//     var steps = deltaTime / easing.dt;
//     stepperStyle = calStepperVals(easing, stepperStyle, steps);
//     // get union set and add compatible prefix
//     render(_objectSpread$s(_objectSpread$s(_objectSpread$s({}, from), to), getCurrStyle()));
//     preTime = now;
//     if (!shouldStopAnimation()) {
//       cafId = requestAnimationFrame(update);
//     }
//   };

//   // t => val timing function like cubic-bezier
//   var timingUpdate = function timingUpdate(now) {
//     if (!beginTime) {
//       beginTime = now;
//     }
//     var t = (now - beginTime) / duration;
//     var currStyle = mapObject(function (key, val) {
//       return alpha.apply(void 0, _toConsumableArray$a(val).concat([easing(t)]));
//     }, timingStyle);

//     // get union set and add compatible prefix
//     render(_objectSpread$s(_objectSpread$s(_objectSpread$s({}, from), to), currStyle));
//     if (t < 1) {
//       cafId = requestAnimationFrame(update);
//     } else {
//       var finalStyle = mapObject(function (key, val) {
//         return alpha.apply(void 0, _toConsumableArray$a(val).concat([easing(1)]));
//       }, timingStyle);
//       render(_objectSpread$s(_objectSpread$s(_objectSpread$s({}, from), to), finalStyle));
//     }
//   };
//   update = easing.isStepper ? stepperUpdate : timingUpdate;

//   // return start animation method
//   return function () {
//     requestAnimationFrame(update);

//     // return stop animation method
//     return function () {
//       cancelAnimationFrame(cafId);
//     };
//   };
// });

// function _typeof$v(obj) { "@babel/helpers - typeof"; return _typeof$v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$v(obj); }
// var _excluded$d = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"];
// function _objectWithoutProperties$c(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$c(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$c(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function _toConsumableArray$9(arr) { return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$9(); }
// function _nonIterableSpread$9() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$f(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$f(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen); }
// function _iterableToArray$9(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$9(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$f(arr); }
// function _arrayLikeToArray$f(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
// function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$r(Object(source), !0).forEach(function (key) { _defineProperty$t(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// function _defineProperty$t(obj, key, value) { key = _toPropertyKey$u(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _classCallCheck$b(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$b(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$u(descriptor.key), descriptor); } }
// function _createClass$b(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$b(Constructor.prototype, protoProps); if (staticProps) _defineProperties$b(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _toPropertyKey$u(arg) { var key = _toPrimitive$u(arg, "string"); return _typeof$v(key) === "symbol" ? key : String(key); }
// function _toPrimitive$u(input, hint) { if (_typeof$v(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$v(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$9(subClass, superClass); }
// function _setPrototypeOf$9(o, p) { _setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$9(o, p); }
// function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf$8(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$8(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$8(this, result); }; }
// function _possibleConstructorReturn$8(self, call) { if (call && (_typeof$v(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$8(self); }
// function _assertThisInitialized$8(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$8(o) { _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$8(o); }
// var Animate = /*#__PURE__*/function (_PureComponent) {
//   _inherits$8(Animate, _PureComponent);
//   var _super = _createSuper$8(Animate);
//   function Animate(props, context) {
//     var _this;
//     _classCallCheck$b(this, Animate);
//     _this = _super.call(this, props, context);
//     var _this$props = _this.props,
//       isActive = _this$props.isActive,
//       attributeName = _this$props.attributeName,
//       from = _this$props.from,
//       to = _this$props.to,
//       steps = _this$props.steps,
//       children = _this$props.children,
//       duration = _this$props.duration;
//     _this.handleStyleChange = _this.handleStyleChange.bind(_assertThisInitialized$8(_this));
//     _this.changeStyle = _this.changeStyle.bind(_assertThisInitialized$8(_this));
//     if (!isActive || duration <= 0) {
//       _this.state = {
//         style: {}
//       };

//       // if children is a function and animation is not active, set style to 'to'
//       if (typeof children === 'function') {
//         _this.state = {
//           style: to
//         };
//       }
//       return _possibleConstructorReturn$8(_this);
//     }
//     if (steps && steps.length) {
//       _this.state = {
//         style: steps[0].style
//       };
//     } else if (from) {
//       if (typeof children === 'function') {
//         _this.state = {
//           style: from
//         };
//         return _possibleConstructorReturn$8(_this);
//       }
//       _this.state = {
//         style: attributeName ? _defineProperty$t({}, attributeName, from) : from
//       };
//     } else {
//       _this.state = {
//         style: {}
//       };
//     }
//     return _this;
//   }
//   _createClass$b(Animate, [{
//     key: "componentDidMount",
//     value: function componentDidMount() {
//       var _this$props2 = this.props,
//         isActive = _this$props2.isActive,
//         canBegin = _this$props2.canBegin;
//       this.mounted = true;
//       if (!isActive || !canBegin) {
//         return;
//       }
//       this.runAnimation(this.props);
//     }
//   }, {
//     key: "componentDidUpdate",
//     value: function componentDidUpdate(prevProps) {
//       var _this$props3 = this.props,
//         isActive = _this$props3.isActive,
//         canBegin = _this$props3.canBegin,
//         attributeName = _this$props3.attributeName,
//         shouldReAnimate = _this$props3.shouldReAnimate,
//         to = _this$props3.to,
//         currentFrom = _this$props3.from;
//       var style = this.state.style;
//       if (!canBegin) {
//         return;
//       }
//       if (!isActive) {
//         var newState = {
//           style: attributeName ? _defineProperty$t({}, attributeName, to) : to
//         };
//         if (this.state && style) {
//           if (attributeName && style[attributeName] !== to || !attributeName && style !== to) {
//             // eslint-disable-next-line react/no-did-update-set-state
//             this.setState(newState);
//           }
//         }
//         return;
//       }
//       if (deepEqual(prevProps.to, to) && prevProps.canBegin && prevProps.isActive) {
//         return;
//       }
//       var isTriggered = !prevProps.canBegin || !prevProps.isActive;
//       if (this.manager) {
//         this.manager.stop();
//       }
//       if (this.stopJSAnimation) {
//         this.stopJSAnimation();
//       }
//       var from = isTriggered || shouldReAnimate ? currentFrom : prevProps.to;
//       if (this.state && style) {
//         var _newState = {
//           style: attributeName ? _defineProperty$t({}, attributeName, from) : from
//         };
//         if (attributeName && [attributeName] !== from || !attributeName && style !== from) {
//           // eslint-disable-next-line react/no-did-update-set-state
//           this.setState(_newState);
//         }
//       }
//       this.runAnimation(_objectSpread$r(_objectSpread$r({}, this.props), {}, {
//         from: from,
//         begin: 0
//       }));
//     }
//   }, {
//     key: "componentWillUnmount",
//     value: function componentWillUnmount() {
//       this.mounted = false;
//       var onAnimationEnd = this.props.onAnimationEnd;
//       if (this.unSubscribe) {
//         this.unSubscribe();
//       }
//       if (this.manager) {
//         this.manager.stop();
//         this.manager = null;
//       }
//       if (this.stopJSAnimation) {
//         this.stopJSAnimation();
//       }
//       if (onAnimationEnd) {
//         onAnimationEnd();
//       }
//     }
//   }, {
//     key: "handleStyleChange",
//     value: function handleStyleChange(style) {
//       this.changeStyle(style);
//     }
//   }, {
//     key: "changeStyle",
//     value: function changeStyle(style) {
//       if (this.mounted) {
//         this.setState({
//           style: style
//         });
//       }
//     }
//   }, {
//     key: "runJSAnimation",
//     value: function runJSAnimation(props) {
//       var _this2 = this;
//       var from = props.from,
//         to = props.to,
//         duration = props.duration,
//         easing = props.easing,
//         begin = props.begin,
//         onAnimationEnd = props.onAnimationEnd,
//         onAnimationStart = props.onAnimationStart;
//       var startAnimation = configUpdate(from, to, configEasing(easing), duration, this.changeStyle);
//       var finalStartAnimation = function finalStartAnimation() {
//         _this2.stopJSAnimation = startAnimation();
//       };
//       this.manager.start([onAnimationStart, begin, finalStartAnimation, duration, onAnimationEnd]);
//     }
//   }, {
//     key: "runStepAnimation",
//     value: function runStepAnimation(props) {
//       var _this3 = this;
//       var steps = props.steps,
//         begin = props.begin,
//         onAnimationStart = props.onAnimationStart;
//       var _steps$ = steps[0],
//         initialStyle = _steps$.style,
//         _steps$$duration = _steps$.duration,
//         initialTime = _steps$$duration === void 0 ? 0 : _steps$$duration;
//       var addStyle = function addStyle(sequence, nextItem, index) {
//         if (index === 0) {
//           return sequence;
//         }
//         var duration = nextItem.duration,
//           _nextItem$easing = nextItem.easing,
//           easing = _nextItem$easing === void 0 ? 'ease' : _nextItem$easing,
//           style = nextItem.style,
//           nextProperties = nextItem.properties,
//           onAnimationEnd = nextItem.onAnimationEnd;
//         var preItem = index > 0 ? steps[index - 1] : nextItem;
//         var properties = nextProperties || Object.keys(style);
//         if (typeof easing === 'function' || easing === 'spring') {
//           return [].concat(_toConsumableArray$9(sequence), [_this3.runJSAnimation.bind(_this3, {
//             from: preItem.style,
//             to: style,
//             duration: duration,
//             easing: easing
//           }), duration]);
//         }
//         var transition = getTransitionVal(properties, duration, easing);
//         var newStyle = _objectSpread$r(_objectSpread$r(_objectSpread$r({}, preItem.style), style), {}, {
//           transition: transition
//         });
//         return [].concat(_toConsumableArray$9(sequence), [newStyle, duration, onAnimationEnd]).filter(identity$1);
//       };
//       return this.manager.start([onAnimationStart].concat(_toConsumableArray$9(steps.reduce(addStyle, [initialStyle, Math.max(initialTime, begin)])), [props.onAnimationEnd]));
//     }
//   }, {
//     key: "runAnimation",
//     value: function runAnimation(props) {
//       if (!this.manager) {
//         this.manager = createAnimateManager();
//       }
//       var begin = props.begin,
//         duration = props.duration,
//         attributeName = props.attributeName,
//         propsTo = props.to,
//         easing = props.easing,
//         onAnimationStart = props.onAnimationStart,
//         onAnimationEnd = props.onAnimationEnd,
//         steps = props.steps,
//         children = props.children;
//       var manager = this.manager;
//       this.unSubscribe = manager.subscribe(this.handleStyleChange);
//       if (typeof easing === 'function' || typeof children === 'function' || easing === 'spring') {
//         this.runJSAnimation(props);
//         return;
//       }
//       if (steps.length > 1) {
//         this.runStepAnimation(props);
//         return;
//       }
//       var to = attributeName ? _defineProperty$t({}, attributeName, propsTo) : propsTo;
//       var transition = getTransitionVal(Object.keys(to), duration, easing);
//       manager.start([onAnimationStart, begin, _objectSpread$r(_objectSpread$r({}, to), {}, {
//         transition: transition
//       }), duration, onAnimationEnd]);
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this$props4 = this.props,
//         children = _this$props4.children;
//         _this$props4.begin;
//         var duration = _this$props4.duration;
//         _this$props4.attributeName;
//         _this$props4.easing;
//         var isActive = _this$props4.isActive;
//         _this$props4.steps;
//         _this$props4.from;
//         _this$props4.to;
//         _this$props4.canBegin;
//         _this$props4.onAnimationEnd;
//         _this$props4.shouldReAnimate;
//         _this$props4.onAnimationReStart;
//         var others = _objectWithoutProperties$c(_this$props4, _excluded$d);
//       var count = Children.count(children);
//       // eslint-disable-next-line react/destructuring-assignment
//       var stateStyle = translateStyle(this.state.style);
//       if (typeof children === 'function') {
//         return children(stateStyle);
//       }
//       if (!isActive || count === 0 || duration <= 0) {
//         return children;
//       }
//       var cloneContainer = function cloneContainer(container) {
//         var _container$props = container.props,
//           _container$props$styl = _container$props.style,
//           style = _container$props$styl === void 0 ? {} : _container$props$styl,
//           className = _container$props.className;
//         var res = /*#__PURE__*/cloneElement(container, _objectSpread$r(_objectSpread$r({}, others), {}, {
//           style: _objectSpread$r(_objectSpread$r({}, style), stateStyle),
//           className: className
//         }));
//         return res;
//       };
//       if (count === 1) {
//         return cloneContainer(Children.only(children));
//       }
//       return /*#__PURE__*/React__default.createElement("div", null, Children.map(children, function (child) {
//         return cloneContainer(child);
//       }));
//     }
//   }]);
//   return Animate;
// }(PureComponent);
// Animate.displayName = 'Animate';
// Animate.defaultProps = {
//   begin: 0,
//   duration: 1000,
//   from: '',
//   to: '',
//   attributeName: '',
//   easing: 'ease',
//   isActive: true,
//   canBegin: true,
//   steps: [],
//   onAnimationEnd: function onAnimationEnd() {},
//   onAnimationStart: function onAnimationStart() {}
// };
// Animate.propTypes = {
//   from: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.string]),
//   to: PropTypes__default.oneOfType([PropTypes__default.object, PropTypes__default.string]),
//   attributeName: PropTypes__default.string,
//   // animation duration
//   duration: PropTypes__default.number,
//   begin: PropTypes__default.number,
//   easing: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.func]),
//   steps: PropTypes__default.arrayOf(PropTypes__default.shape({
//     duration: PropTypes__default.number.isRequired,
//     style: PropTypes__default.object.isRequired,
//     easing: PropTypes__default.oneOfType([PropTypes__default.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']), PropTypes__default.func]),
//     // transition css properties(dash case), optional
//     properties: PropTypes__default.arrayOf('string'),
//     onAnimationEnd: PropTypes__default.func
//   })),
//   children: PropTypes__default.oneOfType([PropTypes__default.node, PropTypes__default.func]),
//   isActive: PropTypes__default.bool,
//   canBegin: PropTypes__default.bool,
//   onAnimationEnd: PropTypes__default.func,
//   // decide if it should reanimate with initial from style when props change
//   shouldReAnimate: PropTypes__default.bool,
//   onAnimationStart: PropTypes__default.func,
//   onAnimationReStart: PropTypes__default.func
// };

// if (Number.isFinite === undefined) {
//   Number.isFinite = function (value) {
//     return typeof value === 'number' && isFinite(value);
//   };
// }
// ({
//   appearOptions: PropTypes__default.object,
//   enterOptions: PropTypes__default.object,
//   leaveOptions: PropTypes__default.object,
//   children: PropTypes__default.element
// });

// ({
//   appear: PropTypes__default.object,
//   enter: PropTypes__default.object,
//   leave: PropTypes__default.object,
//   children: PropTypes__default.oneOfType([PropTypes__default.array, PropTypes__default.element]),
//   component: PropTypes__default.any
// });

// function _typeof$u(o) { "@babel/helpers - typeof"; return _typeof$u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$u(o); }
// function _defineProperty$s(obj, key, value) { key = _toPropertyKey$t(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$t(arg) { var key = _toPrimitive$t(arg, "string"); return _typeof$u(key) === "symbol" ? key : String(key); }
// function _toPrimitive$t(input, hint) { if (_typeof$u(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$u(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var CSS_CLASS_PREFIX = 'recharts-tooltip-wrapper';
// var TOOLTIP_HIDDEN = {
//   visibility: 'hidden'
// };
// function getTooltipCSSClassName(_ref) {
//   var _clsx;
//   var coordinate = _ref.coordinate,
//     translateX = _ref.translateX,
//     translateY = _ref.translateY;
//   return clsx(CSS_CLASS_PREFIX, (_clsx = {}, _defineProperty$s(_clsx, "".concat(CSS_CLASS_PREFIX, "-right"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x), _defineProperty$s(_clsx, "".concat(CSS_CLASS_PREFIX, "-left"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x), _defineProperty$s(_clsx, "".concat(CSS_CLASS_PREFIX, "-bottom"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y), _defineProperty$s(_clsx, "".concat(CSS_CLASS_PREFIX, "-top"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y), _clsx));
// }
// function getTooltipTranslateXY(_ref2) {
//   var allowEscapeViewBox = _ref2.allowEscapeViewBox,
//     coordinate = _ref2.coordinate,
//     key = _ref2.key,
//     offsetTopLeft = _ref2.offsetTopLeft,
//     position = _ref2.position,
//     reverseDirection = _ref2.reverseDirection,
//     tooltipDimension = _ref2.tooltipDimension,
//     viewBox = _ref2.viewBox,
//     viewBoxDimension = _ref2.viewBoxDimension;
//   if (position && isNumber(position[key])) {
//     return position[key];
//   }
//   var negative = coordinate[key] - tooltipDimension - offsetTopLeft;
//   var positive = coordinate[key] + offsetTopLeft;
//   if (allowEscapeViewBox[key]) {
//     return reverseDirection[key] ? negative : positive;
//   }
//   if (reverseDirection[key]) {
//     var _tooltipBoundary = negative;
//     var _viewBoxBoundary = viewBox[key];
//     if (_tooltipBoundary < _viewBoxBoundary) {
//       return Math.max(positive, viewBox[key]);
//     }
//     return Math.max(negative, viewBox[key]);
//   }
//   var tooltipBoundary = positive + tooltipDimension;
//   var viewBoxBoundary = viewBox[key] + viewBoxDimension;
//   if (tooltipBoundary > viewBoxBoundary) {
//     return Math.max(negative, viewBox[key]);
//   }
//   return Math.max(positive, viewBox[key]);
// }
// function getTransformStyle(_ref3) {
//   var translateX = _ref3.translateX,
//     translateY = _ref3.translateY,
//     useTranslate3d = _ref3.useTranslate3d;
//   return translateStyle({
//     transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
//   });
// }
// function getTooltipTranslate(_ref4) {
//   var allowEscapeViewBox = _ref4.allowEscapeViewBox,
//     coordinate = _ref4.coordinate,
//     offsetTopLeft = _ref4.offsetTopLeft,
//     position = _ref4.position,
//     reverseDirection = _ref4.reverseDirection,
//     tooltipBox = _ref4.tooltipBox,
//     useTranslate3d = _ref4.useTranslate3d,
//     viewBox = _ref4.viewBox;
//   var cssProperties, translateX, translateY;
//   if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
//     translateX = getTooltipTranslateXY({
//       allowEscapeViewBox: allowEscapeViewBox,
//       coordinate: coordinate,
//       key: 'x',
//       offsetTopLeft: offsetTopLeft,
//       position: position,
//       reverseDirection: reverseDirection,
//       tooltipDimension: tooltipBox.width,
//       viewBox: viewBox,
//       viewBoxDimension: viewBox.width
//     });
//     translateY = getTooltipTranslateXY({
//       allowEscapeViewBox: allowEscapeViewBox,
//       coordinate: coordinate,
//       key: 'y',
//       offsetTopLeft: offsetTopLeft,
//       position: position,
//       reverseDirection: reverseDirection,
//       tooltipDimension: tooltipBox.height,
//       viewBox: viewBox,
//       viewBoxDimension: viewBox.height
//     });
//     cssProperties = getTransformStyle({
//       translateX: translateX,
//       translateY: translateY,
//       useTranslate3d: useTranslate3d
//     });
//   } else {
//     cssProperties = TOOLTIP_HIDDEN;
//   }
//   return {
//     cssProperties: cssProperties,
//     cssClasses: getTooltipCSSClassName({
//       translateX: translateX,
//       translateY: translateY,
//       coordinate: coordinate
//     })
//   };
// }

// function _typeof$t(o) { "@babel/helpers - typeof"; return _typeof$t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$t(o); }
// function ownKeys$q(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$q(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$q(Object(t), !0).forEach(function (r) { _defineProperty$r(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _classCallCheck$a(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$a(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$s(descriptor.key), descriptor); } }
// function _createClass$a(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$a(Constructor.prototype, protoProps); if (staticProps) _defineProperties$a(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$8(subClass, superClass); }
// function _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }
// function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf$7(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$7(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$7(this, result); }; }
// function _possibleConstructorReturn$7(self, call) { if (call && (_typeof$t(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$7(self); }
// function _assertThisInitialized$7(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$7(o) { _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$7(o); }
// function _defineProperty$r(obj, key, value) { key = _toPropertyKey$s(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$s(arg) { var key = _toPrimitive$s(arg, "string"); return _typeof$t(key) === "symbol" ? key : String(key); }
// function _toPrimitive$s(input, hint) { if (_typeof$t(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$t(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var EPSILON = 1;
// var TooltipBoundingBox = /*#__PURE__*/function (_PureComponent) {
//   _inherits$7(TooltipBoundingBox, _PureComponent);
//   var _super = _createSuper$7(TooltipBoundingBox);
//   function TooltipBoundingBox() {
//     var _this;
//     _classCallCheck$a(this, TooltipBoundingBox);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$r(_assertThisInitialized$7(_this), "state", {
//       dismissed: false,
//       dismissedAtCoordinate: {
//         x: 0,
//         y: 0
//       }
//     });
//     _defineProperty$r(_assertThisInitialized$7(_this), "lastBoundingBox", {
//       width: -1,
//       height: -1
//     });
//     _defineProperty$r(_assertThisInitialized$7(_this), "handleKeyDown", function (event) {
//       if (event.key === 'Escape') {
//         var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
//         _this.setState({
//           dismissed: true,
//           dismissedAtCoordinate: {
//             x: (_this$props$coordinat = (_this$props$coordinat2 = _this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
//             y: (_this$props$coordinat3 = (_this$props$coordinat4 = _this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
//           }
//         });
//       }
//     });
//     return _this;
//   }
//   _createClass$a(TooltipBoundingBox, [{
//     key: "updateBBox",
//     value: function updateBBox() {
//       if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
//         var box = this.wrapperNode.getBoundingClientRect();
//         if (Math.abs(box.width - this.lastBoundingBox.width) > EPSILON || Math.abs(box.height - this.lastBoundingBox.height) > EPSILON) {
//           this.lastBoundingBox.width = box.width;
//           this.lastBoundingBox.height = box.height;
//         }
//       } else if (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) {
//         this.lastBoundingBox.width = -1;
//         this.lastBoundingBox.height = -1;
//       }
//     }
//   }, {
//     key: "componentDidMount",
//     value: function componentDidMount() {
//       document.addEventListener('keydown', this.handleKeyDown);
//       this.updateBBox();
//     }
//   }, {
//     key: "componentWillUnmount",
//     value: function componentWillUnmount() {
//       document.removeEventListener('keydown', this.handleKeyDown);
//     }
//   }, {
//     key: "componentDidUpdate",
//     value: function componentDidUpdate() {
//       var _this$props$coordinat5, _this$props$coordinat6;
//       if (this.props.active) {
//         this.updateBBox();
//       }
//       if (!this.state.dismissed) {
//         return;
//       }
//       if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {
//         this.state.dismissed = false;
//       }
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this2 = this;
//       var _this$props = this.props,
//         active = _this$props.active,
//         allowEscapeViewBox = _this$props.allowEscapeViewBox,
//         animationDuration = _this$props.animationDuration,
//         animationEasing = _this$props.animationEasing,
//         children = _this$props.children,
//         coordinate = _this$props.coordinate,
//         hasPayload = _this$props.hasPayload,
//         isAnimationActive = _this$props.isAnimationActive,
//         offset = _this$props.offset,
//         position = _this$props.position,
//         reverseDirection = _this$props.reverseDirection,
//         useTranslate3d = _this$props.useTranslate3d,
//         viewBox = _this$props.viewBox,
//         wrapperStyle = _this$props.wrapperStyle;
//       var _getTooltipTranslate = getTooltipTranslate({
//           allowEscapeViewBox: allowEscapeViewBox,
//           coordinate: coordinate,
//           offsetTopLeft: offset,
//           position: position,
//           reverseDirection: reverseDirection,
//           tooltipBox: {
//             height: this.lastBoundingBox.height,
//             width: this.lastBoundingBox.width
//           },
//           useTranslate3d: useTranslate3d,
//           viewBox: viewBox
//         }),
//         cssClasses = _getTooltipTranslate.cssClasses,
//         cssProperties = _getTooltipTranslate.cssProperties;
//       var outerStyle = _objectSpread$q(_objectSpread$q(_objectSpread$q({}, isAnimationActive && active && translateStyle({
//         transition: "transform ".concat(animationDuration, "ms ").concat(animationEasing)
//       })), cssProperties), {}, {
//         pointerEvents: 'none',
//         visibility: !this.state.dismissed && active && hasPayload ? 'visible' : 'hidden',
//         position: 'absolute',
//         top: 0,
//         left: 0
//       }, wrapperStyle);
//       return (
//         /*#__PURE__*/
//         // This element allow listening to the `Escape` key.
//         // See https://github.com/recharts/recharts/pull/2925
//         React__default.createElement("div", {
//           tabIndex: -1,
//           role: "dialog",
//           className: cssClasses,
//           style: outerStyle,
//           ref: function ref(node) {
//             _this2.wrapperNode = node;
//           }
//         }, children)
//       );
//     }
//   }]);
//   return TooltipBoundingBox;
// }(PureComponent);

// var parseIsSsrByDefault = function parseIsSsrByDefault() {
//   return !(typeof window !== 'undefined' && window.document && window.document.createElement && window.setTimeout);
// };
// var Global = {
//   isSsr: parseIsSsrByDefault(),
//   get: function get(key) {
//     return Global[key];
//   },
//   set: function set(key, value) {
//     if (typeof key === 'string') {
//       Global[key] = value;
//     } else {
//       var keys = Object.keys(key);
//       if (keys && keys.length) {
//         keys.forEach(function (k) {
//           Global[k] = key[k];
//         });
//       }
//     }
//   }
// };

// function _typeof$s(o) { "@babel/helpers - typeof"; return _typeof$s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$s(o); }
// function ownKeys$p(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$p(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$p(Object(t), !0).forEach(function (r) { _defineProperty$q(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$9(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$r(descriptor.key), descriptor); } }
// function _createClass$9(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$9(Constructor.prototype, protoProps); if (staticProps) _defineProperties$9(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$7(subClass, superClass); }
// function _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }
// function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf$6(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$6(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$6(this, result); }; }
// function _possibleConstructorReturn$6(self, call) { if (call && (_typeof$s(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$6(self); }
// function _assertThisInitialized$6(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$6(o) { _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$6(o); }
// function _defineProperty$q(obj, key, value) { key = _toPropertyKey$r(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$r(arg) { var key = _toPrimitive$r(arg, "string"); return _typeof$s(key) === "symbol" ? key : String(key); }
// function _toPrimitive$r(input, hint) { if (_typeof$s(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$s(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function defaultUniqBy(entry) {
//   return entry.dataKey;
// }
// function renderContent(content, props) {
//   if ( /*#__PURE__*/React__default.isValidElement(content)) {
//     return /*#__PURE__*/React__default.cloneElement(content, props);
//   }
//   if (typeof content === 'function') {
//     return /*#__PURE__*/React__default.createElement(content, props);
//   }
//   return /*#__PURE__*/React__default.createElement(DefaultTooltipContent, props);
// }
// var Tooltip = /*#__PURE__*/function (_PureComponent) {
//   _inherits$6(Tooltip, _PureComponent);
//   var _super = _createSuper$6(Tooltip);
//   function Tooltip() {
//     _classCallCheck$9(this, Tooltip);
//     return _super.apply(this, arguments);
//   }
//   _createClass$9(Tooltip, [{
//     key: "render",
//     value: function render() {
//       var _this$props = this.props,
//         active = _this$props.active,
//         allowEscapeViewBox = _this$props.allowEscapeViewBox,
//         animationDuration = _this$props.animationDuration,
//         animationEasing = _this$props.animationEasing,
//         content = _this$props.content,
//         coordinate = _this$props.coordinate,
//         filterNull = _this$props.filterNull,
//         isAnimationActive = _this$props.isAnimationActive,
//         offset = _this$props.offset,
//         payload = _this$props.payload,
//         payloadUniqBy = _this$props.payloadUniqBy,
//         position = _this$props.position,
//         reverseDirection = _this$props.reverseDirection,
//         useTranslate3d = _this$props.useTranslate3d,
//         viewBox = _this$props.viewBox,
//         wrapperStyle = _this$props.wrapperStyle;
//       var finalPayload = payload !== null && payload !== void 0 ? payload : [];
//       if (filterNull && finalPayload.length) {
//         finalPayload = getUniqPayload(payload.filter(function (entry) {
//           return entry.value != null;
//         }), payloadUniqBy, defaultUniqBy);
//       }
//       var hasPayload = finalPayload.length > 0;
//       return /*#__PURE__*/React__default.createElement(TooltipBoundingBox, {
//         allowEscapeViewBox: allowEscapeViewBox,
//         animationDuration: animationDuration,
//         animationEasing: animationEasing,
//         isAnimationActive: isAnimationActive,
//         active: active,
//         coordinate: coordinate,
//         hasPayload: hasPayload,
//         offset: offset,
//         position: position,
//         reverseDirection: reverseDirection,
//         useTranslate3d: useTranslate3d,
//         viewBox: viewBox,
//         wrapperStyle: wrapperStyle
//       }, renderContent(content, _objectSpread$p(_objectSpread$p({}, this.props), {}, {
//         payload: finalPayload
//       })));
//     }
//   }]);
//   return Tooltip;
// }(PureComponent);
// _defineProperty$q(Tooltip, "displayName", 'Tooltip');
// _defineProperty$q(Tooltip, "defaultProps", {
//   allowEscapeViewBox: {
//     x: false,
//     y: false
//   },
//   animationDuration: 400,
//   animationEasing: 'ease',
//   contentStyle: {},
//   coordinate: {
//     x: 0,
//     y: 0
//   },
//   cursor: true,
//   cursorStyle: {},
//   filterNull: true,
//   isAnimationActive: !Global.isSsr,
//   itemStyle: {},
//   labelStyle: {},
//   offset: 10,
//   reverseDirection: {
//     x: false,
//     y: false
//   },
//   separator: ' : ',
//   trigger: 'hover',
//   useTranslate3d: false,
//   viewBox: {
//     x: 0,
//     y: 0,
//     height: 0,
//     width: 0
//   },
//   wrapperStyle: {}
// });

// /**
//  * @fileOverview Cross
//  */

// var Cell = function Cell(_props) {
//   return null;
// };
// Cell.displayName = 'Cell';

// function _typeof$r(o) { "@babel/helpers - typeof"; return _typeof$r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$r(o); }
// function ownKeys$o(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$o(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$o(Object(t), !0).forEach(function (r) { _defineProperty$p(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$p(obj, key, value) { key = _toPropertyKey$q(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$q(arg) { var key = _toPrimitive$q(arg, "string"); return _typeof$r(key) === "symbol" ? key : String(key); }
// function _toPrimitive$q(input, hint) { if (_typeof$r(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$r(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var stringCache = {
//   widthCache: {},
//   cacheCount: 0
// };
// var MAX_CACHE_NUM = 2000;
// var SPAN_STYLE = {
//   position: 'absolute',
//   top: '-20000px',
//   left: 0,
//   padding: 0,
//   margin: 0,
//   border: 'none',
//   whiteSpace: 'pre'
// };
// var MEASUREMENT_SPAN_ID = 'recharts_measurement_span';
// function removeInvalidKeys(obj) {
//   var copyObj = _objectSpread$o({}, obj);
//   Object.keys(copyObj).forEach(function (key) {
//     if (!copyObj[key]) {
//       delete copyObj[key];
//     }
//   });
//   return copyObj;
// }
// var getStringSize = function getStringSize(text) {
//   var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
//   if (text === undefined || text === null || Global.isSsr) {
//     return {
//       width: 0,
//       height: 0
//     };
//   }
//   var copyStyle = removeInvalidKeys(style);
//   var cacheKey = JSON.stringify({
//     text: text,
//     copyStyle: copyStyle
//   });
//   if (stringCache.widthCache[cacheKey]) {
//     return stringCache.widthCache[cacheKey];
//   }
//   try {
//     var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
//     if (!measurementSpan) {
//       measurementSpan = document.createElement('span');
//       measurementSpan.setAttribute('id', MEASUREMENT_SPAN_ID);
//       measurementSpan.setAttribute('aria-hidden', 'true');
//       document.body.appendChild(measurementSpan);
//     }
//     // Need to use CSS Object Model (CSSOM) to be able to comply with Content Security Policy (CSP)
//     // https://en.wikipedia.org/wiki/Content_Security_Policy
//     var measurementSpanStyle = _objectSpread$o(_objectSpread$o({}, SPAN_STYLE), copyStyle);
//     Object.assign(measurementSpan.style, measurementSpanStyle);
//     measurementSpan.textContent = "".concat(text);
//     var rect = measurementSpan.getBoundingClientRect();
//     var result = {
//       width: rect.width,
//       height: rect.height
//     };
//     stringCache.widthCache[cacheKey] = result;
//     if (++stringCache.cacheCount > MAX_CACHE_NUM) {
//       stringCache.cacheCount = 0;
//       stringCache.widthCache = {};
//     }
//     return result;
//   } catch (e) {
//     return {
//       width: 0,
//       height: 0
//     };
//   }
// };
// var getOffset = function getOffset(rect) {
//   return {
//     top: rect.top + window.scrollY - document.documentElement.clientTop,
//     left: rect.left + window.scrollX - document.documentElement.clientLeft
//   };
// };

// function _typeof$q(o) { "@babel/helpers - typeof"; return _typeof$q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$q(o); }
// function _slicedToArray$7(arr, i) { return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$e(arr, i) || _nonIterableRest$7(); }
// function _nonIterableRest$7() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$e(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$e(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen); }
// function _arrayLikeToArray$e(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$7(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles$7(arr) { if (Array.isArray(arr)) return arr; }
// function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$p(descriptor.key), descriptor); } }
// function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _toPropertyKey$p(arg) { var key = _toPrimitive$p(arg, "string"); return _typeof$q(key) === "symbol" ? key : String(key); }
// function _toPrimitive$p(input, hint) { if (_typeof$q(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$q(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
// var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
// var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
// var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
// var CONVERSION_RATES = {
//   cm: 96 / 2.54,
//   mm: 96 / 25.4,
//   pt: 96 / 72,
//   pc: 96 / 6,
//   "in": 96,
//   Q: 96 / (2.54 * 40),
//   px: 1
// };
// var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
// var STR_NAN = 'NaN';
// function convertToPx(value, unit) {
//   return value * CONVERSION_RATES[unit];
// }
// var DecimalCSS = /*#__PURE__*/function () {
//   function DecimalCSS(num, unit) {
//     _classCallCheck$8(this, DecimalCSS);
//     this.num = num;
//     this.unit = unit;
//     this.num = num;
//     this.unit = unit;
//     if (Number.isNaN(num)) {
//       this.unit = '';
//     }
//     if (unit !== '' && !CSS_LENGTH_UNIT_REGEX.test(unit)) {
//       this.num = NaN;
//       this.unit = '';
//     }
//     if (FIXED_CSS_LENGTH_UNITS.includes(unit)) {
//       this.num = convertToPx(num, unit);
//       this.unit = 'px';
//     }
//   }
//   _createClass$8(DecimalCSS, [{
//     key: "add",
//     value: function add(other) {
//       if (this.unit !== other.unit) {
//         return new DecimalCSS(NaN, '');
//       }
//       return new DecimalCSS(this.num + other.num, this.unit);
//     }
//   }, {
//     key: "subtract",
//     value: function subtract(other) {
//       if (this.unit !== other.unit) {
//         return new DecimalCSS(NaN, '');
//       }
//       return new DecimalCSS(this.num - other.num, this.unit);
//     }
//   }, {
//     key: "multiply",
//     value: function multiply(other) {
//       if (this.unit !== '' && other.unit !== '' && this.unit !== other.unit) {
//         return new DecimalCSS(NaN, '');
//       }
//       return new DecimalCSS(this.num * other.num, this.unit || other.unit);
//     }
//   }, {
//     key: "divide",
//     value: function divide(other) {
//       if (this.unit !== '' && other.unit !== '' && this.unit !== other.unit) {
//         return new DecimalCSS(NaN, '');
//       }
//       return new DecimalCSS(this.num / other.num, this.unit || other.unit);
//     }
//   }, {
//     key: "toString",
//     value: function toString() {
//       return "".concat(this.num).concat(this.unit);
//     }
//   }, {
//     key: "isNaN",
//     value: function isNaN() {
//       return Number.isNaN(this.num);
//     }
//   }], [{
//     key: "parse",
//     value: function parse(str) {
//       var _NUM_SPLIT_REGEX$exec;
//       var _ref = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [],
//         _ref2 = _slicedToArray$7(_ref, 3),
//         numStr = _ref2[1],
//         unit = _ref2[2];
//       return new DecimalCSS(parseFloat(numStr), unit !== null && unit !== void 0 ? unit : '');
//     }
//   }]);
//   return DecimalCSS;
// }();
// function calculateArithmetic(expr) {
//   if (expr.includes(STR_NAN)) {
//     return STR_NAN;
//   }
//   var newExpr = expr;
//   while (newExpr.includes('*') || newExpr.includes('/')) {
//     var _MULTIPLY_OR_DIVIDE_R;
//     var _ref3 = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [],
//       _ref4 = _slicedToArray$7(_ref3, 4),
//       leftOperand = _ref4[1],
//       operator = _ref4[2],
//       rightOperand = _ref4[3];
//     var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : '');
//     var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : '');
//     var result = operator === '*' ? lTs.multiply(rTs) : lTs.divide(rTs);
//     if (result.isNaN()) {
//       return STR_NAN;
//     }
//     newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
//   }
//   while (newExpr.includes('+') || /.-\d+(?:\.\d+)?/.test(newExpr)) {
//     var _ADD_OR_SUBTRACT_REGE;
//     var _ref5 = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [],
//       _ref6 = _slicedToArray$7(_ref5, 4),
//       _leftOperand = _ref6[1],
//       _operator = _ref6[2],
//       _rightOperand = _ref6[3];
//     var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : '');
//     var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : '');
//     var _result = _operator === '+' ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
//     if (_result.isNaN()) {
//       return STR_NAN;
//     }
//     newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
//   }
//   return newExpr;
// }
// var PARENTHESES_REGEX = /\(([^()]*)\)/;
// function calculateParentheses(expr) {
//   var newExpr = expr;
//   while (newExpr.includes('(')) {
//     var _PARENTHESES_REGEX$ex = PARENTHESES_REGEX.exec(newExpr),
//       _PARENTHESES_REGEX$ex2 = _slicedToArray$7(_PARENTHESES_REGEX$ex, 2),
//       parentheticalExpression = _PARENTHESES_REGEX$ex2[1];
//     newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
//   }
//   return newExpr;
// }
// function evaluateExpression(expression) {
//   var newExpr = expression.replace(/\s+/g, '');
//   newExpr = calculateParentheses(newExpr);
//   newExpr = calculateArithmetic(newExpr);
//   return newExpr;
// }
// function safeEvaluateExpression(expression) {
//   try {
//     return evaluateExpression(expression);
//   } catch (e) {
//     /* istanbul ignore next */
//     return STR_NAN;
//   }
// }
// function reduceCSSCalc(expression) {
//   var result = safeEvaluateExpression(expression.slice(5, -1));
//   if (result === STR_NAN) {
//     // notify the user
//     return '';
//   }
//   return result;
// }

// var _excluded$c = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"],
//   _excluded2$4 = ["dx", "dy", "angle", "className", "breakAll"];
// function _extends$j() { _extends$j = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$j.apply(this, arguments); }
// function _objectWithoutProperties$b(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$b(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$b(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function _slicedToArray$6(arr, i) { return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$d(arr, i) || _nonIterableRest$6(); }
// function _nonIterableRest$6() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$d(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$d(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen); }
// function _arrayLikeToArray$d(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$6(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles$6(arr) { if (Array.isArray(arr)) return arr; }
// var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
// var calculateWordWidths = function calculateWordWidths(_ref) {
//   var children = _ref.children,
//     breakAll = _ref.breakAll,
//     style = _ref.style;
//   try {
//     var words = [];
//     if (!isNil$1(children)) {
//       if (breakAll) {
//         words = children.toString().split('');
//       } else {
//         words = children.toString().split(BREAKING_SPACES);
//       }
//     }
//     var wordsWithComputedWidth = words.map(function (word) {
//       return {
//         word: word,
//         width: getStringSize(word, style).width
//       };
//     });
//     var spaceWidth = breakAll ? 0 : getStringSize("\xA0", style).width;
//     return {
//       wordsWithComputedWidth: wordsWithComputedWidth,
//       spaceWidth: spaceWidth
//     };
//   } catch (e) {
//     return null;
//   }
// };
// var calculateWordsByLines = function calculateWordsByLines(_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {
//   var maxLines = _ref2.maxLines,
//     children = _ref2.children,
//     style = _ref2.style,
//     breakAll = _ref2.breakAll;
//   var shouldLimitLines = isNumber(maxLines);
//   var text = children;
//   var calculate = function calculate() {
//     var words = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
//     return words.reduce(function (result, _ref3) {
//       var word = _ref3.word,
//         width = _ref3.width;
//       var currentLine = result[result.length - 1];
//       if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
//         // Word can be added to an existing line
//         currentLine.words.push(word);
//         currentLine.width += width + spaceWidth;
//       } else {
//         // Add first word to line or word is too long to scaleToFit on existing line
//         var newLine = {
//           words: [word],
//           width: width
//         };
//         result.push(newLine);
//       }
//       return result;
//     }, []);
//   };
//   var originalResult = calculate(initialWordsWithComputedWith);
//   var findLongestLine = function findLongestLine(words) {
//     return words.reduce(function (a, b) {
//       return a.width > b.width ? a : b;
//     });
//   };
//   if (!shouldLimitLines) {
//     return originalResult;
//   }
//   var suffix = '…';
//   var checkOverflow = function checkOverflow(index) {
//     var tempText = text.slice(0, index);
//     var words = calculateWordWidths({
//       breakAll: breakAll,
//       style: style,
//       children: tempText + suffix
//     }).wordsWithComputedWidth;
//     var result = calculate(words);
//     var doesOverflow = result.length > maxLines || findLongestLine(result).width > Number(lineWidth);
//     return [doesOverflow, result];
//   };
//   var start = 0;
//   var end = text.length - 1;
//   var iterations = 0;
//   var trimmedResult;
//   while (start <= end && iterations <= text.length - 1) {
//     var middle = Math.floor((start + end) / 2);
//     var prev = middle - 1;
//     var _checkOverflow = checkOverflow(prev),
//       _checkOverflow2 = _slicedToArray$6(_checkOverflow, 2),
//       doesPrevOverflow = _checkOverflow2[0],
//       result = _checkOverflow2[1];
//     var _checkOverflow3 = checkOverflow(middle),
//       _checkOverflow4 = _slicedToArray$6(_checkOverflow3, 1),
//       doesMiddleOverflow = _checkOverflow4[0];
//     if (!doesPrevOverflow && !doesMiddleOverflow) {
//       start = middle + 1;
//     }
//     if (doesPrevOverflow && doesMiddleOverflow) {
//       end = middle - 1;
//     }
//     if (!doesPrevOverflow && doesMiddleOverflow) {
//       trimmedResult = result;
//       break;
//     }
//     iterations++;
//   }

//   // Fallback to originalResult (result without trimming) if we cannot find the
//   // where to trim.  This should not happen :tm:
//   return trimmedResult || originalResult;
// };
// var getWordsWithoutCalculate = function getWordsWithoutCalculate(children) {
//   var words = !isNil$1(children) ? children.toString().split(BREAKING_SPACES) : [];
//   return [{
//     words: words
//   }];
// };
// var getWordsByLines = function getWordsByLines(_ref4) {
//   var width = _ref4.width,
//     scaleToFit = _ref4.scaleToFit,
//     children = _ref4.children,
//     style = _ref4.style,
//     breakAll = _ref4.breakAll,
//     maxLines = _ref4.maxLines;
//   // Only perform calculations if using features that require them (multiline, scaleToFit)
//   if ((width || scaleToFit) && !Global.isSsr) {
//     var wordsWithComputedWidth, spaceWidth;
//     var wordWidths = calculateWordWidths({
//       breakAll: breakAll,
//       children: children,
//       style: style
//     });
//     if (wordWidths) {
//       var wcw = wordWidths.wordsWithComputedWidth,
//         sw = wordWidths.spaceWidth;
//       wordsWithComputedWidth = wcw;
//       spaceWidth = sw;
//     } else {
//       return getWordsWithoutCalculate(children);
//     }
//     return calculateWordsByLines({
//       breakAll: breakAll,
//       children: children,
//       maxLines: maxLines,
//       style: style
//     }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
//   }
//   return getWordsWithoutCalculate(children);
// };
// var DEFAULT_FILL = '#808080';
// var Text = function Text(_ref5) {
//   var _ref5$x = _ref5.x,
//     propsX = _ref5$x === void 0 ? 0 : _ref5$x,
//     _ref5$y = _ref5.y,
//     propsY = _ref5$y === void 0 ? 0 : _ref5$y,
//     _ref5$lineHeight = _ref5.lineHeight,
//     lineHeight = _ref5$lineHeight === void 0 ? '1em' : _ref5$lineHeight,
//     _ref5$capHeight = _ref5.capHeight,
//     capHeight = _ref5$capHeight === void 0 ? '0.71em' : _ref5$capHeight,
//     _ref5$scaleToFit = _ref5.scaleToFit,
//     scaleToFit = _ref5$scaleToFit === void 0 ? false : _ref5$scaleToFit,
//     _ref5$textAnchor = _ref5.textAnchor,
//     textAnchor = _ref5$textAnchor === void 0 ? 'start' : _ref5$textAnchor,
//     _ref5$verticalAnchor = _ref5.verticalAnchor,
//     verticalAnchor = _ref5$verticalAnchor === void 0 ? 'end' : _ref5$verticalAnchor,
//     _ref5$fill = _ref5.fill,
//     fill = _ref5$fill === void 0 ? DEFAULT_FILL : _ref5$fill,
//     props = _objectWithoutProperties$b(_ref5, _excluded$c);
//   var wordsByLines = useMemo(function () {
//     return getWordsByLines({
//       breakAll: props.breakAll,
//       children: props.children,
//       maxLines: props.maxLines,
//       scaleToFit: scaleToFit,
//       style: props.style,
//       width: props.width
//     });
//   }, [props.breakAll, props.children, props.maxLines, scaleToFit, props.style, props.width]);
//   var dx = props.dx,
//     dy = props.dy,
//     angle = props.angle,
//     className = props.className,
//     breakAll = props.breakAll,
//     textProps = _objectWithoutProperties$b(props, _excluded2$4);
//   if (!isNumOrStr(propsX) || !isNumOrStr(propsY)) {
//     return null;
//   }
//   var x = propsX + (isNumber(dx) ? dx : 0);
//   var y = propsY + (isNumber(dy) ? dy : 0);
//   var startDy;
//   switch (verticalAnchor) {
//     case 'start':
//       startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
//       break;
//     case 'middle':
//       startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
//       break;
//     default:
//       startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
//       break;
//   }
//   var transforms = [];
//   if (scaleToFit) {
//     var lineWidth = wordsByLines[0].width;
//     var width = props.width;
//     transforms.push("scale(".concat((isNumber(width) ? width / lineWidth : 1) / lineWidth, ")"));
//   }
//   if (angle) {
//     transforms.push("rotate(".concat(angle, ", ").concat(x, ", ").concat(y, ")"));
//   }
//   if (transforms.length) {
//     textProps.transform = transforms.join(' ');
//   }
//   return /*#__PURE__*/React__default.createElement("text", _extends$j({}, filterProps(textProps, true), {
//     x: x,
//     y: y,
//     className: clsx('recharts-text', className),
//     textAnchor: textAnchor,
//     fill: fill.includes('url') ? DEFAULT_FILL : fill
//   }), wordsByLines.map(function (line, index) {
//     var words = line.words.join(breakAll ? '' : ' ');
//     return /*#__PURE__*/React__default.createElement("tspan", {
//       x: x,
//       dy: index === 0 ? startDy : lineHeight,
//       key: words
//     }, words);
//   }));
// };

// /*
//  *  decimal.js-light v2.5.1
//  *  An arbitrary-precision Decimal type for JavaScript.
//  *  https://github.com/MikeMcl/decimal.js-light
//  *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
//  *  MIT Expat Licence
//  */


// // ------------------------------------  EDITABLE DEFAULTS  ------------------------------------- //


// // The limit on the value of `precision`, and on the value of the first argument to
// // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
// var MAX_DIGITS = 1e9,                        // 0 to 1e9


//   // The initial configuration properties of the Decimal constructor.
//   defaults = {

//     // These values must be integers within the stated ranges (inclusive).
//     // Most of these values can be changed during run-time using `Decimal.config`.

//     // The maximum number of significant digits of the result of a calculation or base conversion.
//     // E.g. `Decimal.config({ precision: 20 });`
//     precision: 20,                         // 1 to MAX_DIGITS

//     // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
//     // `toFixed`, `toPrecision` and `toSignificantDigits`.
//     //
//     // ROUND_UP         0 Away from zero.
//     // ROUND_DOWN       1 Towards zero.
//     // ROUND_CEIL       2 Towards +Infinity.
//     // ROUND_FLOOR      3 Towards -Infinity.
//     // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
//     // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
//     // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
//     // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
//     // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
//     //
//     // E.g.
//     // `Decimal.rounding = 4;`
//     // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
//     rounding: 4,                           // 0 to 8

//     // The exponent value at and beneath which `toString` returns exponential notation.
//     // JavaScript numbers: -7
//     toExpNeg: -7,                          // 0 to -MAX_E

//     // The exponent value at and above which `toString` returns exponential notation.
//     // JavaScript numbers: 21
//     toExpPos:  21,                         // 0 to MAX_E

//     // The natural logarithm of 10.
//     // 115 digits
//     LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286'
//   },


// // ------------------------------------ END OF EDITABLE DEFAULTS -------------------------------- //


//   Decimal,
//   external = true,

//   decimalError = '[DecimalError] ',
//   invalidArgument = decimalError + 'Invalid argument: ',
//   exponentOutOfRange = decimalError + 'Exponent out of range: ',

//   mathfloor = Math.floor,
//   mathpow = Math.pow,

//   isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

//   ONE,
//   BASE = 1e7,
//   LOG_BASE = 7,
//   MAX_SAFE_INTEGER = 9007199254740991,
//   MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),    // 1286742750677284

//   // Decimal.prototype object
//   P = {};


// // Decimal prototype methods


// /*
//  *  absoluteValue                       abs
//  *  comparedTo                          cmp
//  *  decimalPlaces                       dp
//  *  dividedBy                           div
//  *  dividedToIntegerBy                  idiv
//  *  equals                              eq
//  *  exponent
//  *  greaterThan                         gt
//  *  greaterThanOrEqualTo                gte
//  *  isInteger                           isint
//  *  isNegative                          isneg
//  *  isPositive                          ispos
//  *  isZero
//  *  lessThan                            lt
//  *  lessThanOrEqualTo                   lte
//  *  logarithm                           log
//  *  minus                               sub
//  *  modulo                              mod
//  *  naturalExponential                  exp
//  *  naturalLogarithm                    ln
//  *  negated                             neg
//  *  plus                                add
//  *  precision                           sd
//  *  squareRoot                          sqrt
//  *  times                               mul
//  *  toDecimalPlaces                     todp
//  *  toExponential
//  *  toFixed
//  *  toInteger                           toint
//  *  toNumber
//  *  toPower                             pow
//  *  toPrecision
//  *  toSignificantDigits                 tosd
//  *  toString
//  *  valueOf                             val
//  */


// /*
//  * Return a new Decimal whose value is the absolute value of this Decimal.
//  *
//  */
// P.absoluteValue = P.abs = function () {
//   var x = new this.constructor(this);
//   if (x.s) x.s = 1;
//   return x;
// };


// /*
//  * Return
//  *   1    if the value of this Decimal is greater than the value of `y`,
//  *  -1    if the value of this Decimal is less than the value of `y`,
//  *   0    if they have the same value
//  *
//  */
// P.comparedTo = P.cmp = function (y) {
//   var i, j, xdL, ydL,
//     x = this;

//   y = new x.constructor(y);

//   // Signs differ?
//   if (x.s !== y.s) return x.s || -y.s;

//   // Compare exponents.
//   if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;

//   xdL = x.d.length;
//   ydL = y.d.length;

//   // Compare digit by digit.
//   for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
//     if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
//   }

//   // Compare lengths.
//   return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
// };


// /*
//  * Return the number of decimal places of the value of this Decimal.
//  *
//  */
// P.decimalPlaces = P.dp = function () {
//   var x = this,
//     w = x.d.length - 1,
//     dp = (w - x.e) * LOG_BASE;

//   // Subtract the number of trailing zeros of the last word.
//   w = x.d[w];
//   if (w) for (; w % 10 == 0; w /= 10) dp--;

//   return dp < 0 ? 0 : dp;
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal divided by `y`, truncated to
//  * `precision` significant digits.
//  *
//  */
// P.dividedBy = P.div = function (y) {
//   return divide(this, new this.constructor(y));
// };


// /*
//  * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
//  * by the value of `y`, truncated to `precision` significant digits.
//  *
//  */
// P.dividedToIntegerBy = P.idiv = function (y) {
//   var x = this,
//     Ctor = x.constructor;
//   return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);
// };


// /*
//  * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
//  *
//  */
// P.equals = P.eq = function (y) {
//   return !this.cmp(y);
// };


// /*
//  * Return the (base 10) exponent value of this Decimal (this.e is the base 10000000 exponent).
//  *
//  */
// P.exponent = function () {
//   return getBase10Exponent(this);
// };


// /*
//  * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
//  * false.
//  *
//  */
// P.greaterThan = P.gt = function (y) {
//   return this.cmp(y) > 0;
// };


// /*
//  * Return true if the value of this Decimal is greater than or equal to the value of `y`,
//  * otherwise return false.
//  *
//  */
// P.greaterThanOrEqualTo = P.gte = function (y) {
//   return this.cmp(y) >= 0;
// };


// /*
//  * Return true if the value of this Decimal is an integer, otherwise return false.
//  *
//  */
// P.isInteger = P.isint = function () {
//   return this.e > this.d.length - 2;
// };


// /*
//  * Return true if the value of this Decimal is negative, otherwise return false.
//  *
//  */
// P.isNegative = P.isneg = function () {
//   return this.s < 0;
// };


// /*
//  * Return true if the value of this Decimal is positive, otherwise return false.
//  *
//  */
// P.isPositive = P.ispos = function () {
//   return this.s > 0;
// };


// /*
//  * Return true if the value of this Decimal is 0, otherwise return false.
//  *
//  */
// P.isZero = function () {
//   return this.s === 0;
// };


// /*
//  * Return true if the value of this Decimal is less than `y`, otherwise return false.
//  *
//  */
// P.lessThan = P.lt = function (y) {
//   return this.cmp(y) < 0;
// };


// /*
//  * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
//  *
//  */
// P.lessThanOrEqualTo = P.lte = function (y) {
//   return this.cmp(y) < 1;
// };


// /*
//  * Return the logarithm of the value of this Decimal to the specified base, truncated to
//  * `precision` significant digits.
//  *
//  * If no base is specified, return log[10](x).
//  *
//  * log[base](x) = ln(x) / ln(base)
//  *
//  * The maximum error of the result is 1 ulp (unit in the last place).
//  *
//  * [base] {number|string|Decimal} The base of the logarithm.
//  *
//  */
// P.logarithm = P.log = function (base) {
//   var r,
//     x = this,
//     Ctor = x.constructor,
//     pr = Ctor.precision,
//     wpr = pr + 5;

//   // Default base is 10.
//   if (base === void 0) {
//     base = new Ctor(10);
//   } else {
//     base = new Ctor(base);

//     // log[-b](x) = NaN
//     // log[0](x)  = NaN
//     // log[1](x)  = NaN
//     if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + 'NaN');
//   }

//   // log[b](-x) = NaN
//   // log[b](0) = -Infinity
//   if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

//   // log[b](1) = 0
//   if (x.eq(ONE)) return new Ctor(0);

//   external = false;
//   r = divide(ln(x, wpr), ln(base, wpr), wpr);
//   external = true;

//   return round(r, pr);
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal minus `y`, truncated to
//  * `precision` significant digits.
//  *
//  */
// P.minus = P.sub = function (y) {
//   var x = this;
//   y = new x.constructor(y);
//   return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal modulo `y`, truncated to
//  * `precision` significant digits.
//  *
//  */
// P.modulo = P.mod = function (y) {
//   var q,
//     x = this,
//     Ctor = x.constructor,
//     pr = Ctor.precision;

//   y = new Ctor(y);

//   // x % 0 = NaN
//   if (!y.s) throw Error(decimalError + 'NaN');

//   // Return x if x is 0.
//   if (!x.s) return round(new Ctor(x), pr);

//   // Prevent rounding of intermediate calculations.
//   external = false;
//   q = divide(x, y, 0, 1).times(y);
//   external = true;

//   return x.minus(q);
// };


// /*
//  * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
//  * i.e. the base e raised to the power the value of this Decimal, truncated to `precision`
//  * significant digits.
//  *
//  */
// P.naturalExponential = P.exp = function () {
//   return exp(this);
// };


// /*
//  * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
//  * truncated to `precision` significant digits.
//  *
//  */
// P.naturalLogarithm = P.ln = function () {
//   return ln(this);
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
//  * -1.
//  *
//  */
// P.negated = P.neg = function () {
//   var x = new this.constructor(this);
//   x.s = -x.s || 0;
//   return x;
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal plus `y`, truncated to
//  * `precision` significant digits.
//  *
//  */
// P.plus = P.add = function (y) {
//   var x = this;
//   y = new x.constructor(y);
//   return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
// };


// /*
//  * Return the number of significant digits of the value of this Decimal.
//  *
//  * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
//  *
//  */
// P.precision = P.sd = function (z) {
//   var e, sd, w,
//     x = this;

//   if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

//   e = getBase10Exponent(x) + 1;
//   w = x.d.length - 1;
//   sd = w * LOG_BASE + 1;
//   w = x.d[w];

//   // If non-zero...
//   if (w) {

//     // Subtract the number of trailing zeros of the last word.
//     for (; w % 10 == 0; w /= 10) sd--;

//     // Add the number of digits of the first word.
//     for (w = x.d[0]; w >= 10; w /= 10) sd++;
//   }

//   return z && e > sd ? e : sd;
// };


// /*
//  * Return a new Decimal whose value is the square root of this Decimal, truncated to `precision`
//  * significant digits.
//  *
//  */
// P.squareRoot = P.sqrt = function () {
//   var e, n, pr, r, s, t, wpr,
//     x = this,
//     Ctor = x.constructor;

//   // Negative or zero?
//   if (x.s < 1) {
//     if (!x.s) return new Ctor(0);

//     // sqrt(-x) = NaN
//     throw Error(decimalError + 'NaN');
//   }

//   e = getBase10Exponent(x);
//   external = false;

//   // Initial estimate.
//   s = Math.sqrt(+x);

//   // Math.sqrt underflow/overflow?
//   // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
//   if (s == 0 || s == 1 / 0) {
//     n = digitsToString(x.d);
//     if ((n.length + e) % 2 == 0) n += '0';
//     s = Math.sqrt(n);
//     e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

//     if (s == 1 / 0) {
//       n = '5e' + e;
//     } else {
//       n = s.toExponential();
//       n = n.slice(0, n.indexOf('e') + 1) + e;
//     }

//     r = new Ctor(n);
//   } else {
//     r = new Ctor(s.toString());
//   }

//   pr = Ctor.precision;
//   s = wpr = pr + 3;

//   // Newton-Raphson iteration.
//   for (;;) {
//     t = r;
//     r = t.plus(divide(x, t, wpr + 2)).times(0.5);

//     if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
//       n = n.slice(wpr - 3, wpr + 1);

//       // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
//       // 4999, i.e. approaching a rounding boundary, continue the iteration.
//       if (s == wpr && n == '4999') {

//         // On the first iteration only, check to see if rounding up gives the exact result as the
//         // nines may infinitely repeat.
//         round(t, pr + 1, 0);

//         if (t.times(t).eq(x)) {
//           r = t;
//           break;
//         }
//       } else if (n != '9999') {
//         break;
//       }

//       wpr += 4;
//     }
//   }

//   external = true;

//   return round(r, pr);
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal times `y`, truncated to
//  * `precision` significant digits.
//  *
//  */
// P.times = P.mul = function (y) {
//   var carry, e, i, k, r, rL, t, xdL, ydL,
//     x = this,
//     Ctor = x.constructor,
//     xd = x.d,
//     yd = (y = new Ctor(y)).d;

//   // Return 0 if either is 0.
//   if (!x.s || !y.s) return new Ctor(0);

//   y.s *= x.s;
//   e = x.e + y.e;
//   xdL = xd.length;
//   ydL = yd.length;

//   // Ensure xd points to the longer array.
//   if (xdL < ydL) {
//     r = xd;
//     xd = yd;
//     yd = r;
//     rL = xdL;
//     xdL = ydL;
//     ydL = rL;
//   }

//   // Initialise the result array with zeros.
//   r = [];
//   rL = xdL + ydL;
//   for (i = rL; i--;) r.push(0);

//   // Multiply!
//   for (i = ydL; --i >= 0;) {
//     carry = 0;
//     for (k = xdL + i; k > i;) {
//       t = r[k] + yd[i] * xd[k - i - 1] + carry;
//       r[k--] = t % BASE | 0;
//       carry = t / BASE | 0;
//     }

//     r[k] = (r[k] + carry) % BASE | 0;
//   }

//   // Remove trailing zeros.
//   for (; !r[--rL];) r.pop();

//   if (carry) ++e;
//   else r.shift();

//   y.d = r;
//   y.e = e;

//   return external ? round(y, Ctor.precision) : y;
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
//  * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
//  *
//  * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
//  *
//  * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
//  * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
//  *
//  */
// P.toDecimalPlaces = P.todp = function (dp, rm) {
//   var x = this,
//     Ctor = x.constructor;

//   x = new Ctor(x);
//   if (dp === void 0) return x;

//   checkInt32(dp, 0, MAX_DIGITS);

//   if (rm === void 0) rm = Ctor.rounding;
//   else checkInt32(rm, 0, 8);

//   return round(x, dp + getBase10Exponent(x) + 1, rm);
// };


// /*
//  * Return a string representing the value of this Decimal in exponential notation rounded to
//  * `dp` fixed decimal places using rounding mode `rounding`.
//  *
//  * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
//  * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
//  *
//  */
// P.toExponential = function (dp, rm) {
//   var str,
//     x = this,
//     Ctor = x.constructor;

//   if (dp === void 0) {
//     str = toString(x, true);
//   } else {
//     checkInt32(dp, 0, MAX_DIGITS);

//     if (rm === void 0) rm = Ctor.rounding;
//     else checkInt32(rm, 0, 8);

//     x = round(new Ctor(x), dp + 1, rm);
//     str = toString(x, true, dp + 1);
//   }

//   return str;
// };


// /*
//  * Return a string representing the value of this Decimal in normal (fixed-point) notation to
//  * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
//  * omitted.
//  *
//  * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
//  *
//  * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
//  * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
//  *
//  * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
//  * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
//  * (-0).toFixed(3) is '0.000'.
//  * (-0.5).toFixed(0) is '-0'.
//  *
//  */
// P.toFixed = function (dp, rm) {
//   var str, y,
//     x = this,
//     Ctor = x.constructor;

//   if (dp === void 0) return toString(x);

//   checkInt32(dp, 0, MAX_DIGITS);

//   if (rm === void 0) rm = Ctor.rounding;
//   else checkInt32(rm, 0, 8);

//   y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
//   str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);

//   // To determine whether to add the minus sign look at the value before it was rounded,
//   // i.e. look at `x` rather than `y`.
//   return x.isneg() && !x.isZero() ? '-' + str : str;
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
//  * rounding mode `rounding`.
//  *
//  */
// P.toInteger = P.toint = function () {
//   var x = this,
//     Ctor = x.constructor;
//   return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
// };


// /*
//  * Return the value of this Decimal converted to a number primitive.
//  *
//  */
// P.toNumber = function () {
//   return +this;
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal raised to the power `y`,
//  * truncated to `precision` significant digits.
//  *
//  * For non-integer or very large exponents pow(x, y) is calculated using
//  *
//  *   x^y = exp(y*ln(x))
//  *
//  * The maximum error is 1 ulp (unit in last place).
//  *
//  * y {number|string|Decimal} The power to which to raise this Decimal.
//  *
//  */
// P.toPower = P.pow = function (y) {
//   var e, k, pr, r, sign, yIsInt,
//     x = this,
//     Ctor = x.constructor,
//     guard = 12,
//     yn = +(y = new Ctor(y));

//   // pow(x, 0) = 1
//   if (!y.s) return new Ctor(ONE);

//   x = new Ctor(x);

//   // pow(0, y > 0) = 0
//   // pow(0, y < 0) = Infinity
//   if (!x.s) {
//     if (y.s < 1) throw Error(decimalError + 'Infinity');
//     return x;
//   }

//   // pow(1, y) = 1
//   if (x.eq(ONE)) return x;

//   pr = Ctor.precision;

//   // pow(x, 1) = x
//   if (y.eq(ONE)) return round(x, pr);

//   e = y.e;
//   k = y.d.length - 1;
//   yIsInt = e >= k;
//   sign = x.s;

//   if (!yIsInt) {

//     // pow(x < 0, y non-integer) = NaN
//     if (sign < 0) throw Error(decimalError + 'NaN');

//   // If y is a small integer use the 'exponentiation by squaring' algorithm.
//   } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
//     r = new Ctor(ONE);

//     // Max k of 9007199254740991 takes 53 loop iterations.
//     // Maximum digits array length; leaves [28, 34] guard digits.
//     e = Math.ceil(pr / LOG_BASE + 4);

//     external = false;

//     for (;;) {
//       if (k % 2) {
//         r = r.times(x);
//         truncate(r.d, e);
//       }

//       k = mathfloor(k / 2);
//       if (k === 0) break;

//       x = x.times(x);
//       truncate(x.d, e);
//     }

//     external = true;

//     return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);
//   }

//   // Result is negative if x is negative and the last digit of integer y is odd.
//   sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;

//   x.s = 1;
//   external = false;
//   r = y.times(ln(x, pr + guard));
//   external = true;
//   r = exp(r);
//   r.s = sign;

//   return r;
// };


// /*
//  * Return a string representing the value of this Decimal rounded to `sd` significant digits
//  * using rounding mode `rounding`.
//  *
//  * Return exponential notation if `sd` is less than the number of digits necessary to represent
//  * the integer part of the value in normal notation.
//  *
//  * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
//  * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
//  *
//  */
// P.toPrecision = function (sd, rm) {
//   var e, str,
//     x = this,
//     Ctor = x.constructor;

//   if (sd === void 0) {
//     e = getBase10Exponent(x);
//     str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
//   } else {
//     checkInt32(sd, 1, MAX_DIGITS);

//     if (rm === void 0) rm = Ctor.rounding;
//     else checkInt32(rm, 0, 8);

//     x = round(new Ctor(x), sd, rm);
//     e = getBase10Exponent(x);
//     str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
//   }

//   return str;
// };


// /*
//  * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
//  * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
//  * omitted.
//  *
//  * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
//  * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
//  *
//  */
// P.toSignificantDigits = P.tosd = function (sd, rm) {
//   var x = this,
//     Ctor = x.constructor;

//   if (sd === void 0) {
//     sd = Ctor.precision;
//     rm = Ctor.rounding;
//   } else {
//     checkInt32(sd, 1, MAX_DIGITS);

//     if (rm === void 0) rm = Ctor.rounding;
//     else checkInt32(rm, 0, 8);
//   }

//   return round(new Ctor(x), sd, rm);
// };


// /*
//  * Return a string representing the value of this Decimal.
//  *
//  * Return exponential notation if this Decimal has a positive exponent equal to or greater than
//  * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
//  *
//  */
// P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for('nodejs.util.inspect.custom')] = function () {
//   var x = this,
//     e = getBase10Exponent(x),
//     Ctor = x.constructor;

//   return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
// };


// // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


// /*
//  *  add                 P.minus, P.plus
//  *  checkInt32          P.todp, P.toExponential, P.toFixed, P.toPrecision, P.tosd
//  *  digitsToString      P.log, P.sqrt, P.pow, toString, exp, ln
//  *  divide              P.div, P.idiv, P.log, P.mod, P.sqrt, exp, ln
//  *  exp                 P.exp, P.pow
//  *  getBase10Exponent   P.exponent, P.sd, P.toint, P.sqrt, P.todp, P.toFixed, P.toPrecision,
//  *                      P.toString, divide, round, toString, exp, ln
//  *  getLn10             P.log, ln
//  *  getZeroString       digitsToString, toString
//  *  ln                  P.log, P.ln, P.pow, exp
//  *  parseDecimal        Decimal
//  *  round               P.abs, P.idiv, P.log, P.minus, P.mod, P.neg, P.plus, P.toint, P.sqrt,
//  *                      P.times, P.todp, P.toExponential, P.toFixed, P.pow, P.toPrecision, P.tosd,
//  *                      divide, getLn10, exp, ln
//  *  subtract            P.minus, P.plus
//  *  toString            P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf
//  *  truncate            P.pow
//  *
//  *  Throws:             P.log, P.mod, P.sd, P.sqrt, P.pow,  checkInt32, divide, round,
//  *                      getLn10, exp, ln, parseDecimal, Decimal, config
//  */


// function add(x, y) {
//   var carry, d, e, i, k, len, xd, yd,
//     Ctor = x.constructor,
//     pr = Ctor.precision;

//   // If either is zero...
//   if (!x.s || !y.s) {

//     // Return x if y is zero.
//     // Return y if y is non-zero.
//     if (!y.s) y = new Ctor(x);
//     return external ? round(y, pr) : y;
//   }

//   xd = x.d;
//   yd = y.d;

//   // x and y are finite, non-zero numbers with the same sign.

//   k = x.e;
//   e = y.e;
//   xd = xd.slice();
//   i = k - e;

//   // If base 1e7 exponents differ...
//   if (i) {
//     if (i < 0) {
//       d = xd;
//       i = -i;
//       len = yd.length;
//     } else {
//       d = yd;
//       e = k;
//       len = xd.length;
//     }

//     // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
//     k = Math.ceil(pr / LOG_BASE);
//     len = k > len ? k + 1 : len + 1;

//     if (i > len) {
//       i = len;
//       d.length = 1;
//     }

//     // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
//     d.reverse();
//     for (; i--;) d.push(0);
//     d.reverse();
//   }

//   len = xd.length;
//   i = yd.length;

//   // If yd is longer than xd, swap xd and yd so xd points to the longer array.
//   if (len - i < 0) {
//     i = len;
//     d = yd;
//     yd = xd;
//     xd = d;
//   }

//   // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
//   for (carry = 0; i;) {
//     carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
//     xd[i] %= BASE;
//   }

//   if (carry) {
//     xd.unshift(carry);
//     ++e;
//   }

//   // Remove trailing zeros.
//   // No need to check for zero, as +x + +y != 0 && -x + -y != 0
//   for (len = xd.length; xd[--len] == 0;) xd.pop();

//   y.d = xd;
//   y.e = e;

//   return external ? round(y, pr) : y;
// }


// function checkInt32(i, min, max) {
//   if (i !== ~~i || i < min || i > max) {
//     throw Error(invalidArgument + i);
//   }
// }


// function digitsToString(d) {
//   var i, k, ws,
//     indexOfLastWord = d.length - 1,
//     str = '',
//     w = d[0];

//   if (indexOfLastWord > 0) {
//     str += w;
//     for (i = 1; i < indexOfLastWord; i++) {
//       ws = d[i] + '';
//       k = LOG_BASE - ws.length;
//       if (k) str += getZeroString(k);
//       str += ws;
//     }

//     w = d[i];
//     ws = w + '';
//     k = LOG_BASE - ws.length;
//     if (k) str += getZeroString(k);
//   } else if (w === 0) {
//     return '0';
//   }

//   // Remove trailing zeros of last w.
//   for (; w % 10 === 0;) w /= 10;

//   return str + w;
// }


// var divide = (function () {

//   // Assumes non-zero x and k, and hence non-zero result.
//   function multiplyInteger(x, k) {
//     var temp,
//       carry = 0,
//       i = x.length;

//     for (x = x.slice(); i--;) {
//       temp = x[i] * k + carry;
//       x[i] = temp % BASE | 0;
//       carry = temp / BASE | 0;
//     }

//     if (carry) x.unshift(carry);

//     return x;
//   }

//   function compare(a, b, aL, bL) {
//     var i, r;

//     if (aL != bL) {
//       r = aL > bL ? 1 : -1;
//     } else {
//       for (i = r = 0; i < aL; i++) {
//         if (a[i] != b[i]) {
//           r = a[i] > b[i] ? 1 : -1;
//           break;
//         }
//       }
//     }

//     return r;
//   }

//   function subtract(a, b, aL) {
//     var i = 0;

//     // Subtract b from a.
//     for (; aL--;) {
//       a[aL] -= i;
//       i = a[aL] < b[aL] ? 1 : 0;
//       a[aL] = i * BASE + a[aL] - b[aL];
//     }

//     // Remove leading zeros.
//     for (; !a[0] && a.length > 1;) a.shift();
//   }

//   return function (x, y, pr, dp) {
//     var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz,
//       Ctor = x.constructor,
//       sign = x.s == y.s ? 1 : -1,
//       xd = x.d,
//       yd = y.d;

//     // Either 0?
//     if (!x.s) return new Ctor(x);
//     if (!y.s) throw Error(decimalError + 'Division by zero');

//     e = x.e - y.e;
//     yL = yd.length;
//     xL = xd.length;
//     q = new Ctor(sign);
//     qd = q.d = [];

//     // Result exponent may be one less than e.
//     for (i = 0; yd[i] == (xd[i] || 0); ) ++i;
//     if (yd[i] > (xd[i] || 0)) --e;

//     if (pr == null) {
//       sd = pr = Ctor.precision;
//     } else if (dp) {
//       sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
//     } else {
//       sd = pr;
//     }

//     if (sd < 0) return new Ctor(0);

//     // Convert precision in number of base 10 digits to base 1e7 digits.
//     sd = sd / LOG_BASE + 2 | 0;
//     i = 0;

//     // divisor < 1e7
//     if (yL == 1) {
//       k = 0;
//       yd = yd[0];
//       sd++;

//       // k is the carry.
//       for (; (i < xL || k) && sd--; i++) {
//         t = k * BASE + (xd[i] || 0);
//         qd[i] = t / yd | 0;
//         k = t % yd | 0;
//       }

//     // divisor >= 1e7
//     } else {

//       // Normalise xd and yd so highest order digit of yd is >= BASE/2
//       k = BASE / (yd[0] + 1) | 0;

//       if (k > 1) {
//         yd = multiplyInteger(yd, k);
//         xd = multiplyInteger(xd, k);
//         yL = yd.length;
//         xL = xd.length;
//       }

//       xi = yL;
//       rem = xd.slice(0, yL);
//       remL = rem.length;

//       // Add zeros to make remainder as long as divisor.
//       for (; remL < yL;) rem[remL++] = 0;

//       yz = yd.slice();
//       yz.unshift(0);
//       yd0 = yd[0];

//       if (yd[1] >= BASE / 2) ++yd0;

//       do {
//         k = 0;

//         // Compare divisor and remainder.
//         cmp = compare(yd, rem, yL, remL);

//         // If divisor < remainder.
//         if (cmp < 0) {

//           // Calculate trial digit, k.
//           rem0 = rem[0];
//           if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);

//           // k will be how many times the divisor goes into the current remainder.
//           k = rem0 / yd0 | 0;

//           //  Algorithm:
//           //  1. product = divisor * trial digit (k)
//           //  2. if product > remainder: product -= divisor, k--
//           //  3. remainder -= product
//           //  4. if product was < remainder at 2:
//           //    5. compare new remainder and divisor
//           //    6. If remainder > divisor: remainder -= divisor, k++

//           if (k > 1) {
//             if (k >= BASE) k = BASE - 1;

//             // product = divisor * trial digit.
//             prod = multiplyInteger(yd, k);
//             prodL = prod.length;
//             remL = rem.length;

//             // Compare product and remainder.
//             cmp = compare(prod, rem, prodL, remL);

//             // product > remainder.
//             if (cmp == 1) {
//               k--;

//               // Subtract divisor from product.
//               subtract(prod, yL < prodL ? yz : yd, prodL);
//             }
//           } else {

//             // cmp is -1.
//             // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
//             // to avoid it. If k is 1 there is a need to compare yd and rem again below.
//             if (k == 0) cmp = k = 1;
//             prod = yd.slice();
//           }

//           prodL = prod.length;
//           if (prodL < remL) prod.unshift(0);

//           // Subtract product from remainder.
//           subtract(rem, prod, remL);

//           // If product was < previous remainder.
//           if (cmp == -1) {
//             remL = rem.length;

//             // Compare divisor and new remainder.
//             cmp = compare(yd, rem, yL, remL);

//             // If divisor < new remainder, subtract divisor from remainder.
//             if (cmp < 1) {
//               k++;

//               // Subtract divisor from remainder.
//               subtract(rem, yL < remL ? yz : yd, remL);
//             }
//           }

//           remL = rem.length;
//         } else if (cmp === 0) {
//           k++;
//           rem = [0];
//         }    // if cmp === 1, k will be 0

//         // Add the next digit, k, to the result array.
//         qd[i++] = k;

//         // Update the remainder.
//         if (cmp && rem[0]) {
//           rem[remL++] = xd[xi] || 0;
//         } else {
//           rem = [xd[xi]];
//           remL = 1;
//         }

//       } while ((xi++ < xL || rem[0] !== void 0) && sd--);
//     }

//     // Leading zero?
//     if (!qd[0]) qd.shift();

//     q.e = e;

//     return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
//   };
// })();


// /*
//  * Return a new Decimal whose value is the natural exponential of `x` truncated to `sd`
//  * significant digits.
//  *
//  * Taylor/Maclaurin series.
//  *
//  * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
//  *
//  * Argument reduction:
//  *   Repeat x = x / 32, k += 5, until |x| < 0.1
//  *   exp(x) = exp(x / 2^k)^(2^k)
//  *
//  * Previously, the argument was initially reduced by
//  * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
//  * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
//  * found to be slower than just dividing repeatedly by 32 as above.
//  *
//  * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
//  *
//  *  exp(x) is non-terminating for any finite, non-zero x.
//  *
//  */
// function exp(x, sd) {
//   var denominator, guard, pow, sum, t, wpr,
//     i = 0,
//     k = 0,
//     Ctor = x.constructor,
//     pr = Ctor.precision;

//   if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));

//   // exp(0) = 1
//   if (!x.s) return new Ctor(ONE);

//   if (sd == null) {
//     external = false;
//     wpr = pr;
//   } else {
//     wpr = sd;
//   }

//   t = new Ctor(0.03125);

//   while (x.abs().gte(0.1)) {
//     x = x.times(t);    // x = x / 2^5
//     k += 5;
//   }

//   // Estimate the precision increase necessary to ensure the first 4 rounding digits are correct.
//   guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
//   wpr += guard;
//   denominator = pow = sum = new Ctor(ONE);
//   Ctor.precision = wpr;

//   for (;;) {
//     pow = round(pow.times(x), wpr);
//     denominator = denominator.times(++i);
//     t = sum.plus(divide(pow, denominator, wpr));

//     if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
//       while (k--) sum = round(sum.times(sum), wpr);
//       Ctor.precision = pr;
//       return sd == null ? (external = true, round(sum, pr)) : sum;
//     }

//     sum = t;
//   }
// }


// // Calculate the base 10 exponent from the base 1e7 exponent.
// function getBase10Exponent(x) {
//   var e = x.e * LOG_BASE,
//     w = x.d[0];

//   // Add the number of digits of the first word of the digits array.
//   for (; w >= 10; w /= 10) e++;
//   return e;
// }


// function getLn10(Ctor, sd, pr) {

//   if (sd > Ctor.LN10.sd()) {


//     // Reset global state in case the exception is caught.
//     external = true;
//     if (pr) Ctor.precision = pr;
//     throw Error(decimalError + 'LN10 precision limit exceeded');
//   }

//   return round(new Ctor(Ctor.LN10), sd);
// }


// function getZeroString(k) {
//   var zs = '';
//   for (; k--;) zs += '0';
//   return zs;
// }


// /*
//  * Return a new Decimal whose value is the natural logarithm of `x` truncated to `sd` significant
//  * digits.
//  *
//  *  ln(n) is non-terminating (n != 1)
//  *
//  */
// function ln(y, sd) {
//   var c, c0, denominator, e, numerator, sum, t, wpr, x2,
//     n = 1,
//     guard = 10,
//     x = y,
//     xd = x.d,
//     Ctor = x.constructor,
//     pr = Ctor.precision;

//   // ln(-x) = NaN
//   // ln(0) = -Infinity
//   if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

//   // ln(1) = 0
//   if (x.eq(ONE)) return new Ctor(0);

//   if (sd == null) {
//     external = false;
//     wpr = pr;
//   } else {
//     wpr = sd;
//   }

//   if (x.eq(10)) {
//     if (sd == null) external = true;
//     return getLn10(Ctor, wpr);
//   }

//   wpr += guard;
//   Ctor.precision = wpr;
//   c = digitsToString(xd);
//   c0 = c.charAt(0);
//   e = getBase10Exponent(x);

//   if (Math.abs(e) < 1.5e15) {

//     // Argument reduction.
//     // The series converges faster the closer the argument is to 1, so using
//     // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
//     // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
//     // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
//     // later be divided by this number, then separate out the power of 10 using
//     // ln(a*10^b) = ln(a) + b*ln(10).

//     // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
//     //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
//     // max n is 6 (gives 0.7 - 1.3)
//     while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
//       x = x.times(y);
//       c = digitsToString(x.d);
//       c0 = c.charAt(0);
//       n++;
//     }

//     e = getBase10Exponent(x);

//     if (c0 > 1) {
//       x = new Ctor('0.' + c);
//       e++;
//     } else {
//       x = new Ctor(c0 + '.' + c.slice(1));
//     }
//   } else {

//     // The argument reduction method above may result in overflow if the argument y is a massive
//     // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
//     // function using ln(x*10^e) = ln(x) + e*ln(10).
//     t = getLn10(Ctor, wpr + 2, pr).times(e + '');
//     x = ln(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);

//     Ctor.precision = pr;
//     return sd == null ? (external = true, round(x, pr)) : x;
//   }

//   // x is reduced to a value near 1.

//   // Taylor series.
//   // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
//   // where x = (y - 1)/(y + 1)    (|x| < 1)
//   sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
//   x2 = round(x.times(x), wpr);
//   denominator = 3;

//   for (;;) {
//     numerator = round(numerator.times(x2), wpr);
//     t = sum.plus(divide(numerator, new Ctor(denominator), wpr));

//     if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
//       sum = sum.times(2);

//       // Reverse the argument reduction.
//       if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
//       sum = divide(sum, new Ctor(n), wpr);

//       Ctor.precision = pr;
//       return sd == null ? (external = true, round(sum, pr)) : sum;
//     }

//     sum = t;
//     denominator += 2;
//   }
// }


// /*
//  * Parse the value of a new Decimal `x` from string `str`.
//  */
// function parseDecimal(x, str) {
//   var e, i, len;

//   // Decimal point?
//   if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

//   // Exponential form?
//   if ((i = str.search(/e/i)) > 0) {

//     // Determine exponent.
//     if (e < 0) e = i;
//     e += +str.slice(i + 1);
//     str = str.substring(0, i);
//   } else if (e < 0) {

//     // Integer.
//     e = str.length;
//   }

//   // Determine leading zeros.
//   for (i = 0; str.charCodeAt(i) === 48;) ++i;

//   // Determine trailing zeros.
//   for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;
//   str = str.slice(i, len);

//   if (str) {
//     len -= i;
//     e = e - i - 1;
//     x.e = mathfloor(e / LOG_BASE);
//     x.d = [];

//     // Transform base

//     // e is the base 10 exponent.
//     // i is where to slice str to get the first word of the digits array.
//     i = (e + 1) % LOG_BASE;
//     if (e < 0) i += LOG_BASE;

//     if (i < len) {
//       if (i) x.d.push(+str.slice(0, i));
//       for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
//       str = str.slice(i);
//       i = LOG_BASE - str.length;
//     } else {
//       i -= len;
//     }

//     for (; i--;) str += '0';
//     x.d.push(+str);

//     if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);
//   } else {

//     // Zero.
//     x.s = 0;
//     x.e = 0;
//     x.d = [0];
//   }

//   return x;
// }


// /*
//  * Round `x` to `sd` significant digits, using rounding mode `rm` if present (truncate otherwise).
//  */
//  function round(x, sd, rm) {
//   var i, j, k, n, rd, doRound, w, xdi,
//     xd = x.d;

//   // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
//   // w: the word of xd which contains the rounding digit, a base 1e7 number.
//   // xdi: the index of w within xd.
//   // n: the number of digits of w.
//   // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
//   // they had leading zeros)
//   // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

//   // Get the length of the first word of the digits array xd.
//   for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;
//   i = sd - n;

//   // Is the rounding digit in the first word of xd?
//   if (i < 0) {
//     i += LOG_BASE;
//     j = sd;
//     w = xd[xdi = 0];
//   } else {
//     xdi = Math.ceil((i + 1) / LOG_BASE);
//     k = xd.length;
//     if (xdi >= k) return x;
//     w = k = xd[xdi];

//     // Get the number of digits of w.
//     for (n = 1; k >= 10; k /= 10) n++;

//     // Get the index of rd within w.
//     i %= LOG_BASE;

//     // Get the index of rd within w, adjusted for leading zeros.
//     // The number of leading zeros of w is given by LOG_BASE - n.
//     j = i - LOG_BASE + n;
//   }

//   if (rm !== void 0) {
//     k = mathpow(10, n - j - 1);

//     // Get the rounding digit at index j of w.
//     rd = w / k % 10 | 0;

//     // Are there any non-zero digits after the rounding digit?
//     doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;

//     // The expression `w % mathpow(10, n - j - 1)` returns all the digits of w to the right of the
//     // digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression will give
//     // 714.

//     doRound = rm < 4
//       ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
//       : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 &&

//         // Check whether the digit to the left of the rounding digit is odd.
//         ((i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
//           rm == (x.s < 0 ? 8 : 7));
//   }

//   if (sd < 1 || !xd[0]) {
//     if (doRound) {
//       k = getBase10Exponent(x);
//       xd.length = 1;

//       // Convert sd to decimal places.
//       sd = sd - k - 1;

//       // 1, 0.1, 0.01, 0.001, 0.0001 etc.
//       xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
//       x.e = mathfloor(-sd / LOG_BASE) || 0;
//     } else {
//       xd.length = 1;

//       // Zero.
//       xd[0] = x.e = x.s = 0;
//     }

//     return x;
//   }

//   // Remove excess digits.
//   if (i == 0) {
//     xd.length = xdi;
//     k = 1;
//     xdi--;
//   } else {
//     xd.length = xdi + 1;
//     k = mathpow(10, LOG_BASE - i);

//     // E.g. 56700 becomes 56000 if 7 is the rounding digit.
//     // j > 0 means i > number of leading zeros of w.
//     xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
//   }

//   if (doRound) {
//     for (;;) {

//       // Is the digit to be rounded up in the first word of xd?
//       if (xdi == 0) {
//         if ((xd[0] += k) == BASE) {
//           xd[0] = 1;
//           ++x.e;
//         }

//         break;
//       } else {
//         xd[xdi] += k;
//         if (xd[xdi] != BASE) break;
//         xd[xdi--] = 0;
//         k = 1;
//       }
//     }
//   }

//   // Remove trailing zeros.
//   for (i = xd.length; xd[--i] === 0;) xd.pop();

//   if (external && (x.e > MAX_E || x.e < -MAX_E)) {
//     throw Error(exponentOutOfRange + getBase10Exponent(x));
//   }

//   return x;
// }


// function subtract(x, y) {
//   var d, e, i, j, k, len, xd, xe, xLTy, yd,
//     Ctor = x.constructor,
//     pr = Ctor.precision;

//   // Return y negated if x is zero.
//   // Return x if y is zero and x is non-zero.
//   if (!x.s || !y.s) {
//     if (y.s) y.s = -y.s;
//     else y = new Ctor(x);
//     return external ? round(y, pr) : y;
//   }

//   xd = x.d;
//   yd = y.d;

//   // x and y are non-zero numbers with the same sign.

//   e = y.e;
//   xe = x.e;
//   xd = xd.slice();
//   k = xe - e;

//   // If exponents differ...
//   if (k) {
//     xLTy = k < 0;

//     if (xLTy) {
//       d = xd;
//       k = -k;
//       len = yd.length;
//     } else {
//       d = yd;
//       e = xe;
//       len = xd.length;
//     }

//     // Numbers with massively different exponents would result in a very high number of zeros
//     // needing to be prepended, but this can be avoided while still ensuring correct rounding by
//     // limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
//     i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

//     if (k > i) {
//       k = i;
//       d.length = 1;
//     }

//     // Prepend zeros to equalise exponents.
//     d.reverse();
//     for (i = k; i--;) d.push(0);
//     d.reverse();

//   // Base 1e7 exponents equal.
//   } else {

//     // Check digits to determine which is the bigger number.

//     i = xd.length;
//     len = yd.length;
//     xLTy = i < len;
//     if (xLTy) len = i;

//     for (i = 0; i < len; i++) {
//       if (xd[i] != yd[i]) {
//         xLTy = xd[i] < yd[i];
//         break;
//       }
//     }

//     k = 0;
//   }

//   if (xLTy) {
//     d = xd;
//     xd = yd;
//     yd = d;
//     y.s = -y.s;
//   }

//   len = xd.length;

//   // Append zeros to xd if shorter.
//   // Don't add zeros to yd if shorter as subtraction only needs to start at yd length.
//   for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

//   // Subtract yd from xd.
//   for (i = yd.length; i > k;) {
//     if (xd[--i] < yd[i]) {
//       for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
//       --xd[j];
//       xd[i] += BASE;
//     }

//     xd[i] -= yd[i];
//   }

//   // Remove trailing zeros.
//   for (; xd[--len] === 0;) xd.pop();

//   // Remove leading zeros and adjust exponent accordingly.
//   for (; xd[0] === 0; xd.shift()) --e;

//   // Zero?
//   if (!xd[0]) return new Ctor(0);

//   y.d = xd;
//   y.e = e;

//   //return external && xd.length >= pr / LOG_BASE ? round(y, pr) : y;
//   return external ? round(y, pr) : y;
// }


// function toString(x, isExp, sd) {
//   var k,
//     e = getBase10Exponent(x),
//     str = digitsToString(x.d),
//     len = str.length;

//   if (isExp) {
//     if (sd && (k = sd - len) > 0) {
//       str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
//     } else if (len > 1) {
//       str = str.charAt(0) + '.' + str.slice(1);
//     }

//     str = str + (e < 0 ? 'e' : 'e+') + e;
//   } else if (e < 0) {
//     str = '0.' + getZeroString(-e - 1) + str;
//     if (sd && (k = sd - len) > 0) str += getZeroString(k);
//   } else if (e >= len) {
//     str += getZeroString(e + 1 - len);
//     if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
//   } else {
//     if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
//     if (sd && (k = sd - len) > 0) {
//       if (e + 1 === len) str += '.';
//       str += getZeroString(k);
//     }
//   }

//   return x.s < 0 ? '-' + str : str;
// }


// // Does not strip trailing zeros.
// function truncate(arr, len) {
//   if (arr.length > len) {
//     arr.length = len;
//     return true;
//   }
// }


// // Decimal methods


// /*
//  *  clone
//  *  config/set
//  */


// /*
//  * Create and return a Decimal constructor with the same configuration properties as this Decimal
//  * constructor.
//  *
//  */
// function clone$1(obj) {
//   var i, p, ps;

//   /*
//    * The Decimal constructor and exported function.
//    * Return a new Decimal instance.
//    *
//    * value {number|string|Decimal} A numeric value.
//    *
//    */
//   function Decimal(value) {
//     var x = this;

//     // Decimal called without new.
//     if (!(x instanceof Decimal)) return new Decimal(value);

//     // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
//     // which points to Object.
//     x.constructor = Decimal;

//     // Duplicate.
//     if (value instanceof Decimal) {
//       x.s = value.s;
//       x.e = value.e;
//       x.d = (value = value.d) ? value.slice() : value;
//       return;
//     }

//     if (typeof value === 'number') {

//       // Reject Infinity/NaN.
//       if (value * 0 !== 0) {
//         throw Error(invalidArgument + value);
//       }

//       if (value > 0) {
//         x.s = 1;
//       } else if (value < 0) {
//         value = -value;
//         x.s = -1;
//       } else {
//         x.s = 0;
//         x.e = 0;
//         x.d = [0];
//         return;
//       }

//       // Fast path for small integers.
//       if (value === ~~value && value < 1e7) {
//         x.e = 0;
//         x.d = [value];
//         return;
//       }

//       return parseDecimal(x, value.toString());
//     } else if (typeof value !== 'string') {
//       throw Error(invalidArgument + value);
//     }

//     // Minus sign?
//     if (value.charCodeAt(0) === 45) {
//       value = value.slice(1);
//       x.s = -1;
//     } else {
//       x.s = 1;
//     }

//     if (isDecimal.test(value)) parseDecimal(x, value);
//     else throw Error(invalidArgument + value);
//   }

//   Decimal.prototype = P;

//   Decimal.ROUND_UP = 0;
//   Decimal.ROUND_DOWN = 1;
//   Decimal.ROUND_CEIL = 2;
//   Decimal.ROUND_FLOOR = 3;
//   Decimal.ROUND_HALF_UP = 4;
//   Decimal.ROUND_HALF_DOWN = 5;
//   Decimal.ROUND_HALF_EVEN = 6;
//   Decimal.ROUND_HALF_CEIL = 7;
//   Decimal.ROUND_HALF_FLOOR = 8;

//   Decimal.clone = clone$1;
//   Decimal.config = Decimal.set = config;

//   if (obj === void 0) obj = {};
//   if (obj) {
//     ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'];
//     for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
//   }

//   Decimal.config(obj);

//   return Decimal;
// }


// /*
//  * Configure global settings for a Decimal constructor.
//  *
//  * `obj` is an object with one or more of the following properties,
//  *
//  *   precision  {number}
//  *   rounding   {number}
//  *   toExpNeg   {number}
//  *   toExpPos   {number}
//  *
//  * E.g. Decimal.config({ precision: 20, rounding: 4 })
//  *
//  */
// function config(obj) {
//   if (!obj || typeof obj !== 'object') {
//     throw Error(decimalError + 'Object expected');
//   }
//   var i, p, v,
//     ps = [
//       'precision', 1, MAX_DIGITS,
//       'rounding', 0, 8,
//       'toExpNeg', -1 / 0, 0,
//       'toExpPos', 0, 1 / 0
//     ];

//   for (i = 0; i < ps.length; i += 3) {
//     if ((v = obj[p = ps[i]]) !== void 0) {
//       if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
//       else throw Error(invalidArgument + p + ': ' + v);
//     }
//   }

//   if ((v = obj[p = 'LN10']) !== void 0) {
//       if (v == Math.LN10) this[p] = new this(v);
//       else throw Error(invalidArgument + p + ': ' + v);
//   }

//   return this;
// }


// // Create and configure initial Decimal constructor.
// var Decimal = clone$1(defaults);

// // Internal constant.
// ONE = new Decimal(1);

// var Decimal$1 = Decimal;

// function _toConsumableArray$8(arr) { return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$c(arr) || _nonIterableSpread$8(); }

// function _nonIterableSpread$8() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

// function _unsupportedIterableToArray$c(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$c(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen); }

// function _iterableToArray$8(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

// function _arrayWithoutHoles$8(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$c(arr); }

// function _arrayLikeToArray$c(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// var identity = function identity(i) {
//   return i;
// };

// var PLACE_HOLDER = {
//   '@@functional/placeholder': true
// };

// var isPlaceHolder = function isPlaceHolder(val) {
//   return val === PLACE_HOLDER;
// };

// var curry0 = function curry0(fn) {
//   return function _curried() {
//     if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? undefined : arguments[0])) {
//       return _curried;
//     }

//     return fn.apply(void 0, arguments);
//   };
// };

// var curryN = function curryN(n, fn) {
//   if (n === 1) {
//     return fn;
//   }

//   return curry0(function () {
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }

//     var argsLength = args.filter(function (arg) {
//       return arg !== PLACE_HOLDER;
//     }).length;

//     if (argsLength >= n) {
//       return fn.apply(void 0, args);
//     }

//     return curryN(n - argsLength, curry0(function () {
//       for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
//         restArgs[_key2] = arguments[_key2];
//       }

//       var newArgs = args.map(function (arg) {
//         return isPlaceHolder(arg) ? restArgs.shift() : arg;
//       });
//       return fn.apply(void 0, _toConsumableArray$8(newArgs).concat(restArgs));
//     }));
//   });
// };

// var curry = function curry(fn) {
//   return curryN(fn.length, fn);
// };
// var range = function range(begin, end) {
//   var arr = [];

//   for (var i = begin; i < end; ++i) {
//     arr[i - begin] = i;
//   }

//   return arr;
// };
// var map = curry(function (fn, arr) {
//   if (Array.isArray(arr)) {
//     return arr.map(fn);
//   }

//   return Object.keys(arr).map(function (key) {
//     return arr[key];
//   }).map(fn);
// });
// var compose = function compose() {
//   for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
//     args[_key3] = arguments[_key3];
//   }

//   if (!args.length) {
//     return identity;
//   }

//   var fns = args.reverse(); // first function can receive multiply arguments

//   var firstFn = fns[0];
//   var tailsFn = fns.slice(1);
//   return function () {
//     return tailsFn.reduce(function (res, fn) {
//       return fn(res);
//     }, firstFn.apply(void 0, arguments));
//   };
// };
// var reverse = function reverse(arr) {
//   if (Array.isArray(arr)) {
//     return arr.reverse();
//   } // can be string


//   return arr.split('').reverse.join('');
// };
// var memoize = function memoize(fn) {
//   var lastArgs = null;
//   var lastResult = null;
//   return function () {
//     for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
//       args[_key4] = arguments[_key4];
//     }

//     if (lastArgs && args.every(function (val, i) {
//       return val === lastArgs[i];
//     })) {
//       return lastResult;
//     }

//     lastArgs = args;
//     lastResult = fn.apply(void 0, args);
//     return lastResult;
//   };
// };

// /**
//  * @fileOverview 一些公用的运算方法
//  * @author xile611
//  * @date 2015-09-17
//  */
// /**
//  * 获取数值的位数
//  * 其中绝对值属于区间[0.1, 1)， 得到的值为0
//  * 绝对值属于区间[0.01, 0.1)，得到的位数为 -1
//  * 绝对值属于区间[0.001, 0.01)，得到的位数为 -2
//  *
//  * @param  {Number} value 数值
//  * @return {Integer} 位数
//  */

// function getDigitCount(value) {
//   var result;

//   if (value === 0) {
//     result = 1;
//   } else {
//     result = Math.floor(new Decimal$1(value).abs().log(10).toNumber()) + 1;
//   }

//   return result;
// }
// /**
//  * 按照固定的步长获取[start, end)这个区间的数据
//  * 并且需要处理js计算精度的问题
//  *
//  * @param  {Decimal} start 起点
//  * @param  {Decimal} end   终点，不包含该值
//  * @param  {Decimal} step  步长
//  * @return {Array}         若干数值
//  */


// function rangeStep(start, end, step) {
//   var num = new Decimal$1(start);
//   var i = 0;
//   var result = []; // magic number to prevent infinite loop

//   while (num.lt(end) && i < 100000) {
//     result.push(num.toNumber());
//     num = num.add(step);
//     i++;
//   }

//   return result;
// }
// /**
//  * 对数值进行线性插值
//  *
//  * @param  {Number} a  定义域的极点
//  * @param  {Number} b  定义域的极点
//  * @param  {Number} t  [0, 1]内的某个值
//  * @return {Number}    定义域内的某个值
//  */


// var interpolateNumber = curry(function (a, b, t) {
//   var newA = +a;
//   var newB = +b;
//   return newA + t * (newB - newA);
// });
// /**
//  * 线性插值的逆运算
//  *
//  * @param  {Number} a 定义域的极点
//  * @param  {Number} b 定义域的极点
//  * @param  {Number} x 可以认为是插值后的一个输出值
//  * @return {Number}   当x在 a ~ b这个范围内时，返回值属于[0, 1]
//  */

// var uninterpolateNumber = curry(function (a, b, x) {
//   var diff = b - +a;
//   diff = diff || Infinity;
//   return (x - a) / diff;
// });
// /**
//  * 线性插值的逆运算，并且有截断的操作
//  *
//  * @param  {Number} a 定义域的极点
//  * @param  {Number} b 定义域的极点
//  * @param  {Number} x 可以认为是插值后的一个输出值
//  * @return {Number}   当x在 a ~ b这个区间内时，返回值属于[0, 1]，
//  * 当x不在 a ~ b这个区间时，会截断到 a ~ b 这个区间
//  */

// var uninterpolateTruncation = curry(function (a, b, x) {
//   var diff = b - +a;
//   diff = diff || Infinity;
//   return Math.max(0, Math.min(1, (x - a) / diff));
// });
// var Arithmetic = {
//   rangeStep: rangeStep,
//   getDigitCount: getDigitCount,
//   interpolateNumber: interpolateNumber,
//   uninterpolateNumber: uninterpolateNumber,
//   uninterpolateTruncation: uninterpolateTruncation
// };

// function _toConsumableArray$7(arr) { return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$b(arr) || _nonIterableSpread$7(); }

// function _nonIterableSpread$7() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

// function _iterableToArray$7(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

// function _arrayWithoutHoles$7(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$b(arr); }

// function _slicedToArray$5(arr, i) { return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$b(arr, i) || _nonIterableRest$5(); }

// function _nonIterableRest$5() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

// function _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }

// function _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// function _iterableToArrayLimit$5(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

// function _arrayWithHoles$5(arr) { if (Array.isArray(arr)) return arr; }
// /**
//  * Calculate a interval of a minimum value and a maximum value
//  *
//  * @param  {Number} min       The minimum value
//  * @param  {Number} max       The maximum value
//  * @return {Array} An interval
//  */

// function getValidInterval(_ref) {
//   var _ref2 = _slicedToArray$5(_ref, 2),
//       min = _ref2[0],
//       max = _ref2[1];

//   var validMin = min,
//       validMax = max; // exchange

//   if (min > max) {
//     validMin = max;
//     validMax = min;
//   }

//   return [validMin, validMax];
// }
// /**
//  * Calculate the step which is easy to understand between ticks, like 10, 20, 25
//  *
//  * @param  {Decimal} roughStep        The rough step calculated by deviding the
//  * difference by the tickCount
//  * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not
//  * @param  {Integer} correctionFactor A correction factor
//  * @return {Decimal} The step which is easy to understand between two ticks
//  */


// function getFormatStep(roughStep, allowDecimals, correctionFactor) {
//   if (roughStep.lte(0)) {
//     return new Decimal$1(0);
//   }

//   var digitCount = Arithmetic.getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger
//   // order of magnitudes than the rough step

//   var digitCountValue = new Decimal$1(10).pow(digitCount);
//   var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong

//   var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
//   var amendStepRatio = new Decimal$1(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
//   var formatStep = amendStepRatio.mul(digitCountValue);
//   return allowDecimals ? formatStep : new Decimal$1(Math.ceil(formatStep));
// }
// /**
//  * calculate the ticks when the minimum value equals to the maximum value
//  *
//  * @param  {Number}  value         The minimum valuue which is also the maximum value
//  * @param  {Integer} tickCount     The count of ticks
//  * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not
//  * @return {Array}                 ticks
//  */


// function getTickOfSingleValue(value, tickCount, allowDecimals) {
//   var step = 1; // calculate the middle value of ticks

//   var middle = new Decimal$1(value);

//   if (!middle.isint() && allowDecimals) {
//     var absVal = Math.abs(value);

//     if (absVal < 1) {
//       // The step should be a float number when the difference is smaller than 1
//       step = new Decimal$1(10).pow(Arithmetic.getDigitCount(value) - 1);
//       middle = new Decimal$1(Math.floor(middle.div(step).toNumber())).mul(step);
//     } else if (absVal > 1) {
//       // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1
//       middle = new Decimal$1(Math.floor(value));
//     }
//   } else if (value === 0) {
//     middle = new Decimal$1(Math.floor((tickCount - 1) / 2));
//   } else if (!allowDecimals) {
//     middle = new Decimal$1(Math.floor(value));
//   }

//   var middleIndex = Math.floor((tickCount - 1) / 2);
//   var fn = compose(map(function (n) {
//     return middle.add(new Decimal$1(n - middleIndex).mul(step)).toNumber();
//   }), range);
//   return fn(0, tickCount);
// }
// /**
//  * Calculate the step
//  *
//  * @param  {Number}  min              The minimum value of an interval
//  * @param  {Number}  max              The maximum value of an interval
//  * @param  {Integer} tickCount        The count of ticks
//  * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not
//  * @param  {Number}  correctionFactor A correction factor
//  * @return {Object}  The step, minimum value of ticks, maximum value of ticks
//  */


// function calculateStep(min, max, tickCount, allowDecimals) {
//   var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

//   // dirty hack (for recharts' test)
//   if (!Number.isFinite((max - min) / (tickCount - 1))) {
//     return {
//       step: new Decimal$1(0),
//       tickMin: new Decimal$1(0),
//       tickMax: new Decimal$1(0)
//     };
//   } // The step which is easy to understand between two ticks


//   var step = getFormatStep(new Decimal$1(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks

//   var middle; // When 0 is inside the interval, 0 should be a tick

//   if (min <= 0 && max >= 0) {
//     middle = new Decimal$1(0);
//   } else {
//     // calculate the middle value
//     middle = new Decimal$1(min).add(max).div(2); // minus modulo value

//     middle = middle.sub(new Decimal$1(middle).mod(step));
//   }

//   var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());
//   var upCount = Math.ceil(new Decimal$1(max).sub(middle).div(step).toNumber());
//   var scaleCount = belowCount + upCount + 1;

//   if (scaleCount > tickCount) {
//     // When more ticks need to cover the interval, step should be bigger.
//     return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);
//   }

//   if (scaleCount < tickCount) {
//     // When less ticks can cover the interval, we should add some additional ticks
//     upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;
//     belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);
//   }

//   return {
//     step: step,
//     tickMin: middle.sub(new Decimal$1(belowCount).mul(step)),
//     tickMax: middle.add(new Decimal$1(upCount).mul(step))
//   };
// }
// /**
//  * Calculate the ticks of an interval, the count of ticks will be guraranteed
//  *
//  * @param  {Number}  min, max      min: The minimum value, max: The maximum value
//  * @param  {Integer} tickCount     The count of ticks
//  * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not
//  * @return {Array}   ticks
//  */


// function getNiceTickValuesFn(_ref3) {
//   var _ref4 = _slicedToArray$5(_ref3, 2),
//       min = _ref4[0],
//       max = _ref4[1];

//   var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
//   var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
//   // More than two ticks should be return
//   var count = Math.max(tickCount, 2);

//   var _getValidInterval = getValidInterval([min, max]),
//       _getValidInterval2 = _slicedToArray$5(_getValidInterval, 2),
//       cormin = _getValidInterval2[0],
//       cormax = _getValidInterval2[1];

//   if (cormin === -Infinity || cormax === Infinity) {
//     var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray$7(range(0, tickCount - 1).map(function () {
//       return Infinity;
//     }))) : [].concat(_toConsumableArray$7(range(0, tickCount - 1).map(function () {
//       return -Infinity;
//     })), [cormax]);

//     return min > max ? reverse(_values) : _values;
//   }

//   if (cormin === cormax) {
//     return getTickOfSingleValue(cormin, tickCount, allowDecimals);
//   } // Get the step between two ticks


//   var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),
//       step = _calculateStep.step,
//       tickMin = _calculateStep.tickMin,
//       tickMax = _calculateStep.tickMax;

//   var values = Arithmetic.rangeStep(tickMin, tickMax.add(new Decimal$1(0.1).mul(step)), step);
//   return min > max ? reverse(values) : values;
// }
// /**
//  * Calculate the ticks of an interval, the count of ticks won't be guraranteed,
//  * but the domain will be guaranteed
//  *
//  * @param  {Number}  min, max      min: The minimum value, max: The maximum value
//  * @param  {Integer} tickCount     The count of ticks
//  * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not
//  * @return {Array}   ticks
//  */


// function getTickValuesFixedDomainFn(_ref7, tickCount) {
//   var _ref8 = _slicedToArray$5(_ref7, 2),
//       min = _ref8[0],
//       max = _ref8[1];

//   var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

//   // More than two ticks should be return
//   var _getValidInterval5 = getValidInterval([min, max]),
//       _getValidInterval6 = _slicedToArray$5(_getValidInterval5, 2),
//       cormin = _getValidInterval6[0],
//       cormax = _getValidInterval6[1];

//   if (cormin === -Infinity || cormax === Infinity) {
//     return [min, max];
//   }

//   if (cormin === cormax) {
//     return [cormin];
//   }

//   var count = Math.max(tickCount, 2);
//   var step = getFormatStep(new Decimal$1(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
//   var values = [].concat(_toConsumableArray$7(Arithmetic.rangeStep(new Decimal$1(cormin), new Decimal$1(cormax).sub(new Decimal$1(0.99).mul(step)), step)), [cormax]);
//   return min > max ? reverse(values) : values;
// }

// var getNiceTickValues = memoize(getNiceTickValuesFn);
// var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);

// var _excluded$b = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];
// function _extends$i() { _extends$i = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$i.apply(this, arguments); }
// function _slicedToArray$4(arr, i) { return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$a(arr, i) || _nonIterableRest$4(); }
// function _nonIterableRest$4() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }
// function _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$4(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles$4(arr) { if (Array.isArray(arr)) return arr; }
// function _objectWithoutProperties$a(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$a(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$a(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function ErrorBar(props) {
//   var offset = props.offset,
//     layout = props.layout,
//     width = props.width,
//     dataKey = props.dataKey,
//     data = props.data,
//     dataPointFormatter = props.dataPointFormatter,
//     xAxis = props.xAxis,
//     yAxis = props.yAxis,
//     others = _objectWithoutProperties$a(props, _excluded$b);
//   var svgProps = filterProps(others);
//   var errorBars = data.map(function (entry) {
//     var _dataPointFormatter = dataPointFormatter(entry, dataKey),
//       x = _dataPointFormatter.x,
//       y = _dataPointFormatter.y,
//       value = _dataPointFormatter.value,
//       errorVal = _dataPointFormatter.errorVal;
//     if (!errorVal) {
//       return null;
//     }
//     var lineCoordinates = [];
//     var lowBound, highBound;
//     if (Array.isArray(errorVal)) {
//       var _errorVal = _slicedToArray$4(errorVal, 2);
//       lowBound = _errorVal[0];
//       highBound = _errorVal[1];
//     } else {
//       lowBound = highBound = errorVal;
//     }
//     if (layout === 'vertical') {
//       // error bar for horizontal charts, the y is fixed, x is a range value
//       var scale = xAxis.scale;
//       var yMid = y + offset;
//       var yMin = yMid + width;
//       var yMax = yMid - width;
//       var xMin = scale(value - lowBound);
//       var xMax = scale(value + highBound);

//       // the right line of |--|
//       lineCoordinates.push({
//         x1: xMax,
//         y1: yMin,
//         x2: xMax,
//         y2: yMax
//       });
//       // the middle line of |--|
//       lineCoordinates.push({
//         x1: xMin,
//         y1: yMid,
//         x2: xMax,
//         y2: yMid
//       });
//       // the left line of |--|
//       lineCoordinates.push({
//         x1: xMin,
//         y1: yMin,
//         x2: xMin,
//         y2: yMax
//       });
//     } else if (layout === 'horizontal') {
//       // error bar for horizontal charts, the x is fixed, y is a range value
//       var _scale = yAxis.scale;
//       var xMid = x + offset;
//       var _xMin = xMid - width;
//       var _xMax = xMid + width;
//       var _yMin = _scale(value - lowBound);
//       var _yMax = _scale(value + highBound);

//       // the top line
//       lineCoordinates.push({
//         x1: _xMin,
//         y1: _yMax,
//         x2: _xMax,
//         y2: _yMax
//       });
//       // the middle line
//       lineCoordinates.push({
//         x1: xMid,
//         y1: _yMin,
//         x2: xMid,
//         y2: _yMax
//       });
//       // the bottom line
//       lineCoordinates.push({
//         x1: _xMin,
//         y1: _yMin,
//         x2: _xMax,
//         y2: _yMin
//       });
//     }
//     return /*#__PURE__*/React__default.createElement(Layer, _extends$i({
//       className: "recharts-errorBar",
//       key: "bar-".concat(lineCoordinates.map(function (c) {
//         return "".concat(c.x1, "-").concat(c.x2, "-").concat(c.y1, "-").concat(c.y2);
//       }))
//     }, svgProps), lineCoordinates.map(function (coordinates) {
//       return /*#__PURE__*/React__default.createElement("line", _extends$i({}, coordinates, {
//         key: "line-".concat(coordinates.x1, "-").concat(coordinates.x2, "-").concat(coordinates.y1, "-").concat(coordinates.y2)
//       }));
//     }));
//   });
//   return /*#__PURE__*/React__default.createElement(Layer, {
//     className: "recharts-errorBars"
//   }, errorBars);
// }
// ErrorBar.defaultProps = {
//   stroke: 'black',
//   strokeWidth: 1.5,
//   width: 5,
//   offset: 0,
//   layout: 'horizontal'
// };
// ErrorBar.displayName = 'ErrorBar';

// function _typeof$p(o) { "@babel/helpers - typeof"; return _typeof$p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$p(o); }
// function ownKeys$n(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$n(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$n(Object(t), !0).forEach(function (r) { _defineProperty$o(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$o(obj, key, value) { key = _toPropertyKey$o(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$o(arg) { var key = _toPrimitive$o(arg, "string"); return _typeof$p(key) === "symbol" ? key : String(key); }
// function _toPrimitive$o(input, hint) { if (_typeof$p(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$p(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var getLegendProps = function getLegendProps(_ref) {
//   var children = _ref.children,
//     formattedGraphicalItems = _ref.formattedGraphicalItems,
//     legendWidth = _ref.legendWidth,
//     legendContent = _ref.legendContent;
//   var legendItem = findChildByType(children, Legend);
//   if (!legendItem) {
//     return null;
//   }
//   var legendData;
//   if (legendItem.props && legendItem.props.payload) {
//     legendData = legendItem.props && legendItem.props.payload;
//   } else if (legendContent === 'children') {
//     legendData = (formattedGraphicalItems || []).reduce(function (result, _ref2) {
//       var item = _ref2.item,
//         props = _ref2.props;
//       var data = props.sectors || props.data || [];
//       return result.concat(data.map(function (entry) {
//         return {
//           type: legendItem.props.iconType || item.props.legendType,
//           value: entry.name,
//           color: entry.fill,
//           payload: entry
//         };
//       }));
//     }, []);
//   } else {
//     legendData = (formattedGraphicalItems || []).map(function (_ref3) {
//       var item = _ref3.item;
//       var _item$props = item.props,
//         dataKey = _item$props.dataKey,
//         name = _item$props.name,
//         legendType = _item$props.legendType,
//         hide = _item$props.hide;
//       return {
//         inactive: hide,
//         dataKey: dataKey,
//         type: legendItem.props.iconType || legendType || 'square',
//         color: getMainColorOfGraphicItem(item),
//         value: name || dataKey,
//         // @ts-expect-error property strokeDasharray is required in Payload but optional in props
//         payload: item.props
//       };
//     });
//   }
//   return _objectSpread$n(_objectSpread$n(_objectSpread$n({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {
//     payload: legendData,
//     item: legendItem
//   });
// };

// function _typeof$o(o) { "@babel/helpers - typeof"; return _typeof$o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$o(o); }
// function ownKeys$m(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$m(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$m(Object(t), !0).forEach(function (r) { _defineProperty$n(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$n(obj, key, value) { key = _toPropertyKey$n(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$n(arg) { var key = _toPrimitive$n(arg, "string"); return _typeof$o(key) === "symbol" ? key : String(key); }
// function _toPrimitive$n(input, hint) { if (_typeof$o(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$o(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _toConsumableArray$6(arr) { return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread$6(); }
// function _nonIterableSpread$6() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }
// function _iterableToArray$6(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$6(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$9(arr); }
// function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function getValueByDataKey(obj, dataKey, defaultValue) {
//   if (isNil$1(obj) || isNil$1(dataKey)) {
//     return defaultValue;
//   }
//   if (isNumOrStr(dataKey)) {
//     return get(obj, dataKey, defaultValue);
//   }
//   if (isFunction(dataKey)) {
//     return dataKey(obj);
//   }
//   return defaultValue;
// }
// /**
//  * Get domain of data by key.
//  * @param  {Array}   data      The data displayed in the chart
//  * @param  {String}  key       The unique key of a group of data
//  * @param  {String}  type      The type of axis
//  * @param  {Boolean} filterNil Whether or not filter nil values
//  * @return {Array} Domain of data
//  */
// function getDomainOfDataByKey(data, key, type, filterNil) {
//   var flattenData = flatMap(data, function (entry) {
//     return getValueByDataKey(entry, key);
//   });
//   if (type === 'number') {
//     // @ts-expect-error parseFloat type only accepts strings
//     var domain = flattenData.filter(function (entry) {
//       return isNumber(entry) || parseFloat(entry);
//     });
//     return domain.length ? [min(domain), max(domain)] : [Infinity, -Infinity];
//   }
//   var validateData = filterNil ? flattenData.filter(function (entry) {
//     return !isNil$1(entry);
//   }) : flattenData;

//   // Supports x-axis of Date type
//   return validateData.map(function (entry) {
//     return isNumOrStr(entry) || entry instanceof Date ? entry : '';
//   });
// }
// var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {
//   var _ticks$length;
//   var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
//   var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;
//   var axis = arguments.length > 3 ? arguments[3] : undefined;
//   var index = -1;
//   var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;

//   // if there are 1 or less ticks ticks then the active tick is at index 0
//   if (len <= 1) {
//     return 0;
//   }
//   if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {
//     var range = axis.range;
//     // ticks are distributed in a circle
//     for (var i = 0; i < len; i++) {
//       var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
//       var cur = unsortedTicks[i].coordinate;
//       var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
//       var sameDirectionCoord = void 0;
//       if (mathSign(cur - before) !== mathSign(after - cur)) {
//         var diffInterval = [];
//         if (mathSign(after - cur) === mathSign(range[1] - range[0])) {
//           sameDirectionCoord = after;
//           var curInRange = cur + range[1] - range[0];
//           diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
//           diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
//         } else {
//           sameDirectionCoord = before;
//           var afterInRange = after + range[1] - range[0];
//           diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
//           diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
//         }
//         var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
//         if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
//           index = unsortedTicks[i].index;
//           break;
//         }
//       } else {
//         var minValue = Math.min(before, after);
//         var maxValue = Math.max(before, after);
//         if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
//           index = unsortedTicks[i].index;
//           break;
//         }
//       }
//     }
//   } else {
//     // ticks are distributed in a single direction
//     for (var _i = 0; _i < len; _i++) {
//       if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {
//         index = ticks[_i].index;
//         break;
//       }
//     }
//   }
//   return index;
// };

// /**
//  * Get the main color of each graphic item
//  * @param  {ReactElement} item A graphic item
//  * @return {String}            Color
//  */
// var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {
//   var _ref = item,
//     displayName = _ref.type.displayName; // TODO: check if displayName is valid.
//   var _item$props = item.props,
//     stroke = _item$props.stroke,
//     fill = _item$props.fill;
//   var result;
//   switch (displayName) {
//     case 'Line':
//       result = stroke;
//       break;
//     case 'Area':
//     case 'Radar':
//       result = stroke && stroke !== 'none' ? stroke : fill;
//       break;
//     default:
//       result = fill;
//       break;
//   }
//   return result;
// };
// /**
//  * Calculate the size of all groups for stacked bar graph
//  * @param  {Object} stackGroups The items grouped by axisId and stackId
//  * @return {Object} The size of all groups
//  */
// var getBarSizeList = function getBarSizeList(_ref2) {
//   var globalSize = _ref2.barSize,
//     _ref2$stackGroups = _ref2.stackGroups,
//     stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;
//   if (!stackGroups) {
//     return {};
//   }
//   var result = {};
//   var numericAxisIds = Object.keys(stackGroups);
//   for (var i = 0, len = numericAxisIds.length; i < len; i++) {
//     var sgs = stackGroups[numericAxisIds[i]].stackGroups;
//     var stackIds = Object.keys(sgs);
//     for (var j = 0, sLen = stackIds.length; j < sLen; j++) {
//       var _sgs$stackIds$j = sgs[stackIds[j]],
//         items = _sgs$stackIds$j.items,
//         cateAxisId = _sgs$stackIds$j.cateAxisId;
//       var barItems = items.filter(function (item) {
//         return getDisplayName(item.type).indexOf('Bar') >= 0;
//       });
//       if (barItems && barItems.length) {
//         var selfSize = barItems[0].props.barSize;
//         var cateId = barItems[0].props[cateAxisId];
//         if (!result[cateId]) {
//           result[cateId] = [];
//         }
//         result[cateId].push({
//           item: barItems[0],
//           stackList: barItems.slice(1),
//           barSize: isNil$1(selfSize) ? globalSize : selfSize
//         });
//       }
//     }
//   }
//   return result;
// };
// /**
//  * Calculate the size of each bar and offset between start of band and the bar
//  *
//  * @param  {number} bandSize is the size of area where bars can render
//  * @param  {number | string} barGap is the gap size, as a percentage of `bandSize`.
//  *                                  Can be defined as number or percent string
//  * @param  {number | string} barCategoryGap is the gap size, as a percentage of `bandSize`.
//  *                                  Can be defined as number or percent string
//  * @param  {Array<object>} sizeList Sizes of all groups
//  * @param  {number} maxBarSize The maximum size of each bar
//  * @return {Array<object>} The size and offset of each bar
//  */
// var getBarPosition = function getBarPosition(_ref3) {
//   var barGap = _ref3.barGap,
//     barCategoryGap = _ref3.barCategoryGap,
//     bandSize = _ref3.bandSize,
//     _ref3$sizeList = _ref3.sizeList,
//     sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList,
//     maxBarSize = _ref3.maxBarSize;
//   var len = sizeList.length;
//   if (len < 1) return null;
//   var realBarGap = getPercentValue(barGap, bandSize, 0, true);
//   var result;
//   var initialValue = [];

//   // whether or not is barSize setted by user
//   if (sizeList[0].barSize === +sizeList[0].barSize) {
//     var useFull = false;
//     var fullBarSize = bandSize / len;
//     // @ts-expect-error the type check above does not check for type number explicitly
//     var sum = sizeList.reduce(function (res, entry) {
//       return res + entry.barSize || 0;
//     }, 0);
//     sum += (len - 1) * realBarGap;
//     if (sum >= bandSize) {
//       sum -= (len - 1) * realBarGap;
//       realBarGap = 0;
//     }
//     if (sum >= bandSize && fullBarSize > 0) {
//       useFull = true;
//       fullBarSize *= 0.9;
//       sum = len * fullBarSize;
//     }
//     var offset = (bandSize - sum) / 2 >> 0;
//     var prev = {
//       offset: offset - realBarGap,
//       size: 0
//     };
//     result = sizeList.reduce(function (res, entry) {
//       var newPosition = {
//         item: entry.item,
//         position: {
//           offset: prev.offset + prev.size + realBarGap,
//           // @ts-expect-error the type check above does not check for type number explicitly
//           size: useFull ? fullBarSize : entry.barSize
//         }
//       };
//       var newRes = [].concat(_toConsumableArray$6(res), [newPosition]);
//       prev = newRes[newRes.length - 1].position;
//       if (entry.stackList && entry.stackList.length) {
//         entry.stackList.forEach(function (item) {
//           newRes.push({
//             item: item,
//             position: prev
//           });
//         });
//       }
//       return newRes;
//     }, initialValue);
//   } else {
//     var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
//     if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
//       realBarGap = 0;
//     }
//     var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
//     if (originalSize > 1) {
//       originalSize >>= 0;
//     }
//     var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
//     result = sizeList.reduce(function (res, entry, i) {
//       var newRes = [].concat(_toConsumableArray$6(res), [{
//         item: entry.item,
//         position: {
//           offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
//           size: size
//         }
//       }]);
//       if (entry.stackList && entry.stackList.length) {
//         entry.stackList.forEach(function (item) {
//           newRes.push({
//             item: item,
//             position: newRes[newRes.length - 1].position
//           });
//         });
//       }
//       return newRes;
//     }, initialValue);
//   }
//   return result;
// };
// var appendOffsetOfLegend = function appendOffsetOfLegend(offset, _unused, props, legendBox) {
//   var children = props.children,
//     width = props.width,
//     margin = props.margin;
//   var legendWidth = width - (margin.left || 0) - (margin.right || 0);
//   var legendProps = getLegendProps({
//     children: children,
//     legendWidth: legendWidth
//   });
//   if (legendProps) {
//     var _ref4 = legendBox || {},
//       boxWidth = _ref4.width,
//       boxHeight = _ref4.height;
//     var align = legendProps.align,
//       verticalAlign = legendProps.verticalAlign,
//       layout = legendProps.layout;
//     if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {
//       return _objectSpread$m(_objectSpread$m({}, offset), {}, _defineProperty$n({}, align, offset[align] + (boxWidth || 0)));
//     }
//     if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {
//       return _objectSpread$m(_objectSpread$m({}, offset), {}, _defineProperty$n({}, verticalAlign, offset[verticalAlign] + (boxHeight || 0)));
//     }
//   }
//   return offset;
// };
// var isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {
//   if (isNil$1(axisType)) {
//     return true;
//   }
//   if (layout === 'horizontal') {
//     return axisType === 'yAxis';
//   }
//   if (layout === 'vertical') {
//     return axisType === 'xAxis';
//   }
//   if (direction === 'x') {
//     return axisType === 'xAxis';
//   }
//   if (direction === 'y') {
//     return axisType === 'yAxis';
//   }
//   return true;
// };
// var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {
//   var children = item.props.children;
//   var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {
//     return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);
//   });
//   if (errorBars && errorBars.length) {
//     var keys = errorBars.map(function (errorBarChild) {
//       return errorBarChild.props.dataKey;
//     });
//     return data.reduce(function (result, entry) {
//       var entryValue = getValueByDataKey(entry, dataKey, 0);
//       var mainValue = Array.isArray(entryValue) ? [min(entryValue), max(entryValue)] : [entryValue, entryValue];
//       var errorDomain = keys.reduce(function (prevErrorArr, k) {
//         var errorValue = getValueByDataKey(entry, k, 0);
//         var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);
//         var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);
//         return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
//       }, [Infinity, -Infinity]);
//       return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
//     }, [Infinity, -Infinity]);
//   }
//   return null;
// };
// var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {
//   var domains = items.map(function (item) {
//     return getDomainOfErrorBars(data, item, dataKey, layout, axisType);
//   }).filter(function (entry) {
//     return !isNil$1(entry);
//   });
//   if (domains && domains.length) {
//     return domains.reduce(function (result, entry) {
//       return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
//     }, [Infinity, -Infinity]);
//   }
//   return null;
// };

// /**
//  * Get domain of data by the configuration of item element
//  * @param  {Array}   data      The data displayed in the chart
//  * @param  {Array}   items     The instances of item
//  * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis
//  * @param  {LayoutType} layout The type of layout
//  * @param  {Boolean} filterNil Whether or not filter nil values
//  * @return {Array}        Domain
//  */
// var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {
//   var domains = items.map(function (item) {
//     var dataKey = item.props.dataKey;
//     if (type === 'number' && dataKey) {
//       return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);
//     }
//     return getDomainOfDataByKey(data, dataKey, type, filterNil);
//   });
//   if (type === 'number') {
//     // Calculate the domain of number axis
//     return domains.reduce(
//     // @ts-expect-error if (type === number) means that the domain is numerical type
//     // - but this link is missing in the type definition
//     function (result, entry) {
//       return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
//     }, [Infinity, -Infinity]);
//   }
//   var tag = {};
//   // Get the union set of category axis
//   return domains.reduce(function (result, entry) {
//     for (var i = 0, len = entry.length; i < len; i++) {
//       // @ts-expect-error Date cannot index an object
//       if (!tag[entry[i]]) {
//         // @ts-expect-error Date cannot index an object
//         tag[entry[i]] = true;

//         // @ts-expect-error Date cannot index an object
//         result.push(entry[i]);
//       }
//     }
//     return result;
//   }, []);
// };
// var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {
//   return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';
// };

// /**
//  * Calculate the Coordinates of grid
//  * @param  {Array} ticks           The ticks in axis
//  * @param {Number} minValue        The minimun value of axis
//  * @param {Number} maxValue        The maximun value of axis
//  * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not
//  * @return {Array}                 Coordinates
//  */
// var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, minValue, maxValue, syncWithTicks) {
//   if (syncWithTicks) {
//     return ticks.map(function (entry) {
//       return entry.coordinate;
//     });
//   }
//   var hasMin, hasMax;
//   var values = ticks.map(function (entry) {
//     if (entry.coordinate === minValue) {
//       hasMin = true;
//     }
//     if (entry.coordinate === maxValue) {
//       hasMax = true;
//     }
//     return entry.coordinate;
//   });
//   if (!hasMin) {
//     values.push(minValue);
//   }
//   if (!hasMax) {
//     values.push(maxValue);
//   }
//   return values;
// };

// /**
//  * Get the ticks of an axis
//  * @param  {Object}  axis The configuration of an axis
//  * @param {Boolean} isGrid Whether or not are the ticks in grid
//  * @param {Boolean} isAll Return the ticks of all the points or not
//  * @return {Array}  Ticks
//  */
// var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {
//   if (!axis) return null;
//   var scale = axis.scale;
//   var duplicateDomain = axis.duplicateDomain,
//     type = axis.type,
//     range = axis.range;
//   var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;
//   var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
//   offset = axis.axisType === 'angleAxis' && (range === null || range === void 0 ? void 0 : range.length) >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;

//   // The ticks set by user should only affect the ticks adjacent to axis line
//   if (isGrid && (axis.ticks || axis.niceTicks)) {
//     var result = (axis.ticks || axis.niceTicks).map(function (entry) {
//       var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
//       return {
//         // If the scaleContent is not a number, the coordinate will be NaN.
//         // That could be the case for example with a PointScale and a string as domain.
//         coordinate: scale(scaleContent) + offset,
//         value: entry,
//         offset: offset
//       };
//     });
//     return result.filter(function (row) {
//       return !isNan(row.coordinate);
//     });
//   }

//   // When axis is a categorial axis, but the type of axis is number or the scale of axis is not "auto"
//   if (axis.isCategorical && axis.categoricalDomain) {
//     return axis.categoricalDomain.map(function (entry, index) {
//       return {
//         coordinate: scale(entry) + offset,
//         value: entry,
//         index: index,
//         offset: offset
//       };
//     });
//   }
//   if (scale.ticks && !isAll) {
//     return scale.ticks(axis.tickCount).map(function (entry) {
//       return {
//         coordinate: scale(entry) + offset,
//         value: entry,
//         offset: offset
//       };
//     });
//   }

//   // When axis has duplicated text, serial numbers are used to generate scale
//   return scale.domain().map(function (entry, index) {
//     return {
//       coordinate: scale(entry) + offset,
//       value: duplicateDomain ? duplicateDomain[entry] : entry,
//       index: index,
//       offset: offset
//     };
//   });
// };

// /**
//  * combine the handlers
//  * @param  {Function} defaultHandler Internal private handler
//  * @param  {Function} childHandler Handler function specified in child component
//  * @return {Function}                The combined handler
//  */

// var handlerWeakMap = new WeakMap();
// var combineEventHandlers = function combineEventHandlers(defaultHandler, childHandler) {
//   if (typeof childHandler !== 'function') {
//     return defaultHandler;
//   }
//   if (!handlerWeakMap.has(defaultHandler)) {
//     handlerWeakMap.set(defaultHandler, new WeakMap());
//   }
//   var childWeakMap = handlerWeakMap.get(defaultHandler);
//   if (childWeakMap.has(childHandler)) {
//     return childWeakMap.get(childHandler);
//   }
//   var combineHandler = function combineHandler() {
//     defaultHandler.apply(void 0, arguments);
//     childHandler.apply(void 0, arguments);
//   };
//   childWeakMap.set(childHandler, combineHandler);
//   return combineHandler;
// };

// /**
//  * Parse the scale function of axis
//  * @param  {Object}   axis          The option of axis
//  * @param  {String}   chartType     The displayName of chart
//  * @param  {Boolean}  hasBar        if it has a bar
//  * @return {object}               The scale function and resolved name
//  */
// var parseScale = function parseScale(axis, chartType, hasBar) {
//   var scale = axis.scale,
//     type = axis.type,
//     layout = axis.layout,
//     axisType = axis.axisType;
//   if (scale === 'auto') {
//     if (layout === 'radial' && axisType === 'radiusAxis') {
//       return {
//         scale: d3Scales.scaleBand(),
//         realScaleType: 'band'
//       };
//     }
//     if (layout === 'radial' && axisType === 'angleAxis') {
//       return {
//         scale: d3Scales.scaleLinear(),
//         realScaleType: 'linear'
//       };
//     }
//     if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {
//       return {
//         scale: d3Scales.scalePoint(),
//         realScaleType: 'point'
//       };
//     }
//     if (type === 'category') {
//       return {
//         scale: d3Scales.scaleBand(),
//         realScaleType: 'band'
//       };
//     }
//     return {
//       scale: d3Scales.scaleLinear(),
//       realScaleType: 'linear'
//     };
//   }
//   if (isString(scale)) {
//     var name = "scale".concat(upperFirst(scale));
//     return {
//       scale: (d3Scales[name] || d3Scales.scalePoint)(),
//       realScaleType: d3Scales[name] ? name : 'point'
//     };
//   }
//   return isFunction(scale) ? {
//     scale: scale
//   } : {
//     scale: d3Scales.scalePoint(),
//     realScaleType: 'point'
//   };
// };
// var EPS = 1e-4;
// var checkDomainOfScale = function checkDomainOfScale(scale) {
//   var domain = scale.domain();
//   if (!domain || domain.length <= 2) {
//     return;
//   }
//   var len = domain.length;
//   var range = scale.range();
//   var minValue = Math.min(range[0], range[1]) - EPS;
//   var maxValue = Math.max(range[0], range[1]) + EPS;
//   var first = scale(domain[0]);
//   var last = scale(domain[len - 1]);
//   if (first < minValue || first > maxValue || last < minValue || last > maxValue) {
//     scale.domain([domain[0], domain[len - 1]]);
//   }
// };
// var findPositionOfBar = function findPositionOfBar(barPosition, child) {
//   if (!barPosition) {
//     return null;
//   }
//   for (var i = 0, len = barPosition.length; i < len; i++) {
//     if (barPosition[i].item === child) {
//       return barPosition[i].position;
//     }
//   }
//   return null;
// };

// /**
//  * Both value and domain are tuples of two numbers
//  * - but the type stays as array of numbers until we have better support in rest of the app
//  * @param {Array} value input that will be truncated
//  * @param {Array} domain boundaries
//  * @returns {Array} tuple of two numbers
//  */
// var truncateByDomain = function truncateByDomain(value, domain) {
//   if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {
//     return value;
//   }
//   var minValue = Math.min(domain[0], domain[1]);
//   var maxValue = Math.max(domain[0], domain[1]);
//   var result = [value[0], value[1]];
//   if (!isNumber(value[0]) || value[0] < minValue) {
//     result[0] = minValue;
//   }
//   if (!isNumber(value[1]) || value[1] > maxValue) {
//     result[1] = maxValue;
//   }
//   if (result[0] > maxValue) {
//     result[0] = maxValue;
//   }
//   if (result[1] < minValue) {
//     result[1] = minValue;
//   }
//   return result;
// };

// /**
//  * Stacks all positive numbers above zero and all negative numbers below zero.
//  *
//  * If all values in the series are positive then this behaves the same as 'none' stacker.
//  *
//  * @param {Array} series from d3-shape Stack
//  * @return {Array} series with applied offset
//  */
// var offsetSign = function offsetSign(series) {
//   var n = series.length;
//   if (n <= 0) {
//     return;
//   }
//   for (var j = 0, m = series[0].length; j < m; ++j) {
//     var positive = 0;
//     var negative = 0;
//     for (var i = 0; i < n; ++i) {
//       var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];

//       /* eslint-disable prefer-destructuring, no-param-reassign */
//       if (value >= 0) {
//         series[i][j][0] = positive;
//         series[i][j][1] = positive + value;
//         positive = series[i][j][1];
//       } else {
//         series[i][j][0] = negative;
//         series[i][j][1] = negative + value;
//         negative = series[i][j][1];
//       }
//       /* eslint-enable prefer-destructuring, no-param-reassign */
//     }
//   }
// };

// /**
//  * Replaces all negative values with zero when stacking data.
//  *
//  * If all values in the series are positive then this behaves the same as 'none' stacker.
//  *
//  * @param {Array} series from d3-shape Stack
//  * @return {Array} series with applied offset
//  */
// var offsetPositive = function offsetPositive(series) {
//   var n = series.length;
//   if (n <= 0) {
//     return;
//   }
//   for (var j = 0, m = series[0].length; j < m; ++j) {
//     var positive = 0;
//     for (var i = 0; i < n; ++i) {
//       var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];

//       /* eslint-disable prefer-destructuring, no-param-reassign */
//       if (value >= 0) {
//         series[i][j][0] = positive;
//         series[i][j][1] = positive + value;
//         positive = series[i][j][1];
//       } else {
//         series[i][j][0] = 0;
//         series[i][j][1] = 0;
//       }
//       /* eslint-enable prefer-destructuring, no-param-reassign */
//     }
//   }
// };

// /**
//  * Function type to compute offset for stacked data.
//  *
//  * d3-shape has something fishy going on with its types.
//  * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.
//  * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.
//  * The same I can see in the source code itself:
//  * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042
//  * That one unfortunately has no types but we can tell it passes three-dimensional array.
//  *
//  * Which leads me to believe that definitelytyped is wrong on this one.
//  * There's open discussion on this topic without much attention:
//  * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042
//  */

// var STACK_OFFSET_MAP = {
//   sign: offsetSign,
//   // @ts-expect-error definitelytyped types are incorrect
//   expand: stackOffsetExpand,
//   // @ts-expect-error definitelytyped types are incorrect
//   none: stackOffsetNone,
//   // @ts-expect-error definitelytyped types are incorrect
//   silhouette: stackOffsetSilhouette,
//   // @ts-expect-error definitelytyped types are incorrect
//   wiggle: stackOffsetWiggle,
//   positive: offsetPositive
// };
// var getStackedData = function getStackedData(data, stackItems, offsetType) {
//   var dataKeys = stackItems.map(function (item) {
//     return item.props.dataKey;
//   });
//   var offsetAccessor = STACK_OFFSET_MAP[offsetType];
//   var stack$1 = stack()
//   // @ts-expect-error stack.keys type wants an array of strings, but we provide array of DataKeys
//   .keys(dataKeys).value(function (d, key) {
//     return +getValueByDataKey(d, key, 0);
//   }).order(stackOrderNone)
//   // @ts-expect-error definitelytyped types are incorrect
//   .offset(offsetAccessor);
//   return stack$1(data);
// };
// var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
//   if (!data) {
//     return null;
//   }

//   // reversing items to affect render order (for layering)
//   var items = reverseStackOrder ? _items.reverse() : _items;
//   var parentStackGroupsInitialValue = {};
//   var stackGroups = items.reduce(function (result, item) {
//     var _item$props2 = item.props,
//       stackId = _item$props2.stackId,
//       hide = _item$props2.hide;
//     if (hide) {
//       return result;
//     }
//     var axisId = item.props[numericAxisId];
//     var parentGroup = result[axisId] || {
//       hasStack: false,
//       stackGroups: {}
//     };
//     if (isNumOrStr(stackId)) {
//       var childGroup = parentGroup.stackGroups[stackId] || {
//         numericAxisId: numericAxisId,
//         cateAxisId: cateAxisId,
//         items: []
//       };
//       childGroup.items.push(item);
//       parentGroup.hasStack = true;
//       parentGroup.stackGroups[stackId] = childGroup;
//     } else {
//       parentGroup.stackGroups[uniqueId('_stackId_')] = {
//         numericAxisId: numericAxisId,
//         cateAxisId: cateAxisId,
//         items: [item]
//       };
//     }
//     return _objectSpread$m(_objectSpread$m({}, result), {}, _defineProperty$n({}, axisId, parentGroup));
//   }, parentStackGroupsInitialValue);
//   var axisStackGroupsInitialValue = {};
//   return Object.keys(stackGroups).reduce(function (result, axisId) {
//     var group = stackGroups[axisId];
//     if (group.hasStack) {
//       var stackGroupsInitialValue = {};
//       group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {
//         var g = group.stackGroups[stackId];
//         return _objectSpread$m(_objectSpread$m({}, res), {}, _defineProperty$n({}, stackId, {
//           numericAxisId: numericAxisId,
//           cateAxisId: cateAxisId,
//           items: g.items,
//           stackedData: getStackedData(data, g.items, offsetType)
//         }));
//       }, stackGroupsInitialValue);
//     }
//     return _objectSpread$m(_objectSpread$m({}, result), {}, _defineProperty$n({}, axisId, group));
//   }, axisStackGroupsInitialValue);
// };

// /**
//  * Configure the scale function of axis
//  * @param {Object} scale The scale function
//  * @param {Object} opts  The configuration of axis
//  * @return {Object}      null
//  */
// var getTicksOfScale = function getTicksOfScale(scale, opts) {
//   var realScaleType = opts.realScaleType,
//     type = opts.type,
//     tickCount = opts.tickCount,
//     originalDomain = opts.originalDomain,
//     allowDecimals = opts.allowDecimals;
//   var scaleType = realScaleType || opts.scale;
//   if (scaleType !== 'auto' && scaleType !== 'linear') {
//     return null;
//   }
//   if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {
//     // Calculate the ticks by the number of grid when the axis is a number axis
//     var domain = scale.domain();
//     if (!domain.length) {
//       return null;
//     }
//     var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);
//     scale.domain([min(tickValues), max(tickValues)]);
//     return {
//       niceTicks: tickValues
//     };
//   }
//   if (tickCount && type === 'number') {
//     var _domain = scale.domain();
//     var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);
//     return {
//       niceTicks: _tickValues
//     };
//   }
//   return null;
// };
// var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref5) {
//   var axis = _ref5.axis,
//     ticks = _ref5.ticks,
//     bandSize = _ref5.bandSize,
//     entry = _ref5.entry,
//     index = _ref5.index,
//     dataKey = _ref5.dataKey;
//   if (axis.type === 'category') {
//     // find coordinate of category axis by the value of category
//     if (!axis.allowDuplicatedCategory && axis.dataKey && !isNil$1(entry[axis.dataKey])) {
//       var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);
//       if (matchedTick) {
//         return matchedTick.coordinate + bandSize / 2;
//       }
//     }
//     return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;
//   }
//   var value = getValueByDataKey(entry, !isNil$1(dataKey) ? dataKey : axis.dataKey);
//   return !isNil$1(value) ? axis.scale(value) : null;
// };
// var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref6) {
//   var axis = _ref6.axis,
//     ticks = _ref6.ticks,
//     offset = _ref6.offset,
//     bandSize = _ref6.bandSize,
//     entry = _ref6.entry,
//     index = _ref6.index;
//   if (axis.type === 'category') {
//     return ticks[index] ? ticks[index].coordinate + offset : null;
//   }
//   var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);
//   return !isNil$1(value) ? axis.scale(value) - bandSize / 2 + offset : null;
// };
// var getBaseValueOfBar = function getBaseValueOfBar(_ref7) {
//   var numericAxis = _ref7.numericAxis;
//   var domain = numericAxis.scale.domain();
//   if (numericAxis.type === 'number') {
//     var minValue = Math.min(domain[0], domain[1]);
//     var maxValue = Math.max(domain[0], domain[1]);
//     if (minValue <= 0 && maxValue >= 0) {
//       return 0;
//     }
//     if (maxValue < 0) {
//       return maxValue;
//     }
//     return minValue;
//   }
//   return domain[0];
// };
// var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {
//   var stackId = item.props.stackId;
//   if (isNumOrStr(stackId)) {
//     var group = stackGroups[stackId];
//     if (group) {
//       var itemIndex = group.items.indexOf(item);
//       return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
//     }
//   }
//   return null;
// };
// var getDomainOfSingle = function getDomainOfSingle(data) {
//   return data.reduce(function (result, entry) {
//     return [min(entry.concat([result[0]]).filter(isNumber)), max(entry.concat([result[1]]).filter(isNumber))];
//   }, [Infinity, -Infinity]);
// };
// var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {
//   return Object.keys(stackGroups).reduce(function (result, stackId) {
//     var group = stackGroups[stackId];
//     var stackedData = group.stackedData;
//     var domain = stackedData.reduce(function (res, entry) {
//       var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));
//       return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];
//     }, [Infinity, -Infinity]);
//     return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
//   }, [Infinity, -Infinity]).map(function (result) {
//     return result === Infinity || result === -Infinity ? 0 : result;
//   });
// };
// var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
// var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
// var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {
//   if (isFunction(specifiedDomain)) {
//     return specifiedDomain(dataDomain, allowDataOverflow);
//   }
//   if (!Array.isArray(specifiedDomain)) {
//     return dataDomain;
//   }
//   var domain = [];

//   /* eslint-disable prefer-destructuring */
//   if (isNumber(specifiedDomain[0])) {
//     domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
//   } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
//     var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
//     domain[0] = dataDomain[0] - value;
//   } else if (isFunction(specifiedDomain[0])) {
//     domain[0] = specifiedDomain[0](dataDomain[0]);
//   } else {
//     domain[0] = dataDomain[0];
//   }
//   if (isNumber(specifiedDomain[1])) {
//     domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
//   } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
//     var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];
//     domain[1] = dataDomain[1] + _value;
//   } else if (isFunction(specifiedDomain[1])) {
//     domain[1] = specifiedDomain[1](dataDomain[1]);
//   } else {
//     domain[1] = dataDomain[1];
//   }
//   /* eslint-enable prefer-destructuring */

//   return domain;
// };

// /**
//  * Calculate the size between two category
//  * @param  {Object} axis  The options of axis
//  * @param  {Array}  ticks The ticks of axis
//  * @param  {Boolean} isBar if items in axis are bars
//  * @return {Number} Size
//  */
// var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {
//   // @ts-expect-error we need to rethink scale type
//   if (axis && axis.scale && axis.scale.bandwidth) {
//     // @ts-expect-error we need to rethink scale type
//     var bandWidth = axis.scale.bandwidth();
//     if (!isBar || bandWidth > 0) {
//       return bandWidth;
//     }
//   }
//   if (axis && ticks && ticks.length >= 2) {
//     var orderedTicks = sortBy(ticks, function (o) {
//       return o.coordinate;
//     });
//     var bandSize = Infinity;
//     for (var i = 1, len = orderedTicks.length; i < len; i++) {
//       var cur = orderedTicks[i];
//       var prev = orderedTicks[i - 1];
//       bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
//     }
//     return bandSize === Infinity ? 0 : bandSize;
//   }
//   return isBar ? undefined : 0;
// };
// /**
//  * parse the domain of a category axis when a domain is specified
//  * @param   {Array}        specifiedDomain  The domain specified by users
//  * @param   {Array}        calculatedDomain The domain calculated by dateKey
//  * @param   {ReactElement} axisChild        The axis ReactElement
//  * @returns {Array}        domains
//  */
// var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {
//   if (!specifiedDomain || !specifiedDomain.length) {
//     return calculatedDomain;
//   }
//   if (isEqual$1(specifiedDomain, get(axisChild, 'type.defaultProps.domain'))) {
//     return calculatedDomain;
//   }
//   return specifiedDomain;
// };
// var getTooltipItem = function getTooltipItem(graphicalItem, payload) {
//   var _graphicalItem$props = graphicalItem.props,
//     dataKey = _graphicalItem$props.dataKey,
//     name = _graphicalItem$props.name,
//     unit = _graphicalItem$props.unit,
//     formatter = _graphicalItem$props.formatter,
//     tooltipType = _graphicalItem$props.tooltipType,
//     chartType = _graphicalItem$props.chartType;
//   return _objectSpread$m(_objectSpread$m({}, filterProps(graphicalItem)), {}, {
//     dataKey: dataKey,
//     unit: unit,
//     formatter: formatter,
//     name: name || dataKey,
//     color: getMainColorOfGraphicItem(graphicalItem),
//     value: getValueByDataKey(payload, dataKey),
//     type: tooltipType,
//     payload: payload,
//     chartType: chartType
//   });
// };

// function _typeof$n(o) { "@babel/helpers - typeof"; return _typeof$n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$n(o); }
// function ownKeys$l(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$l(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$l(Object(t), !0).forEach(function (r) { _defineProperty$m(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$m(obj, key, value) { key = _toPropertyKey$m(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$m(arg) { var key = _toPrimitive$m(arg, "string"); return _typeof$n(key) === "symbol" ? key : String(key); }
// function _toPrimitive$m(input, hint) { if (_typeof$n(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$n(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var RADIAN = Math.PI / 180;
// var radianToDegree = function radianToDegree(angleInRadian) {
//   return angleInRadian * 180 / Math.PI;
// };
// var polarToCartesian = function polarToCartesian(cx, cy, radius, angle) {
//   return {
//     x: cx + Math.cos(-RADIAN * angle) * radius,
//     y: cy + Math.sin(-RADIAN * angle) * radius
//   };
// };
// var distanceBetweenPoints = function distanceBetweenPoints(point, anotherPoint) {
//   var x1 = point.x,
//     y1 = point.y;
//   var x2 = anotherPoint.x,
//     y2 = anotherPoint.y;
//   return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
// };
// var getAngleOfPoint = function getAngleOfPoint(_ref, _ref2) {
//   var x = _ref.x,
//     y = _ref.y;
//   var cx = _ref2.cx,
//     cy = _ref2.cy;
//   var radius = distanceBetweenPoints({
//     x: x,
//     y: y
//   }, {
//     x: cx,
//     y: cy
//   });
//   if (radius <= 0) {
//     return {
//       radius: radius
//     };
//   }
//   var cos = (x - cx) / radius;
//   var angleInRadian = Math.acos(cos);
//   if (y > cy) {
//     angleInRadian = 2 * Math.PI - angleInRadian;
//   }
//   return {
//     radius: radius,
//     angle: radianToDegree(angleInRadian),
//     angleInRadian: angleInRadian
//   };
// };
// var formatAngleOfSector = function formatAngleOfSector(_ref3) {
//   var startAngle = _ref3.startAngle,
//     endAngle = _ref3.endAngle;
//   var startCnt = Math.floor(startAngle / 360);
//   var endCnt = Math.floor(endAngle / 360);
//   var min = Math.min(startCnt, endCnt);
//   return {
//     startAngle: startAngle - min * 360,
//     endAngle: endAngle - min * 360
//   };
// };
// var reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor(angle, _ref4) {
//   var startAngle = _ref4.startAngle,
//     endAngle = _ref4.endAngle;
//   var startCnt = Math.floor(startAngle / 360);
//   var endCnt = Math.floor(endAngle / 360);
//   var min = Math.min(startCnt, endCnt);
//   return angle + min * 360;
// };
// var inRangeOfSector = function inRangeOfSector(_ref5, sector) {
//   var x = _ref5.x,
//     y = _ref5.y;
//   var _getAngleOfPoint = getAngleOfPoint({
//       x: x,
//       y: y
//     }, sector),
//     radius = _getAngleOfPoint.radius,
//     angle = _getAngleOfPoint.angle;
//   var innerRadius = sector.innerRadius,
//     outerRadius = sector.outerRadius;
//   if (radius < innerRadius || radius > outerRadius) {
//     return false;
//   }
//   if (radius === 0) {
//     return true;
//   }
//   var _formatAngleOfSector = formatAngleOfSector(sector),
//     startAngle = _formatAngleOfSector.startAngle,
//     endAngle = _formatAngleOfSector.endAngle;
//   var formatAngle = angle;
//   var inRange;
//   if (startAngle <= endAngle) {
//     while (formatAngle > endAngle) {
//       formatAngle -= 360;
//     }
//     while (formatAngle < startAngle) {
//       formatAngle += 360;
//     }
//     inRange = formatAngle >= startAngle && formatAngle <= endAngle;
//   } else {
//     while (formatAngle > startAngle) {
//       formatAngle -= 360;
//     }
//     while (formatAngle < endAngle) {
//       formatAngle += 360;
//     }
//     inRange = formatAngle >= endAngle && formatAngle <= startAngle;
//   }
//   if (inRange) {
//     return _objectSpread$l(_objectSpread$l({}, sector), {}, {
//       radius: radius,
//       angle: reverseFormatAngleOfSetor(formatAngle, sector)
//     });
//   }
//   return null;
// };

// function _typeof$m(o) { "@babel/helpers - typeof"; return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$m(o); }
// var _excluded$a = ["offset"];
// function _toConsumableArray$5(arr) { return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$5(); }
// function _nonIterableSpread$5() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }
// function _iterableToArray$5(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$5(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$8(arr); }
// function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _objectWithoutProperties$9(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$9(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$9(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function ownKeys$k(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$k(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$k(Object(t), !0).forEach(function (r) { _defineProperty$l(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$l(obj, key, value) { key = _toPropertyKey$l(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$l(arg) { var key = _toPrimitive$l(arg, "string"); return _typeof$m(key) === "symbol" ? key : String(key); }
// function _toPrimitive$l(input, hint) { if (_typeof$m(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$m(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _extends$h() { _extends$h = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$h.apply(this, arguments); }
// var getLabel = function getLabel(props) {
//   var value = props.value,
//     formatter = props.formatter;
//   var label = isNil$1(props.children) ? value : props.children;
//   if (isFunction(formatter)) {
//     return formatter(label);
//   }
//   return label;
// };
// var getDeltaAngle$1 = function getDeltaAngle(startAngle, endAngle) {
//   var sign = mathSign(endAngle - startAngle);
//   var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
//   return sign * deltaAngle;
// };
// var renderRadialLabel = function renderRadialLabel(labelProps, label, attrs) {
//   var position = labelProps.position,
//     viewBox = labelProps.viewBox,
//     offset = labelProps.offset,
//     className = labelProps.className;
//   var _ref = viewBox,
//     cx = _ref.cx,
//     cy = _ref.cy,
//     innerRadius = _ref.innerRadius,
//     outerRadius = _ref.outerRadius,
//     startAngle = _ref.startAngle,
//     endAngle = _ref.endAngle,
//     clockWise = _ref.clockWise;
//   var radius = (innerRadius + outerRadius) / 2;
//   var deltaAngle = getDeltaAngle$1(startAngle, endAngle);
//   var sign = deltaAngle >= 0 ? 1 : -1;
//   var labelAngle, direction;
//   if (position === 'insideStart') {
//     labelAngle = startAngle + sign * offset;
//     direction = clockWise;
//   } else if (position === 'insideEnd') {
//     labelAngle = endAngle - sign * offset;
//     direction = !clockWise;
//   } else if (position === 'end') {
//     labelAngle = endAngle + sign * offset;
//     direction = clockWise;
//   }
//   direction = deltaAngle <= 0 ? direction : !direction;
//   var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
//   var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
//   var path = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
//   var id = isNil$1(labelProps.id) ? uniqueId('recharts-radial-line-') : labelProps.id;
//   return /*#__PURE__*/React__default.createElement("text", _extends$h({}, attrs, {
//     dominantBaseline: "central",
//     className: clsx('recharts-radial-bar-label', className)
//   }), /*#__PURE__*/React__default.createElement("defs", null, /*#__PURE__*/React__default.createElement("path", {
//     id: id,
//     d: path
//   })), /*#__PURE__*/React__default.createElement("textPath", {
//     xlinkHref: "#".concat(id)
//   }, label));
// };
// var getAttrsOfPolarLabel = function getAttrsOfPolarLabel(props) {
//   var viewBox = props.viewBox,
//     offset = props.offset,
//     position = props.position;
//   var _ref2 = viewBox,
//     cx = _ref2.cx,
//     cy = _ref2.cy,
//     innerRadius = _ref2.innerRadius,
//     outerRadius = _ref2.outerRadius,
//     startAngle = _ref2.startAngle,
//     endAngle = _ref2.endAngle;
//   var midAngle = (startAngle + endAngle) / 2;
//   if (position === 'outside') {
//     var _polarToCartesian = polarToCartesian(cx, cy, outerRadius + offset, midAngle),
//       _x = _polarToCartesian.x,
//       _y = _polarToCartesian.y;
//     return {
//       x: _x,
//       y: _y,
//       textAnchor: _x >= cx ? 'start' : 'end',
//       verticalAnchor: 'middle'
//     };
//   }
//   if (position === 'center') {
//     return {
//       x: cx,
//       y: cy,
//       textAnchor: 'middle',
//       verticalAnchor: 'middle'
//     };
//   }
//   if (position === 'centerTop') {
//     return {
//       x: cx,
//       y: cy,
//       textAnchor: 'middle',
//       verticalAnchor: 'start'
//     };
//   }
//   if (position === 'centerBottom') {
//     return {
//       x: cx,
//       y: cy,
//       textAnchor: 'middle',
//       verticalAnchor: 'end'
//     };
//   }
//   var r = (innerRadius + outerRadius) / 2;
//   var _polarToCartesian2 = polarToCartesian(cx, cy, r, midAngle),
//     x = _polarToCartesian2.x,
//     y = _polarToCartesian2.y;
//   return {
//     x: x,
//     y: y,
//     textAnchor: 'middle',
//     verticalAnchor: 'middle'
//   };
// };
// var getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel(props) {
//   var viewBox = props.viewBox,
//     parentViewBox = props.parentViewBox,
//     offset = props.offset,
//     position = props.position;
//   var _ref3 = viewBox,
//     x = _ref3.x,
//     y = _ref3.y,
//     width = _ref3.width,
//     height = _ref3.height;

//   // Define vertical offsets and position inverts based on the value being positive or negative
//   var verticalSign = height >= 0 ? 1 : -1;
//   var verticalOffset = verticalSign * offset;
//   var verticalEnd = verticalSign > 0 ? 'end' : 'start';
//   var verticalStart = verticalSign > 0 ? 'start' : 'end';

//   // Define horizontal offsets and position inverts based on the value being positive or negative
//   var horizontalSign = width >= 0 ? 1 : -1;
//   var horizontalOffset = horizontalSign * offset;
//   var horizontalEnd = horizontalSign > 0 ? 'end' : 'start';
//   var horizontalStart = horizontalSign > 0 ? 'start' : 'end';
//   if (position === 'top') {
//     var attrs = {
//       x: x + width / 2,
//       y: y - verticalSign * offset,
//       textAnchor: 'middle',
//       verticalAnchor: verticalEnd
//     };
//     return _objectSpread$k(_objectSpread$k({}, attrs), parentViewBox ? {
//       height: Math.max(y - parentViewBox.y, 0),
//       width: width
//     } : {});
//   }
//   if (position === 'bottom') {
//     var _attrs = {
//       x: x + width / 2,
//       y: y + height + verticalOffset,
//       textAnchor: 'middle',
//       verticalAnchor: verticalStart
//     };
//     return _objectSpread$k(_objectSpread$k({}, _attrs), parentViewBox ? {
//       height: Math.max(parentViewBox.y + parentViewBox.height - (y + height), 0),
//       width: width
//     } : {});
//   }
//   if (position === 'left') {
//     var _attrs2 = {
//       x: x - horizontalOffset,
//       y: y + height / 2,
//       textAnchor: horizontalEnd,
//       verticalAnchor: 'middle'
//     };
//     return _objectSpread$k(_objectSpread$k({}, _attrs2), parentViewBox ? {
//       width: Math.max(_attrs2.x - parentViewBox.x, 0),
//       height: height
//     } : {});
//   }
//   if (position === 'right') {
//     var _attrs3 = {
//       x: x + width + horizontalOffset,
//       y: y + height / 2,
//       textAnchor: horizontalStart,
//       verticalAnchor: 'middle'
//     };
//     return _objectSpread$k(_objectSpread$k({}, _attrs3), parentViewBox ? {
//       width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
//       height: height
//     } : {});
//   }
//   var sizeAttrs = parentViewBox ? {
//     width: width,
//     height: height
//   } : {};
//   if (position === 'insideLeft') {
//     return _objectSpread$k({
//       x: x + horizontalOffset,
//       y: y + height / 2,
//       textAnchor: horizontalStart,
//       verticalAnchor: 'middle'
//     }, sizeAttrs);
//   }
//   if (position === 'insideRight') {
//     return _objectSpread$k({
//       x: x + width - horizontalOffset,
//       y: y + height / 2,
//       textAnchor: horizontalEnd,
//       verticalAnchor: 'middle'
//     }, sizeAttrs);
//   }
//   if (position === 'insideTop') {
//     return _objectSpread$k({
//       x: x + width / 2,
//       y: y + verticalOffset,
//       textAnchor: 'middle',
//       verticalAnchor: verticalStart
//     }, sizeAttrs);
//   }
//   if (position === 'insideBottom') {
//     return _objectSpread$k({
//       x: x + width / 2,
//       y: y + height - verticalOffset,
//       textAnchor: 'middle',
//       verticalAnchor: verticalEnd
//     }, sizeAttrs);
//   }
//   if (position === 'insideTopLeft') {
//     return _objectSpread$k({
//       x: x + horizontalOffset,
//       y: y + verticalOffset,
//       textAnchor: horizontalStart,
//       verticalAnchor: verticalStart
//     }, sizeAttrs);
//   }
//   if (position === 'insideTopRight') {
//     return _objectSpread$k({
//       x: x + width - horizontalOffset,
//       y: y + verticalOffset,
//       textAnchor: horizontalEnd,
//       verticalAnchor: verticalStart
//     }, sizeAttrs);
//   }
//   if (position === 'insideBottomLeft') {
//     return _objectSpread$k({
//       x: x + horizontalOffset,
//       y: y + height - verticalOffset,
//       textAnchor: horizontalStart,
//       verticalAnchor: verticalEnd
//     }, sizeAttrs);
//   }
//   if (position === 'insideBottomRight') {
//     return _objectSpread$k({
//       x: x + width - horizontalOffset,
//       y: y + height - verticalOffset,
//       textAnchor: horizontalEnd,
//       verticalAnchor: verticalEnd
//     }, sizeAttrs);
//   }
//   if (isObject(position) && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) {
//     return _objectSpread$k({
//       x: x + getPercentValue(position.x, width),
//       y: y + getPercentValue(position.y, height),
//       textAnchor: 'end',
//       verticalAnchor: 'end'
//     }, sizeAttrs);
//   }
//   return _objectSpread$k({
//     x: x + width / 2,
//     y: y + height / 2,
//     textAnchor: 'middle',
//     verticalAnchor: 'middle'
//   }, sizeAttrs);
// };
// var isPolar = function isPolar(viewBox) {
//   return 'cx' in viewBox && isNumber(viewBox.cx);
// };
// function Label$7(_ref4) {
//   var _ref4$offset = _ref4.offset,
//     offset = _ref4$offset === void 0 ? 5 : _ref4$offset,
//     restProps = _objectWithoutProperties$9(_ref4, _excluded$a);
//   var props = _objectSpread$k({
//     offset: offset
//   }, restProps);
//   var viewBox = props.viewBox,
//     position = props.position,
//     value = props.value,
//     children = props.children,
//     content = props.content,
//     _props$className = props.className,
//     className = _props$className === void 0 ? '' : _props$className,
//     textBreakAll = props.textBreakAll;
//   if (!viewBox || isNil$1(value) && isNil$1(children) && ! /*#__PURE__*/isValidElement(content) && !isFunction(content)) {
//     return null;
//   }
//   if ( /*#__PURE__*/isValidElement(content)) {
//     return /*#__PURE__*/cloneElement(content, props);
//   }
//   var label;
//   if (isFunction(content)) {
//     label = /*#__PURE__*/createElement(content, props);
//     if ( /*#__PURE__*/isValidElement(label)) {
//       return label;
//     }
//   } else {
//     label = getLabel(props);
//   }
//   var isPolarLabel = isPolar(viewBox);
//   var attrs = filterProps(props, true);
//   if (isPolarLabel && (position === 'insideStart' || position === 'insideEnd' || position === 'end')) {
//     return renderRadialLabel(props, label, attrs);
//   }
//   var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);
//   return /*#__PURE__*/React__default.createElement(Text, _extends$h({
//     className: clsx('recharts-label', className)
//   }, attrs, positionAttrs, {
//     breakAll: textBreakAll
//   }), label);
// }
// Label$7.displayName = 'Label';
// var parseViewBox = function parseViewBox(props) {
//   var cx = props.cx,
//     cy = props.cy,
//     angle = props.angle,
//     startAngle = props.startAngle,
//     endAngle = props.endAngle,
//     r = props.r,
//     radius = props.radius,
//     innerRadius = props.innerRadius,
//     outerRadius = props.outerRadius,
//     x = props.x,
//     y = props.y,
//     top = props.top,
//     left = props.left,
//     width = props.width,
//     height = props.height,
//     clockWise = props.clockWise,
//     labelViewBox = props.labelViewBox;
//   if (labelViewBox) {
//     return labelViewBox;
//   }
//   if (isNumber(width) && isNumber(height)) {
//     if (isNumber(x) && isNumber(y)) {
//       return {
//         x: x,
//         y: y,
//         width: width,
//         height: height
//       };
//     }
//     if (isNumber(top) && isNumber(left)) {
//       return {
//         x: top,
//         y: left,
//         width: width,
//         height: height
//       };
//     }
//   }
//   if (isNumber(x) && isNumber(y)) {
//     return {
//       x: x,
//       y: y,
//       width: 0,
//       height: 0
//     };
//   }
//   if (isNumber(cx) && isNumber(cy)) {
//     return {
//       cx: cx,
//       cy: cy,
//       startAngle: startAngle || angle || 0,
//       endAngle: endAngle || angle || 0,
//       innerRadius: innerRadius || 0,
//       outerRadius: outerRadius || radius || r || 0,
//       clockWise: clockWise
//     };
//   }
//   if (props.viewBox) {
//     return props.viewBox;
//   }
//   return {};
// };
// var parseLabel = function parseLabel(label, viewBox) {
//   if (!label) {
//     return null;
//   }
//   if (label === true) {
//     return /*#__PURE__*/React__default.createElement(Label$7, {
//       key: "label-implicit",
//       viewBox: viewBox
//     });
//   }
//   if (isNumOrStr(label)) {
//     return /*#__PURE__*/React__default.createElement(Label$7, {
//       key: "label-implicit",
//       viewBox: viewBox,
//       value: label
//     });
//   }
//   if ( /*#__PURE__*/isValidElement(label)) {
//     if (label.type === Label$7) {
//       return /*#__PURE__*/cloneElement(label, {
//         key: 'label-implicit',
//         viewBox: viewBox
//       });
//     }
//     return /*#__PURE__*/React__default.createElement(Label$7, {
//       key: "label-implicit",
//       content: label,
//       viewBox: viewBox
//     });
//   }
//   if (isFunction(label)) {
//     return /*#__PURE__*/React__default.createElement(Label$7, {
//       key: "label-implicit",
//       content: label,
//       viewBox: viewBox
//     });
//   }
//   if (isObject(label)) {
//     return /*#__PURE__*/React__default.createElement(Label$7, _extends$h({
//       viewBox: viewBox
//     }, label, {
//       key: "label-implicit"
//     }));
//   }
//   return null;
// };
// var renderCallByParent$1 = function renderCallByParent(parentProps, viewBox) {
//   var checkPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
//   if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
//     return null;
//   }
//   var children = parentProps.children;
//   var parentViewBox = parseViewBox(parentProps);
//   var explicitChildren = findAllByType(children, Label$7).map(function (child, index) {
//     return /*#__PURE__*/cloneElement(child, {
//       viewBox: viewBox || parentViewBox,
//       // eslint-disable-next-line react/no-array-index-key
//       key: "label-".concat(index)
//     });
//   });
//   if (!checkPropsLabel) {
//     return explicitChildren;
//   }
//   var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);
//   return [implicitLabel].concat(_toConsumableArray$5(explicitChildren));
// };
// Label$7.parseViewBox = parseViewBox;
// Label$7.renderCallByParent = renderCallByParent$1;

// function _typeof$l(o) { "@babel/helpers - typeof"; return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$l(o); }
// var _excluded$9 = ["valueAccessor"],
//   _excluded2$3 = ["data", "dataKey", "clockWise", "id", "textBreakAll"];
// function _toConsumableArray$4(arr) { return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$4(); }
// function _nonIterableSpread$4() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }
// function _iterableToArray$4(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$4(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$7(arr); }
// function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _extends$g() { _extends$g = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$g.apply(this, arguments); }
// function ownKeys$j(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$j(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$j(Object(t), !0).forEach(function (r) { _defineProperty$k(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$k(obj, key, value) { key = _toPropertyKey$k(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$k(arg) { var key = _toPrimitive$k(arg, "string"); return _typeof$l(key) === "symbol" ? key : String(key); }
// function _toPrimitive$k(input, hint) { if (_typeof$l(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$l(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _objectWithoutProperties$8(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$8(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$8(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// var defaultAccessor = function defaultAccessor(entry) {
//   return Array.isArray(entry.value) ? last(entry.value) : entry.value;
// };
// function LabelList(_ref) {
//   var _ref$valueAccessor = _ref.valueAccessor,
//     valueAccessor = _ref$valueAccessor === void 0 ? defaultAccessor : _ref$valueAccessor,
//     restProps = _objectWithoutProperties$8(_ref, _excluded$9);
//   var data = restProps.data,
//     dataKey = restProps.dataKey,
//     clockWise = restProps.clockWise,
//     id = restProps.id,
//     textBreakAll = restProps.textBreakAll,
//     others = _objectWithoutProperties$8(restProps, _excluded2$3);
//   if (!data || !data.length) {
//     return null;
//   }
//   return /*#__PURE__*/React__default.createElement(Layer, {
//     className: "recharts-label-list"
//   }, data.map(function (entry, index) {
//     var value = isNil$1(dataKey) ? valueAccessor(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
//     var idProps = isNil$1(id) ? {} : {
//       id: "".concat(id, "-").concat(index)
//     };
//     return /*#__PURE__*/React__default.createElement(Label$7, _extends$g({}, filterProps(entry, true), others, idProps, {
//       parentViewBox: entry.parentViewBox,
//       value: value,
//       textBreakAll: textBreakAll,
//       viewBox: Label$7.parseViewBox(isNil$1(clockWise) ? entry : _objectSpread$j(_objectSpread$j({}, entry), {}, {
//         clockWise: clockWise
//       })),
//       key: "label-".concat(index) // eslint-disable-line react/no-array-index-key
//       ,
//       index: index
//     }));
//   }));
// }
// LabelList.displayName = 'LabelList';
// function parseLabelList(label, data) {
//   if (!label) {
//     return null;
//   }
//   if (label === true) {
//     return /*#__PURE__*/React__default.createElement(LabelList, {
//       key: "labelList-implicit",
//       data: data
//     });
//   }
//   if ( /*#__PURE__*/React__default.isValidElement(label) || isFunction(label)) {
//     return /*#__PURE__*/React__default.createElement(LabelList, {
//       key: "labelList-implicit",
//       data: data,
//       content: label
//     });
//   }
//   if (isObject(label)) {
//     return /*#__PURE__*/React__default.createElement(LabelList, _extends$g({
//       data: data
//     }, label, {
//       key: "labelList-implicit"
//     }));
//   }
//   return null;
// }
// function renderCallByParent(parentProps, data) {
//   var checkPropsLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
//   if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
//     return null;
//   }
//   var children = parentProps.children;
//   var explicitChildren = findAllByType(children, LabelList).map(function (child, index) {
//     return /*#__PURE__*/cloneElement(child, {
//       data: data,
//       // eslint-disable-next-line react/no-array-index-key
//       key: "labelList-".concat(index)
//     });
//   });
//   if (!checkPropsLabel) {
//     return explicitChildren;
//   }
//   var implicitLabelList = parseLabelList(parentProps.label, data);
//   return [implicitLabelList].concat(_toConsumableArray$4(explicitChildren));
// }
// LabelList.renderCallByParent = renderCallByParent;

// function _typeof$k(o) { "@babel/helpers - typeof"; return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$k(o); }
// function _extends$f() { _extends$f = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$f.apply(this, arguments); }
// function ownKeys$i(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$i(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$i(Object(t), !0).forEach(function (r) { _defineProperty$j(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$j(obj, key, value) { key = _toPropertyKey$j(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$j(arg) { var key = _toPrimitive$j(arg, "string"); return _typeof$k(key) === "symbol" ? key : String(key); }
// function _toPrimitive$j(input, hint) { if (_typeof$k(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$k(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var getDeltaAngle = function getDeltaAngle(startAngle, endAngle) {
//   var sign = mathSign(endAngle - startAngle);
//   var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
//   return sign * deltaAngle;
// };
// var getTangentCircle = function getTangentCircle(_ref) {
//   var cx = _ref.cx,
//     cy = _ref.cy,
//     radius = _ref.radius,
//     angle = _ref.angle,
//     sign = _ref.sign,
//     isExternal = _ref.isExternal,
//     cornerRadius = _ref.cornerRadius,
//     cornerIsExternal = _ref.cornerIsExternal;
//   var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
//   var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
//   var centerAngle = cornerIsExternal ? angle : angle + sign * theta;
//   var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
//   // The coordinate of point which is tangent to the circle
//   var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
//   // The coordinate of point which is tangent to the radius line
//   var lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle;
//   var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);
//   return {
//     center: center,
//     circleTangency: circleTangency,
//     lineTangency: lineTangency,
//     theta: theta
//   };
// };
// var getSectorPath = function getSectorPath(_ref2) {
//   var cx = _ref2.cx,
//     cy = _ref2.cy,
//     innerRadius = _ref2.innerRadius,
//     outerRadius = _ref2.outerRadius,
//     startAngle = _ref2.startAngle,
//     endAngle = _ref2.endAngle;
//   var angle = getDeltaAngle(startAngle, endAngle);

//   // When the angle of sector equals to 360, star point and end point coincide
//   var tempEndAngle = startAngle + angle;
//   var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
//   var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
//   var path = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
//   if (innerRadius > 0) {
//     var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
//     var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
//     path += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
//   } else {
//     path += "L ".concat(cx, ",").concat(cy, " Z");
//   }
//   return path;
// };
// var getSectorWithCorner = function getSectorWithCorner(_ref3) {
//   var cx = _ref3.cx,
//     cy = _ref3.cy,
//     innerRadius = _ref3.innerRadius,
//     outerRadius = _ref3.outerRadius,
//     cornerRadius = _ref3.cornerRadius,
//     forceCornerRadius = _ref3.forceCornerRadius,
//     cornerIsExternal = _ref3.cornerIsExternal,
//     startAngle = _ref3.startAngle,
//     endAngle = _ref3.endAngle;
//   var sign = mathSign(endAngle - startAngle);
//   var _getTangentCircle = getTangentCircle({
//       cx: cx,
//       cy: cy,
//       radius: outerRadius,
//       angle: startAngle,
//       sign: sign,
//       cornerRadius: cornerRadius,
//       cornerIsExternal: cornerIsExternal
//     }),
//     soct = _getTangentCircle.circleTangency,
//     solt = _getTangentCircle.lineTangency,
//     sot = _getTangentCircle.theta;
//   var _getTangentCircle2 = getTangentCircle({
//       cx: cx,
//       cy: cy,
//       radius: outerRadius,
//       angle: endAngle,
//       sign: -sign,
//       cornerRadius: cornerRadius,
//       cornerIsExternal: cornerIsExternal
//     }),
//     eoct = _getTangentCircle2.circleTangency,
//     eolt = _getTangentCircle2.lineTangency,
//     eot = _getTangentCircle2.theta;
//   var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
//   if (outerArcAngle < 0) {
//     if (forceCornerRadius) {
//       return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
//     }
//     return getSectorPath({
//       cx: cx,
//       cy: cy,
//       innerRadius: innerRadius,
//       outerRadius: outerRadius,
//       startAngle: startAngle,
//       endAngle: endAngle
//     });
//   }
//   var path = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
//   if (innerRadius > 0) {
//     var _getTangentCircle3 = getTangentCircle({
//         cx: cx,
//         cy: cy,
//         radius: innerRadius,
//         angle: startAngle,
//         sign: sign,
//         isExternal: true,
//         cornerRadius: cornerRadius,
//         cornerIsExternal: cornerIsExternal
//       }),
//       sict = _getTangentCircle3.circleTangency,
//       silt = _getTangentCircle3.lineTangency,
//       sit = _getTangentCircle3.theta;
//     var _getTangentCircle4 = getTangentCircle({
//         cx: cx,
//         cy: cy,
//         radius: innerRadius,
//         angle: endAngle,
//         sign: -sign,
//         isExternal: true,
//         cornerRadius: cornerRadius,
//         cornerIsExternal: cornerIsExternal
//       }),
//       eict = _getTangentCircle4.circleTangency,
//       eilt = _getTangentCircle4.lineTangency,
//       eit = _getTangentCircle4.theta;
//     var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
//     if (innerArcAngle < 0 && cornerRadius === 0) {
//       return "".concat(path, "L").concat(cx, ",").concat(cy, "Z");
//     }
//     path += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
//   } else {
//     path += "L".concat(cx, ",").concat(cy, "Z");
//   }
//   return path;
// };
// var defaultProps$3 = {
//   cx: 0,
//   cy: 0,
//   innerRadius: 0,
//   outerRadius: 0,
//   startAngle: 0,
//   endAngle: 0,
//   cornerRadius: 0,
//   forceCornerRadius: false,
//   cornerIsExternal: false
// };
// var Sector = function Sector(sectorProps) {
//   var props = _objectSpread$i(_objectSpread$i({}, defaultProps$3), sectorProps);
//   var cx = props.cx,
//     cy = props.cy,
//     innerRadius = props.innerRadius,
//     outerRadius = props.outerRadius,
//     cornerRadius = props.cornerRadius,
//     forceCornerRadius = props.forceCornerRadius,
//     cornerIsExternal = props.cornerIsExternal,
//     startAngle = props.startAngle,
//     endAngle = props.endAngle,
//     className = props.className;
//   if (outerRadius < innerRadius || startAngle === endAngle) {
//     return null;
//   }
//   var layerClass = clsx('recharts-sector', className);
//   var deltaRadius = outerRadius - innerRadius;
//   var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
//   var path;
//   if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
//     path = getSectorWithCorner({
//       cx: cx,
//       cy: cy,
//       innerRadius: innerRadius,
//       outerRadius: outerRadius,
//       cornerRadius: Math.min(cr, deltaRadius / 2),
//       forceCornerRadius: forceCornerRadius,
//       cornerIsExternal: cornerIsExternal,
//       startAngle: startAngle,
//       endAngle: endAngle
//     });
//   } else {
//     path = getSectorPath({
//       cx: cx,
//       cy: cy,
//       innerRadius: innerRadius,
//       outerRadius: outerRadius,
//       startAngle: startAngle,
//       endAngle: endAngle
//     });
//   }
//   return /*#__PURE__*/React__default.createElement("path", _extends$f({}, filterProps(props, true), {
//     className: layerClass,
//     d: path,
//     role: "img"
//   }));
// };

// function _typeof$j(o) { "@babel/helpers - typeof"; return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$j(o); }
// function _extends$e() { _extends$e = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$e.apply(this, arguments); }
// function ownKeys$h(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$h(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$h(Object(t), !0).forEach(function (r) { _defineProperty$i(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$i(obj, key, value) { key = _toPropertyKey$i(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$i(arg) { var key = _toPrimitive$i(arg, "string"); return _typeof$j(key) === "symbol" ? key : String(key); }
// function _toPrimitive$i(input, hint) { if (_typeof$j(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$j(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var CURVE_FACTORIES = {
//   curveBasisClosed: curveBasisClosed,
//   curveBasisOpen: curveBasisOpen,
//   curveBasis: curveBasis,
//   curveBumpX: curveBumpX,
//   curveBumpY: curveBumpY,
//   curveLinearClosed: curveLinearClosed,
//   curveLinear: curveLinear,
//   curveMonotoneX: curveMonotoneX,
//   curveMonotoneY: curveMonotoneY,
//   curveNatural: curveNatural,
//   curveStep: curveStep,
//   curveStepAfter: curveStepAfter,
//   curveStepBefore: curveStepBefore
// };
// var defined = function defined(p) {
//   return p.x === +p.x && p.y === +p.y;
// };
// var getX = function getX(p) {
//   return p.x;
// };
// var getY = function getY(p) {
//   return p.y;
// };
// var getCurveFactory = function getCurveFactory(type, layout) {
//   if (isFunction(type)) {
//     return type;
//   }
//   var name = "curve".concat(upperFirst(type));
//   if ((name === 'curveMonotone' || name === 'curveBump') && layout) {
//     return CURVE_FACTORIES["".concat(name).concat(layout === 'vertical' ? 'Y' : 'X')];
//   }
//   return CURVE_FACTORIES[name] || curveLinear;
// };
// /**
//  * Calculate the path of curve
//  * @return {String} path
//  */
// var getPath$1 = function getPath(_ref) {
//   var _ref$type = _ref.type,
//     type = _ref$type === void 0 ? 'linear' : _ref$type,
//     _ref$points = _ref.points,
//     points = _ref$points === void 0 ? [] : _ref$points,
//     baseLine = _ref.baseLine,
//     layout = _ref.layout,
//     _ref$connectNulls = _ref.connectNulls,
//     connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls;
//   var curveFactory = getCurveFactory(type, layout);
//   var formatPoints = connectNulls ? points.filter(function (entry) {
//     return defined(entry);
//   }) : points;
//   var lineFunction;
//   if (Array.isArray(baseLine)) {
//     var formatBaseLine = connectNulls ? baseLine.filter(function (base) {
//       return defined(base);
//     }) : baseLine;
//     var areaPoints = formatPoints.map(function (entry, index) {
//       return _objectSpread$h(_objectSpread$h({}, entry), {}, {
//         base: formatBaseLine[index]
//       });
//     });
//     if (layout === 'vertical') {
//       lineFunction = area().y(getY).x1(getX).x0(function (d) {
//         return d.base.x;
//       });
//     } else {
//       lineFunction = area().x(getX).y1(getY).y0(function (d) {
//         return d.base.y;
//       });
//     }
//     lineFunction.defined(defined).curve(curveFactory);
//     return lineFunction(areaPoints);
//   }
//   if (layout === 'vertical' && isNumber(baseLine)) {
//     lineFunction = area().y(getY).x1(getX).x0(baseLine);
//   } else if (isNumber(baseLine)) {
//     lineFunction = area().x(getX).y1(getY).y0(baseLine);
//   } else {
//     lineFunction = line().x(getX).y(getY);
//   }
//   lineFunction.defined(defined).curve(curveFactory);
//   return lineFunction(formatPoints);
// };
// var Curve = function Curve(props) {
//   var className = props.className,
//     points = props.points,
//     path = props.path,
//     pathRef = props.pathRef;
//   if ((!points || !points.length) && !path) {
//     return null;
//   }
//   var realPath = points && points.length ? getPath$1(props) : path;
//   return /*#__PURE__*/React__default.createElement("path", _extends$e({}, filterProps(props), adaptEventHandlers(props), {
//     className: clsx('recharts-curve', className),
//     d: realPath,
//     ref: pathRef
//   }));
// };

// function _typeof$i(o) { "@babel/helpers - typeof"; return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$i(o); }
// function _extends$d() { _extends$d = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$d.apply(this, arguments); }
// function _slicedToArray$3(arr, i) { return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$3(); }
// function _nonIterableRest$3() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }
// function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$3(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles$3(arr) { if (Array.isArray(arr)) return arr; }
// function ownKeys$g(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$g(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$g(Object(t), !0).forEach(function (r) { _defineProperty$h(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$h(obj, key, value) { key = _toPropertyKey$h(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$h(arg) { var key = _toPrimitive$h(arg, "string"); return _typeof$i(key) === "symbol" ? key : String(key); }
// function _toPrimitive$h(input, hint) { if (_typeof$i(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$i(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var getRectanglePath = function getRectanglePath(x, y, width, height, radius) {
//   var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
//   var ySign = height >= 0 ? 1 : -1;
//   var xSign = width >= 0 ? 1 : -1;
//   var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
//   var path;
//   if (maxRadius > 0 && radius instanceof Array) {
//     var newRadius = [0, 0, 0, 0];
//     for (var i = 0, len = 4; i < len; i++) {
//       newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
//     }
//     path = "M".concat(x, ",").concat(y + ySign * newRadius[0]);
//     if (newRadius[0] > 0) {
//       path += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x + xSign * newRadius[0], ",").concat(y);
//     }
//     path += "L ".concat(x + width - xSign * newRadius[1], ",").concat(y);
//     if (newRadius[1] > 0) {
//       path += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x + width, ",").concat(y + ySign * newRadius[1]);
//     }
//     path += "L ".concat(x + width, ",").concat(y + height - ySign * newRadius[2]);
//     if (newRadius[2] > 0) {
//       path += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x + width - xSign * newRadius[2], ",").concat(y + height);
//     }
//     path += "L ".concat(x + xSign * newRadius[3], ",").concat(y + height);
//     if (newRadius[3] > 0) {
//       path += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x, ",").concat(y + height - ySign * newRadius[3]);
//     }
//     path += 'Z';
//   } else if (maxRadius > 0 && radius === +radius && radius > 0) {
//     var _newRadius = Math.min(maxRadius, radius);
//     path = "M ".concat(x, ",").concat(y + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + xSign * _newRadius, ",").concat(y, "\n            L ").concat(x + width - xSign * _newRadius, ",").concat(y, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + width, ",").concat(y + ySign * _newRadius, "\n            L ").concat(x + width, ",").concat(y + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + width - xSign * _newRadius, ",").concat(y + height, "\n            L ").concat(x + xSign * _newRadius, ",").concat(y + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x, ",").concat(y + height - ySign * _newRadius, " Z");
//   } else {
//     path = "M ".concat(x, ",").concat(y, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
//   }
//   return path;
// };
// var isInRectangle = function isInRectangle(point, rect) {
//   if (!point || !rect) {
//     return false;
//   }
//   var px = point.x,
//     py = point.y;
//   var x = rect.x,
//     y = rect.y,
//     width = rect.width,
//     height = rect.height;
//   if (Math.abs(width) > 0 && Math.abs(height) > 0) {
//     var minX = Math.min(x, x + width);
//     var maxX = Math.max(x, x + width);
//     var minY = Math.min(y, y + height);
//     var maxY = Math.max(y, y + height);
//     return px >= minX && px <= maxX && py >= minY && py <= maxY;
//   }
//   return false;
// };
// var defaultProps$2 = {
//   x: 0,
//   y: 0,
//   width: 0,
//   height: 0,
//   // The radius of border
//   // The radius of four corners when radius is a number
//   // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
//   radius: 0,
//   isAnimationActive: false,
//   isUpdateAnimationActive: false,
//   animationBegin: 0,
//   animationDuration: 1500,
//   animationEasing: 'ease'
// };
// var Rectangle = function Rectangle(rectangleProps) {
//   var props = _objectSpread$g(_objectSpread$g({}, defaultProps$2), rectangleProps);
//   var pathRef = useRef$2();
//   var _useState = useState$1(-1),
//     _useState2 = _slicedToArray$3(_useState, 2),
//     totalLength = _useState2[0],
//     setTotalLength = _useState2[1];
//   useEffect$2(function () {
//     if (pathRef.current && pathRef.current.getTotalLength) {
//       try {
//         var pathTotalLength = pathRef.current.getTotalLength();
//         if (pathTotalLength) {
//           setTotalLength(pathTotalLength);
//         }
//       } catch (err) {
//         // calculate total length error
//       }
//     }
//   }, []);
//   var x = props.x,
//     y = props.y,
//     width = props.width,
//     height = props.height,
//     radius = props.radius,
//     className = props.className;
//   var animationEasing = props.animationEasing,
//     animationDuration = props.animationDuration,
//     animationBegin = props.animationBegin,
//     isAnimationActive = props.isAnimationActive,
//     isUpdateAnimationActive = props.isUpdateAnimationActive;
//   if (x !== +x || y !== +y || width !== +width || height !== +height || width === 0 || height === 0) {
//     return null;
//   }
//   var layerClass = clsx('recharts-rectangle', className);
//   if (!isUpdateAnimationActive) {
//     return /*#__PURE__*/React__default.createElement("path", _extends$d({}, filterProps(props, true), {
//       className: layerClass,
//       d: getRectanglePath(x, y, width, height, radius)
//     }));
//   }
//   return /*#__PURE__*/React__default.createElement(Animate, {
//     canBegin: totalLength > 0,
//     from: {
//       width: width,
//       height: height,
//       x: x,
//       y: y
//     },
//     to: {
//       width: width,
//       height: height,
//       x: x,
//       y: y
//     },
//     duration: animationDuration,
//     animationEasing: animationEasing,
//     isActive: isUpdateAnimationActive
//   }, function (_ref) {
//     var currWidth = _ref.width,
//       currHeight = _ref.height,
//       currX = _ref.x,
//       currY = _ref.y;
//     return /*#__PURE__*/React__default.createElement(Animate, {
//       canBegin: totalLength > 0,
//       from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
//       to: "".concat(totalLength, "px 0px"),
//       attributeName: "strokeDasharray",
//       begin: animationBegin,
//       duration: animationDuration,
//       isActive: isAnimationActive,
//       easing: animationEasing
//     }, /*#__PURE__*/React__default.createElement("path", _extends$d({}, filterProps(props, true), {
//       className: layerClass,
//       d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
//       ref: pathRef
//     })));
//   });
// };

// function _extends$c() { _extends$c = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$c.apply(this, arguments); }
// var Dot = function Dot(props) {
//   var cx = props.cx,
//     cy = props.cy,
//     r = props.r,
//     className = props.className;
//   var layerClass = clsx('recharts-dot', className);
//   if (cx === +cx && cy === +cy && r === +r) {
//     return /*#__PURE__*/React__default.createElement("circle", _extends$c({}, filterProps(props), adaptEventHandlers(props), {
//       className: layerClass,
//       cx: cx,
//       cy: cy,
//       r: r
//     }));
//   }
//   return null;
// };

// function _typeof$h(o) { "@babel/helpers - typeof"; return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$h(o); }
// var _excluded$8 = ["x", "y", "top", "left", "width", "height", "className"];
// function _extends$b() { _extends$b = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$b.apply(this, arguments); }
// function ownKeys$f(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$f(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$f(Object(t), !0).forEach(function (r) { _defineProperty$g(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$g(obj, key, value) { key = _toPropertyKey$g(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$g(arg) { var key = _toPrimitive$g(arg, "string"); return _typeof$h(key) === "symbol" ? key : String(key); }
// function _toPrimitive$g(input, hint) { if (_typeof$h(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$h(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _objectWithoutProperties$7(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$7(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$7(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// var getPath = function getPath(x, y, width, height, top, left) {
//   return "M".concat(x, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y, "h").concat(width);
// };
// var Cross = function Cross(_ref) {
//   var _ref$x = _ref.x,
//     x = _ref$x === void 0 ? 0 : _ref$x,
//     _ref$y = _ref.y,
//     y = _ref$y === void 0 ? 0 : _ref$y,
//     _ref$top = _ref.top,
//     top = _ref$top === void 0 ? 0 : _ref$top,
//     _ref$left = _ref.left,
//     left = _ref$left === void 0 ? 0 : _ref$left,
//     _ref$width = _ref.width,
//     width = _ref$width === void 0 ? 0 : _ref$width,
//     _ref$height = _ref.height,
//     height = _ref$height === void 0 ? 0 : _ref$height,
//     className = _ref.className,
//     rest = _objectWithoutProperties$7(_ref, _excluded$8);
//   var props = _objectSpread$f({
//     x: x,
//     y: y,
//     top: top,
//     left: left,
//     width: width,
//     height: height
//   }, rest);
//   if (!isNumber(x) || !isNumber(y) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
//     return null;
//   }
//   return /*#__PURE__*/React__default.createElement("path", _extends$b({}, filterProps(props, true), {
//     className: clsx('recharts-cross', className),
//     d: getPath(x, y, width, height, top, left)
//   }));
// };

// function _typeof$g(o) { "@babel/helpers - typeof"; return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$g(o); }
// function _extends$a() { _extends$a = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$a.apply(this, arguments); }
// function _slicedToArray$2(arr, i) { return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$5(arr, i) || _nonIterableRest$2(); }
// function _nonIterableRest$2() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }
// function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$2(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles$2(arr) { if (Array.isArray(arr)) return arr; }
// function ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty$f(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$f(obj, key, value) { key = _toPropertyKey$f(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$f(arg) { var key = _toPrimitive$f(arg, "string"); return _typeof$g(key) === "symbol" ? key : String(key); }
// function _toPrimitive$f(input, hint) { if (_typeof$g(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$g(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var getTrapezoidPath = function getTrapezoidPath(x, y, upperWidth, lowerWidth, height) {
//   var widthGap = upperWidth - lowerWidth;
//   var path;
//   path = "M ".concat(x, ",").concat(y);
//   path += "L ".concat(x + upperWidth, ",").concat(y);
//   path += "L ".concat(x + upperWidth - widthGap / 2, ",").concat(y + height);
//   path += "L ".concat(x + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y + height);
//   path += "L ".concat(x, ",").concat(y, " Z");
//   return path;
// };
// var defaultProps$1 = {
//   x: 0,
//   y: 0,
//   upperWidth: 0,
//   lowerWidth: 0,
//   height: 0,
//   isUpdateAnimationActive: false,
//   animationBegin: 0,
//   animationDuration: 1500,
//   animationEasing: 'ease'
// };
// var Trapezoid = function Trapezoid(props) {
//   var trapezoidProps = _objectSpread$e(_objectSpread$e({}, defaultProps$1), props);
//   var pathRef = useRef$2();
//   var _useState = useState$1(-1),
//     _useState2 = _slicedToArray$2(_useState, 2),
//     totalLength = _useState2[0],
//     setTotalLength = _useState2[1];
//   useEffect$2(function () {
//     if (pathRef.current && pathRef.current.getTotalLength) {
//       try {
//         var pathTotalLength = pathRef.current.getTotalLength();
//         if (pathTotalLength) {
//           setTotalLength(pathTotalLength);
//         }
//       } catch (err) {
//         // calculate total length error
//       }
//     }
//   }, []);
//   var x = trapezoidProps.x,
//     y = trapezoidProps.y,
//     upperWidth = trapezoidProps.upperWidth,
//     lowerWidth = trapezoidProps.lowerWidth,
//     height = trapezoidProps.height,
//     className = trapezoidProps.className;
//   var animationEasing = trapezoidProps.animationEasing,
//     animationDuration = trapezoidProps.animationDuration,
//     animationBegin = trapezoidProps.animationBegin,
//     isUpdateAnimationActive = trapezoidProps.isUpdateAnimationActive;
//   if (x !== +x || y !== +y || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {
//     return null;
//   }
//   var layerClass = clsx('recharts-trapezoid', className);
//   if (!isUpdateAnimationActive) {
//     return /*#__PURE__*/React__default.createElement("g", null, /*#__PURE__*/React__default.createElement("path", _extends$a({}, filterProps(trapezoidProps, true), {
//       className: layerClass,
//       d: getTrapezoidPath(x, y, upperWidth, lowerWidth, height)
//     })));
//   }
//   return /*#__PURE__*/React__default.createElement(Animate, {
//     canBegin: totalLength > 0,
//     from: {
//       upperWidth: 0,
//       lowerWidth: 0,
//       height: height,
//       x: x,
//       y: y
//     },
//     to: {
//       upperWidth: upperWidth,
//       lowerWidth: lowerWidth,
//       height: height,
//       x: x,
//       y: y
//     },
//     duration: animationDuration,
//     animationEasing: animationEasing,
//     isActive: isUpdateAnimationActive
//   }, function (_ref) {
//     var currUpperWidth = _ref.upperWidth,
//       currLowerWidth = _ref.lowerWidth,
//       currHeight = _ref.height,
//       currX = _ref.x,
//       currY = _ref.y;
//     return /*#__PURE__*/React__default.createElement(Animate, {
//       canBegin: totalLength > 0,
//       from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
//       to: "".concat(totalLength, "px 0px"),
//       attributeName: "strokeDasharray",
//       begin: animationBegin,
//       duration: animationDuration,
//       easing: animationEasing
//     }, /*#__PURE__*/React__default.createElement("path", _extends$a({}, filterProps(trapezoidProps, true), {
//       className: layerClass,
//       d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
//       ref: pathRef
//     })));
//   });
// };

// var _excluded$7 = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
// function _typeof$f(o) { "@babel/helpers - typeof"; return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$f(o); }
// function _objectWithoutProperties$6(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$6(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$6(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty$e(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$e(obj, key, value) { key = _toPropertyKey$e(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$e(arg) { var key = _toPrimitive$e(arg, "string"); return _typeof$f(key) === "symbol" ? key : String(key); }
// function _toPrimitive$e(input, hint) { if (_typeof$f(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$f(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

// /**
//  * This is an abstraction for rendering a user defined prop for a customized shape in several forms.
//  *
//  * <Shape /> is the root and will handle taking in:
//  *  - an object of svg properties
//  *  - a boolean
//  *  - a render prop(inline function that returns jsx)
//  *  - a react element
//  *
//  * <ShapeSelector /> is a subcomponent of <Shape /> and used to match a component
//  * to the value of props.shapeType that is passed to the root.
//  *
//  */

// function defaultPropTransformer(option, props) {
//   return _objectSpread$d(_objectSpread$d({}, props), option);
// }
// function isSymbolsProps(shapeType, _elementProps) {
//   return shapeType === 'symbols';
// }
// function ShapeSelector(_ref) {
//   var shapeType = _ref.shapeType,
//     elementProps = _ref.elementProps;
//   switch (shapeType) {
//     case 'rectangle':
//       return /*#__PURE__*/React__default.createElement(Rectangle, elementProps);
//     case 'trapezoid':
//       return /*#__PURE__*/React__default.createElement(Trapezoid, elementProps);
//     case 'sector':
//       return /*#__PURE__*/React__default.createElement(Sector, elementProps);
//     case 'symbols':
//       if (isSymbolsProps(shapeType)) {
//         return /*#__PURE__*/React__default.createElement(Symbols, elementProps);
//       }
//       break;
//     default:
//       return null;
//   }
// }
// function getPropsFromShapeOption(option) {
//   if ( /*#__PURE__*/isValidElement(option)) {
//     return option.props;
//   }
//   return option;
// }
// function Shape(_ref2) {
//   var option = _ref2.option,
//     shapeType = _ref2.shapeType,
//     _ref2$propTransformer = _ref2.propTransformer,
//     propTransformer = _ref2$propTransformer === void 0 ? defaultPropTransformer : _ref2$propTransformer,
//     _ref2$activeClassName = _ref2.activeClassName,
//     activeClassName = _ref2$activeClassName === void 0 ? 'recharts-active-shape' : _ref2$activeClassName,
//     isActive = _ref2.isActive,
//     props = _objectWithoutProperties$6(_ref2, _excluded$7);
//   var shape;
//   if ( /*#__PURE__*/isValidElement(option)) {
//     shape = /*#__PURE__*/cloneElement(option, _objectSpread$d(_objectSpread$d({}, props), getPropsFromShapeOption(option)));
//   } else if (isFunction(option)) {
//     shape = option(props);
//   } else if (isPlainObject$1(option) && !isBoolean(option)) {
//     var nextProps = propTransformer(option, props);
//     shape = /*#__PURE__*/React__default.createElement(ShapeSelector, {
//       shapeType: shapeType,
//       elementProps: nextProps
//     });
//   } else {
//     var elementProps = props;
//     shape = /*#__PURE__*/React__default.createElement(ShapeSelector, {
//       shapeType: shapeType,
//       elementProps: elementProps
//     });
//   }
//   if (isActive) {
//     return /*#__PURE__*/React__default.createElement(Layer, {
//       className: activeClassName
//     }, shape);
//   }
//   return shape;
// }

// /**
//  * This is an abstraction to handle identifying the active index from a tooltip mouse interaction
//  */

// function isFunnel(graphicalItem, _item) {
//   return _item != null && 'trapezoids' in graphicalItem.props;
// }
// function isPie(graphicalItem, _item) {
//   return _item != null && 'sectors' in graphicalItem.props;
// }
// function isScatter(graphicalItem, _item) {
//   return _item != null && 'points' in graphicalItem.props;
// }
// function compareFunnel(shapeData, activeTooltipItem) {
//   var _activeTooltipItem$la, _activeTooltipItem$la2;
//   var xMatches = shapeData.x === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la === void 0 ? void 0 : _activeTooltipItem$la.x) || shapeData.x === activeTooltipItem.x;
//   var yMatches = shapeData.y === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la2 = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la2 === void 0 ? void 0 : _activeTooltipItem$la2.y) || shapeData.y === activeTooltipItem.y;
//   return xMatches && yMatches;
// }
// function comparePie(shapeData, activeTooltipItem) {
//   var startAngleMatches = shapeData.endAngle === activeTooltipItem.endAngle;
//   var endAngleMatches = shapeData.startAngle === activeTooltipItem.startAngle;
//   return startAngleMatches && endAngleMatches;
// }
// function compareScatter(shapeData, activeTooltipItem) {
//   var xMatches = shapeData.x === activeTooltipItem.x;
//   var yMatches = shapeData.y === activeTooltipItem.y;
//   var zMatches = shapeData.z === activeTooltipItem.z;
//   return xMatches && yMatches && zMatches;
// }
// function getComparisonFn(graphicalItem, activeItem) {
//   var comparison;
//   if (isFunnel(graphicalItem, activeItem)) {
//     comparison = compareFunnel;
//   } else if (isPie(graphicalItem, activeItem)) {
//     comparison = comparePie;
//   } else if (isScatter(graphicalItem, activeItem)) {
//     comparison = compareScatter;
//   }
//   return comparison;
// }
// function getShapeDataKey(graphicalItem, activeItem) {
//   var shapeKey;
//   if (isFunnel(graphicalItem, activeItem)) {
//     shapeKey = 'trapezoids';
//   } else if (isPie(graphicalItem, activeItem)) {
//     shapeKey = 'sectors';
//   } else if (isScatter(graphicalItem, activeItem)) {
//     shapeKey = 'points';
//   }
//   return shapeKey;
// }
// function getActiveShapeTooltipPayload(graphicalItem, activeItem) {
//   if (isFunnel(graphicalItem, activeItem)) {
//     var _activeItem$tooltipPa;
//     return (_activeItem$tooltipPa = activeItem.tooltipPayload) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa[0]) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa.payload) === null || _activeItem$tooltipPa === void 0 ? void 0 : _activeItem$tooltipPa.payload;
//   }
//   if (isPie(graphicalItem, activeItem)) {
//     var _activeItem$tooltipPa2;
//     return (_activeItem$tooltipPa2 = activeItem.tooltipPayload) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2[0]) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2.payload) === null || _activeItem$tooltipPa2 === void 0 ? void 0 : _activeItem$tooltipPa2.payload;
//   }
//   if (isScatter(graphicalItem, activeItem)) {
//     return activeItem.payload;
//   }
//   return {};
// }
// /**
//  *
//  * @param {GetActiveShapeIndexForTooltip} arg an object of incoming attributes from Tooltip
//  * @returns {number}
//  *
//  * To handle possible duplicates in the data set,
//  * match both the data value of the active item to a data value on a graph item,
//  * and match the mouse coordinates of the active item to the coordinates of in a particular components shape data.
//  * This assumes equal lengths of shape objects to data items.
//  */
// function getActiveShapeIndexForTooltip(_ref3) {
//   var activeTooltipItem = _ref3.activeTooltipItem,
//     graphicalItem = _ref3.graphicalItem,
//     itemData = _ref3.itemData;
//   var shapeKey = getShapeDataKey(graphicalItem, activeTooltipItem);
//   var tooltipPayload = getActiveShapeTooltipPayload(graphicalItem, activeTooltipItem);
//   var activeItemMatches = itemData.filter(function (datum, dataIndex) {
//     var valuesMatch = isEqual$1(tooltipPayload, datum);
//     var mouseCoordinateMatches = graphicalItem.props[shapeKey].filter(function (shapeData) {
//       var comparison = getComparisonFn(graphicalItem, activeTooltipItem);
//       return comparison(shapeData, activeTooltipItem);
//     });

//     // get the last index in case of multiple matches
//     var indexOfMouseCoordinates = graphicalItem.props[shapeKey].indexOf(mouseCoordinateMatches[mouseCoordinateMatches.length - 1]);
//     var coordinatesMatch = dataIndex === indexOfMouseCoordinates;
//     return valuesMatch && coordinatesMatch;
//   });

//   // get the last index in case of multiple matches
//   var activeIndex = itemData.indexOf(activeItemMatches[activeItemMatches.length - 1]);
//   return activeIndex;
// }

// function _typeof$e(o) { "@babel/helpers - typeof"; return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$e(o); }
// function ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty$d(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$d(obj, key, value) { key = _toPropertyKey$d(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$d(arg) { var key = _toPrimitive$d(arg, "string"); return _typeof$e(key) === "symbol" ? key : String(key); }
// function _toPrimitive$d(input, hint) { if (_typeof$e(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$e(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var PREFIX_LIST = ['Webkit', 'Moz', 'O', 'ms'];
// var generatePrefixStyle = function generatePrefixStyle(name, value) {
//   if (!name) {
//     return null;
//   }
//   var camelName = name.replace(/(\w)/, function (v) {
//     return v.toUpperCase();
//   });
//   var result = PREFIX_LIST.reduce(function (res, entry) {
//     return _objectSpread$c(_objectSpread$c({}, res), {}, _defineProperty$d({}, entry + camelName, value));
//   }, {});
//   result[name] = value;
//   return result;
// };

// function _typeof$d(o) { "@babel/helpers - typeof"; return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$d(o); }
// function _extends$9() { _extends$9 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }
// function ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty$c(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$c(descriptor.key), descriptor); } }
// function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$6(subClass, superClass); }
// function _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }
// function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf$5(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$5(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$5(this, result); }; }
// function _possibleConstructorReturn$5(self, call) { if (call && (_typeof$d(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$5(self); }
// function _assertThisInitialized$5(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$5(o) { _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$5(o); }
// function _defineProperty$c(obj, key, value) { key = _toPropertyKey$c(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$c(arg) { var key = _toPrimitive$c(arg, "string"); return _typeof$d(key) === "symbol" ? key : String(key); }
// function _toPrimitive$c(input, hint) { if (_typeof$d(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$d(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var createScale = function createScale(_ref) {
//   var data = _ref.data,
//     startIndex = _ref.startIndex,
//     endIndex = _ref.endIndex,
//     x = _ref.x,
//     width = _ref.width,
//     travellerWidth = _ref.travellerWidth;
//   if (!data || !data.length) {
//     return {};
//   }
//   var len = data.length;
//   var scale = scalePoint().domain(range$1(0, len)).range([x, x + width - travellerWidth]);
//   var scaleValues = scale.domain().map(function (entry) {
//     return scale(entry);
//   });
//   return {
//     isTextActive: false,
//     isSlideMoving: false,
//     isTravellerMoving: false,
//     isTravellerFocused: false,
//     startX: scale(startIndex),
//     endX: scale(endIndex),
//     scale: scale,
//     scaleValues: scaleValues
//   };
// };
// var isTouch = function isTouch(e) {
//   return e.changedTouches && !!e.changedTouches.length;
// };
// var Brush = /*#__PURE__*/function (_PureComponent) {
//   _inherits$5(Brush, _PureComponent);
//   var _super = _createSuper$5(Brush);
//   function Brush(props) {
//     var _this;
//     _classCallCheck$7(this, Brush);
//     _this = _super.call(this, props);
//     _defineProperty$c(_assertThisInitialized$5(_this), "handleDrag", function (e) {
//       if (_this.leaveTimer) {
//         clearTimeout(_this.leaveTimer);
//         _this.leaveTimer = null;
//       }
//       if (_this.state.isTravellerMoving) {
//         _this.handleTravellerMove(e);
//       } else if (_this.state.isSlideMoving) {
//         _this.handleSlideDrag(e);
//       }
//     });
//     _defineProperty$c(_assertThisInitialized$5(_this), "handleTouchMove", function (e) {
//       if (e.changedTouches != null && e.changedTouches.length > 0) {
//         _this.handleDrag(e.changedTouches[0]);
//       }
//     });
//     _defineProperty$c(_assertThisInitialized$5(_this), "handleDragEnd", function () {
//       _this.setState({
//         isTravellerMoving: false,
//         isSlideMoving: false
//       }, function () {
//         var _this$props = _this.props,
//           endIndex = _this$props.endIndex,
//           onDragEnd = _this$props.onDragEnd,
//           startIndex = _this$props.startIndex;
//         onDragEnd === null || onDragEnd === void 0 || onDragEnd({
//           endIndex: endIndex,
//           startIndex: startIndex
//         });
//       });
//       _this.detachDragEndListener();
//     });
//     _defineProperty$c(_assertThisInitialized$5(_this), "handleLeaveWrapper", function () {
//       if (_this.state.isTravellerMoving || _this.state.isSlideMoving) {
//         _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);
//       }
//     });
//     _defineProperty$c(_assertThisInitialized$5(_this), "handleEnterSlideOrTraveller", function () {
//       _this.setState({
//         isTextActive: true
//       });
//     });
//     _defineProperty$c(_assertThisInitialized$5(_this), "handleLeaveSlideOrTraveller", function () {
//       _this.setState({
//         isTextActive: false
//       });
//     });
//     _defineProperty$c(_assertThisInitialized$5(_this), "handleSlideDragStart", function (e) {
//       var event = isTouch(e) ? e.changedTouches[0] : e;
//       _this.setState({
//         isTravellerMoving: false,
//         isSlideMoving: true,
//         slideMoveStartX: event.pageX
//       });
//       _this.attachDragEndListener();
//     });
//     _this.travellerDragStartHandlers = {
//       startX: _this.handleTravellerDragStart.bind(_assertThisInitialized$5(_this), 'startX'),
//       endX: _this.handleTravellerDragStart.bind(_assertThisInitialized$5(_this), 'endX')
//     };
//     _this.state = {};
//     return _this;
//   }
//   _createClass$7(Brush, [{
//     key: "componentWillUnmount",
//     value: function componentWillUnmount() {
//       if (this.leaveTimer) {
//         clearTimeout(this.leaveTimer);
//         this.leaveTimer = null;
//       }
//       this.detachDragEndListener();
//     }
//   }, {
//     key: "getIndex",
//     value: function getIndex(_ref2) {
//       var startX = _ref2.startX,
//         endX = _ref2.endX;
//       var scaleValues = this.state.scaleValues;
//       var _this$props2 = this.props,
//         gap = _this$props2.gap,
//         data = _this$props2.data;
//       var lastIndex = data.length - 1;
//       var min = Math.min(startX, endX);
//       var max = Math.max(startX, endX);
//       var minIndex = Brush.getIndexInRange(scaleValues, min);
//       var maxIndex = Brush.getIndexInRange(scaleValues, max);
//       return {
//         startIndex: minIndex - minIndex % gap,
//         endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
//       };
//     }
//   }, {
//     key: "getTextOfTick",
//     value: function getTextOfTick(index) {
//       var _this$props3 = this.props,
//         data = _this$props3.data,
//         tickFormatter = _this$props3.tickFormatter,
//         dataKey = _this$props3.dataKey;
//       var text = getValueByDataKey(data[index], dataKey, index);
//       return isFunction(tickFormatter) ? tickFormatter(text, index) : text;
//     }
//   }, {
//     key: "attachDragEndListener",
//     value: function attachDragEndListener() {
//       window.addEventListener('mouseup', this.handleDragEnd, true);
//       window.addEventListener('touchend', this.handleDragEnd, true);
//       window.addEventListener('mousemove', this.handleDrag, true);
//     }
//   }, {
//     key: "detachDragEndListener",
//     value: function detachDragEndListener() {
//       window.removeEventListener('mouseup', this.handleDragEnd, true);
//       window.removeEventListener('touchend', this.handleDragEnd, true);
//       window.removeEventListener('mousemove', this.handleDrag, true);
//     }
//   }, {
//     key: "handleSlideDrag",
//     value: function handleSlideDrag(e) {
//       var _this$state = this.state,
//         slideMoveStartX = _this$state.slideMoveStartX,
//         startX = _this$state.startX,
//         endX = _this$state.endX;
//       var _this$props4 = this.props,
//         x = _this$props4.x,
//         width = _this$props4.width,
//         travellerWidth = _this$props4.travellerWidth,
//         startIndex = _this$props4.startIndex,
//         endIndex = _this$props4.endIndex,
//         onChange = _this$props4.onChange;
//       var delta = e.pageX - slideMoveStartX;
//       if (delta > 0) {
//         delta = Math.min(delta, x + width - travellerWidth - endX, x + width - travellerWidth - startX);
//       } else if (delta < 0) {
//         delta = Math.max(delta, x - startX, x - endX);
//       }
//       var newIndex = this.getIndex({
//         startX: startX + delta,
//         endX: endX + delta
//       });
//       if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {
//         onChange(newIndex);
//       }
//       this.setState({
//         startX: startX + delta,
//         endX: endX + delta,
//         slideMoveStartX: e.pageX
//       });
//     }
//   }, {
//     key: "handleTravellerDragStart",
//     value: function handleTravellerDragStart(id, e) {
//       var event = isTouch(e) ? e.changedTouches[0] : e;
//       this.setState({
//         isSlideMoving: false,
//         isTravellerMoving: true,
//         movingTravellerId: id,
//         brushMoveStartX: event.pageX
//       });
//       this.attachDragEndListener();
//     }
//   }, {
//     key: "handleTravellerMove",
//     value: function handleTravellerMove(e) {
//       var _this$setState;
//       var _this$state2 = this.state,
//         brushMoveStartX = _this$state2.brushMoveStartX,
//         movingTravellerId = _this$state2.movingTravellerId,
//         endX = _this$state2.endX,
//         startX = _this$state2.startX;
//       var prevValue = this.state[movingTravellerId];
//       var _this$props5 = this.props,
//         x = _this$props5.x,
//         width = _this$props5.width,
//         travellerWidth = _this$props5.travellerWidth,
//         onChange = _this$props5.onChange,
//         gap = _this$props5.gap,
//         data = _this$props5.data;
//       var params = {
//         startX: this.state.startX,
//         endX: this.state.endX
//       };
//       var delta = e.pageX - brushMoveStartX;
//       if (delta > 0) {
//         delta = Math.min(delta, x + width - travellerWidth - prevValue);
//       } else if (delta < 0) {
//         delta = Math.max(delta, x - prevValue);
//       }
//       params[movingTravellerId] = prevValue + delta;
//       var newIndex = this.getIndex(params);
//       var startIndex = newIndex.startIndex,
//         endIndex = newIndex.endIndex;
//       var isFullGap = function isFullGap() {
//         var lastIndex = data.length - 1;
//         if (movingTravellerId === 'startX' && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === 'endX' && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {
//           return true;
//         }
//         return false;
//       };
//       this.setState((_this$setState = {}, _defineProperty$c(_this$setState, movingTravellerId, prevValue + delta), _defineProperty$c(_this$setState, "brushMoveStartX", e.pageX), _this$setState), function () {
//         if (onChange) {
//           if (isFullGap()) {
//             onChange(newIndex);
//           }
//         }
//       });
//     }
//   }, {
//     key: "handleTravellerMoveKeyboard",
//     value: function handleTravellerMoveKeyboard(direction, id) {
//       var _this2 = this;
//       // scaleValues are a list of coordinates. For example: [65, 250, 435, 620, 805, 990].
//       var _this$state3 = this.state,
//         scaleValues = _this$state3.scaleValues,
//         startX = _this$state3.startX,
//         endX = _this$state3.endX;
//       // currentScaleValue refers to which coordinate the current traveller should be placed at.
//       var currentScaleValue = this.state[id];
//       var currentIndex = scaleValues.indexOf(currentScaleValue);
//       if (currentIndex === -1) {
//         return;
//       }
//       var newIndex = currentIndex + direction;
//       if (newIndex === -1 || newIndex >= scaleValues.length) {
//         return;
//       }
//       var newScaleValue = scaleValues[newIndex];

//       // Prevent travellers from being on top of each other or overlapping
//       if (id === 'startX' && newScaleValue >= endX || id === 'endX' && newScaleValue <= startX) {
//         return;
//       }
//       this.setState(_defineProperty$c({}, id, newScaleValue), function () {
//         _this2.props.onChange(_this2.getIndex({
//           startX: _this2.state.startX,
//           endX: _this2.state.endX
//         }));
//       });
//     }
//   }, {
//     key: "renderBackground",
//     value: function renderBackground() {
//       var _this$props6 = this.props,
//         x = _this$props6.x,
//         y = _this$props6.y,
//         width = _this$props6.width,
//         height = _this$props6.height,
//         fill = _this$props6.fill,
//         stroke = _this$props6.stroke;
//       return /*#__PURE__*/React__default.createElement("rect", {
//         stroke: stroke,
//         fill: fill,
//         x: x,
//         y: y,
//         width: width,
//         height: height
//       });
//     }
//   }, {
//     key: "renderPanorama",
//     value: function renderPanorama() {
//       var _this$props7 = this.props,
//         x = _this$props7.x,
//         y = _this$props7.y,
//         width = _this$props7.width,
//         height = _this$props7.height,
//         data = _this$props7.data,
//         children = _this$props7.children,
//         padding = _this$props7.padding;
//       var chartElement = Children.only(children);
//       if (!chartElement) {
//         return null;
//       }
//       return /*#__PURE__*/React__default.cloneElement(chartElement, {
//         x: x,
//         y: y,
//         width: width,
//         height: height,
//         margin: padding,
//         compact: true,
//         data: data
//       });
//     }
//   }, {
//     key: "renderTravellerLayer",
//     value: function renderTravellerLayer(travellerX, id) {
//       var _this3 = this;
//       var _this$props8 = this.props,
//         y = _this$props8.y,
//         travellerWidth = _this$props8.travellerWidth,
//         height = _this$props8.height,
//         traveller = _this$props8.traveller,
//         ariaLabel = _this$props8.ariaLabel,
//         data = _this$props8.data,
//         startIndex = _this$props8.startIndex,
//         endIndex = _this$props8.endIndex;
//       var x = Math.max(travellerX, this.props.x);
//       var travellerProps = _objectSpread$b(_objectSpread$b({}, filterProps(this.props)), {}, {
//         x: x,
//         y: y,
//         width: travellerWidth,
//         height: height
//       });
//       var ariaLabelBrush = ariaLabel || "Min value: ".concat(data[startIndex].name, ", Max value: ").concat(data[endIndex].name);
//       return /*#__PURE__*/React__default.createElement(Layer, {
//         tabIndex: 0,
//         role: "slider",
//         "aria-label": ariaLabelBrush,
//         "aria-valuenow": travellerX,
//         className: "recharts-brush-traveller",
//         onMouseEnter: this.handleEnterSlideOrTraveller,
//         onMouseLeave: this.handleLeaveSlideOrTraveller,
//         onMouseDown: this.travellerDragStartHandlers[id],
//         onTouchStart: this.travellerDragStartHandlers[id],
//         onKeyDown: function onKeyDown(e) {
//           if (!['ArrowLeft', 'ArrowRight'].includes(e.key)) {
//             return;
//           }
//           e.preventDefault();
//           e.stopPropagation();
//           _this3.handleTravellerMoveKeyboard(e.key === 'ArrowRight' ? 1 : -1, id);
//         },
//         onFocus: function onFocus() {
//           _this3.setState({
//             isTravellerFocused: true
//           });
//         },
//         onBlur: function onBlur() {
//           _this3.setState({
//             isTravellerFocused: false
//           });
//         },
//         style: {
//           cursor: 'col-resize'
//         }
//       }, Brush.renderTraveller(traveller, travellerProps));
//     }
//   }, {
//     key: "renderSlide",
//     value: function renderSlide(startX, endX) {
//       var _this$props9 = this.props,
//         y = _this$props9.y,
//         height = _this$props9.height,
//         stroke = _this$props9.stroke,
//         travellerWidth = _this$props9.travellerWidth;
//       var x = Math.min(startX, endX) + travellerWidth;
//       var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
//       return /*#__PURE__*/React__default.createElement("rect", {
//         className: "recharts-brush-slide",
//         onMouseEnter: this.handleEnterSlideOrTraveller,
//         onMouseLeave: this.handleLeaveSlideOrTraveller,
//         onMouseDown: this.handleSlideDragStart,
//         onTouchStart: this.handleSlideDragStart,
//         style: {
//           cursor: 'move'
//         },
//         stroke: "none",
//         fill: stroke,
//         fillOpacity: 0.2,
//         x: x,
//         y: y,
//         width: width,
//         height: height
//       });
//     }
//   }, {
//     key: "renderText",
//     value: function renderText() {
//       var _this$props10 = this.props,
//         startIndex = _this$props10.startIndex,
//         endIndex = _this$props10.endIndex,
//         y = _this$props10.y,
//         height = _this$props10.height,
//         travellerWidth = _this$props10.travellerWidth,
//         stroke = _this$props10.stroke;
//       var _this$state4 = this.state,
//         startX = _this$state4.startX,
//         endX = _this$state4.endX;
//       var offset = 5;
//       var attrs = {
//         pointerEvents: 'none',
//         fill: stroke
//       };
//       return /*#__PURE__*/React__default.createElement(Layer, {
//         className: "recharts-brush-texts"
//       }, /*#__PURE__*/React__default.createElement(Text, _extends$9({
//         textAnchor: "end",
//         verticalAnchor: "middle",
//         x: Math.min(startX, endX) - offset,
//         y: y + height / 2
//       }, attrs), this.getTextOfTick(startIndex)), /*#__PURE__*/React__default.createElement(Text, _extends$9({
//         textAnchor: "start",
//         verticalAnchor: "middle",
//         x: Math.max(startX, endX) + travellerWidth + offset,
//         y: y + height / 2
//       }, attrs), this.getTextOfTick(endIndex)));
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this$props11 = this.props,
//         data = _this$props11.data,
//         className = _this$props11.className,
//         children = _this$props11.children,
//         x = _this$props11.x,
//         y = _this$props11.y,
//         width = _this$props11.width,
//         height = _this$props11.height,
//         alwaysShowText = _this$props11.alwaysShowText;
//       var _this$state5 = this.state,
//         startX = _this$state5.startX,
//         endX = _this$state5.endX,
//         isTextActive = _this$state5.isTextActive,
//         isSlideMoving = _this$state5.isSlideMoving,
//         isTravellerMoving = _this$state5.isTravellerMoving,
//         isTravellerFocused = _this$state5.isTravellerFocused;
//       if (!data || !data.length || !isNumber(x) || !isNumber(y) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {
//         return null;
//       }
//       var layerClass = clsx('recharts-brush', className);
//       var isPanoramic = React__default.Children.count(children) === 1;
//       var style = generatePrefixStyle('userSelect', 'none');
//       return /*#__PURE__*/React__default.createElement(Layer, {
//         className: layerClass,
//         onMouseLeave: this.handleLeaveWrapper,
//         onTouchMove: this.handleTouchMove,
//         style: style
//       }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, 'startX'), this.renderTravellerLayer(endX, 'endX'), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && this.renderText());
//     }
//   }], [{
//     key: "renderDefaultTraveller",
//     value: function renderDefaultTraveller(props) {
//       var x = props.x,
//         y = props.y,
//         width = props.width,
//         height = props.height,
//         stroke = props.stroke;
//       var lineY = Math.floor(y + height / 2) - 1;
//       return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("rect", {
//         x: x,
//         y: y,
//         width: width,
//         height: height,
//         fill: stroke,
//         stroke: "none"
//       }), /*#__PURE__*/React__default.createElement("line", {
//         x1: x + 1,
//         y1: lineY,
//         x2: x + width - 1,
//         y2: lineY,
//         fill: "none",
//         stroke: "#fff"
//       }), /*#__PURE__*/React__default.createElement("line", {
//         x1: x + 1,
//         y1: lineY + 2,
//         x2: x + width - 1,
//         y2: lineY + 2,
//         fill: "none",
//         stroke: "#fff"
//       }));
//     }
//   }, {
//     key: "renderTraveller",
//     value: function renderTraveller(option, props) {
//       var rectangle;
//       if ( /*#__PURE__*/React__default.isValidElement(option)) {
//         rectangle = /*#__PURE__*/React__default.cloneElement(option, props);
//       } else if (isFunction(option)) {
//         rectangle = option(props);
//       } else {
//         rectangle = Brush.renderDefaultTraveller(props);
//       }
//       return rectangle;
//     }
//   }, {
//     key: "getDerivedStateFromProps",
//     value: function getDerivedStateFromProps(nextProps, prevState) {
//       var data = nextProps.data,
//         width = nextProps.width,
//         x = nextProps.x,
//         travellerWidth = nextProps.travellerWidth,
//         updateId = nextProps.updateId,
//         startIndex = nextProps.startIndex,
//         endIndex = nextProps.endIndex;
//       if (data !== prevState.prevData || updateId !== prevState.prevUpdateId) {
//         return _objectSpread$b({
//           prevData: data,
//           prevTravellerWidth: travellerWidth,
//           prevUpdateId: updateId,
//           prevX: x,
//           prevWidth: width
//         }, data && data.length ? createScale({
//           data: data,
//           width: width,
//           x: x,
//           travellerWidth: travellerWidth,
//           startIndex: startIndex,
//           endIndex: endIndex
//         }) : {
//           scale: null,
//           scaleValues: null
//         });
//       }
//       if (prevState.scale && (width !== prevState.prevWidth || x !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
//         prevState.scale.range([x, x + width - travellerWidth]);
//         var scaleValues = prevState.scale.domain().map(function (entry) {
//           return prevState.scale(entry);
//         });
//         return {
//           prevData: data,
//           prevTravellerWidth: travellerWidth,
//           prevUpdateId: updateId,
//           prevX: x,
//           prevWidth: width,
//           startX: prevState.scale(nextProps.startIndex),
//           endX: prevState.scale(nextProps.endIndex),
//           scaleValues: scaleValues
//         };
//       }
//       return null;
//     }
//   }, {
//     key: "getIndexInRange",
//     value: function getIndexInRange(valueRange, x) {
//       var len = valueRange.length;
//       var start = 0;
//       var end = len - 1;
//       while (end - start > 1) {
//         var middle = Math.floor((start + end) / 2);
//         if (valueRange[middle] > x) {
//           end = middle;
//         } else {
//           start = middle;
//         }
//       }
//       return x >= valueRange[end] ? end : start;
//     }
//   }]);
//   return Brush;
// }(PureComponent);
// _defineProperty$c(Brush, "displayName", 'Brush');
// _defineProperty$c(Brush, "defaultProps", {
//   height: 40,
//   travellerWidth: 5,
//   gap: 1,
//   fill: '#fff',
//   stroke: '#666',
//   padding: {
//     top: 1,
//     right: 1,
//     bottom: 1,
//     left: 1
//   },
//   leaveTimeOut: 1000,
//   alwaysShowText: false
// });

// var ifOverflowMatches = function ifOverflowMatches(props, value) {
//   var alwaysShow = props.alwaysShow;
//   var ifOverflow = props.ifOverflow;
//   if (alwaysShow) {
//     ifOverflow = 'extendDomain';
//   }
//   return ifOverflow === value;
// };

// function _typeof$c(o) { "@babel/helpers - typeof"; return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$c(o); }
// var _excluded$6 = ["x", "y"];
// function _extends$8() { _extends$8 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }
// function ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty$b(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$b(obj, key, value) { key = _toPropertyKey$b(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$b(arg) { var key = _toPrimitive$b(arg, "string"); return _typeof$c(key) === "symbol" ? key : String(key); }
// function _toPrimitive$b(input, hint) { if (_typeof$c(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$c(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _objectWithoutProperties$5(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$5(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$5(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// // Rectangle props is expecting x, y, height, width as numbers, name as a string, and radius as a custom type
// // When props are being spread in from a user defined component in Bar,
// // the prop types of an SVGElement have these typed as something else.
// // This function will return the passed in props
// // along with x, y, height as numbers, name as a string, and radius as number | [number, numbe, number, number]
// function typeguardBarRectangleProps(_ref, props) {
//   var xProp = _ref.x,
//     yProp = _ref.y,
//     option = _objectWithoutProperties$5(_ref, _excluded$6);
//   var xValue = "".concat(xProp);
//   var x = parseInt(xValue, 10);
//   var yValue = "".concat(yProp);
//   var y = parseInt(yValue, 10);
//   var heightValue = "".concat(props.height || option.height);
//   var height = parseInt(heightValue, 10);
//   var widthValue = "".concat(props.width || option.width);
//   var width = parseInt(widthValue, 10);
//   return _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, props), option), x ? {
//     x: x
//   } : {}), y ? {
//     y: y
//   } : {}), {}, {
//     height: height,
//     width: width,
//     name: props.name,
//     radius: props.radius
//   });
// }
// function BarRectangle(props) {
//   return /*#__PURE__*/React__default.createElement(Shape, _extends$8({
//     shapeType: "rectangle",
//     propTransformer: typeguardBarRectangleProps,
//     activeClassName: "recharts-active-bar"
//   }, props));
// }

// var _excluded$5 = ["value", "background"];
// function _typeof$b(o) { "@babel/helpers - typeof"; return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$b(o); }
// function _objectWithoutProperties$4(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$4(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$4(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function _extends$7() { _extends$7 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }
// function ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty$a(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$a(descriptor.key), descriptor); } }
// function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$5(subClass, superClass); }
// function _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }
// function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf$4(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$4(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$4(this, result); }; }
// function _possibleConstructorReturn$4(self, call) { if (call && (_typeof$b(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$4(self); }
// function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$4(o) { _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$4(o); }
// function _defineProperty$a(obj, key, value) { key = _toPropertyKey$a(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$a(arg) { var key = _toPrimitive$a(arg, "string"); return _typeof$b(key) === "symbol" ? key : String(key); }
// function _toPrimitive$a(input, hint) { if (_typeof$b(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$b(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var Bar = /*#__PURE__*/function (_PureComponent) {
//   _inherits$4(Bar, _PureComponent);
//   var _super = _createSuper$4(Bar);
//   function Bar() {
//     var _this;
//     _classCallCheck$6(this, Bar);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$a(_assertThisInitialized$4(_this), "state", {
//       isAnimationFinished: false
//     });
//     _defineProperty$a(_assertThisInitialized$4(_this), "id", uniqueId('recharts-bar-'));
//     _defineProperty$a(_assertThisInitialized$4(_this), "handleAnimationEnd", function () {
//       var onAnimationEnd = _this.props.onAnimationEnd;
//       _this.setState({
//         isAnimationFinished: true
//       });
//       if (onAnimationEnd) {
//         onAnimationEnd();
//       }
//     });
//     _defineProperty$a(_assertThisInitialized$4(_this), "handleAnimationStart", function () {
//       var onAnimationStart = _this.props.onAnimationStart;
//       _this.setState({
//         isAnimationFinished: false
//       });
//       if (onAnimationStart) {
//         onAnimationStart();
//       }
//     });
//     return _this;
//   }
//   _createClass$6(Bar, [{
//     key: "renderRectanglesStatically",
//     value: function renderRectanglesStatically(data) {
//       var _this2 = this;
//       var _this$props = this.props,
//         shape = _this$props.shape,
//         dataKey = _this$props.dataKey,
//         activeIndex = _this$props.activeIndex,
//         activeBar = _this$props.activeBar;
//       var baseProps = filterProps(this.props);
//       return data && data.map(function (entry, i) {
//         var isActive = i === activeIndex;
//         var option = isActive ? activeBar : shape;
//         var props = _objectSpread$9(_objectSpread$9(_objectSpread$9({}, baseProps), entry), {}, {
//           isActive: isActive,
//           option: option,
//           index: i,
//           dataKey: dataKey,
//           onAnimationStart: _this2.handleAnimationStart,
//           onAnimationEnd: _this2.handleAnimationEnd
//         });
//         return /*#__PURE__*/React__default.createElement(Layer, _extends$7({
//           className: "recharts-bar-rectangle"
//         }, adaptEventsOfChild(_this2.props, entry, i), {
//           key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value)
//         }), /*#__PURE__*/React__default.createElement(BarRectangle, props));
//       });
//     }
//   }, {
//     key: "renderRectanglesWithAnimation",
//     value: function renderRectanglesWithAnimation() {
//       var _this3 = this;
//       var _this$props2 = this.props,
//         data = _this$props2.data,
//         layout = _this$props2.layout,
//         isAnimationActive = _this$props2.isAnimationActive,
//         animationBegin = _this$props2.animationBegin,
//         animationDuration = _this$props2.animationDuration,
//         animationEasing = _this$props2.animationEasing,
//         animationId = _this$props2.animationId;
//       var prevData = this.state.prevData;
//       return /*#__PURE__*/React__default.createElement(Animate, {
//         begin: animationBegin,
//         duration: animationDuration,
//         isActive: isAnimationActive,
//         easing: animationEasing,
//         from: {
//           t: 0
//         },
//         to: {
//           t: 1
//         },
//         key: "bar-".concat(animationId),
//         onAnimationEnd: this.handleAnimationEnd,
//         onAnimationStart: this.handleAnimationStart
//       }, function (_ref) {
//         var t = _ref.t;
//         var stepData = data.map(function (entry, index) {
//           var prev = prevData && prevData[index];
//           if (prev) {
//             var interpolatorX = interpolateNumber$1(prev.x, entry.x);
//             var interpolatorY = interpolateNumber$1(prev.y, entry.y);
//             var interpolatorWidth = interpolateNumber$1(prev.width, entry.width);
//             var interpolatorHeight = interpolateNumber$1(prev.height, entry.height);
//             return _objectSpread$9(_objectSpread$9({}, entry), {}, {
//               x: interpolatorX(t),
//               y: interpolatorY(t),
//               width: interpolatorWidth(t),
//               height: interpolatorHeight(t)
//             });
//           }
//           if (layout === 'horizontal') {
//             var _interpolatorHeight = interpolateNumber$1(0, entry.height);
//             var h = _interpolatorHeight(t);
//             return _objectSpread$9(_objectSpread$9({}, entry), {}, {
//               y: entry.y + entry.height - h,
//               height: h
//             });
//           }
//           var interpolator = interpolateNumber$1(0, entry.width);
//           var w = interpolator(t);
//           return _objectSpread$9(_objectSpread$9({}, entry), {}, {
//             width: w
//           });
//         });
//         return /*#__PURE__*/React__default.createElement(Layer, null, _this3.renderRectanglesStatically(stepData));
//       });
//     }
//   }, {
//     key: "renderRectangles",
//     value: function renderRectangles() {
//       var _this$props3 = this.props,
//         data = _this$props3.data,
//         isAnimationActive = _this$props3.isAnimationActive;
//       var prevData = this.state.prevData;
//       if (isAnimationActive && data && data.length && (!prevData || !isEqual$1(prevData, data))) {
//         return this.renderRectanglesWithAnimation();
//       }
//       return this.renderRectanglesStatically(data);
//     }
//   }, {
//     key: "renderBackground",
//     value: function renderBackground() {
//       var _this4 = this;
//       var _this$props4 = this.props,
//         data = _this$props4.data,
//         dataKey = _this$props4.dataKey,
//         activeIndex = _this$props4.activeIndex;
//       var backgroundProps = filterProps(this.props.background);
//       return data.map(function (entry, i) {
//         entry.value;
//           var background = entry.background,
//           rest = _objectWithoutProperties$4(entry, _excluded$5);
//         if (!background) {
//           return null;
//         }
//         var props = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, rest), {}, {
//           fill: '#eee'
//         }, background), backgroundProps), adaptEventsOfChild(_this4.props, entry, i)), {}, {
//           onAnimationStart: _this4.handleAnimationStart,
//           onAnimationEnd: _this4.handleAnimationEnd,
//           dataKey: dataKey,
//           index: i,
//           key: "background-bar-".concat(i),
//           className: 'recharts-bar-background-rectangle'
//         });
//         return /*#__PURE__*/React__default.createElement(BarRectangle, _extends$7({
//           option: _this4.props.background,
//           isActive: i === activeIndex
//         }, props));
//       });
//     }
//   }, {
//     key: "renderErrorBar",
//     value: function renderErrorBar(needClip, clipPathId) {
//       if (this.props.isAnimationActive && !this.state.isAnimationFinished) {
//         return null;
//       }
//       var _this$props5 = this.props,
//         data = _this$props5.data,
//         xAxis = _this$props5.xAxis,
//         yAxis = _this$props5.yAxis,
//         layout = _this$props5.layout,
//         children = _this$props5.children;
//       var errorBarItems = findAllByType(children, ErrorBar);
//       if (!errorBarItems) {
//         return null;
//       }
//       var offset = layout === 'vertical' ? data[0].height / 2 : data[0].width / 2;
//       var dataPointFormatter = function dataPointFormatter(dataPoint, dataKey) {
//         /**
//          * if the value coming from `getComposedData` is an array then this is a stacked bar chart.
//          * arr[1] represents end value of the bar since the data is in the form of [startValue, endValue].
//          * */
//         var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
//         return {
//           x: dataPoint.x,
//           y: dataPoint.y,
//           value: value,
//           errorVal: getValueByDataKey(dataPoint, dataKey)
//         };
//       };
//       var errorBarProps = {
//         clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
//       };
//       return /*#__PURE__*/React__default.createElement(Layer, errorBarProps, errorBarItems.map(function (item) {
//         return /*#__PURE__*/React__default.cloneElement(item, {
//           key: "error-bar-".concat(clipPathId, "-").concat(item.props.dataKey),
//           data: data,
//           xAxis: xAxis,
//           yAxis: yAxis,
//           layout: layout,
//           offset: offset,
//           dataPointFormatter: dataPointFormatter
//         });
//       }));
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this$props6 = this.props,
//         hide = _this$props6.hide,
//         data = _this$props6.data,
//         className = _this$props6.className,
//         xAxis = _this$props6.xAxis,
//         yAxis = _this$props6.yAxis,
//         left = _this$props6.left,
//         top = _this$props6.top,
//         width = _this$props6.width,
//         height = _this$props6.height,
//         isAnimationActive = _this$props6.isAnimationActive,
//         background = _this$props6.background,
//         id = _this$props6.id;
//       if (hide || !data || !data.length) {
//         return null;
//       }
//       var isAnimationFinished = this.state.isAnimationFinished;
//       var layerClass = clsx('recharts-bar', className);
//       var needClipX = xAxis && xAxis.allowDataOverflow;
//       var needClipY = yAxis && yAxis.allowDataOverflow;
//       var needClip = needClipX || needClipY;
//       var clipPathId = isNil$1(id) ? this.id : id;
//       return /*#__PURE__*/React__default.createElement(Layer, {
//         className: layerClass
//       }, needClipX || needClipY ? /*#__PURE__*/React__default.createElement("defs", null, /*#__PURE__*/React__default.createElement("clipPath", {
//         id: "clipPath-".concat(clipPathId)
//       }, /*#__PURE__*/React__default.createElement("rect", {
//         x: needClipX ? left : left - width / 2,
//         y: needClipY ? top : top - height / 2,
//         width: needClipX ? width : width * 2,
//         height: needClipY ? height : height * 2
//       }))) : null, /*#__PURE__*/React__default.createElement(Layer, {
//         className: "recharts-bar-rectangles",
//         clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
//       }, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, data));
//     }
//   }], [{
//     key: "getDerivedStateFromProps",
//     value: function getDerivedStateFromProps(nextProps, prevState) {
//       if (nextProps.animationId !== prevState.prevAnimationId) {
//         return {
//           prevAnimationId: nextProps.animationId,
//           curData: nextProps.data,
//           prevData: prevState.curData
//         };
//       }
//       if (nextProps.data !== prevState.curData) {
//         return {
//           curData: nextProps.data
//         };
//       }
//       return null;
//     }
//   }]);
//   return Bar;
// }(PureComponent);
// _defineProperty$a(Bar, "displayName", 'Bar');
// _defineProperty$a(Bar, "defaultProps", {
//   xAxisId: 0,
//   yAxisId: 0,
//   legendType: 'rect',
//   minPointSize: 0,
//   hide: false,
//   data: [],
//   layout: 'vertical',
//   activeBar: true,
//   isAnimationActive: !Global.isSsr,
//   animationBegin: 0,
//   animationDuration: 400,
//   animationEasing: 'ease'
// });
// /**
//  * Compose the data of each group
//  * @param {Object} props Props for the component
//  * @param {Object} item        An instance of Bar
//  * @param {Array} barPosition  The offset and size of each bar
//  * @param {Object} xAxis       The configuration of x-axis
//  * @param {Object} yAxis       The configuration of y-axis
//  * @param {Array} stackedData  The stacked data of a bar item
//  * @return{Array} Composed data
//  */
// _defineProperty$a(Bar, "getComposedData", function (_ref2) {
//   var props = _ref2.props,
//     item = _ref2.item,
//     barPosition = _ref2.barPosition,
//     bandSize = _ref2.bandSize,
//     xAxis = _ref2.xAxis,
//     yAxis = _ref2.yAxis,
//     xAxisTicks = _ref2.xAxisTicks,
//     yAxisTicks = _ref2.yAxisTicks,
//     stackedData = _ref2.stackedData,
//     dataStartIndex = _ref2.dataStartIndex,
//     displayedData = _ref2.displayedData,
//     offset = _ref2.offset;
//   var pos = findPositionOfBar(barPosition, item);
//   if (!pos) {
//     return null;
//   }
//   var layout = props.layout;
//   var _item$props = item.props,
//     dataKey = _item$props.dataKey,
//     children = _item$props.children,
//     minPointSize = _item$props.minPointSize;
//   var numericAxis = layout === 'horizontal' ? yAxis : xAxis;
//   var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
//   var baseValue = getBaseValueOfBar({
//     numericAxis: numericAxis
//   });
//   var cells = findAllByType(children, Cell);
//   var rects = displayedData.map(function (entry, index) {
//     var value, x, y, width, height, background;
//     if (stackedData) {
//       value = truncateByDomain(stackedData[dataStartIndex + index], stackedDomain);
//     } else {
//       value = getValueByDataKey(entry, dataKey);
//       if (!Array.isArray(value)) {
//         value = [baseValue, value];
//       }
//     }
//     if (layout === 'horizontal') {
//       var _ref4;
//       var _ref3 = [yAxis.scale(value[0]), yAxis.scale(value[1])],
//         baseValueScale = _ref3[0],
//         currentValueScale = _ref3[1];
//       x = getCateCoordinateOfBar({
//         axis: xAxis,
//         ticks: xAxisTicks,
//         bandSize: bandSize,
//         offset: pos.offset,
//         entry: entry,
//         index: index
//       });
//       y = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : undefined;
//       width = pos.size;
//       var computedHeight = baseValueScale - currentValueScale;
//       height = Number.isNaN(computedHeight) ? 0 : computedHeight;
//       background = {
//         x: x,
//         y: yAxis.y,
//         width: width,
//         height: yAxis.height
//       };
//       if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
//         var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
//         y -= delta;
//         height += delta;
//       }
//     } else {
//       var _ref5 = [xAxis.scale(value[0]), xAxis.scale(value[1])],
//         _baseValueScale = _ref5[0],
//         _currentValueScale = _ref5[1];
//       x = _baseValueScale;
//       y = getCateCoordinateOfBar({
//         axis: yAxis,
//         ticks: yAxisTicks,
//         bandSize: bandSize,
//         offset: pos.offset,
//         entry: entry,
//         index: index
//       });
//       width = _currentValueScale - _baseValueScale;
//       height = pos.size;
//       background = {
//         x: xAxis.x,
//         y: y,
//         width: xAxis.width,
//         height: height
//       };
//       if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
//         var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
//         width += _delta;
//       }
//     }
//     return _objectSpread$9(_objectSpread$9(_objectSpread$9({}, entry), {}, {
//       x: x,
//       y: y,
//       width: width,
//       height: height,
//       value: stackedData ? value : value[1],
//       payload: entry,
//       background: background
//     }, cells && cells[index] && cells[index].props), {}, {
//       tooltipPayload: [getTooltipItem(item, entry)],
//       tooltipPosition: {
//         x: x + width / 2,
//         y: y + height / 2
//       }
//     });
//   });
//   return _objectSpread$9({
//     data: rects,
//     layout: layout
//   }, offset);
// });

// function _typeof$a(o) { "@babel/helpers - typeof"; return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$a(o); }
// function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$9(descriptor.key), descriptor); } }
// function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty$9(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$9(obj, key, value) { key = _toPropertyKey$9(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$9(arg) { var key = _toPrimitive$9(arg, "string"); return _typeof$a(key) === "symbol" ? key : String(key); }
// function _toPrimitive$9(input, hint) { if (_typeof$a(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$a(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

// /**
//  * Calculate the scale function, position, width, height of axes
//  * @param  {Object} props     Latest props
//  * @param  {Object} axisMap   The configuration of axes
//  * @param  {Object} offset    The offset of main part in the svg element
//  * @param  {String} axisType  The type of axes, x-axis or y-axis
//  * @param  {String} chartName The name of chart
//  * @return {Object} Configuration
//  */
// var formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {
//   var width = props.width,
//     height = props.height,
//     layout = props.layout,
//     children = props.children;
//   var ids = Object.keys(axisMap);
//   var steps = {
//     left: offset.left,
//     leftMirror: offset.left,
//     right: width - offset.right,
//     rightMirror: width - offset.right,
//     top: offset.top,
//     topMirror: offset.top,
//     bottom: height - offset.bottom,
//     bottomMirror: height - offset.bottom
//   };
//   var hasBar = !!findChildByType(children, Bar);
//   return ids.reduce(function (result, id) {
//     var axis = axisMap[id];
//     var orientation = axis.orientation,
//       domain = axis.domain,
//       _axis$padding = axis.padding,
//       padding = _axis$padding === void 0 ? {} : _axis$padding,
//       mirror = axis.mirror,
//       reversed = axis.reversed;
//     var offsetKey = "".concat(orientation).concat(mirror ? 'Mirror' : '');
//     var calculatedPadding, range, x, y, needSpace;
//     if (axis.type === 'number' && (axis.padding === 'gap' || axis.padding === 'no-gap')) {
//       var diff = domain[1] - domain[0];
//       var smallestDistanceBetweenValues = Infinity;
//       var sortedValues = axis.categoricalDomain.sort();
//       sortedValues.forEach(function (value, index) {
//         if (index > 0) {
//           smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index - 1] || 0), smallestDistanceBetweenValues);
//         }
//       });
//       var smallestDistanceInPercent = smallestDistanceBetweenValues / diff;
//       var rangeWidth = axis.layout === 'vertical' ? offset.height : offset.width;
//       if (axis.padding === 'gap') {
//         calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;
//       }
//       if (axis.padding === 'no-gap') {
//         var gap = getPercentValue(props.barCategoryGap, smallestDistanceInPercent * rangeWidth);
//         var halfBand = smallestDistanceInPercent * rangeWidth / 2;
//         calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;
//       }
//     }
//     if (axisType === 'xAxis') {
//       range = [offset.left + (padding.left || 0) + (calculatedPadding || 0), offset.left + offset.width - (padding.right || 0) - (calculatedPadding || 0)];
//     } else if (axisType === 'yAxis') {
//       range = layout === 'horizontal' ? [offset.top + offset.height - (padding.bottom || 0), offset.top + (padding.top || 0)] : [offset.top + (padding.top || 0) + (calculatedPadding || 0), offset.top + offset.height - (padding.bottom || 0) - (calculatedPadding || 0)];
//     } else {
//       range = axis.range;
//     }
//     if (reversed) {
//       range = [range[1], range[0]];
//     }
//     var _parseScale = parseScale(axis, chartName, hasBar),
//       scale = _parseScale.scale,
//       realScaleType = _parseScale.realScaleType;
//     scale.domain(domain).range(range);
//     checkDomainOfScale(scale);
//     var ticks = getTicksOfScale(scale, _objectSpread$8(_objectSpread$8({}, axis), {}, {
//       realScaleType: realScaleType
//     }));
//     if (axisType === 'xAxis') {
//       needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;
//       x = offset.left;
//       y = steps[offsetKey] - needSpace * axis.height;
//     } else if (axisType === 'yAxis') {
//       needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;
//       x = steps[offsetKey] - needSpace * axis.width;
//       y = offset.top;
//     }
//     var finalAxis = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, axis), ticks), {}, {
//       realScaleType: realScaleType,
//       x: x,
//       y: y,
//       scale: scale,
//       width: axisType === 'xAxis' ? offset.width : axis.width,
//       height: axisType === 'yAxis' ? offset.height : axis.height
//     });
//     finalAxis.bandSize = getBandSizeOfAxis(finalAxis, ticks);
//     if (!axis.hide && axisType === 'xAxis') {
//       steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;
//     } else if (!axis.hide) {
//       steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;
//     }
//     return _objectSpread$8(_objectSpread$8({}, result), {}, _defineProperty$9({}, id, finalAxis));
//   }, {});
// };
// var rectWithPoints = function rectWithPoints(_ref, _ref2) {
//   var x1 = _ref.x,
//     y1 = _ref.y;
//   var x2 = _ref2.x,
//     y2 = _ref2.y;
//   return {
//     x: Math.min(x1, x2),
//     y: Math.min(y1, y2),
//     width: Math.abs(x2 - x1),
//     height: Math.abs(y2 - y1)
//   };
// };

// /**
//  * Compute the x, y, width, and height of a box from two reference points.
//  * @param  {Object} coords     x1, x2, y1, and y2
//  * @return {Object} object
//  */
// var rectWithCoords = function rectWithCoords(_ref3) {
//   var x1 = _ref3.x1,
//     y1 = _ref3.y1,
//     x2 = _ref3.x2,
//     y2 = _ref3.y2;
//   return rectWithPoints({
//     x: x1,
//     y: y1
//   }, {
//     x: x2,
//     y: y2
//   });
// };
// var ScaleHelper = /*#__PURE__*/function () {
//   function ScaleHelper(scale) {
//     _classCallCheck$5(this, ScaleHelper);
//     this.scale = scale;
//   }
//   _createClass$5(ScaleHelper, [{
//     key: "domain",
//     get: function get() {
//       return this.scale.domain;
//     }
//   }, {
//     key: "range",
//     get: function get() {
//       return this.scale.range;
//     }
//   }, {
//     key: "rangeMin",
//     get: function get() {
//       return this.range()[0];
//     }
//   }, {
//     key: "rangeMax",
//     get: function get() {
//       return this.range()[1];
//     }
//   }, {
//     key: "bandwidth",
//     get: function get() {
//       return this.scale.bandwidth;
//     }
//   }, {
//     key: "apply",
//     value: function apply(value) {
//       var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
//         bandAware = _ref4.bandAware,
//         position = _ref4.position;
//       if (value === undefined) {
//         return undefined;
//       }
//       if (position) {
//         switch (position) {
//           case 'start':
//             {
//               return this.scale(value);
//             }
//           case 'middle':
//             {
//               var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
//               return this.scale(value) + offset;
//             }
//           case 'end':
//             {
//               var _offset = this.bandwidth ? this.bandwidth() : 0;
//               return this.scale(value) + _offset;
//             }
//           default:
//             {
//               return this.scale(value);
//             }
//         }
//       }
//       if (bandAware) {
//         var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
//         return this.scale(value) + _offset2;
//       }
//       return this.scale(value);
//     }
//   }, {
//     key: "isInRange",
//     value: function isInRange(value) {
//       var range = this.range();
//       var first = range[0];
//       var last = range[range.length - 1];
//       return first <= last ? value >= first && value <= last : value >= last && value <= first;
//     }
//   }], [{
//     key: "create",
//     value: function create(obj) {
//       return new ScaleHelper(obj);
//     }
//   }]);
//   return ScaleHelper;
// }();
// _defineProperty$9(ScaleHelper, "EPS", 1e-4);
// var createLabeledScales = function createLabeledScales(options) {
//   var scales = Object.keys(options).reduce(function (res, key) {
//     return _objectSpread$8(_objectSpread$8({}, res), {}, _defineProperty$9({}, key, ScaleHelper.create(options[key])));
//   }, {});
//   return _objectSpread$8(_objectSpread$8({}, scales), {}, {
//     apply: function apply(coord) {
//       var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
//         bandAware = _ref5.bandAware,
//         position = _ref5.position;
//       return mapValues(coord, function (value, label) {
//         return scales[label].apply(value, {
//           bandAware: bandAware,
//           position: position
//         });
//       });
//     },
//     isInRange: function isInRange(coord) {
//       return every(coord, function (value, label) {
//         return scales[label].isInRange(value);
//       });
//     }
//   });
// };

// /** Normalizes the angle so that 0 <= angle < 180.
//  * @param {number} angle Angle in degrees.
//  * @return {number} the normalized angle with a value of at least 0 and never greater or equal to 180. */
// function normalizeAngle(angle) {
//   return (angle % 180 + 180) % 180;
// }

// /** Calculates the width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.
//  * @param {Object} size Width and height of the text in a horizontal position.
//  * @param {number} angle Angle in degrees in which the text is displayed.
//  * @return {number} The width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.
//  */
// var getAngledRectangleWidth = function getAngledRectangleWidth(_ref6) {
//   var width = _ref6.width,
//     height = _ref6.height;
//   var angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
//   // Ensure angle is >= 0 && < 180
//   var normalizedAngle = normalizeAngle(angle);
//   var angleRadians = normalizedAngle * Math.PI / 180;

//   /* Depending on the height and width of the rectangle, we may need to use different formulas to calculate the angled
//    * width. This threshold defines when each formula should kick in. */
//   var angleThreshold = Math.atan(height / width);
//   var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
//   return Math.abs(angledWidth);
// };

// function _typeof$9(o) { "@babel/helpers - typeof"; return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$9(o); }
// function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty$8(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$8(obj, key, value) { key = _toPropertyKey$8(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$8(arg) { var key = _toPrimitive$8(arg, "string"); return _typeof$9(key) === "symbol" ? key : String(key); }
// function _toPrimitive$8(input, hint) { if (_typeof$9(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$9(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$1(); }
// function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }
// function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _iterableToArrayLimit$1(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }
// function _extends$6() { _extends$6 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }
// var renderLine = function renderLine(option, props) {
//   var line;
//   if ( /*#__PURE__*/React__default.isValidElement(option)) {
//     line = /*#__PURE__*/React__default.cloneElement(option, props);
//   } else if (isFunction(option)) {
//     line = option(props);
//   } else {
//     line = /*#__PURE__*/React__default.createElement("line", _extends$6({}, props, {
//       className: "recharts-reference-line-line"
//     }));
//   }
//   return line;
// };

// // TODO: ScaleHelper
// var getEndPoints = function getEndPoints(scales, isFixedX, isFixedY, isSegment, props) {
//   var _props$viewBox = props.viewBox,
//     x = _props$viewBox.x,
//     y = _props$viewBox.y,
//     width = _props$viewBox.width,
//     height = _props$viewBox.height,
//     position = props.position;
//   if (isFixedY) {
//     var yCoord = props.y,
//       orientation = props.yAxis.orientation;
//     var coord = scales.y.apply(yCoord, {
//       position: position
//     });
//     if (ifOverflowMatches(props, 'discard') && !scales.y.isInRange(coord)) {
//       return null;
//     }
//     var points = [{
//       x: x + width,
//       y: coord
//     }, {
//       x: x,
//       y: coord
//     }];
//     return orientation === 'left' ? points.reverse() : points;
//   }
//   if (isFixedX) {
//     var xCoord = props.x,
//       _orientation = props.xAxis.orientation;
//     var _coord = scales.x.apply(xCoord, {
//       position: position
//     });
//     if (ifOverflowMatches(props, 'discard') && !scales.x.isInRange(_coord)) {
//       return null;
//     }
//     var _points = [{
//       x: _coord,
//       y: y + height
//     }, {
//       x: _coord,
//       y: y
//     }];
//     return _orientation === 'top' ? _points.reverse() : _points;
//   }
//   if (isSegment) {
//     var segment = props.segment;
//     var _points2 = segment.map(function (p) {
//       return scales.apply(p, {
//         position: position
//       });
//     });
//     if (ifOverflowMatches(props, 'discard') && some(_points2, function (p) {
//       return !scales.isInRange(p);
//     })) {
//       return null;
//     }
//     return _points2;
//   }
//   return null;
// };
// function ReferenceLine(props) {
//   var fixedX = props.x,
//     fixedY = props.y,
//     segment = props.segment,
//     xAxis = props.xAxis,
//     yAxis = props.yAxis,
//     shape = props.shape,
//     className = props.className,
//     alwaysShow = props.alwaysShow,
//     clipPathId = props.clipPathId;
//   warn$1(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
//   var scales = createLabeledScales({
//     x: xAxis.scale,
//     y: yAxis.scale
//   });
//   var isX = isNumOrStr(fixedX);
//   var isY = isNumOrStr(fixedY);
//   var isSegment = segment && segment.length === 2;
//   var endPoints = getEndPoints(scales, isX, isY, isSegment, props);
//   if (!endPoints) {
//     return null;
//   }
//   var _endPoints = _slicedToArray$1(endPoints, 2),
//     _endPoints$ = _endPoints[0],
//     x1 = _endPoints$.x,
//     y1 = _endPoints$.y,
//     _endPoints$2 = _endPoints[1],
//     x2 = _endPoints$2.x,
//     y2 = _endPoints$2.y;
//   var clipPath = ifOverflowMatches(props, 'hidden') ? "url(#".concat(clipPathId, ")") : undefined;
//   var lineProps = _objectSpread$7(_objectSpread$7({
//     clipPath: clipPath
//   }, filterProps(props, true)), {}, {
//     x1: x1,
//     y1: y1,
//     x2: x2,
//     y2: y2
//   });
//   return /*#__PURE__*/React__default.createElement(Layer, {
//     className: clsx('recharts-reference-line', className)
//   }, renderLine(shape, lineProps), Label$7.renderCallByParent(props, rectWithCoords({
//     x1: x1,
//     y1: y1,
//     x2: x2,
//     y2: y2
//   })));
// }
// ReferenceLine.displayName = 'ReferenceLine';
// ReferenceLine.defaultProps = {
//   isFront: false,
//   ifOverflow: 'discard',
//   xAxisId: 0,
//   yAxisId: 0,
//   fill: 'none',
//   stroke: '#ccc',
//   fillOpacity: 1,
//   strokeWidth: 1,
//   position: 'middle'
// };

// function _typeof$8(o) { "@babel/helpers - typeof"; return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$8(o); }
// function _extends$5() { _extends$5 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }
// function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty$7(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$7(obj, key, value) { key = _toPropertyKey$7(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$7(arg) { var key = _toPrimitive$7(arg, "string"); return _typeof$8(key) === "symbol" ? key : String(key); }
// function _toPrimitive$7(input, hint) { if (_typeof$8(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$8(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var getCoordinate = function getCoordinate(props) {
//   var x = props.x,
//     y = props.y,
//     xAxis = props.xAxis,
//     yAxis = props.yAxis;
//   var scales = createLabeledScales({
//     x: xAxis.scale,
//     y: yAxis.scale
//   });
//   var result = scales.apply({
//     x: x,
//     y: y
//   }, {
//     bandAware: true
//   });
//   if (ifOverflowMatches(props, 'discard') && !scales.isInRange(result)) {
//     return null;
//   }
//   return result;
// };
// function ReferenceDot(props) {
//   var x = props.x,
//     y = props.y,
//     r = props.r,
//     alwaysShow = props.alwaysShow,
//     clipPathId = props.clipPathId;
//   var isX = isNumOrStr(x);
//   var isY = isNumOrStr(y);
//   warn$1(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
//   if (!isX || !isY) {
//     return null;
//   }
//   var coordinate = getCoordinate(props);
//   if (!coordinate) {
//     return null;
//   }
//   var cx = coordinate.x,
//     cy = coordinate.y;
//   var shape = props.shape,
//     className = props.className;
//   var clipPath = ifOverflowMatches(props, 'hidden') ? "url(#".concat(clipPathId, ")") : undefined;
//   var dotProps = _objectSpread$6(_objectSpread$6({
//     clipPath: clipPath
//   }, filterProps(props, true)), {}, {
//     cx: cx,
//     cy: cy
//   });
//   return /*#__PURE__*/React__default.createElement(Layer, {
//     className: clsx('recharts-reference-dot', className)
//   }, ReferenceDot.renderDot(shape, dotProps), Label$7.renderCallByParent(props, {
//     x: cx - r,
//     y: cy - r,
//     width: 2 * r,
//     height: 2 * r
//   }));
// }
// ReferenceDot.displayName = 'ReferenceDot';
// ReferenceDot.defaultProps = {
//   isFront: false,
//   ifOverflow: 'discard',
//   xAxisId: 0,
//   yAxisId: 0,
//   r: 10,
//   fill: '#fff',
//   stroke: '#ccc',
//   fillOpacity: 1,
//   strokeWidth: 1
// };
// ReferenceDot.renderDot = function (option, props) {
//   var dot;
//   if ( /*#__PURE__*/React__default.isValidElement(option)) {
//     dot = /*#__PURE__*/React__default.cloneElement(option, props);
//   } else if (isFunction(option)) {
//     dot = option(props);
//   } else {
//     dot = /*#__PURE__*/React__default.createElement(Dot, _extends$5({}, props, {
//       cx: props.cx,
//       cy: props.cy,
//       className: "recharts-reference-dot-dot"
//     }));
//   }
//   return dot;
// };

// function _typeof$7(o) { "@babel/helpers - typeof"; return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$7(o); }
// function _extends$4() { _extends$4 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
// function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty$6(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$6(obj, key, value) { key = _toPropertyKey$6(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$6(arg) { var key = _toPrimitive$6(arg, "string"); return _typeof$7(key) === "symbol" ? key : String(key); }
// function _toPrimitive$6(input, hint) { if (_typeof$7(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$7(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var getRect = function getRect(hasX1, hasX2, hasY1, hasY2, props) {
//   var xValue1 = props.x1,
//     xValue2 = props.x2,
//     yValue1 = props.y1,
//     yValue2 = props.y2,
//     xAxis = props.xAxis,
//     yAxis = props.yAxis;
//   if (!xAxis || !yAxis) return null;
//   var scales = createLabeledScales({
//     x: xAxis.scale,
//     y: yAxis.scale
//   });
//   var p1 = {
//     x: hasX1 ? scales.x.apply(xValue1, {
//       position: 'start'
//     }) : scales.x.rangeMin,
//     y: hasY1 ? scales.y.apply(yValue1, {
//       position: 'start'
//     }) : scales.y.rangeMin
//   };
//   var p2 = {
//     x: hasX2 ? scales.x.apply(xValue2, {
//       position: 'end'
//     }) : scales.x.rangeMax,
//     y: hasY2 ? scales.y.apply(yValue2, {
//       position: 'end'
//     }) : scales.y.rangeMax
//   };
//   if (ifOverflowMatches(props, 'discard') && (!scales.isInRange(p1) || !scales.isInRange(p2))) {
//     return null;
//   }
//   return rectWithPoints(p1, p2);
// };
// function ReferenceArea(props) {
//   var x1 = props.x1,
//     x2 = props.x2,
//     y1 = props.y1,
//     y2 = props.y2,
//     className = props.className,
//     alwaysShow = props.alwaysShow,
//     clipPathId = props.clipPathId;
//   warn$1(alwaysShow === undefined, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
//   var hasX1 = isNumOrStr(x1);
//   var hasX2 = isNumOrStr(x2);
//   var hasY1 = isNumOrStr(y1);
//   var hasY2 = isNumOrStr(y2);
//   var shape = props.shape;
//   if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {
//     return null;
//   }
//   var rect = getRect(hasX1, hasX2, hasY1, hasY2, props);
//   if (!rect && !shape) {
//     return null;
//   }
//   var clipPath = ifOverflowMatches(props, 'hidden') ? "url(#".concat(clipPathId, ")") : undefined;
//   return /*#__PURE__*/React__default.createElement(Layer, {
//     className: clsx('recharts-reference-area', className)
//   }, ReferenceArea.renderRect(shape, _objectSpread$5(_objectSpread$5({
//     clipPath: clipPath
//   }, filterProps(props, true)), rect)), Label$7.renderCallByParent(props, rect));
// }
// ReferenceArea.displayName = 'ReferenceArea';
// ReferenceArea.defaultProps = {
//   isFront: false,
//   ifOverflow: 'discard',
//   xAxisId: 0,
//   yAxisId: 0,
//   r: 10,
//   fill: '#ccc',
//   fillOpacity: 0.5,
//   stroke: 'none',
//   strokeWidth: 1
// };
// ReferenceArea.renderRect = function (option, props) {
//   var rect;
//   if ( /*#__PURE__*/React__default.isValidElement(option)) {
//     rect = /*#__PURE__*/React__default.cloneElement(option, props);
//   } else if (isFunction(option)) {
//     rect = option(props);
//   } else {
//     rect = /*#__PURE__*/React__default.createElement(Rectangle, _extends$4({}, props, {
//       className: "recharts-reference-area-rect"
//     }));
//   }
//   return rect;
// };

// /**
//  * Given an array and a number N, return a new array which contains every nTh
//  * element of the input array. For n below 1, an empty array is returned.
//  * If isValid is provided, all candidates must suffice the condition, else undefined is returned.
//  * @param {T[]} array An input array.
//  * @param {integer} n A number
//  * @param {Function} isValid A function to evaluate a candidate form the array
//  * @returns {T[]} The result array of the same type as the input array.
//  */
// function getEveryNthWithCondition(array, n, isValid) {
//   if (n < 1) {
//     return [];
//   }
//   if (n === 1 && isValid === undefined) {
//     return array;
//   }
//   var result = [];
//   for (var i = 0; i < array.length; i += n) {
//     if (isValid === undefined || isValid(array[i]) === true) {
//       result.push(array[i]);
//     } else {
//       return undefined;
//     }
//   }
//   return result;
// }

// function getAngledTickWidth(contentSize, unitSize, angle) {
//   var size = {
//     width: contentSize.width + unitSize.width,
//     height: contentSize.height + unitSize.height
//   };
//   return getAngledRectangleWidth(size, angle);
// }
// function getTickBoundaries(viewBox, sign, sizeKey) {
//   var isWidth = sizeKey === 'width';
//   var x = viewBox.x,
//     y = viewBox.y,
//     width = viewBox.width,
//     height = viewBox.height;
//   if (sign === 1) {
//     return {
//       start: isWidth ? x : y,
//       end: isWidth ? x + width : y + height
//     };
//   }
//   return {
//     start: isWidth ? x + width : y + height,
//     end: isWidth ? x : y
//   };
// }
// function isVisible(sign, tickPosition, getSize, start, end) {
//   /* Since getSize() is expensive (it reads the ticks' size from the DOM), we do this check first to avoid calculating
//    * the tick's size. */
//   if (sign * tickPosition < sign * start || sign * tickPosition > sign * end) {
//     return false;
//   }
//   var size = getSize();
//   return sign * (tickPosition - sign * size / 2 - start) >= 0 && sign * (tickPosition + sign * size / 2 - end) <= 0;
// }
// function getNumberIntervalTicks(ticks, interval) {
//   return getEveryNthWithCondition(ticks, interval + 1);
// }

// function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {
//   var result = (ticks || []).slice();
//   var initialStart = boundaries.start,
//     end = boundaries.end;
//   var index = 0;
//   // Premature optimisation idea 1: Estimate a lower bound, and start from there.
//   // For now, start from every tick
//   var stepsize = 1;
//   var start = initialStart;
//   var _loop = function _loop() {
//       // Given stepsize, evaluate whether every stepsize-th tick can be shown.
//       // If it can not, then increase the stepsize by 1, and try again.

//       var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];

//       // Break condition - If we have evaluate all the ticks, then we are done.
//       if (entry === undefined) {
//         return {
//           v: getEveryNthWithCondition(ticks, stepsize)
//         };
//       }

//       // Check if the element collides with the next element
//       var i = index;
//       var size;
//       var getSize = function getSize() {
//         if (size === undefined) {
//           size = getTickSize(entry, i);
//         }
//         return size;
//       };
//       var tickCoord = entry.coordinate;
//       // We will always show the first tick.
//       var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);
//       if (!isShow) {
//         // Start all over with a larger stepsize
//         index = 0;
//         start = initialStart;
//         stepsize += 1;
//       }
//       if (isShow) {
//         // If it can be shown, update the start
//         start = tickCoord + sign * (getSize() / 2 + minTickGap);
//         index += stepsize;
//       }
//     },
//     _ret;
//   while (stepsize <= result.length) {
//     _ret = _loop();
//     if (_ret) return _ret.v;
//   }
//   return [];
// }

// function _typeof$6(o) { "@babel/helpers - typeof"; return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$6(o); }
// function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty$5(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty$5(obj, key, value) { key = _toPropertyKey$5(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$5(arg) { var key = _toPrimitive$5(arg, "string"); return _typeof$6(key) === "symbol" ? key : String(key); }
// function _toPrimitive$5(input, hint) { if (_typeof$6(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$6(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// function getTicksEnd(sign, boundaries, getTickSize, ticks, minTickGap) {
//   var result = (ticks || []).slice();
//   var len = result.length;
//   var start = boundaries.start;
//   var end = boundaries.end;
//   var _loop = function _loop(i) {
//     var entry = result[i];
//     var size;
//     var getSize = function getSize() {
//       if (size === undefined) {
//         size = getTickSize(entry, i);
//       }
//       return size;
//     };
//     if (i === len - 1) {
//       var gap = sign * (entry.coordinate + sign * getSize() / 2 - end);
//       result[i] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
//         tickCoord: gap > 0 ? entry.coordinate - gap * sign : entry.coordinate
//       });
//     } else {
//       result[i] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
//         tickCoord: entry.coordinate
//       });
//     }
//     var isShow = isVisible(sign, entry.tickCoord, getSize, start, end);
//     if (isShow) {
//       end = entry.tickCoord - sign * (getSize() / 2 + minTickGap);
//       result[i] = _objectSpread$4(_objectSpread$4({}, entry), {}, {
//         isShow: true
//       });
//     }
//   };
//   for (var i = len - 1; i >= 0; i--) {
//     _loop(i);
//   }
//   return result;
// }
// function getTicksStart(sign, boundaries, getTickSize, ticks, minTickGap, preserveEnd) {
//   var result = (ticks || []).slice();
//   var len = result.length;
//   var start = boundaries.start,
//     end = boundaries.end;
//   if (preserveEnd) {
//     // Try to guarantee the tail to be displayed
//     var tail = ticks[len - 1];
//     var tailSize = getTickSize(tail, len - 1);
//     var tailGap = sign * (tail.coordinate + sign * tailSize / 2 - end);
//     result[len - 1] = tail = _objectSpread$4(_objectSpread$4({}, tail), {}, {
//       tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate
//     });
//     var isTailShow = isVisible(sign, tail.tickCoord, function () {
//       return tailSize;
//     }, start, end);
//     if (isTailShow) {
//       end = tail.tickCoord - sign * (tailSize / 2 + minTickGap);
//       result[len - 1] = _objectSpread$4(_objectSpread$4({}, tail), {}, {
//         isShow: true
//       });
//     }
//   }
//   var count = preserveEnd ? len - 1 : len;
//   var _loop2 = function _loop2(i) {
//     var entry = result[i];
//     var size;
//     var getSize = function getSize() {
//       if (size === undefined) {
//         size = getTickSize(entry, i);
//       }
//       return size;
//     };
//     if (i === 0) {
//       var gap = sign * (entry.coordinate - sign * getSize() / 2 - start);
//       result[i] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
//         tickCoord: gap < 0 ? entry.coordinate - gap * sign : entry.coordinate
//       });
//     } else {
//       result[i] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, {
//         tickCoord: entry.coordinate
//       });
//     }
//     var isShow = isVisible(sign, entry.tickCoord, getSize, start, end);
//     if (isShow) {
//       start = entry.tickCoord + sign * (getSize() / 2 + minTickGap);
//       result[i] = _objectSpread$4(_objectSpread$4({}, entry), {}, {
//         isShow: true
//       });
//     }
//   };
//   for (var i = 0; i < count; i++) {
//     _loop2(i);
//   }
//   return result;
// }
// function getTicks(props, fontSize, letterSpacing) {
//   var tick = props.tick,
//     ticks = props.ticks,
//     viewBox = props.viewBox,
//     minTickGap = props.minTickGap,
//     orientation = props.orientation,
//     interval = props.interval,
//     tickFormatter = props.tickFormatter,
//     unit = props.unit,
//     angle = props.angle;
//   if (!ticks || !ticks.length || !tick) {
//     return [];
//   }
//   if (isNumber(interval) || Global.isSsr) {
//     return getNumberIntervalTicks(ticks, typeof interval === 'number' && isNumber(interval) ? interval : 0);
//   }
//   var candidates = [];
//   var sizeKey = orientation === 'top' || orientation === 'bottom' ? 'width' : 'height';
//   var unitSize = unit && sizeKey === 'width' ? getStringSize(unit, {
//     fontSize: fontSize,
//     letterSpacing: letterSpacing
//   }) : {
//     width: 0,
//     height: 0
//   };
//   var getTickSize = function getTickSize(content, index) {
//     var value = isFunction(tickFormatter) ? tickFormatter(content.value, index) : content.value;
//     // Recharts only supports angles when sizeKey === 'width'
//     return sizeKey === 'width' ? getAngledTickWidth(getStringSize(value, {
//       fontSize: fontSize,
//       letterSpacing: letterSpacing
//     }), unitSize, angle) : getStringSize(value, {
//       fontSize: fontSize,
//       letterSpacing: letterSpacing
//     })[sizeKey];
//   };
//   var sign = ticks.length >= 2 ? mathSign(ticks[1].coordinate - ticks[0].coordinate) : 1;
//   var boundaries = getTickBoundaries(viewBox, sign, sizeKey);
//   if (interval === 'equidistantPreserveStart') {
//     return getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap);
//   }
//   if (interval === 'preserveStart' || interval === 'preserveStartEnd') {
//     candidates = getTicksStart(sign, boundaries, getTickSize, ticks, minTickGap, interval === 'preserveStartEnd');
//   } else {
//     candidates = getTicksEnd(sign, boundaries, getTickSize, ticks, minTickGap);
//   }
//   return candidates.filter(function (entry) {
//     return entry.isShow;
//   });
// }

// var _excluded$4 = ["viewBox"],
//   _excluded2$2 = ["viewBox"],
//   _excluded3 = ["ticks"];
// function _typeof$5(o) { "@babel/helpers - typeof"; return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$5(o); }
// function _extends$3() { _extends$3 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
// function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty$4(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _objectWithoutProperties$3(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$3(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$3(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor); } }
// function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$4(subClass, superClass); }
// function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }
// function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf$3(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$3(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$3(this, result); }; }
// function _possibleConstructorReturn$3(self, call) { if (call && (_typeof$5(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$3(self); }
// function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$3(o) { _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$3(o); }
// function _defineProperty$4(obj, key, value) { key = _toPropertyKey$4(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$4(arg) { var key = _toPrimitive$4(arg, "string"); return _typeof$5(key) === "symbol" ? key : String(key); }
// function _toPrimitive$4(input, hint) { if (_typeof$5(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$5(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

// /** The orientation of the axis in correspondence to the chart */

// /** A unit to be appended to a value */

// /** The formatter function of tick */

// var CartesianAxis = /*#__PURE__*/function (_Component) {
//   _inherits$3(CartesianAxis, _Component);
//   var _super = _createSuper$3(CartesianAxis);
//   function CartesianAxis(props) {
//     var _this;
//     _classCallCheck$4(this, CartesianAxis);
//     _this = _super.call(this, props);
//     _this.state = {
//       fontSize: '',
//       letterSpacing: ''
//     };
//     return _this;
//   }
//   _createClass$4(CartesianAxis, [{
//     key: "shouldComponentUpdate",
//     value: function shouldComponentUpdate(_ref, nextState) {
//       var viewBox = _ref.viewBox,
//         restProps = _objectWithoutProperties$3(_ref, _excluded$4);
//       // props.viewBox is sometimes generated every time -
//       // check that specially as object equality is likely to fail
//       var _this$props = this.props,
//         viewBoxOld = _this$props.viewBox,
//         restPropsOld = _objectWithoutProperties$3(_this$props, _excluded2$2);
//       return !shallowEqual(viewBox, viewBoxOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(nextState, this.state);
//     }
//   }, {
//     key: "componentDidMount",
//     value: function componentDidMount() {
//       var htmlLayer = this.layerReference;
//       if (!htmlLayer) return;
//       var tick = htmlLayer.getElementsByClassName('recharts-cartesian-axis-tick-value')[0];
//       if (tick) {
//         this.setState({
//           fontSize: window.getComputedStyle(tick).fontSize,
//           letterSpacing: window.getComputedStyle(tick).letterSpacing
//         });
//       }
//     }

//     /**
//      * Calculate the coordinates of endpoints in ticks
//      * @param  {Object} data The data of a simple tick
//      * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
//      *  (x2, y2): The coordinate of endpoint close to axis
//      */
//   }, {
//     key: "getTickLineCoord",
//     value: function getTickLineCoord(data) {
//       var _this$props2 = this.props,
//         x = _this$props2.x,
//         y = _this$props2.y,
//         width = _this$props2.width,
//         height = _this$props2.height,
//         orientation = _this$props2.orientation,
//         tickSize = _this$props2.tickSize,
//         mirror = _this$props2.mirror,
//         tickMargin = _this$props2.tickMargin;
//       var x1, x2, y1, y2, tx, ty;
//       var sign = mirror ? -1 : 1;
//       var finalTickSize = data.tickSize || tickSize;
//       var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
//       switch (orientation) {
//         case 'top':
//           x1 = x2 = data.coordinate;
//           y2 = y + +!mirror * height;
//           y1 = y2 - sign * finalTickSize;
//           ty = y1 - sign * tickMargin;
//           tx = tickCoord;
//           break;
//         case 'left':
//           y1 = y2 = data.coordinate;
//           x2 = x + +!mirror * width;
//           x1 = x2 - sign * finalTickSize;
//           tx = x1 - sign * tickMargin;
//           ty = tickCoord;
//           break;
//         case 'right':
//           y1 = y2 = data.coordinate;
//           x2 = x + +mirror * width;
//           x1 = x2 + sign * finalTickSize;
//           tx = x1 + sign * tickMargin;
//           ty = tickCoord;
//           break;
//         default:
//           x1 = x2 = data.coordinate;
//           y2 = y + +mirror * height;
//           y1 = y2 + sign * finalTickSize;
//           ty = y1 + sign * tickMargin;
//           tx = tickCoord;
//           break;
//       }
//       return {
//         line: {
//           x1: x1,
//           y1: y1,
//           x2: x2,
//           y2: y2
//         },
//         tick: {
//           x: tx,
//           y: ty
//         }
//       };
//     }
//   }, {
//     key: "getTickTextAnchor",
//     value: function getTickTextAnchor() {
//       var _this$props3 = this.props,
//         orientation = _this$props3.orientation,
//         mirror = _this$props3.mirror;
//       var textAnchor;
//       switch (orientation) {
//         case 'left':
//           textAnchor = mirror ? 'start' : 'end';
//           break;
//         case 'right':
//           textAnchor = mirror ? 'end' : 'start';
//           break;
//         default:
//           textAnchor = 'middle';
//           break;
//       }
//       return textAnchor;
//     }
//   }, {
//     key: "getTickVerticalAnchor",
//     value: function getTickVerticalAnchor() {
//       var _this$props4 = this.props,
//         orientation = _this$props4.orientation,
//         mirror = _this$props4.mirror;
//       var verticalAnchor = 'end';
//       switch (orientation) {
//         case 'left':
//         case 'right':
//           verticalAnchor = 'middle';
//           break;
//         case 'top':
//           verticalAnchor = mirror ? 'start' : 'end';
//           break;
//         default:
//           verticalAnchor = mirror ? 'end' : 'start';
//           break;
//       }
//       return verticalAnchor;
//     }
//   }, {
//     key: "renderAxisLine",
//     value: function renderAxisLine() {
//       var _this$props5 = this.props,
//         x = _this$props5.x,
//         y = _this$props5.y,
//         width = _this$props5.width,
//         height = _this$props5.height,
//         orientation = _this$props5.orientation,
//         mirror = _this$props5.mirror,
//         axisLine = _this$props5.axisLine;
//       var props = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, filterProps(this.props)), filterProps(axisLine)), {}, {
//         fill: 'none'
//       });
//       if (orientation === 'top' || orientation === 'bottom') {
//         var needHeight = +(orientation === 'top' && !mirror || orientation === 'bottom' && mirror);
//         props = _objectSpread$3(_objectSpread$3({}, props), {}, {
//           x1: x,
//           y1: y + needHeight * height,
//           x2: x + width,
//           y2: y + needHeight * height
//         });
//       } else {
//         var needWidth = +(orientation === 'left' && !mirror || orientation === 'right' && mirror);
//         props = _objectSpread$3(_objectSpread$3({}, props), {}, {
//           x1: x + needWidth * width,
//           y1: y,
//           x2: x + needWidth * width,
//           y2: y + height
//         });
//       }
//       return /*#__PURE__*/React__default.createElement("line", _extends$3({}, props, {
//         className: clsx('recharts-cartesian-axis-line', get(axisLine, 'className'))
//       }));
//     }
//   }, {
//     key: "renderTicks",
//     value:
//     /**
//      * render the ticks
//      * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
//      * @param {string} fontSize Fontsize to consider for tick spacing
//      * @param {string} letterSpacing Letterspacing to consider for tick spacing
//      * @return {ReactComponent} renderedTicks
//      */
//     function renderTicks(ticks, fontSize, letterSpacing) {
//       var _this2 = this;
//       var _this$props6 = this.props,
//         tickLine = _this$props6.tickLine,
//         stroke = _this$props6.stroke,
//         tick = _this$props6.tick,
//         tickFormatter = _this$props6.tickFormatter,
//         unit = _this$props6.unit;
//       var finalTicks = getTicks(_objectSpread$3(_objectSpread$3({}, this.props), {}, {
//         ticks: ticks
//       }), fontSize, letterSpacing);
//       var textAnchor = this.getTickTextAnchor();
//       var verticalAnchor = this.getTickVerticalAnchor();
//       var axisProps = filterProps(this.props);
//       var customTickProps = filterProps(tick);
//       var tickLineProps = _objectSpread$3(_objectSpread$3({}, axisProps), {}, {
//         fill: 'none'
//       }, filterProps(tickLine));
//       var items = finalTicks.map(function (entry, i) {
//         var _this2$getTickLineCoo = _this2.getTickLineCoord(entry),
//           lineCoord = _this2$getTickLineCoo.line,
//           tickCoord = _this2$getTickLineCoo.tick;
//         var tickProps = _objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({
//           textAnchor: textAnchor,
//           verticalAnchor: verticalAnchor
//         }, axisProps), {}, {
//           stroke: 'none',
//           fill: stroke
//         }, customTickProps), tickCoord), {}, {
//           index: i,
//           payload: entry,
//           visibleTicksCount: finalTicks.length,
//           tickFormatter: tickFormatter
//         });
//         return /*#__PURE__*/React__default.createElement(Layer, _extends$3({
//           className: "recharts-cartesian-axis-tick",
//           key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
//         }, adaptEventsOfChild(_this2.props, entry, i)), tickLine && /*#__PURE__*/React__default.createElement("line", _extends$3({}, tickLineProps, lineCoord, {
//           className: clsx('recharts-cartesian-axis-tick-line', get(tickLine, 'className'))
//         })), tick && CartesianAxis.renderTickItem(tick, tickProps, "".concat(isFunction(tickFormatter) ? tickFormatter(entry.value, i) : entry.value).concat(unit || '')));
//       });
//       return /*#__PURE__*/React__default.createElement("g", {
//         className: "recharts-cartesian-axis-ticks"
//       }, items);
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this3 = this;
//       var _this$props7 = this.props,
//         axisLine = _this$props7.axisLine,
//         width = _this$props7.width,
//         height = _this$props7.height,
//         ticksGenerator = _this$props7.ticksGenerator,
//         className = _this$props7.className,
//         hide = _this$props7.hide;
//       if (hide) {
//         return null;
//       }
//       var _this$props8 = this.props,
//         ticks = _this$props8.ticks,
//         noTicksProps = _objectWithoutProperties$3(_this$props8, _excluded3);
//       var finalTicks = ticks;
//       if (isFunction(ticksGenerator)) {
//         finalTicks = ticks && ticks.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);
//       }
//       if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) {
//         return null;
//       }
//       return /*#__PURE__*/React__default.createElement(Layer, {
//         className: clsx('recharts-cartesian-axis', className),
//         ref: function ref(_ref2) {
//           _this3.layerReference = _ref2;
//         }
//       }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), Label$7.renderCallByParent(this.props));
//     }
//   }], [{
//     key: "renderTickItem",
//     value: function renderTickItem(option, props, value) {
//       var tickItem;
//       if ( /*#__PURE__*/React__default.isValidElement(option)) {
//         tickItem = /*#__PURE__*/React__default.cloneElement(option, props);
//       } else if (isFunction(option)) {
//         tickItem = option(props);
//       } else {
//         tickItem = /*#__PURE__*/React__default.createElement(Text, _extends$3({}, props, {
//           className: "recharts-cartesian-axis-tick-value"
//         }), value);
//       }
//       return tickItem;
//     }
//   }]);
//   return CartesianAxis;
// }(Component);
// _defineProperty$4(CartesianAxis, "displayName", 'CartesianAxis');
// _defineProperty$4(CartesianAxis, "defaultProps", {
//   x: 0,
//   y: 0,
//   width: 0,
//   height: 0,
//   viewBox: {
//     x: 0,
//     y: 0,
//     width: 0,
//     height: 0
//   },
//   // The orientation of axis
//   orientation: 'bottom',
//   // The ticks
//   ticks: [],
//   stroke: '#666',
//   tickLine: true,
//   axisLine: true,
//   tick: true,
//   mirror: false,
//   minTickGap: 5,
//   // The width or height of tick
//   tickSize: 6,
//   tickMargin: 2,
//   interval: 'preserveEnd'
// });

// var _excluded$3 = ["x1", "y1", "x2", "y2", "key"],
//   _excluded2$1 = ["offset"];
// function _typeof$4(o) { "@babel/helpers - typeof"; return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$4(o); }
// function _extends$2() { _extends$2 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
// function _objectWithoutProperties$2(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$2(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$2(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty$3(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor); } }
// function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$3(subClass, superClass); }
// function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }
// function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf$2(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$2(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$2(this, result); }; }
// function _possibleConstructorReturn$2(self, call) { if (call && (_typeof$4(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$2(self); }
// function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$2(o) { _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$2(o); }
// function _defineProperty$3(obj, key, value) { key = _toPropertyKey$3(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$3(arg) { var key = _toPrimitive$3(arg, "string"); return _typeof$4(key) === "symbol" ? key : String(key); }
// function _toPrimitive$3(input, hint) { if (_typeof$4(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$4(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var CartesianGrid = /*#__PURE__*/function (_PureComponent) {
//   _inherits$2(CartesianGrid, _PureComponent);
//   var _super = _createSuper$2(CartesianGrid);
//   function CartesianGrid() {
//     _classCallCheck$3(this, CartesianGrid);
//     return _super.apply(this, arguments);
//   }
//   _createClass$3(CartesianGrid, [{
//     key: "renderHorizontal",
//     value:
//     /**
//      * Draw the horizontal grid lines
//      * @param {Array} horizontalPoints either passed in as props or generated from function
//      * @return {Group} Horizontal lines
//      */
//     function renderHorizontal(horizontalPoints) {
//       var _this = this;
//       var _this$props = this.props,
//         x = _this$props.x,
//         width = _this$props.width,
//         horizontal = _this$props.horizontal;
//       if (!horizontalPoints || !horizontalPoints.length) {
//         return null;
//       }
//       var items = horizontalPoints.map(function (entry, i) {
//         var props = _objectSpread$2(_objectSpread$2({}, _this.props), {}, {
//           x1: x,
//           y1: entry,
//           x2: x + width,
//           y2: entry,
//           key: "line-".concat(i),
//           index: i
//         });
//         return CartesianGrid.renderLineItem(horizontal, props);
//       });
//       return /*#__PURE__*/React__default.createElement("g", {
//         className: "recharts-cartesian-grid-horizontal"
//       }, items);
//     }

//     /**
//      * Draw vertical grid lines
//      * @param {Array} verticalPoints either passed in as props or generated from function
//      * @return {Group} Vertical lines
//      */
//   }, {
//     key: "renderVertical",
//     value: function renderVertical(verticalPoints) {
//       var _this2 = this;
//       var _this$props2 = this.props,
//         y = _this$props2.y,
//         height = _this$props2.height,
//         vertical = _this$props2.vertical;
//       if (!verticalPoints || !verticalPoints.length) {
//         return null;
//       }
//       var items = verticalPoints.map(function (entry, i) {
//         var props = _objectSpread$2(_objectSpread$2({}, _this2.props), {}, {
//           x1: entry,
//           y1: y,
//           x2: entry,
//           y2: y + height,
//           key: "line-".concat(i),
//           index: i
//         });
//         return CartesianGrid.renderLineItem(vertical, props);
//       });
//       return /*#__PURE__*/React__default.createElement("g", {
//         className: "recharts-cartesian-grid-vertical"
//       }, items);
//     }

//     /**
//      * Draw vertical grid stripes filled by colors
//      * @param {Array} verticalPoints either passed in as props or generated from function
//      * @return {Group} Vertical stripes
//      */
//   }, {
//     key: "renderVerticalStripes",
//     value: function renderVerticalStripes(verticalPoints) {
//       var verticalFill = this.props.verticalFill;
//       if (!verticalFill || !verticalFill.length) {
//         return null;
//       }
//       var _this$props3 = this.props,
//         fillOpacity = _this$props3.fillOpacity,
//         x = _this$props3.x,
//         y = _this$props3.y,
//         width = _this$props3.width,
//         height = _this$props3.height;
//       var roundedSortedVerticalPoints = verticalPoints.map(function (e) {
//         return Math.round(e + x - x);
//       }).sort(function (a, b) {
//         return a - b;
//       });
//       if (x !== roundedSortedVerticalPoints[0]) {
//         roundedSortedVerticalPoints.unshift(0);
//       }
//       var items = roundedSortedVerticalPoints.map(function (entry, i) {
//         var lastStripe = !roundedSortedVerticalPoints[i + 1];
//         var lineWidth = lastStripe ? x + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
//         if (lineWidth <= 0) {
//           return null;
//         }
//         var colorIndex = i % verticalFill.length;
//         return /*#__PURE__*/React__default.createElement("rect", {
//           key: "react-".concat(i) // eslint-disable-line react/no-array-index-key
//           ,
//           x: entry,
//           y: y,
//           width: lineWidth,
//           height: height,
//           stroke: "none",
//           fill: verticalFill[colorIndex],
//           fillOpacity: fillOpacity,
//           className: "recharts-cartesian-grid-bg"
//         });
//       });
//       return /*#__PURE__*/React__default.createElement("g", {
//         className: "recharts-cartesian-gridstripes-vertical"
//       }, items);
//     }

//     /**
//      * Draw horizontal grid stripes filled by colors
//      * @param {Array} horizontalPoints either passed in as props or generated from function
//      * @return {Group} Horizontal stripes
//      */
//   }, {
//     key: "renderHorizontalStripes",
//     value: function renderHorizontalStripes(horizontalPoints) {
//       var horizontalFill = this.props.horizontalFill;
//       if (!horizontalFill || !horizontalFill.length) {
//         return null;
//       }
//       var _this$props4 = this.props,
//         fillOpacity = _this$props4.fillOpacity,
//         x = _this$props4.x,
//         y = _this$props4.y,
//         width = _this$props4.width,
//         height = _this$props4.height;
//       var roundedSortedHorizontalPoints = horizontalPoints.map(function (e) {
//         return Math.round(e + y - y);
//       }).sort(function (a, b) {
//         return a - b;
//       });
//       if (y !== roundedSortedHorizontalPoints[0]) {
//         roundedSortedHorizontalPoints.unshift(0);
//       }
//       var items = roundedSortedHorizontalPoints.map(function (entry, i) {
//         var lastStripe = !roundedSortedHorizontalPoints[i + 1];
//         var lineHeight = lastStripe ? y + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
//         if (lineHeight <= 0) {
//           return null;
//         }
//         var colorIndex = i % horizontalFill.length;
//         return /*#__PURE__*/React__default.createElement("rect", {
//           key: "react-".concat(i) // eslint-disable-line react/no-array-index-key
//           ,
//           y: entry,
//           x: x,
//           height: lineHeight,
//           width: width,
//           stroke: "none",
//           fill: horizontalFill[colorIndex],
//           fillOpacity: fillOpacity,
//           className: "recharts-cartesian-grid-bg"
//         });
//       });
//       return /*#__PURE__*/React__default.createElement("g", {
//         className: "recharts-cartesian-gridstripes-horizontal"
//       }, items);
//     }
//   }, {
//     key: "renderBackground",
//     value: function renderBackground() {
//       var fill = this.props.fill;
//       if (!fill || fill === 'none') {
//         return null;
//       }
//       var _this$props5 = this.props,
//         fillOpacity = _this$props5.fillOpacity,
//         x = _this$props5.x,
//         y = _this$props5.y,
//         width = _this$props5.width,
//         height = _this$props5.height;
//       return /*#__PURE__*/React__default.createElement("rect", {
//         x: x,
//         y: y,
//         width: width,
//         height: height,
//         stroke: "none",
//         fill: fill,
//         fillOpacity: fillOpacity,
//         className: "recharts-cartesian-grid-bg"
//       });
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _this$props6 = this.props,
//         x = _this$props6.x,
//         y = _this$props6.y,
//         width = _this$props6.width,
//         height = _this$props6.height,
//         horizontal = _this$props6.horizontal,
//         vertical = _this$props6.vertical,
//         horizontalCoordinatesGenerator = _this$props6.horizontalCoordinatesGenerator,
//         verticalCoordinatesGenerator = _this$props6.verticalCoordinatesGenerator,
//         xAxis = _this$props6.xAxis,
//         yAxis = _this$props6.yAxis,
//         offset = _this$props6.offset,
//         chartWidth = _this$props6.chartWidth,
//         chartHeight = _this$props6.chartHeight,
//         syncWithTicks = _this$props6.syncWithTicks,
//         horizontalValues = _this$props6.horizontalValues,
//         verticalValues = _this$props6.verticalValues;
//       if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x) || x !== +x || !isNumber(y) || y !== +y) {
//         return null;
//       }
//       var _this$props7 = this.props,
//         horizontalPoints = _this$props7.horizontalPoints,
//         verticalPoints = _this$props7.verticalPoints;

//       // No horizontal points are specified
//       if ((!horizontalPoints || !horizontalPoints.length) && isFunction(horizontalCoordinatesGenerator)) {
//         var isHorizontalValues = horizontalValues && horizontalValues.length;
//         horizontalPoints = horizontalCoordinatesGenerator({
//           yAxis: yAxis ? _objectSpread$2(_objectSpread$2({}, yAxis), {}, {
//             ticks: isHorizontalValues ? horizontalValues : yAxis.ticks
//           }) : undefined,
//           width: chartWidth,
//           height: chartHeight,
//           offset: offset
//         }, isHorizontalValues ? true : syncWithTicks);
//       }

//       // No vertical points are specified
//       if ((!verticalPoints || !verticalPoints.length) && isFunction(verticalCoordinatesGenerator)) {
//         var isVerticalValues = verticalValues && verticalValues.length;
//         verticalPoints = verticalCoordinatesGenerator({
//           xAxis: xAxis ? _objectSpread$2(_objectSpread$2({}, xAxis), {}, {
//             ticks: isVerticalValues ? verticalValues : xAxis.ticks
//           }) : undefined,
//           width: chartWidth,
//           height: chartHeight,
//           offset: offset
//         }, isVerticalValues ? true : syncWithTicks);
//       }
//       return /*#__PURE__*/React__default.createElement("g", {
//         className: "recharts-cartesian-grid"
//       }, this.renderBackground(), horizontal && this.renderHorizontal(horizontalPoints), vertical && this.renderVertical(verticalPoints), horizontal && this.renderHorizontalStripes(horizontalPoints), vertical && this.renderVerticalStripes(verticalPoints));
//     }
//   }], [{
//     key: "renderLineItem",
//     value: function renderLineItem(option, props) {
//       var lineItem;
//       if ( /*#__PURE__*/React__default.isValidElement(option)) {
//         lineItem = /*#__PURE__*/React__default.cloneElement(option, props);
//       } else if (isFunction(option)) {
//         lineItem = option(props);
//       } else {
//         var x1 = props.x1,
//           y1 = props.y1,
//           x2 = props.x2,
//           y2 = props.y2,
//           key = props.key,
//           others = _objectWithoutProperties$2(props, _excluded$3);
//         var _filterProps = filterProps(others);
//           _filterProps.offset;
//           var restOfFilteredProps = _objectWithoutProperties$2(_filterProps, _excluded2$1);
//         lineItem = /*#__PURE__*/React__default.createElement("line", _extends$2({}, restOfFilteredProps, {
//           x1: x1,
//           y1: y1,
//           x2: x2,
//           y2: y2,
//           fill: "none",
//           key: key
//         }));
//       }
//       return lineItem;
//     }
//   }]);
//   return CartesianGrid;
// }(PureComponent);
// _defineProperty$3(CartesianGrid, "displayName", 'CartesianGrid');
// _defineProperty$3(CartesianGrid, "defaultProps", {
//   horizontal: true,
//   vertical: true,
//   // The ordinates of horizontal grid lines
//   horizontalPoints: [],
//   // The abscissas of vertical grid lines
//   verticalPoints: [],
//   stroke: '#ccc',
//   fill: 'none',
//   // The fill of colors of grid lines
//   verticalFill: [],
//   horizontalFill: []
// });

// var _excluded$2 = ["type", "layout", "connectNulls", "ref"];
// function _typeof$3(o) { "@babel/helpers - typeof"; return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$3(o); }
// function _objectWithoutProperties$1(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$1(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function _extends$1() { _extends$1 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
// function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty$2(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _toConsumableArray$3(arr) { return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$3(); }
// function _nonIterableSpread$3() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }
// function _iterableToArray$3(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$3(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$3(arr); }
// function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor); } }
// function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$2(subClass, superClass); }
// function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }
// function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }
// function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$3(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized$1(self); }
// function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }
// function _defineProperty$2(obj, key, value) { key = _toPropertyKey$2(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$2(arg) { var key = _toPrimitive$2(arg, "string"); return _typeof$3(key) === "symbol" ? key : String(key); }
// function _toPrimitive$2(input, hint) { if (_typeof$3(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$3(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var Line = /*#__PURE__*/function (_PureComponent) {
//   _inherits$1(Line, _PureComponent);
//   var _super = _createSuper$1(Line);
//   function Line() {
//     var _this;
//     _classCallCheck$2(this, Line);
//     for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
//       args[_key] = arguments[_key];
//     }
//     _this = _super.call.apply(_super, [this].concat(args));
//     _defineProperty$2(_assertThisInitialized$1(_this), "state", {
//       isAnimationFinished: true,
//       totalLength: 0
//     });
//     _defineProperty$2(_assertThisInitialized$1(_this), "generateSimpleStrokeDasharray", function (totalLength, length) {
//       return "".concat(length, "px ").concat(totalLength - length, "px");
//     });
//     _defineProperty$2(_assertThisInitialized$1(_this), "getStrokeDasharray", function (length, totalLength, lines) {
//       var lineLength = lines.reduce(function (pre, next) {
//         return pre + next;
//       });

//       // if lineLength is 0 return the default when no strokeDasharray is provided
//       if (!lineLength) {
//         return _this.generateSimpleStrokeDasharray(totalLength, length);
//       }
//       var count = Math.floor(length / lineLength);
//       var remainLength = length % lineLength;
//       var restLength = totalLength - length;
//       var remainLines = [];
//       for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) {
//         if (sum + lines[i] > remainLength) {
//           remainLines = [].concat(_toConsumableArray$3(lines.slice(0, i)), [remainLength - sum]);
//           break;
//         }
//       }
//       var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
//       return [].concat(_toConsumableArray$3(Line.repeat(lines, count)), _toConsumableArray$3(remainLines), emptyLines).map(function (line) {
//         return "".concat(line, "px");
//       }).join(', ');
//     });
//     _defineProperty$2(_assertThisInitialized$1(_this), "id", uniqueId('recharts-line-'));
//     _defineProperty$2(_assertThisInitialized$1(_this), "pathRef", function (node) {
//       _this.mainCurve = node;
//     });
//     _defineProperty$2(_assertThisInitialized$1(_this), "handleAnimationEnd", function () {
//       _this.setState({
//         isAnimationFinished: true
//       });
//       if (_this.props.onAnimationEnd) {
//         _this.props.onAnimationEnd();
//       }
//     });
//     _defineProperty$2(_assertThisInitialized$1(_this), "handleAnimationStart", function () {
//       _this.setState({
//         isAnimationFinished: false
//       });
//       if (_this.props.onAnimationStart) {
//         _this.props.onAnimationStart();
//       }
//     });
//     return _this;
//   }
//   _createClass$2(Line, [{
//     key: "componentDidMount",
//     value: function componentDidMount() {
//       if (!this.props.isAnimationActive) {
//         return;
//       }
//       var totalLength = this.getTotalLength();
//       this.setState({
//         totalLength: totalLength
//       });
//     }
//   }, {
//     key: "componentDidUpdate",
//     value: function componentDidUpdate() {
//       if (!this.props.isAnimationActive) {
//         return;
//       }
//       var totalLength = this.getTotalLength();
//       if (totalLength !== this.state.totalLength) {
//         this.setState({
//           totalLength: totalLength
//         });
//       }
//     }
//   }, {
//     key: "getTotalLength",
//     value: function getTotalLength() {
//       var curveDom = this.mainCurve;
//       try {
//         return curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;
//       } catch (err) {
//         return 0;
//       }
//     }
//   }, {
//     key: "renderErrorBar",
//     value: function renderErrorBar(needClip, clipPathId) {
//       if (this.props.isAnimationActive && !this.state.isAnimationFinished) {
//         return null;
//       }
//       var _this$props = this.props,
//         points = _this$props.points,
//         xAxis = _this$props.xAxis,
//         yAxis = _this$props.yAxis,
//         layout = _this$props.layout,
//         children = _this$props.children;
//       var errorBarItems = findAllByType(children, ErrorBar);
//       if (!errorBarItems) {
//         return null;
//       }
//       var dataPointFormatter = function dataPointFormatter(dataPoint, dataKey) {
//         return {
//           x: dataPoint.x,
//           y: dataPoint.y,
//           value: dataPoint.value,
//           errorVal: getValueByDataKey(dataPoint.payload, dataKey)
//         };
//       };
//       var errorBarProps = {
//         clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
//       };
//       return /*#__PURE__*/React__default.createElement(Layer, errorBarProps, errorBarItems.map(function (item) {
//         return /*#__PURE__*/React__default.cloneElement(item, {
//           key: "bar-".concat(item.props.dataKey),
//           data: points,
//           xAxis: xAxis,
//           yAxis: yAxis,
//           layout: layout,
//           dataPointFormatter: dataPointFormatter
//         });
//       }));
//     }
//   }, {
//     key: "renderDots",
//     value: function renderDots(needClip, clipDot, clipPathId) {
//       var isAnimationActive = this.props.isAnimationActive;
//       if (isAnimationActive && !this.state.isAnimationFinished) {
//         return null;
//       }
//       var _this$props2 = this.props,
//         dot = _this$props2.dot,
//         points = _this$props2.points,
//         dataKey = _this$props2.dataKey;
//       var lineProps = filterProps(this.props);
//       var customDotProps = filterProps(dot, true);
//       var dots = points.map(function (entry, i) {
//         var dotProps = _objectSpread$1(_objectSpread$1(_objectSpread$1({
//           key: "dot-".concat(i),
//           r: 3
//         }, lineProps), customDotProps), {}, {
//           value: entry.value,
//           dataKey: dataKey,
//           cx: entry.x,
//           cy: entry.y,
//           index: i,
//           payload: entry.payload
//         });
//         return Line.renderDotItem(dot, dotProps);
//       });
//       var dotsProps = {
//         clipPath: needClip ? "url(#clipPath-".concat(clipDot ? '' : 'dots-').concat(clipPathId, ")") : null
//       };
//       return /*#__PURE__*/React__default.createElement(Layer, _extends$1({
//         className: "recharts-line-dots",
//         key: "dots"
//       }, dotsProps), dots);
//     }
//   }, {
//     key: "renderCurveStatically",
//     value: function renderCurveStatically(points, needClip, clipPathId, props) {
//       var _this$props3 = this.props,
//         type = _this$props3.type,
//         layout = _this$props3.layout,
//         connectNulls = _this$props3.connectNulls;
//         _this$props3.ref;
//         var others = _objectWithoutProperties$1(_this$props3, _excluded$2);
//       var curveProps = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, filterProps(others, true)), {}, {
//         fill: 'none',
//         className: 'recharts-line-curve',
//         clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
//         points: points
//       }, props), {}, {
//         type: type,
//         layout: layout,
//         connectNulls: connectNulls
//       });
//       return /*#__PURE__*/React__default.createElement(Curve, _extends$1({}, curveProps, {
//         pathRef: this.pathRef
//       }));
//     }
//   }, {
//     key: "renderCurveWithAnimation",
//     value: function renderCurveWithAnimation(needClip, clipPathId) {
//       var _this2 = this;
//       var _this$props4 = this.props,
//         points = _this$props4.points,
//         strokeDasharray = _this$props4.strokeDasharray,
//         isAnimationActive = _this$props4.isAnimationActive,
//         animationBegin = _this$props4.animationBegin,
//         animationDuration = _this$props4.animationDuration,
//         animationEasing = _this$props4.animationEasing,
//         animationId = _this$props4.animationId,
//         animateNewValues = _this$props4.animateNewValues,
//         width = _this$props4.width,
//         height = _this$props4.height;
//       var _this$state = this.state,
//         prevPoints = _this$state.prevPoints,
//         totalLength = _this$state.totalLength;
//       return /*#__PURE__*/React__default.createElement(Animate, {
//         begin: animationBegin,
//         duration: animationDuration,
//         isActive: isAnimationActive,
//         easing: animationEasing,
//         from: {
//           t: 0
//         },
//         to: {
//           t: 1
//         },
//         key: "line-".concat(animationId),
//         onAnimationEnd: this.handleAnimationEnd,
//         onAnimationStart: this.handleAnimationStart
//       }, function (_ref) {
//         var t = _ref.t;
//         if (prevPoints) {
//           var prevPointsDiffFactor = prevPoints.length / points.length;
//           var stepData = points.map(function (entry, index) {
//             var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
//             if (prevPoints[prevPointIndex]) {
//               var prev = prevPoints[prevPointIndex];
//               var interpolatorX = interpolateNumber$1(prev.x, entry.x);
//               var interpolatorY = interpolateNumber$1(prev.y, entry.y);
//               return _objectSpread$1(_objectSpread$1({}, entry), {}, {
//                 x: interpolatorX(t),
//                 y: interpolatorY(t)
//               });
//             }

//             // magic number of faking previous x and y location
//             if (animateNewValues) {
//               var _interpolatorX = interpolateNumber$1(width * 2, entry.x);
//               var _interpolatorY = interpolateNumber$1(height / 2, entry.y);
//               return _objectSpread$1(_objectSpread$1({}, entry), {}, {
//                 x: _interpolatorX(t),
//                 y: _interpolatorY(t)
//               });
//             }
//             return _objectSpread$1(_objectSpread$1({}, entry), {}, {
//               x: entry.x,
//               y: entry.y
//             });
//           });
//           return _this2.renderCurveStatically(stepData, needClip, clipPathId);
//         }
//         var interpolator = interpolateNumber$1(0, totalLength);
//         var curLength = interpolator(t);
//         var currentStrokeDasharray;
//         if (strokeDasharray) {
//           var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map(function (num) {
//             return parseFloat(num);
//           });
//           currentStrokeDasharray = _this2.getStrokeDasharray(curLength, totalLength, lines);
//         } else {
//           currentStrokeDasharray = _this2.generateSimpleStrokeDasharray(totalLength, curLength);
//         }
//         return _this2.renderCurveStatically(points, needClip, clipPathId, {
//           strokeDasharray: currentStrokeDasharray
//         });
//       });
//     }
//   }, {
//     key: "renderCurve",
//     value: function renderCurve(needClip, clipPathId) {
//       var _this$props5 = this.props,
//         points = _this$props5.points,
//         isAnimationActive = _this$props5.isAnimationActive;
//       var _this$state2 = this.state,
//         prevPoints = _this$state2.prevPoints,
//         totalLength = _this$state2.totalLength;
//       if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !isEqual$1(prevPoints, points))) {
//         return this.renderCurveWithAnimation(needClip, clipPathId);
//       }
//       return this.renderCurveStatically(points, needClip, clipPathId);
//     }
//   }, {
//     key: "render",
//     value: function render() {
//       var _filterProps;
//       var _this$props6 = this.props,
//         hide = _this$props6.hide,
//         dot = _this$props6.dot,
//         points = _this$props6.points,
//         className = _this$props6.className,
//         xAxis = _this$props6.xAxis,
//         yAxis = _this$props6.yAxis,
//         top = _this$props6.top,
//         left = _this$props6.left,
//         width = _this$props6.width,
//         height = _this$props6.height,
//         isAnimationActive = _this$props6.isAnimationActive,
//         id = _this$props6.id;
//       if (hide || !points || !points.length) {
//         return null;
//       }
//       var isAnimationFinished = this.state.isAnimationFinished;
//       var hasSinglePoint = points.length === 1;
//       var layerClass = clsx('recharts-line', className);
//       var needClipX = xAxis && xAxis.allowDataOverflow;
//       var needClipY = yAxis && yAxis.allowDataOverflow;
//       var needClip = needClipX || needClipY;
//       var clipPathId = isNil$1(id) ? this.id : id;
//       var _ref2 = (_filterProps = filterProps(dot)) !== null && _filterProps !== void 0 ? _filterProps : {
//           r: 3,
//           strokeWidth: 2
//         },
//         _ref2$r = _ref2.r,
//         r = _ref2$r === void 0 ? 3 : _ref2$r,
//         _ref2$strokeWidth = _ref2.strokeWidth,
//         strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;
//       var _ref3 = isDotProps(dot) ? dot : {},
//         _ref3$clipDot = _ref3.clipDot,
//         clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;
//       var dotSize = r * 2 + strokeWidth;
//       return /*#__PURE__*/React__default.createElement(Layer, {
//         className: layerClass
//       }, needClipX || needClipY ? /*#__PURE__*/React__default.createElement("defs", null, /*#__PURE__*/React__default.createElement("clipPath", {
//         id: "clipPath-".concat(clipPathId)
//       }, /*#__PURE__*/React__default.createElement("rect", {
//         x: needClipX ? left : left - width / 2,
//         y: needClipY ? top : top - height / 2,
//         width: needClipX ? width : width * 2,
//         height: needClipY ? height : height * 2
//       })), !clipDot && /*#__PURE__*/React__default.createElement("clipPath", {
//         id: "clipPath-dots-".concat(clipPathId)
//       }, /*#__PURE__*/React__default.createElement("rect", {
//         x: left - dotSize / 2,
//         y: top - dotSize / 2,
//         width: width + dotSize,
//         height: height + dotSize
//       }))) : null, !hasSinglePoint && this.renderCurve(needClip, clipPathId), this.renderErrorBar(needClip, clipPathId), (hasSinglePoint || dot) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, points));
//     }
//   }], [{
//     key: "getDerivedStateFromProps",
//     value: function getDerivedStateFromProps(nextProps, prevState) {
//       if (nextProps.animationId !== prevState.prevAnimationId) {
//         return {
//           prevAnimationId: nextProps.animationId,
//           curPoints: nextProps.points,
//           prevPoints: prevState.curPoints
//         };
//       }
//       if (nextProps.points !== prevState.curPoints) {
//         return {
//           curPoints: nextProps.points
//         };
//       }
//       return null;
//     }
//   }, {
//     key: "repeat",
//     value: function repeat(lines, count) {
//       var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray$3(lines), [0]) : lines;
//       var result = [];
//       for (var i = 0; i < count; ++i) {
//         result = [].concat(_toConsumableArray$3(result), _toConsumableArray$3(linesUnit));
//       }
//       return result;
//     }
//   }, {
//     key: "renderDotItem",
//     value: function renderDotItem(option, props) {
//       var dotItem;
//       if ( /*#__PURE__*/React__default.isValidElement(option)) {
//         dotItem = /*#__PURE__*/React__default.cloneElement(option, props);
//       } else if (isFunction(option)) {
//         dotItem = option(props);
//       } else {
//         var className = clsx('recharts-line-dot', option ? option.className : '');
//         dotItem = /*#__PURE__*/React__default.createElement(Dot, _extends$1({}, props, {
//           className: className
//         }));
//       }
//       return dotItem;
//     }
//   }]);
//   return Line;
// }(PureComponent);
// _defineProperty$2(Line, "displayName", 'Line');
// _defineProperty$2(Line, "defaultProps", {
//   xAxisId: 0,
//   yAxisId: 0,
//   connectNulls: false,
//   activeDot: true,
//   dot: true,
//   legendType: 'line',
//   stroke: '#3182bd',
//   strokeWidth: 1,
//   fill: '#fff',
//   points: [],
//   isAnimationActive: !Global.isSsr,
//   animateNewValues: true,
//   animationBegin: 0,
//   animationDuration: 1500,
//   animationEasing: 'ease',
//   hide: false,
//   label: false
// });
// /**
//  * Compose the data of each group
//  * @param {Object} props The props from the component
//  * @param  {Object} xAxis   The configuration of x-axis
//  * @param  {Object} yAxis   The configuration of y-axis
//  * @param  {String} dataKey The unique key of a group
//  * @return {Array}  Composed data
//  */
// _defineProperty$2(Line, "getComposedData", function (_ref4) {
//   var props = _ref4.props,
//     xAxis = _ref4.xAxis,
//     yAxis = _ref4.yAxis,
//     xAxisTicks = _ref4.xAxisTicks,
//     yAxisTicks = _ref4.yAxisTicks,
//     dataKey = _ref4.dataKey,
//     bandSize = _ref4.bandSize,
//     displayedData = _ref4.displayedData,
//     offset = _ref4.offset;
//   var layout = props.layout;
//   var points = displayedData.map(function (entry, index) {
//     var value = getValueByDataKey(entry, dataKey);
//     if (layout === 'horizontal') {
//       return {
//         x: getCateCoordinateOfLine({
//           axis: xAxis,
//           ticks: xAxisTicks,
//           bandSize: bandSize,
//           entry: entry,
//           index: index
//         }),
//         y: isNil$1(value) ? null : yAxis.scale(value),
//         value: value,
//         payload: entry
//       };
//     }
//     return {
//       x: isNil$1(value) ? null : xAxis.scale(value),
//       y: getCateCoordinateOfLine({
//         axis: yAxis,
//         ticks: yAxisTicks,
//         bandSize: bandSize,
//         entry: entry,
//         index: index
//       }),
//       value: value,
//       payload: entry
//     };
//   });
//   return _objectSpread$1({
//     points: points,
//     layout: layout
//   }, offset);
// });

// /**
//  * @fileOverview X Axis
//  */

// /** Define of XAxis props */

// var XAxis = function XAxis() {
//   return null;
// };
// XAxis.displayName = 'XAxis';
// XAxis.defaultProps = {
//   allowDecimals: true,
//   hide: false,
//   orientation: 'bottom',
//   width: 0,
//   height: 30,
//   mirror: false,
//   xAxisId: 0,
//   tickCount: 5,
//   type: 'category',
//   padding: {
//     left: 0,
//     right: 0
//   },
//   allowDataOverflow: false,
//   scale: 'auto',
//   reversed: false,
//   allowDuplicatedCategory: true
// };

// /**
//  * @fileOverview Y Axis
//  */

// var YAxis = function YAxis() {
//   return null;
// };
// YAxis.displayName = 'YAxis';
// YAxis.defaultProps = {
//   allowDuplicatedCategory: true,
//   allowDecimals: true,
//   hide: false,
//   orientation: 'left',
//   width: 60,
//   height: 0,
//   mirror: false,
//   yAxisId: 0,
//   tickCount: 5,
//   type: 'number',
//   padding: {
//     top: 0,
//     bottom: 0
//   },
//   allowDataOverflow: false,
//   scale: 'auto',
//   reversed: false
// };

// var isProduction = process.env.NODE_ENV === 'production';
// var prefix = 'Invariant failed';
// function invariant(condition, message) {
//     if (condition) {
//         return;
//     }
//     if (isProduction) {
//         throw new Error(prefix);
//     }
//     var provided = typeof message === 'function' ? message() : message;
//     var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
//     throw new Error(value);
// }

// /**
//  * Only applicable for radial layouts
//  * @param {Object} activeCoordinate ChartCoordinate
//  * @returns {Object} RadialCursorPoints
//  */
// function getRadialCursorPoints(activeCoordinate) {
//   var cx = activeCoordinate.cx,
//     cy = activeCoordinate.cy,
//     radius = activeCoordinate.radius,
//     startAngle = activeCoordinate.startAngle,
//     endAngle = activeCoordinate.endAngle;
//   var startPoint = polarToCartesian(cx, cy, radius, startAngle);
//   var endPoint = polarToCartesian(cx, cy, radius, endAngle);
//   return {
//     points: [startPoint, endPoint],
//     cx: cx,
//     cy: cy,
//     radius: radius,
//     startAngle: startAngle,
//     endAngle: endAngle
//   };
// }

// function _toConsumableArray$2(arr) { return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2(); }
// function _nonIterableSpread$2() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }
// function _iterableToArray$2(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$2(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$2(arr); }
// function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// var detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType, specifiedTicks) {
//   var lines = findAllByType(children, ReferenceLine);
//   var dots = findAllByType(children, ReferenceDot);
//   var elements = [].concat(_toConsumableArray$2(lines), _toConsumableArray$2(dots));
//   var areas = findAllByType(children, ReferenceArea);
//   var idKey = "".concat(axisType, "Id");
//   var valueKey = axisType[0];
//   var finalDomain = domain;
//   if (elements.length) {
//     finalDomain = elements.reduce(function (result, el) {
//       if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[valueKey])) {
//         var value = el.props[valueKey];
//         return [Math.min(result[0], value), Math.max(result[1], value)];
//       }
//       return result;
//     }, finalDomain);
//   }
//   if (areas.length) {
//     var key1 = "".concat(valueKey, "1");
//     var key2 = "".concat(valueKey, "2");
//     finalDomain = areas.reduce(function (result, el) {
//       if (el.props[idKey] === axisId && ifOverflowMatches(el.props, 'extendDomain') && isNumber(el.props[key1]) && isNumber(el.props[key2])) {
//         var value1 = el.props[key1];
//         var value2 = el.props[key2];
//         return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
//       }
//       return result;
//     }, finalDomain);
//   }
//   if (specifiedTicks && specifiedTicks.length) {
//     finalDomain = specifiedTicks.reduce(function (result, tick) {
//       if (isNumber(tick)) {
//         return [Math.min(result[0], tick), Math.max(result[1], tick)];
//       }
//       return result;
//     }, finalDomain);
//   }
//   return finalDomain;
// };

// var eventCenter = new EventEmitter();
// var SYNC_EVENT = 'recharts.syncMouseEvents';

// function _typeof$2(o) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$2(o); }
// function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor); } }
// function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _defineProperty$1(obj, key, value) { key = _toPropertyKey$1(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey$1(arg) { var key = _toPrimitive$1(arg, "string"); return _typeof$2(key) === "symbol" ? key : String(key); }
// function _toPrimitive$1(input, hint) { if (_typeof$2(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$2(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var AccessibilityManager = /*#__PURE__*/function () {
//   function AccessibilityManager() {
//     _classCallCheck$1(this, AccessibilityManager);
//     _defineProperty$1(this, "activeIndex", 0);
//     _defineProperty$1(this, "coordinateList", []);
//     _defineProperty$1(this, "layout", 'horizontal');
//   }
//   _createClass$1(AccessibilityManager, [{
//     key: "setDetails",
//     value: function setDetails(_ref) {
//       var _ref$coordinateList = _ref.coordinateList,
//         coordinateList = _ref$coordinateList === void 0 ? [] : _ref$coordinateList,
//         _ref$container = _ref.container,
//         container = _ref$container === void 0 ? null : _ref$container,
//         _ref$layout = _ref.layout,
//         layout = _ref$layout === void 0 ? null : _ref$layout,
//         _ref$offset = _ref.offset,
//         offset = _ref$offset === void 0 ? null : _ref$offset,
//         _ref$mouseHandlerCall = _ref.mouseHandlerCallback,
//         mouseHandlerCallback = _ref$mouseHandlerCall === void 0 ? null : _ref$mouseHandlerCall;
//       this.coordinateList = coordinateList !== null && coordinateList !== void 0 ? coordinateList : this.coordinateList;
//       this.container = container !== null && container !== void 0 ? container : this.container;
//       this.layout = layout !== null && layout !== void 0 ? layout : this.layout;
//       this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
//       this.mouseHandlerCallback = mouseHandlerCallback !== null && mouseHandlerCallback !== void 0 ? mouseHandlerCallback : this.mouseHandlerCallback;

//       // Keep activeIndex in the bounds between 0 and the last coordinate index
//       this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);
//     }
//   }, {
//     key: "focus",
//     value: function focus() {
//       this.spoofMouse();
//     }
//   }, {
//     key: "keyboardEvent",
//     value: function keyboardEvent(e) {
//       // The AccessibilityManager relies on the Tooltip component. When tooltips suddenly stop existing,
//       // it can cause errors. We use this function to check. We don't want arrow keys to be processed
//       // if there are no tooltips, since that will cause unexpected behavior of users.
//       if (this.coordinateList.length === 0) {
//         return;
//       }
//       switch (e.key) {
//         case 'ArrowRight':
//           {
//             if (this.layout !== 'horizontal') {
//               return;
//             }
//             this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1);
//             this.spoofMouse();
//             break;
//           }
//         case 'ArrowLeft':
//           {
//             if (this.layout !== 'horizontal') {
//               return;
//             }
//             this.activeIndex = Math.max(this.activeIndex - 1, 0);
//             this.spoofMouse();
//             break;
//           }
//       }
//     }
//   }, {
//     key: "spoofMouse",
//     value: function spoofMouse() {
//       var _window, _window2;
//       if (this.layout !== 'horizontal') {
//         return;
//       }

//       // This can happen when the tooltips suddenly stop existing as children of the component
//       // That update doesn't otherwise fire events, so we have to double check here.
//       if (this.coordinateList.length === 0) {
//         return;
//       }
//       var _this$container$getBo = this.container.getBoundingClientRect(),
//         x = _this$container$getBo.x,
//         y = _this$container$getBo.y,
//         height = _this$container$getBo.height;
//       var coordinate = this.coordinateList[this.activeIndex].coordinate;
//       var scrollOffsetX = ((_window = window) === null || _window === void 0 ? void 0 : _window.scrollX) || 0;
//       var scrollOffsetY = ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.scrollY) || 0;
//       var pageX = x + coordinate + scrollOffsetX;
//       var pageY = y + this.offset.top + height / 2 + scrollOffsetY;
//       this.mouseHandlerCallback({
//         pageX: pageX,
//         pageY: pageY
//       });
//     }
//   }]);
//   return AccessibilityManager;
// }();

// /**
//  * Takes a domain and user props to determine whether he provided the domain via props or if we need to calculate it.
//  * @param   {AxisDomain}  domain              The potential domain from props
//  * @param   {Boolean}     allowDataOverflow   from props
//  * @param   {String}      axisType            from props
//  * @returns {Boolean}                         `true` if domain is specified by user
//  */
// function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {
//   if (axisType === 'number' && allowDataOverflow === true && Array.isArray(domain)) {
//     var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];
//     var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];

//     /*
//      * The `isNumber` check is needed because the user could also provide strings like "dataMin" via the domain props.
//      * In such case, we have to compute the domain from the data.
//      */
//     if (!!domainStart && !!domainEnd && isNumber(domainStart) && isNumber(domainEnd)) {
//       return true;
//     }
//   }
//   return false;
// }

// function getCursorPoints(layout, activeCoordinate, offset) {
//   var x1, y1, x2, y2;
//   if (layout === 'horizontal') {
//     x1 = activeCoordinate.x;
//     x2 = x1;
//     y1 = offset.top;
//     y2 = offset.top + offset.height;
//   } else if (layout === 'vertical') {
//     y1 = activeCoordinate.y;
//     y2 = y1;
//     x1 = offset.left;
//     x2 = offset.left + offset.width;
//   } else if (activeCoordinate.cx != null && activeCoordinate.cy != null) {
//     if (layout === 'centric') {
//       var cx = activeCoordinate.cx,
//         cy = activeCoordinate.cy,
//         innerRadius = activeCoordinate.innerRadius,
//         outerRadius = activeCoordinate.outerRadius,
//         angle = activeCoordinate.angle;
//       var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
//       var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
//       x1 = innerPoint.x;
//       y1 = innerPoint.y;
//       x2 = outerPoint.x;
//       y2 = outerPoint.y;
//     } else {
//       return getRadialCursorPoints(activeCoordinate);
//     }
//   }
//   return [{
//     x: x1,
//     y: y1
//   }, {
//     x: x2,
//     y: y2
//   }];
// }

// function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
//   var halfSize = tooltipAxisBandSize / 2;
//   return {
//     stroke: 'none',
//     fill: '#ccc',
//     x: layout === 'horizontal' ? activeCoordinate.x - halfSize : offset.left + 0.5,
//     y: layout === 'horizontal' ? offset.top + 0.5 : activeCoordinate.y - halfSize,
//     width: layout === 'horizontal' ? tooltipAxisBandSize : offset.width - 1,
//     height: layout === 'horizontal' ? offset.height - 1 : tooltipAxisBandSize
//   };
// }

// var _excluded$1 = ["item"],
//   _excluded2 = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
// function _typeof$1(o) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$1(o); }
// function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest(); }
// function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
// function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
// function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
// function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
// function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
// function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
// function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
// function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf$1(subClass, superClass); }
// function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }
// function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
// function _possibleConstructorReturn(self, call) { if (call && (_typeof$1(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
// function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
// function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// function _toConsumableArray$1(arr) { return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1(); }
// function _nonIterableSpread$1() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
// function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
// function _iterableToArray$1(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
// function _arrayWithoutHoles$1(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$1(arr); }
// function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
// function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof$1(key) === "symbol" ? key : String(key); }
// function _toPrimitive(input, hint) { if (_typeof$1(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof$1(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// var ORIENT_MAP = {
//   xAxis: ['bottom', 'top'],
//   yAxis: ['left', 'right']
// };
// var FULL_WIDTH_AND_HEIGHT = {
//   width: '100%',
//   height: '100%'
// };
// var originCoordinate = {
//   x: 0,
//   y: 0
// };
// var calculateTooltipPos = function calculateTooltipPos(rangeObj, layout) {
//   if (layout === 'horizontal') {
//     return rangeObj.x;
//   }
//   if (layout === 'vertical') {
//     return rangeObj.y;
//   }
//   if (layout === 'centric') {
//     return rangeObj.angle;
//   }
//   return rangeObj.radius;
// };
// var getActiveCoordinate = function getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj) {
//   var entry = tooltipTicks.find(function (tick) {
//     return tick && tick.index === activeIndex;
//   });
//   if (entry) {
//     if (layout === 'horizontal') {
//       return {
//         x: entry.coordinate,
//         y: rangeObj.y
//       };
//     }
//     if (layout === 'vertical') {
//       return {
//         x: rangeObj.x,
//         y: entry.coordinate
//       };
//     }
//     if (layout === 'centric') {
//       var _angle = entry.coordinate;
//       var _radius = rangeObj.radius;
//       return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
//         angle: _angle,
//         radius: _radius
//       });
//     }
//     var radius = entry.coordinate;
//     var angle = rangeObj.angle;
//     return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
//       angle: angle,
//       radius: radius
//     });
//   }
//   return originCoordinate;
// };
// var getDisplayedData = function getDisplayedData(data, _ref) {
//   var graphicalItems = _ref.graphicalItems,
//     dataStartIndex = _ref.dataStartIndex,
//     dataEndIndex = _ref.dataEndIndex;
//   var itemsData = (graphicalItems !== null && graphicalItems !== void 0 ? graphicalItems : []).reduce(function (result, child) {
//     var itemData = child.props.data;
//     if (itemData && itemData.length) {
//       return [].concat(_toConsumableArray$1(result), _toConsumableArray$1(itemData));
//     }
//     return result;
//   }, []);
//   if (itemsData.length > 0) {
//     return itemsData;
//   }
//   if (data && data.length && isNumber(dataStartIndex) && isNumber(dataEndIndex)) {
//     return data.slice(dataStartIndex, dataEndIndex + 1);
//   }
//   return [];
// };
// function getDefaultDomainByAxisType(axisType) {
//   return axisType === 'number' ? [0, 'auto'] : undefined;
// }

// /**
//  * Get the content to be displayed in the tooltip
//  * @param  {Object} state          Current state
//  * @param  {Array}  chartData      The data defined in chart
//  * @param  {Number} activeIndex    Active index of data
//  * @param  {String} activeLabel    Active label of data
//  * @return {Array}                 The content of tooltip
//  */
// var getTooltipContent = function getTooltipContent(state, chartData, activeIndex, activeLabel) {
//   var graphicalItems = state.graphicalItems,
//     tooltipAxis = state.tooltipAxis;
//   var displayedData = getDisplayedData(chartData, state);
//   if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {
//     return null;
//   }
//   // get data by activeIndex when the axis don't allow duplicated category
//   return graphicalItems.reduce(function (result, child) {
//     var _child$props$data;
//     var hide = child.props.hide;
//     if (hide) {
//       return result;
//     }

//     /**
//      * Fixes: https://github.com/recharts/recharts/issues/3669
//      * Defaulting to chartData below to fix an edge case where the tooltip does not include data from all charts
//      * when a separate dataset is passed to chart prop data and specified on Line/Area/etc prop data
//      */
//     var data = (_child$props$data = child.props.data) !== null && _child$props$data !== void 0 ? _child$props$data : chartData;
//     if (data && state.dataStartIndex + state.dataEndIndex !== 0) {
//       data = data.slice(state.dataStartIndex, state.dataEndIndex + 1);
//     }
//     var payload;
//     if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
//       // graphic child has data props
//       var entries = data === undefined ? displayedData : data;
//       payload = findEntryInArray(entries, tooltipAxis.dataKey, activeLabel);
//     } else {
//       payload = data && data[activeIndex] || displayedData[activeIndex];
//     }
//     if (!payload) {
//       return result;
//     }
//     return [].concat(_toConsumableArray$1(result), [getTooltipItem(child, payload)]);
//   }, []);
// };

// /**
//  * Returns tooltip data based on a mouse position (as a parameter or in state)
//  * @param  {Object} state     current state
//  * @param  {Array}  chartData the data defined in chart
//  * @param  {String} layout     The layout type of chart
//  * @param  {Object} rangeObj  { x, y } coordinates
//  * @return {Object}           Tooltip data data
//  */
// var getTooltipData = function getTooltipData(state, chartData, layout, rangeObj) {
//   var rangeData = rangeObj || {
//     x: state.chartX,
//     y: state.chartY
//   };
//   var pos = calculateTooltipPos(rangeData, layout);
//   var ticks = state.orderedTooltipTicks,
//     axis = state.tooltipAxis,
//     tooltipTicks = state.tooltipTicks;
//   var activeIndex = calculateActiveTickIndex(pos, ticks, tooltipTicks, axis);
//   if (activeIndex >= 0 && tooltipTicks) {
//     var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;
//     var activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel);
//     var activeCoordinate = getActiveCoordinate(layout, ticks, activeIndex, rangeData);
//     return {
//       activeTooltipIndex: activeIndex,
//       activeLabel: activeLabel,
//       activePayload: activePayload,
//       activeCoordinate: activeCoordinate
//     };
//   }
//   return null;
// };

// /**
//  * Get the configuration of axis by the options of axis instance
//  * @param  {Object} props         Latest props
//  * @param {Array}  axes           The instance of axes
//  * @param  {Array} graphicalItems The instances of item
//  * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis
//  * @param  {String} axisIdKey     The unique id of an axis
//  * @param  {Object} stackGroups   The items grouped by axisId and stackId
//  * @param {Number} dataStartIndex The start index of the data series when a brush is applied
//  * @param {Number} dataEndIndex   The end index of the data series when a brush is applied
//  * @return {Object}      Configuration
//  */
// var getAxisMapByAxes = function getAxisMapByAxes(props, _ref2) {
//   var axes = _ref2.axes,
//     graphicalItems = _ref2.graphicalItems,
//     axisType = _ref2.axisType,
//     axisIdKey = _ref2.axisIdKey,
//     stackGroups = _ref2.stackGroups,
//     dataStartIndex = _ref2.dataStartIndex,
//     dataEndIndex = _ref2.dataEndIndex;
//   var layout = props.layout,
//     children = props.children,
//     stackOffset = props.stackOffset;
//   var isCategorical = isCategoricalAxis(layout, axisType);

//   // Eliminate duplicated axes
//   return axes.reduce(function (result, child) {
//     var _child$props$domain2;
//     var _child$props = child.props,
//       type = _child$props.type,
//       dataKey = _child$props.dataKey,
//       allowDataOverflow = _child$props.allowDataOverflow,
//       allowDuplicatedCategory = _child$props.allowDuplicatedCategory,
//       scale = _child$props.scale,
//       ticks = _child$props.ticks,
//       includeHidden = _child$props.includeHidden;
//     var axisId = child.props[axisIdKey];
//     if (result[axisId]) {
//       return result;
//     }
//     var displayedData = getDisplayedData(props.data, {
//       graphicalItems: graphicalItems.filter(function (item) {
//         return item.props[axisIdKey] === axisId;
//       }),
//       dataStartIndex: dataStartIndex,
//       dataEndIndex: dataEndIndex
//     });
//     var len = displayedData.length;
//     var domain, duplicateDomain, categoricalDomain;

//     /*
//      * This is a hack to short-circuit the domain creation here to enhance performance.
//      * Usually, the data is used to determine the domain, but when the user specifies
//      * a domain upfront (via props), there is no need to calculate the domain start and end,
//      * which is very expensive for a larger amount of data.
//      * The only thing that would prohibit short-circuiting is when the user doesn't allow data overflow,
//      * because the axis is supposed to ignore the specified domain that way.
//      */
//     if (isDomainSpecifiedByUser(child.props.domain, allowDataOverflow, type)) {
//       domain = parseSpecifiedDomain(child.props.domain, null, allowDataOverflow);
//       /* The chart can be categorical and have the domain specified in numbers
//        * we still need to calculate the categorical domain
//        * TODO: refactor this more
//        */
//       if (isCategorical && (type === 'number' || scale !== 'auto')) {
//         categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, 'category');
//       }
//     }

//     // if the domain is defaulted we need this for `originalDomain` as well
//     var defaultDomain = getDefaultDomainByAxisType(type);

//     // we didn't create the domain from user's props above, so we need to calculate it
//     if (!domain || domain.length === 0) {
//       var _child$props$domain;
//       var childDomain = (_child$props$domain = child.props.domain) !== null && _child$props$domain !== void 0 ? _child$props$domain : defaultDomain;
//       if (dataKey) {
//         // has dataKey in <Axis />
//         domain = getDomainOfDataByKey(displayedData, dataKey, type);
//         if (type === 'category' && isCategorical) {
//           // the field type is category data and this axis is categorical axis
//           var duplicate = hasDuplicate(domain);
//           if (allowDuplicatedCategory && duplicate) {
//             duplicateDomain = domain;
//             // When category axis has duplicated text, serial numbers are used to generate scale
//             domain = range$1(0, len);
//           } else if (!allowDuplicatedCategory) {
//             // remove duplicated category
//             domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function (finalDomain, entry) {
//               return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray$1(finalDomain), [entry]);
//             }, []);
//           }
//         } else if (type === 'category') {
//           // the field type is category data and this axis is numerical axis
//           if (!allowDuplicatedCategory) {
//             domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function (finalDomain, entry) {
//               return finalDomain.indexOf(entry) >= 0 || entry === '' || isNil$1(entry) ? finalDomain : [].concat(_toConsumableArray$1(finalDomain), [entry]);
//             }, []);
//           } else {
//             // eliminate undefined or null or empty string
//             domain = domain.filter(function (entry) {
//               return entry !== '' && !isNil$1(entry);
//             });
//           }
//         } else if (type === 'number') {
//           // the field type is numerical
//           var errorBarsDomain = parseErrorBarsOfAxis(displayedData, graphicalItems.filter(function (item) {
//             return item.props[axisIdKey] === axisId && (includeHidden || !item.props.hide);
//           }), dataKey, axisType, layout);
//           if (errorBarsDomain) {
//             domain = errorBarsDomain;
//           }
//         }
//         if (isCategorical && (type === 'number' || scale !== 'auto')) {
//           categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, 'category');
//         }
//       } else if (isCategorical) {
//         // the axis is a categorical axis
//         domain = range$1(0, len);
//       } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === 'number') {
//         // when stackOffset is 'expand', the domain may be calculated as [0, 1.000000000002]
//         domain = stackOffset === 'expand' ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
//       } else {
//         domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function (item) {
//           return item.props[axisIdKey] === axisId && (includeHidden || !item.props.hide);
//         }), type, layout, true);
//       }
//       if (type === 'number') {
//         // To detect wether there is any reference lines whose props alwaysShow is true
//         domain = detectReferenceElementsDomain(children, domain, axisId, axisType, ticks);
//         if (childDomain) {
//           domain = parseSpecifiedDomain(childDomain, domain, allowDataOverflow);
//         }
//       } else if (type === 'category' && childDomain) {
//         var axisDomain = childDomain;
//         var isDomainValid = domain.every(function (entry) {
//           return axisDomain.indexOf(entry) >= 0;
//         });
//         if (isDomainValid) {
//           domain = axisDomain;
//         }
//       }
//     }
//     return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, child.props), {}, {
//       axisType: axisType,
//       domain: domain,
//       categoricalDomain: categoricalDomain,
//       duplicateDomain: duplicateDomain,
//       originalDomain: (_child$props$domain2 = child.props.domain) !== null && _child$props$domain2 !== void 0 ? _child$props$domain2 : defaultDomain,
//       isCategorical: isCategorical,
//       layout: layout
//     })));
//   }, {});
// };

// /**
//  * Get the configuration of axis by the options of item,
//  * this kind of axis does not display in chart
//  * @param  {Object} props         Latest props
//  * @param  {Array} graphicalItems The instances of item
//  * @param  {ReactElement} Axis    Axis Component
//  * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis
//  * @param  {String} axisIdKey     The unique id of an axis
//  * @param  {Object} stackGroups   The items grouped by axisId and stackId
//  * @param {Number} dataStartIndex The start index of the data series when a brush is applied
//  * @param {Number} dataEndIndex   The end index of the data series when a brush is applied
//  * @return {Object}               Configuration
//  */
// var getAxisMapByItems = function getAxisMapByItems(props, _ref3) {
//   var graphicalItems = _ref3.graphicalItems,
//     Axis = _ref3.Axis,
//     axisType = _ref3.axisType,
//     axisIdKey = _ref3.axisIdKey,
//     stackGroups = _ref3.stackGroups,
//     dataStartIndex = _ref3.dataStartIndex,
//     dataEndIndex = _ref3.dataEndIndex;
//   var layout = props.layout,
//     children = props.children;
//   var displayedData = getDisplayedData(props.data, {
//     graphicalItems: graphicalItems,
//     dataStartIndex: dataStartIndex,
//     dataEndIndex: dataEndIndex
//   });
//   var len = displayedData.length;
//   var isCategorical = isCategoricalAxis(layout, axisType);
//   var index = -1;

//   // The default type of x-axis is category axis,
//   // The default contents of x-axis is the serial numbers of data
//   // The default type of y-axis is number axis
//   // The default contents of y-axis is the domain of data
//   return graphicalItems.reduce(function (result, child) {
//     var axisId = child.props[axisIdKey];
//     var originalDomain = getDefaultDomainByAxisType('number');
//     if (!result[axisId]) {
//       index++;
//       var domain;
//       if (isCategorical) {
//         domain = range$1(0, len);
//       } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {
//         domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
//         domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
//       } else {
//         domain = parseSpecifiedDomain(originalDomain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function (item) {
//           return item.props[axisIdKey] === axisId && !item.props.hide;
//         }), 'number', layout), Axis.defaultProps.allowDataOverflow);
//         domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
//       }
//       return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({
//         axisType: axisType
//       }, Axis.defaultProps), {}, {
//         hide: true,
//         orientation: get(ORIENT_MAP, "".concat(axisType, ".").concat(index % 2), null),
//         domain: domain,
//         originalDomain: originalDomain,
//         isCategorical: isCategorical,
//         layout: layout
//         // specify scale when no Axis
//         // scale: isCategorical ? 'band' : 'linear',
//       })));
//     }

//     return result;
//   }, {});
// };

// /**
//  * Get the configuration of all x-axis or y-axis
//  * @param  {Object} props          Latest props
//  * @param  {String} axisType       The type of axis
//  * @param  {React.ComponentType}  [AxisComp]      Axis Component
//  * @param  {Array}  graphicalItems The instances of item
//  * @param  {Object} stackGroups    The items grouped by axisId and stackId
//  * @param {Number} dataStartIndex  The start index of the data series when a brush is applied
//  * @param {Number} dataEndIndex    The end index of the data series when a brush is applied
//  * @return {Object}          Configuration
//  */
// var getAxisMap = function getAxisMap(props, _ref4) {
//   var _ref4$axisType = _ref4.axisType,
//     axisType = _ref4$axisType === void 0 ? 'xAxis' : _ref4$axisType,
//     AxisComp = _ref4.AxisComp,
//     graphicalItems = _ref4.graphicalItems,
//     stackGroups = _ref4.stackGroups,
//     dataStartIndex = _ref4.dataStartIndex,
//     dataEndIndex = _ref4.dataEndIndex;
//   var children = props.children;
//   var axisIdKey = "".concat(axisType, "Id");
//   // Get all the instance of Axis
//   var axes = findAllByType(children, AxisComp);
//   var axisMap = {};
//   if (axes && axes.length) {
//     axisMap = getAxisMapByAxes(props, {
//       axes: axes,
//       graphicalItems: graphicalItems,
//       axisType: axisType,
//       axisIdKey: axisIdKey,
//       stackGroups: stackGroups,
//       dataStartIndex: dataStartIndex,
//       dataEndIndex: dataEndIndex
//     });
//   } else if (graphicalItems && graphicalItems.length) {
//     axisMap = getAxisMapByItems(props, {
//       Axis: AxisComp,
//       graphicalItems: graphicalItems,
//       axisType: axisType,
//       axisIdKey: axisIdKey,
//       stackGroups: stackGroups,
//       dataStartIndex: dataStartIndex,
//       dataEndIndex: dataEndIndex
//     });
//   }
//   return axisMap;
// };
// var tooltipTicksGenerator = function tooltipTicksGenerator(axisMap) {
//   var axis = getAnyElementOfObject(axisMap);
//   var tooltipTicks = getTicksOfAxis(axis, false, true);
//   return {
//     tooltipTicks: tooltipTicks,
//     orderedTooltipTicks: sortBy(tooltipTicks, function (o) {
//       return o.coordinate;
//     }),
//     tooltipAxis: axis,
//     tooltipAxisBandSize: getBandSizeOfAxis(axis, tooltipTicks)
//   };
// };

// /**
//  * Returns default, reset state for the categorical chart.
//  * @param {Object} props Props object to use when creating the default state
//  * @return {Object} Whole new state
//  */
// var createDefaultState = function createDefaultState(props) {
//   var children = props.children,
//     defaultShowTooltip = props.defaultShowTooltip;
//   var brushItem = findChildByType(children, Brush);
//   var startIndex = 0;
//   var endIndex = 0;
//   if (props.data && props.data.length !== 0) {
//     endIndex = props.data.length - 1;
//   }
//   if (brushItem && brushItem.props) {
//     if (brushItem.props.startIndex >= 0) {
//       startIndex = brushItem.props.startIndex;
//     }
//     if (brushItem.props.endIndex >= 0) {
//       endIndex = brushItem.props.endIndex;
//     }
//   }
//   return {
//     chartX: 0,
//     chartY: 0,
//     dataStartIndex: startIndex,
//     dataEndIndex: endIndex,
//     activeTooltipIndex: -1,
//     isTooltipActive: Boolean(defaultShowTooltip)
//   };
// };
// var hasGraphicalBarItem = function hasGraphicalBarItem(graphicalItems) {
//   if (!graphicalItems || !graphicalItems.length) {
//     return false;
//   }
//   return graphicalItems.some(function (item) {
//     var name = getDisplayName(item && item.type);
//     return name && name.indexOf('Bar') >= 0;
//   });
// };
// var getAxisNameByLayout = function getAxisNameByLayout(layout) {
//   if (layout === 'horizontal') {
//     return {
//       numericAxisName: 'yAxis',
//       cateAxisName: 'xAxis'
//     };
//   }
//   if (layout === 'vertical') {
//     return {
//       numericAxisName: 'xAxis',
//       cateAxisName: 'yAxis'
//     };
//   }
//   if (layout === 'centric') {
//     return {
//       numericAxisName: 'radiusAxis',
//       cateAxisName: 'angleAxis'
//     };
//   }
//   return {
//     numericAxisName: 'angleAxis',
//     cateAxisName: 'radiusAxis'
//   };
// };

// /**
//  * Calculate the offset of main part in the svg element
//  * @param  {Object} params.props          Latest props
//  * @param  {Array}  params.graphicalItems The instances of item
//  * @param  {Object} params.xAxisMap       The configuration of x-axis
//  * @param  {Object} params.yAxisMap       The configuration of y-axis
//  * @param  {Object} prevLegendBBox        The boundary box of legend
//  * @return {Object} The offset of main part in the svg element
//  */
// var calculateOffset = function calculateOffset(_ref5, prevLegendBBox) {
//   var props = _ref5.props,
//     graphicalItems = _ref5.graphicalItems,
//     _ref5$xAxisMap = _ref5.xAxisMap,
//     xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap,
//     _ref5$yAxisMap = _ref5.yAxisMap,
//     yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;
//   var width = props.width,
//     height = props.height,
//     children = props.children;
//   var margin = props.margin || {};
//   var brushItem = findChildByType(children, Brush);
//   var legendItem = findChildByType(children, Legend);
//   var offsetH = Object.keys(yAxisMap).reduce(function (result, id) {
//     var entry = yAxisMap[id];
//     var orientation = entry.orientation;
//     if (!entry.mirror && !entry.hide) {
//       return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));
//     }
//     return result;
//   }, {
//     left: margin.left || 0,
//     right: margin.right || 0
//   });
//   var offsetV = Object.keys(xAxisMap).reduce(function (result, id) {
//     var entry = xAxisMap[id];
//     var orientation = entry.orientation;
//     if (!entry.mirror && !entry.hide) {
//       return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, get(result, "".concat(orientation)) + entry.height));
//     }
//     return result;
//   }, {
//     top: margin.top || 0,
//     bottom: margin.bottom || 0
//   });
//   var offset = _objectSpread(_objectSpread({}, offsetV), offsetH);
//   var brushBottom = offset.bottom;
//   if (brushItem) {
//     offset.bottom += brushItem.props.height || Brush.defaultProps.height;
//   }
//   if (legendItem && prevLegendBBox) {
//     // @ts-expect-error margin is optional in props but required in appendOffsetOfLegend
//     offset = appendOffsetOfLegend(offset, graphicalItems, props, prevLegendBBox);
//   }
//   var offsetWidth = width - offset.left - offset.right;
//   var offsetHeight = height - offset.top - offset.bottom;
//   return _objectSpread(_objectSpread({
//     brushBottom: brushBottom
//   }, offset), {}, {
//     // never return negative values for height and width
//     width: Math.max(offsetWidth, 0),
//     height: Math.max(offsetHeight, 0)
//   });
// };
// var generateCategoricalChart = function generateCategoricalChart(_ref6) {
//   var _class;
//   var chartName = _ref6.chartName,
//     GraphicalChild = _ref6.GraphicalChild,
//     _ref6$defaultTooltipE = _ref6.defaultTooltipEventType,
//     defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? 'axis' : _ref6$defaultTooltipE,
//     _ref6$validateTooltip = _ref6.validateTooltipEventTypes,
//     validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? ['axis'] : _ref6$validateTooltip,
//     axisComponents = _ref6.axisComponents,
//     legendContent = _ref6.legendContent,
//     formatAxisMap = _ref6.formatAxisMap,
//     defaultProps = _ref6.defaultProps;
//   var getFormatItems = function getFormatItems(props, currentState) {
//     var graphicalItems = currentState.graphicalItems,
//       stackGroups = currentState.stackGroups,
//       offset = currentState.offset,
//       updateId = currentState.updateId,
//       dataStartIndex = currentState.dataStartIndex,
//       dataEndIndex = currentState.dataEndIndex;
//     var barSize = props.barSize,
//       layout = props.layout,
//       barGap = props.barGap,
//       barCategoryGap = props.barCategoryGap,
//       globalMaxBarSize = props.maxBarSize;
//     var _getAxisNameByLayout = getAxisNameByLayout(layout),
//       numericAxisName = _getAxisNameByLayout.numericAxisName,
//       cateAxisName = _getAxisNameByLayout.cateAxisName;
//     var hasBar = hasGraphicalBarItem(graphicalItems);
//     var sizeList = hasBar && getBarSizeList({
//       barSize: barSize,
//       stackGroups: stackGroups
//     });
//     var formattedItems = [];
//     graphicalItems.forEach(function (item, index) {
//       var displayedData = getDisplayedData(props.data, {
//         graphicalItems: [item],
//         dataStartIndex: dataStartIndex,
//         dataEndIndex: dataEndIndex
//       });
//       var _item$props = item.props,
//         dataKey = _item$props.dataKey,
//         childMaxBarSize = _item$props.maxBarSize;
//       // axisId of the numerical axis
//       var numericAxisId = item.props["".concat(numericAxisName, "Id")];
//       // axisId of the categorical axis
//       var cateAxisId = item.props["".concat(cateAxisName, "Id")];
//       var axisObjInitialValue = {};
//       var axisObj = axisComponents.reduce(function (result, entry) {
//         var _item$type$displayNam, _item$type, _objectSpread6;
//         // map of axisId to axis for a specific axis type
//         var axisMap = currentState["".concat(entry.axisType, "Map")];
//         // axisId of axis we are currently computing
//         var id = item.props["".concat(entry.axisType, "Id")];

//         /**
//          * tell the user in dev mode that their configuration is incorrect if we cannot find a match between
//          * axisId on the chart and axisId on the axis. zAxis does not get passed in the map for ComposedChart,
//          * leave it out of the check for now.
//          */
//         !(axisMap && axisMap[id] || entry.axisType === 'zAxis') ? process.env.NODE_ENV !== "production" ? invariant(false, "Specifying a(n) ".concat(entry.axisType, "Id requires a corresponding ").concat(entry.axisType
//         // @ts-expect-error we should stop reading data from ReactElements
//         , "Id on the targeted graphical component ").concat((_item$type$displayNam = item === null || item === void 0 || (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) !== null && _item$type$displayNam !== void 0 ? _item$type$displayNam : '')) : invariant(false) : void 0;

//         // the axis we are currently formatting
//         var axis = axisMap[id];
//         return _objectSpread(_objectSpread({}, result), {}, (_objectSpread6 = {}, _defineProperty(_objectSpread6, entry.axisType, axis), _defineProperty(_objectSpread6, "".concat(entry.axisType, "Ticks"), getTicksOfAxis(axis)), _objectSpread6));
//       }, axisObjInitialValue);
//       var cateAxis = axisObj[cateAxisName];
//       var cateTicks = axisObj["".concat(cateAxisName, "Ticks")];
//       var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);
//       var itemIsBar = getDisplayName(item.type).indexOf('Bar') >= 0;
//       var bandSize = getBandSizeOfAxis(cateAxis, cateTicks);
//       var barPosition = [];
//       if (itemIsBar) {
//         var _ref7, _getBandSizeOfAxis;
//         // 如果是bar，计算bar的位置
//         var maxBarSize = isNil$1(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
//         var barBandSize = (_ref7 = (_getBandSizeOfAxis = getBandSizeOfAxis(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;
//         barPosition = getBarPosition({
//           barGap: barGap,
//           barCategoryGap: barCategoryGap,
//           bandSize: barBandSize !== bandSize ? barBandSize : bandSize,
//           sizeList: sizeList[cateAxisId],
//           maxBarSize: maxBarSize
//         });
//         if (barBandSize !== bandSize) {
//           barPosition = barPosition.map(function (pos) {
//             return _objectSpread(_objectSpread({}, pos), {}, {
//               position: _objectSpread(_objectSpread({}, pos.position), {}, {
//                 offset: pos.position.offset - barBandSize / 2
//               })
//             });
//           });
//         }
//       }
//       // @ts-expect-error we should stop reading data from ReactElements
//       var composedFn = item && item.type && item.type.getComposedData;
//       if (composedFn) {
//         var _objectSpread7;
//         formattedItems.push({
//           props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {
//             displayedData: displayedData,
//             props: props,
//             dataKey: dataKey,
//             item: item,
//             bandSize: bandSize,
//             barPosition: barPosition,
//             offset: offset,
//             stackedData: stackedData,
//             layout: layout,
//             dataStartIndex: dataStartIndex,
//             dataEndIndex: dataEndIndex
//           }))), {}, (_objectSpread7 = {
//             key: item.key || "item-".concat(index)
//           }, _defineProperty(_objectSpread7, numericAxisName, axisObj[numericAxisName]), _defineProperty(_objectSpread7, cateAxisName, axisObj[cateAxisName]), _defineProperty(_objectSpread7, "animationId", updateId), _objectSpread7)),
//           childIndex: parseChildIndex(item, props.children),
//           item: item
//         });
//       }
//     });
//     return formattedItems;
//   };

//   /**
//    * The AxisMaps are expensive to render on large data sets
//    * so provide the ability to store them in state and only update them when necessary
//    * they are dependent upon the start and end index of
//    * the brush so it's important that this method is called _after_
//    * the state is updated with any new start/end indices
//    *
//    * @param {Object} props          The props object to be used for updating the axismaps
//    * dataStartIndex: The start index of the data series when a brush is applied
//    * dataEndIndex: The end index of the data series when a brush is applied
//    * updateId: The update id
//    * @param {Object} prevState      Prev state
//    * @return {Object} state New state to set
//    */
//   var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups(_ref8, prevState) {
//     var props = _ref8.props,
//       dataStartIndex = _ref8.dataStartIndex,
//       dataEndIndex = _ref8.dataEndIndex,
//       updateId = _ref8.updateId;
//     if (!validateWidthHeight({
//       props: props
//     })) {
//       return null;
//     }
//     var children = props.children,
//       layout = props.layout,
//       stackOffset = props.stackOffset,
//       data = props.data,
//       reverseStackOrder = props.reverseStackOrder;
//     var _getAxisNameByLayout2 = getAxisNameByLayout(layout),
//       numericAxisName = _getAxisNameByLayout2.numericAxisName,
//       cateAxisName = _getAxisNameByLayout2.cateAxisName;
//     var graphicalItems = findAllByType(children, GraphicalChild);
//     var stackGroups = getStackGroupsByAxisId(data, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder);
//     var axisObj = axisComponents.reduce(function (result, entry) {
//       var name = "".concat(entry.axisType, "Map");
//       return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {
//         graphicalItems: graphicalItems,
//         stackGroups: entry.axisType === numericAxisName && stackGroups,
//         dataStartIndex: dataStartIndex,
//         dataEndIndex: dataEndIndex
//       }))));
//     }, {});
//     var offset = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {
//       props: props,
//       graphicalItems: graphicalItems
//     }), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);
//     Object.keys(axisObj).forEach(function (key) {
//       axisObj[key] = formatAxisMap(props, axisObj[key], offset, key.replace('Map', ''), chartName);
//     });
//     var cateAxisMap = axisObj["".concat(cateAxisName, "Map")];
//     var ticksObj = tooltipTicksGenerator(cateAxisMap);
//     var formattedGraphicalItems = getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {
//       dataStartIndex: dataStartIndex,
//       dataEndIndex: dataEndIndex,
//       updateId: updateId,
//       graphicalItems: graphicalItems,
//       stackGroups: stackGroups,
//       offset: offset
//     }));
//     return _objectSpread(_objectSpread({
//       formattedGraphicalItems: formattedGraphicalItems,
//       graphicalItems: graphicalItems,
//       offset: offset,
//       stackGroups: stackGroups
//     }, ticksObj), axisObj);
//   };
//   return _class = /*#__PURE__*/function (_Component) {
//     _inherits(CategoricalChartWrapper, _Component);
//     var _super = _createSuper(CategoricalChartWrapper);
//     function CategoricalChartWrapper(_props) {
//       var _props$id, _props$throttleDelay;
//       var _this;
//       _classCallCheck(this, CategoricalChartWrapper);
//       _this = _super.call(this, _props);
//       _defineProperty(_assertThisInitialized(_this), "eventEmitterSymbol", Symbol('rechartsEventEmitter'));
//       _defineProperty(_assertThisInitialized(_this), "accessibilityManager", new AccessibilityManager());
//       _defineProperty(_assertThisInitialized(_this), "handleLegendBBoxUpdate", function (box) {
//         if (box) {
//           var _this$state = _this.state,
//             dataStartIndex = _this$state.dataStartIndex,
//             dataEndIndex = _this$state.dataEndIndex,
//             updateId = _this$state.updateId;
//           _this.setState(_objectSpread({
//             legendBBox: box
//           }, updateStateOfAxisMapsOffsetAndStackGroups({
//             props: _this.props,
//             dataStartIndex: dataStartIndex,
//             dataEndIndex: dataEndIndex,
//             updateId: updateId
//           }, _objectSpread(_objectSpread({}, _this.state), {}, {
//             legendBBox: box
//           }))));
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleReceiveSyncEvent", function (cId, data, emitter) {
//         if (_this.props.syncId === cId) {
//           if (emitter === _this.eventEmitterSymbol && typeof _this.props.syncMethod !== 'function') {
//             return;
//           }
//           _this.applySyncEvent(data);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleBrushChange", function (_ref9) {
//         var startIndex = _ref9.startIndex,
//           endIndex = _ref9.endIndex;
//         // Only trigger changes if the extents of the brush have actually changed
//         if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
//           var updateId = _this.state.updateId;
//           _this.setState(function () {
//             return _objectSpread({
//               dataStartIndex: startIndex,
//               dataEndIndex: endIndex
//             }, updateStateOfAxisMapsOffsetAndStackGroups({
//               props: _this.props,
//               dataStartIndex: startIndex,
//               dataEndIndex: endIndex,
//               updateId: updateId
//             }, _this.state));
//           });
//           _this.triggerSyncEvent({
//             dataStartIndex: startIndex,
//             dataEndIndex: endIndex
//           });
//         }
//       });
//       /**
//        * The handler of mouse entering chart
//        * @param  {Object} e              Event object
//        * @return {Null}                  null
//        */
//       _defineProperty(_assertThisInitialized(_this), "handleMouseEnter", function (e) {
//         var mouse = _this.getMouseInfo(e);
//         if (mouse) {
//           var _nextState = _objectSpread(_objectSpread({}, mouse), {}, {
//             isTooltipActive: true
//           });
//           _this.setState(_nextState);
//           _this.triggerSyncEvent(_nextState);
//           var onMouseEnter = _this.props.onMouseEnter;
//           if (isFunction(onMouseEnter)) {
//             onMouseEnter(_nextState, e);
//           }
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "triggeredAfterMouseMove", function (e) {
//         var mouse = _this.getMouseInfo(e);
//         var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, {
//           isTooltipActive: true
//         }) : {
//           isTooltipActive: false
//         };
//         _this.setState(nextState);
//         _this.triggerSyncEvent(nextState);
//         var onMouseMove = _this.props.onMouseMove;
//         if (isFunction(onMouseMove)) {
//           onMouseMove(nextState, e);
//         }
//       });
//       /**
//        * The handler of mouse entering a scatter
//        * @param {Object} el The active scatter
//        * @return {Object} no return
//        */
//       _defineProperty(_assertThisInitialized(_this), "handleItemMouseEnter", function (el) {
//         _this.setState(function () {
//           return {
//             isTooltipActive: true,
//             activeItem: el,
//             activePayload: el.tooltipPayload,
//             activeCoordinate: el.tooltipPosition || {
//               x: el.cx,
//               y: el.cy
//             }
//           };
//         });
//       });
//       /**
//        * The handler of mouse leaving a scatter
//        * @return {Object} no return
//        */
//       _defineProperty(_assertThisInitialized(_this), "handleItemMouseLeave", function () {
//         _this.setState(function () {
//           return {
//             isTooltipActive: false
//           };
//         });
//       });
//       /**
//        * The handler of mouse moving in chart
//        * @param  {React.MouseEvent} e        Event object
//        * @return {void} no return
//        */
//       _defineProperty(_assertThisInitialized(_this), "handleMouseMove", function (e) {
//         e.persist();
//         _this.throttleTriggeredAfterMouseMove(e);
//       });
//       /**
//        * The handler if mouse leaving chart
//        * @param {Object} e Event object
//        * @return {Null} no return
//        */
//       _defineProperty(_assertThisInitialized(_this), "handleMouseLeave", function (e) {
//         var nextState = {
//           isTooltipActive: false
//         };
//         _this.setState(nextState);
//         _this.triggerSyncEvent(nextState);
//         var onMouseLeave = _this.props.onMouseLeave;
//         if (isFunction(onMouseLeave)) {
//           onMouseLeave(nextState, e);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleOuterEvent", function (e) {
//         var eventName = getReactEventByType(e);
//         var event = get(_this.props, "".concat(eventName));
//         if (eventName && isFunction(event)) {
//           var _mouse;
//           var mouse;
//           if (/.*touch.*/i.test(eventName)) {
//             mouse = _this.getMouseInfo(e.changedTouches[0]);
//           } else {
//             mouse = _this.getMouseInfo(e);
//           }
//           event((_mouse = mouse) !== null && _mouse !== void 0 ? _mouse : {}, e);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleClick", function (e) {
//         var mouse = _this.getMouseInfo(e);
//         if (mouse) {
//           var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, {
//             isTooltipActive: true
//           });
//           _this.setState(_nextState2);
//           _this.triggerSyncEvent(_nextState2);
//           var onClick = _this.props.onClick;
//           if (isFunction(onClick)) {
//             onClick(_nextState2, e);
//           }
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleMouseDown", function (e) {
//         var onMouseDown = _this.props.onMouseDown;
//         if (isFunction(onMouseDown)) {
//           var _nextState3 = _this.getMouseInfo(e);
//           onMouseDown(_nextState3, e);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleMouseUp", function (e) {
//         var onMouseUp = _this.props.onMouseUp;
//         if (isFunction(onMouseUp)) {
//           var _nextState4 = _this.getMouseInfo(e);
//           onMouseUp(_nextState4, e);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleTouchMove", function (e) {
//         if (e.changedTouches != null && e.changedTouches.length > 0) {
//           _this.throttleTriggeredAfterMouseMove(e.changedTouches[0]);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleTouchStart", function (e) {
//         if (e.changedTouches != null && e.changedTouches.length > 0) {
//           _this.handleMouseDown(e.changedTouches[0]);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "handleTouchEnd", function (e) {
//         if (e.changedTouches != null && e.changedTouches.length > 0) {
//           _this.handleMouseUp(e.changedTouches[0]);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "triggerSyncEvent", function (data) {
//         if (_this.props.syncId !== undefined) {
//           eventCenter.emit(SYNC_EVENT, _this.props.syncId, data, _this.eventEmitterSymbol);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "applySyncEvent", function (data) {
//         var _this$props = _this.props,
//           layout = _this$props.layout,
//           syncMethod = _this$props.syncMethod;
//         var updateId = _this.state.updateId;
//         var dataStartIndex = data.dataStartIndex,
//           dataEndIndex = data.dataEndIndex;
//         if (data.dataStartIndex !== undefined || data.dataEndIndex !== undefined) {
//           _this.setState(_objectSpread({
//             dataStartIndex: dataStartIndex,
//             dataEndIndex: dataEndIndex
//           }, updateStateOfAxisMapsOffsetAndStackGroups({
//             props: _this.props,
//             dataStartIndex: dataStartIndex,
//             dataEndIndex: dataEndIndex,
//             updateId: updateId
//           }, _this.state)));
//         } else if (data.activeTooltipIndex !== undefined) {
//           var chartX = data.chartX,
//             chartY = data.chartY;
//           var activeTooltipIndex = data.activeTooltipIndex;
//           var _this$state2 = _this.state,
//             offset = _this$state2.offset,
//             tooltipTicks = _this$state2.tooltipTicks;
//           if (!offset) {
//             return;
//           }
//           if (typeof syncMethod === 'function') {
//             // Call a callback function. If there is an application specific algorithm
//             activeTooltipIndex = syncMethod(tooltipTicks, data);
//           } else if (syncMethod === 'value') {
//             // Set activeTooltipIndex to the index with the same value as data.activeLabel
//             // For loop instead of findIndex because the latter is very slow in some browsers
//             activeTooltipIndex = -1; // in case we cannot find the element
//             for (var i = 0; i < tooltipTicks.length; i++) {
//               if (tooltipTicks[i].value === data.activeLabel) {
//                 activeTooltipIndex = i;
//                 break;
//               }
//             }
//           }
//           var viewBox = _objectSpread(_objectSpread({}, offset), {}, {
//             x: offset.left,
//             y: offset.top
//           });
//           // When a categorical chart is combined with another chart, the value of chartX
//           // and chartY may beyond the boundaries.
//           var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);
//           var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);
//           var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;
//           var activePayload = getTooltipContent(_this.state, _this.props.data, activeTooltipIndex);
//           var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
//             x: layout === 'horizontal' ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
//             y: layout === 'horizontal' ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
//           } : originCoordinate;
//           _this.setState(_objectSpread(_objectSpread({}, data), {}, {
//             activeLabel: activeLabel,
//             activeCoordinate: activeCoordinate,
//             activePayload: activePayload,
//             activeTooltipIndex: activeTooltipIndex
//           }));
//         } else {
//           _this.setState(data);
//         }
//       });
//       _defineProperty(_assertThisInitialized(_this), "verticalCoordinatesGenerator", function (_ref10, syncWithTicks) {
//         var xAxis = _ref10.xAxis,
//           width = _ref10.width,
//           height = _ref10.height,
//           offset = _ref10.offset;
//         return getCoordinatesOfGrid(getTicks(_objectSpread(_objectSpread(_objectSpread({}, CartesianAxis.defaultProps), xAxis), {}, {
//           ticks: getTicksOfAxis(xAxis, true),
//           viewBox: {
//             x: 0,
//             y: 0,
//             width: width,
//             height: height
//           }
//         })), offset.left, offset.left + offset.width, syncWithTicks);
//       });
//       _defineProperty(_assertThisInitialized(_this), "horizontalCoordinatesGenerator", function (_ref11, syncWithTicks) {
//         var yAxis = _ref11.yAxis,
//           width = _ref11.width,
//           height = _ref11.height,
//           offset = _ref11.offset;
//         return getCoordinatesOfGrid(getTicks(_objectSpread(_objectSpread(_objectSpread({}, CartesianAxis.defaultProps), yAxis), {}, {
//           ticks: getTicksOfAxis(yAxis, true),
//           viewBox: {
//             x: 0,
//             y: 0,
//             width: width,
//             height: height
//           }
//         })), offset.top, offset.top + offset.height, syncWithTicks);
//       });
//       _defineProperty(_assertThisInitialized(_this), "axesTicksGenerator", function (axis) {
//         return getTicksOfAxis(axis, true);
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderCursor", function (element) {
//         var _element$props$active;
//         var _this$state3 = _this.state,
//           isTooltipActive = _this$state3.isTooltipActive,
//           activeCoordinate = _this$state3.activeCoordinate,
//           activePayload = _this$state3.activePayload,
//           offset = _this$state3.offset,
//           activeTooltipIndex = _this$state3.activeTooltipIndex,
//           tooltipAxisBandSize = _this$state3.tooltipAxisBandSize;
//         var tooltipEventType = _this.getTooltipEventType();
//         // The cursor is a part of the Tooltip, and it should be shown (by default) when the Tooltip is active.
//         var isActive = (_element$props$active = element.props.active) !== null && _element$props$active !== void 0 ? _element$props$active : isTooltipActive;
//         if (!element || !element.props.cursor || !isActive || !activeCoordinate || chartName !== 'ScatterChart' && tooltipEventType !== 'axis') {
//           return null;
//         }
//         var layout = _this.props.layout;
//         var restProps;
//         var cursorComp = Curve;
//         if (chartName === 'ScatterChart') {
//           restProps = activeCoordinate;
//           cursorComp = Cross;
//         } else if (chartName === 'BarChart') {
//           restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
//           cursorComp = Rectangle;
//         } else if (layout === 'radial') {
//           var _getRadialCursorPoint = getRadialCursorPoints(activeCoordinate),
//             cx = _getRadialCursorPoint.cx,
//             cy = _getRadialCursorPoint.cy,
//             radius = _getRadialCursorPoint.radius,
//             startAngle = _getRadialCursorPoint.startAngle,
//             endAngle = _getRadialCursorPoint.endAngle;
//           restProps = {
//             cx: cx,
//             cy: cy,
//             startAngle: startAngle,
//             endAngle: endAngle,
//             innerRadius: radius,
//             outerRadius: radius
//           };
//           cursorComp = Sector;
//         } else {
//           restProps = {
//             points: getCursorPoints(layout, activeCoordinate, offset)
//           };
//           cursorComp = Curve;
//         }
//         var key = element.key || '_recharts-cursor';
//         var cursorProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
//           stroke: '#ccc',
//           pointerEvents: 'none'
//         }, offset), restProps), filterProps(element.props.cursor)), {}, {
//           payload: activePayload,
//           payloadIndex: activeTooltipIndex,
//           key: key,
//           className: 'recharts-tooltip-cursor'
//         });
//         return /*#__PURE__*/isValidElement(element.props.cursor) ? /*#__PURE__*/cloneElement(element.props.cursor, cursorProps) : /*#__PURE__*/createElement(cursorComp, cursorProps);
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderPolarAxis", function (element, displayName, index) {
//         var axisType = get(element, 'type.axisType');
//         var axisMap = get(_this.state, "".concat(axisType, "Map"));
//         var axisOption = axisMap && axisMap[element.props["".concat(axisType, "Id")]];
//         return /*#__PURE__*/cloneElement(element, _objectSpread(_objectSpread({}, axisOption), {}, {
//           className: axisType,
//           key: element.key || "".concat(displayName, "-").concat(index),
//           ticks: getTicksOfAxis(axisOption, true)
//         }));
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderXAxis", function (element, displayName, index) {
//         var xAxisMap = _this.state.xAxisMap;
//         var axisObj = xAxisMap[element.props.xAxisId];
//         return _this.renderAxis(axisObj, element, displayName, index);
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderYAxis", function (element, displayName, index) {
//         var yAxisMap = _this.state.yAxisMap;
//         var axisObj = yAxisMap[element.props.yAxisId];
//         return _this.renderAxis(axisObj, element, displayName, index);
//       });
//       /**
//        * Draw grid
//        * @param  {ReactElement} element the grid item
//        * @return {ReactElement} The instance of grid
//        */
//       _defineProperty(_assertThisInitialized(_this), "renderGrid", function (element) {
//         var _this$state4 = _this.state,
//           xAxisMap = _this$state4.xAxisMap,
//           yAxisMap = _this$state4.yAxisMap,
//           offset = _this$state4.offset;
//         var _this$props2 = _this.props,
//           width = _this$props2.width,
//           height = _this$props2.height;
//         var xAxis = getAnyElementOfObject(xAxisMap);
//         var yAxisWithFiniteDomain = find(yAxisMap, function (axis) {
//           return every(axis.domain, Number.isFinite);
//         });
//         var yAxis = yAxisWithFiniteDomain || getAnyElementOfObject(yAxisMap);
//         var props = element.props || {};
//         return /*#__PURE__*/cloneElement(element, {
//           key: element.key || 'grid',
//           x: isNumber(props.x) ? props.x : offset.left,
//           y: isNumber(props.y) ? props.y : offset.top,
//           width: isNumber(props.width) ? props.width : offset.width,
//           height: isNumber(props.height) ? props.height : offset.height,
//           xAxis: xAxis,
//           yAxis: yAxis,
//           offset: offset,
//           chartWidth: width,
//           chartHeight: height,
//           verticalCoordinatesGenerator: props.verticalCoordinatesGenerator || _this.verticalCoordinatesGenerator,
//           horizontalCoordinatesGenerator: props.horizontalCoordinatesGenerator || _this.horizontalCoordinatesGenerator
//         });
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderPolarGrid", function (element) {
//         var _element$props = element.props,
//           radialLines = _element$props.radialLines,
//           polarAngles = _element$props.polarAngles,
//           polarRadius = _element$props.polarRadius;
//         var _this$state5 = _this.state,
//           radiusAxisMap = _this$state5.radiusAxisMap,
//           angleAxisMap = _this$state5.angleAxisMap;
//         var radiusAxis = getAnyElementOfObject(radiusAxisMap);
//         var angleAxis = getAnyElementOfObject(angleAxisMap);
//         var cx = angleAxis.cx,
//           cy = angleAxis.cy,
//           innerRadius = angleAxis.innerRadius,
//           outerRadius = angleAxis.outerRadius;
//         return /*#__PURE__*/cloneElement(element, {
//           polarAngles: Array.isArray(polarAngles) ? polarAngles : getTicksOfAxis(angleAxis, true).map(function (entry) {
//             return entry.coordinate;
//           }),
//           polarRadius: Array.isArray(polarRadius) ? polarRadius : getTicksOfAxis(radiusAxis, true).map(function (entry) {
//             return entry.coordinate;
//           }),
//           cx: cx,
//           cy: cy,
//           innerRadius: innerRadius,
//           outerRadius: outerRadius,
//           key: element.key || 'polar-grid',
//           radialLines: radialLines
//         });
//       });
//       /**
//        * Draw legend
//        * @return {ReactElement}            The instance of Legend
//        */
//       _defineProperty(_assertThisInitialized(_this), "renderLegend", function () {
//         var formattedGraphicalItems = _this.state.formattedGraphicalItems;
//         var _this$props3 = _this.props,
//           children = _this$props3.children,
//           width = _this$props3.width,
//           height = _this$props3.height;
//         var margin = _this.props.margin || {};
//         var legendWidth = width - (margin.left || 0) - (margin.right || 0);
//         var props = getLegendProps({
//           children: children,
//           formattedGraphicalItems: formattedGraphicalItems,
//           legendWidth: legendWidth,
//           legendContent: legendContent
//         });
//         if (!props) {
//           return null;
//         }
//         var item = props.item,
//           otherProps = _objectWithoutProperties(props, _excluded$1);
//         return /*#__PURE__*/cloneElement(item, _objectSpread(_objectSpread({}, otherProps), {}, {
//           chartWidth: width,
//           chartHeight: height,
//           margin: margin,
//           onBBoxUpdate: _this.handleLegendBBoxUpdate
//         }));
//       });
//       /**
//        * Draw Tooltip
//        * @return {ReactElement}  The instance of Tooltip
//        */
//       _defineProperty(_assertThisInitialized(_this), "renderTooltip", function () {
//         var _tooltipItem$props$ac;
//         var children = _this.props.children;
//         var tooltipItem = findChildByType(children, Tooltip);
//         if (!tooltipItem) {
//           return null;
//         }
//         var _this$state6 = _this.state,
//           isTooltipActive = _this$state6.isTooltipActive,
//           activeCoordinate = _this$state6.activeCoordinate,
//           activePayload = _this$state6.activePayload,
//           activeLabel = _this$state6.activeLabel,
//           offset = _this$state6.offset;

//         // The user can set isActive on the Tooltip,
//         // and we respect the user to enable customisation.
//         // The Tooltip is active if the user has set isActive, or if the tooltip is active due to a mouse event.
//         var isActive = (_tooltipItem$props$ac = tooltipItem.props.active) !== null && _tooltipItem$props$ac !== void 0 ? _tooltipItem$props$ac : isTooltipActive;
//         return /*#__PURE__*/cloneElement(tooltipItem, {
//           viewBox: _objectSpread(_objectSpread({}, offset), {}, {
//             x: offset.left,
//             y: offset.top
//           }),
//           active: isActive,
//           label: activeLabel,
//           payload: isActive ? activePayload : [],
//           coordinate: activeCoordinate
//         });
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderBrush", function (element) {
//         var _this$props4 = _this.props,
//           margin = _this$props4.margin,
//           data = _this$props4.data;
//         var _this$state7 = _this.state,
//           offset = _this$state7.offset,
//           dataStartIndex = _this$state7.dataStartIndex,
//           dataEndIndex = _this$state7.dataEndIndex,
//           updateId = _this$state7.updateId;

//         // TODO: update brush when children update
//         return /*#__PURE__*/cloneElement(element, {
//           key: element.key || '_recharts-brush',
//           onChange: combineEventHandlers(_this.handleBrushChange, element.props.onChange),
//           data: data,
//           x: isNumber(element.props.x) ? element.props.x : offset.left,
//           y: isNumber(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),
//           width: isNumber(element.props.width) ? element.props.width : offset.width,
//           startIndex: dataStartIndex,
//           endIndex: dataEndIndex,
//           updateId: "brush-".concat(updateId)
//         });
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderReferenceElement", function (element, displayName, index) {
//         if (!element) {
//           return null;
//         }
//         var _assertThisInitialize = _assertThisInitialized(_this),
//           clipPathId = _assertThisInitialize.clipPathId;
//         var _this$state8 = _this.state,
//           xAxisMap = _this$state8.xAxisMap,
//           yAxisMap = _this$state8.yAxisMap,
//           offset = _this$state8.offset;
//         var _element$props2 = element.props,
//           xAxisId = _element$props2.xAxisId,
//           yAxisId = _element$props2.yAxisId;
//         return /*#__PURE__*/cloneElement(element, {
//           key: element.key || "".concat(displayName, "-").concat(index),
//           xAxis: xAxisMap[xAxisId],
//           yAxis: yAxisMap[yAxisId],
//           viewBox: {
//             x: offset.left,
//             y: offset.top,
//             width: offset.width,
//             height: offset.height
//           },
//           clipPathId: clipPathId
//         });
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderActivePoints", function (_ref12) {
//         var item = _ref12.item,
//           activePoint = _ref12.activePoint,
//           basePoint = _ref12.basePoint,
//           childIndex = _ref12.childIndex,
//           isRange = _ref12.isRange;
//         var result = [];
//         var key = item.props.key;
//         var _item$item$props = item.item.props,
//           activeDot = _item$item$props.activeDot,
//           dataKey = _item$item$props.dataKey;
//         var dotProps = _objectSpread(_objectSpread({
//           index: childIndex,
//           dataKey: dataKey,
//           cx: activePoint.x,
//           cy: activePoint.y,
//           r: 4,
//           fill: getMainColorOfGraphicItem(item.item),
//           strokeWidth: 2,
//           stroke: '#fff',
//           payload: activePoint.payload,
//           value: activePoint.value,
//           key: "".concat(key, "-activePoint-").concat(childIndex)
//         }, filterProps(activeDot)), adaptEventHandlers(activeDot));
//         result.push(CategoricalChartWrapper.renderActiveDot(activeDot, dotProps));
//         if (basePoint) {
//           result.push(CategoricalChartWrapper.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {
//             cx: basePoint.x,
//             cy: basePoint.y,
//             key: "".concat(key, "-basePoint-").concat(childIndex)
//           })));
//         } else if (isRange) {
//           result.push(null);
//         }
//         return result;
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderGraphicChild", function (element, displayName, index) {
//         var item = _this.filterFormatItem(element, displayName, index);
//         if (!item) {
//           return null;
//         }
//         var tooltipEventType = _this.getTooltipEventType();
//         var _this$state9 = _this.state,
//           isTooltipActive = _this$state9.isTooltipActive,
//           tooltipAxis = _this$state9.tooltipAxis,
//           activeTooltipIndex = _this$state9.activeTooltipIndex,
//           activeLabel = _this$state9.activeLabel;
//         var children = _this.props.children;
//         var tooltipItem = findChildByType(children, Tooltip);
//         var _item$props2 = item.props,
//           points = _item$props2.points,
//           isRange = _item$props2.isRange,
//           baseLine = _item$props2.baseLine;
//         var _item$item$props2 = item.item.props,
//           activeDot = _item$item$props2.activeDot,
//           hide = _item$item$props2.hide,
//           activeBar = _item$item$props2.activeBar,
//           activeShape = _item$item$props2.activeShape;
//         var hasActive = Boolean(!hide && isTooltipActive && tooltipItem && (activeDot || activeBar || activeShape));
//         var itemEvents = {};
//         if (tooltipEventType !== 'axis' && tooltipItem && tooltipItem.props.trigger === 'click') {
//           itemEvents = {
//             onClick: combineEventHandlers(_this.handleItemMouseEnter, element.props.onClick)
//           };
//         } else if (tooltipEventType !== 'axis') {
//           itemEvents = {
//             onMouseLeave: combineEventHandlers(_this.handleItemMouseLeave, element.props.onMouseLeave),
//             onMouseEnter: combineEventHandlers(_this.handleItemMouseEnter, element.props.onMouseEnter)
//           };
//         }
//         var graphicalItem = /*#__PURE__*/cloneElement(element, _objectSpread(_objectSpread({}, item.props), itemEvents));
//         function findWithPayload(entry) {
//           // TODO needs to verify dataKey is Function
//           return typeof tooltipAxis.dataKey === 'function' ? tooltipAxis.dataKey(entry.payload) : null;
//         }
//         if (hasActive) {
//           if (activeTooltipIndex >= 0) {
//             var activePoint, basePoint;
//             if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
//               // number transform to string
//               var specifiedKey = typeof tooltipAxis.dataKey === 'function' ? findWithPayload : 'payload.'.concat(tooltipAxis.dataKey.toString());
//               activePoint = findEntryInArray(points, specifiedKey, activeLabel);
//               basePoint = isRange && baseLine && findEntryInArray(baseLine, specifiedKey, activeLabel);
//             } else {
//               activePoint = points === null || points === void 0 ? void 0 : points[activeTooltipIndex];
//               basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
//             }
//             if (activeShape || activeBar) {
//               var activeIndex = element.props.activeIndex !== undefined ? element.props.activeIndex : activeTooltipIndex;
//               return [/*#__PURE__*/cloneElement(element, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {
//                 activeIndex: activeIndex
//               })), null, null];
//             }
//             if (!isNil$1(activePoint)) {
//               return [graphicalItem].concat(_toConsumableArray$1(_this.renderActivePoints({
//                 item: item,
//                 activePoint: activePoint,
//                 basePoint: basePoint,
//                 childIndex: activeTooltipIndex,
//                 isRange: isRange
//               })));
//             }
//           } else {
//             var _this$getItemByXY;
//             /**
//              * We hit this block if consumer uses a Tooltip without XAxis and/or YAxis.
//              * In which case, this.state.activeTooltipIndex never gets set
//              * because the mouse events that trigger that value getting set never get trigged without the axis components.
//              *
//              * An example usage case is a FunnelChart
//              */
//             var _ref13 = (_this$getItemByXY = _this.getItemByXY(_this.state.activeCoordinate)) !== null && _this$getItemByXY !== void 0 ? _this$getItemByXY : {
//                 graphicalItem: graphicalItem
//               },
//               _ref13$graphicalItem = _ref13.graphicalItem,
//               _ref13$graphicalItem$ = _ref13$graphicalItem.item,
//               xyItem = _ref13$graphicalItem$ === void 0 ? element : _ref13$graphicalItem$,
//               childIndex = _ref13$graphicalItem.childIndex;
//             var elementProps = _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {
//               activeIndex: childIndex
//             });
//             return [/*#__PURE__*/cloneElement(xyItem, elementProps), null, null];
//           }
//         }
//         if (isRange) {
//           return [graphicalItem, null, null];
//         }
//         return [graphicalItem, null];
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderCustomized", function (element, displayName, index) {
//         return /*#__PURE__*/cloneElement(element, _objectSpread(_objectSpread({
//           key: "recharts-customized-".concat(index)
//         }, _this.props), _this.state));
//       });
//       _defineProperty(_assertThisInitialized(_this), "renderMap", {
//         CartesianGrid: {
//           handler: _this.renderGrid,
//           once: true
//         },
//         ReferenceArea: {
//           handler: _this.renderReferenceElement
//         },
//         ReferenceLine: {
//           handler: _this.renderReferenceElement
//         },
//         ReferenceDot: {
//           handler: _this.renderReferenceElement
//         },
//         XAxis: {
//           handler: _this.renderXAxis
//         },
//         YAxis: {
//           handler: _this.renderYAxis
//         },
//         Brush: {
//           handler: _this.renderBrush,
//           once: true
//         },
//         Bar: {
//           handler: _this.renderGraphicChild
//         },
//         Line: {
//           handler: _this.renderGraphicChild
//         },
//         Area: {
//           handler: _this.renderGraphicChild
//         },
//         Radar: {
//           handler: _this.renderGraphicChild
//         },
//         RadialBar: {
//           handler: _this.renderGraphicChild
//         },
//         Scatter: {
//           handler: _this.renderGraphicChild
//         },
//         Pie: {
//           handler: _this.renderGraphicChild
//         },
//         Funnel: {
//           handler: _this.renderGraphicChild
//         },
//         Tooltip: {
//           handler: _this.renderCursor,
//           once: true
//         },
//         PolarGrid: {
//           handler: _this.renderPolarGrid,
//           once: true
//         },
//         PolarAngleAxis: {
//           handler: _this.renderPolarAxis
//         },
//         PolarRadiusAxis: {
//           handler: _this.renderPolarAxis
//         },
//         Customized: {
//           handler: _this.renderCustomized
//         }
//       });
//       _this.clipPathId = "".concat((_props$id = _props.id) !== null && _props$id !== void 0 ? _props$id : uniqueId('recharts'), "-clip");

//       // trigger 60fps
//       _this.throttleTriggeredAfterMouseMove = throttle$1(_this.triggeredAfterMouseMove, (_props$throttleDelay = _props.throttleDelay) !== null && _props$throttleDelay !== void 0 ? _props$throttleDelay : 1000 / 60);
//       _this.state = {};
//       return _this;
//     }
//     _createClass(CategoricalChartWrapper, [{
//       key: "componentDidMount",
//       value: function componentDidMount() {
//         var _this$props$margin$le, _this$props$margin$to;
//         this.addListener();
//         this.accessibilityManager.setDetails({
//           container: this.container,
//           offset: {
//             left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,
//             top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0
//           },
//           coordinateList: this.state.tooltipTicks,
//           mouseHandlerCallback: this.triggeredAfterMouseMove,
//           layout: this.props.layout
//         });
//       }
//     }, {
//       key: "getSnapshotBeforeUpdate",
//       value: function getSnapshotBeforeUpdate(prevProps, prevState) {
//         if (!this.props.accessibilityLayer) {
//           return null;
//         }
//         if (this.state.tooltipTicks !== prevState.tooltipTicks) {
//           this.accessibilityManager.setDetails({
//             coordinateList: this.state.tooltipTicks
//           });
//         }
//         if (this.props.layout !== prevProps.layout) {
//           this.accessibilityManager.setDetails({
//             layout: this.props.layout
//           });
//         }
//         if (this.props.margin !== prevProps.margin) {
//           var _this$props$margin$le2, _this$props$margin$to2;
//           this.accessibilityManager.setDetails({
//             offset: {
//               left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,
//               top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0
//             }
//           });
//         }

//         // Something has to be returned for getSnapshotBeforeUpdate
//         return null;
//       }
//     }, {
//       key: "componentDidUpdate",
//       value:
//       // eslint-disable-next-line @typescript-eslint/no-empty-function
//       function componentDidUpdate() {}
//     }, {
//       key: "componentWillUnmount",
//       value: function componentWillUnmount() {
//         this.removeListener();
//         this.throttleTriggeredAfterMouseMove.cancel();
//       }
//     }, {
//       key: "getTooltipEventType",
//       value: function getTooltipEventType() {
//         var tooltipItem = findChildByType(this.props.children, Tooltip);
//         if (tooltipItem && typeof tooltipItem.props.shared === 'boolean') {
//           var eventType = tooltipItem.props.shared ? 'axis' : 'item';
//           return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;
//         }
//         return defaultTooltipEventType;
//       }

//       /**
//        * Get the information of mouse in chart, return null when the mouse is not in the chart
//        * @param  {MousePointer} event    The event object
//        * @return {Object}          Mouse data
//        */
//     }, {
//       key: "getMouseInfo",
//       value: function getMouseInfo(event) {
//         if (!this.container) {
//           return null;
//         }
//         var element = this.container;
//         var boundingRect = element.getBoundingClientRect();
//         var containerOffset = getOffset(boundingRect);
//         var e = {
//           chartX: Math.round(event.pageX - containerOffset.left),
//           chartY: Math.round(event.pageY - containerOffset.top)
//         };
//         var scale = boundingRect.width / element.offsetWidth || 1;
//         var rangeObj = this.inRange(e.chartX, e.chartY, scale);
//         if (!rangeObj) {
//           return null;
//         }
//         var _this$state10 = this.state,
//           xAxisMap = _this$state10.xAxisMap,
//           yAxisMap = _this$state10.yAxisMap;
//         var tooltipEventType = this.getTooltipEventType();
//         if (tooltipEventType !== 'axis' && xAxisMap && yAxisMap) {
//           var xScale = getAnyElementOfObject(xAxisMap).scale;
//           var yScale = getAnyElementOfObject(yAxisMap).scale;
//           var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;
//           var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;
//           return _objectSpread(_objectSpread({}, e), {}, {
//             xValue: xValue,
//             yValue: yValue
//           });
//         }
//         var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);
//         if (toolTipData) {
//           return _objectSpread(_objectSpread({}, e), toolTipData);
//         }
//         return null;
//       }
//     }, {
//       key: "inRange",
//       value: function inRange(x, y) {
//         var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
//         var layout = this.props.layout;
//         var scaledX = x / scale,
//           scaledY = y / scale;
//         if (layout === 'horizontal' || layout === 'vertical') {
//           var offset = this.state.offset;
//           var isInRange = scaledX >= offset.left && scaledX <= offset.left + offset.width && scaledY >= offset.top && scaledY <= offset.top + offset.height;
//           return isInRange ? {
//             x: scaledX,
//             y: scaledY
//           } : null;
//         }
//         var _this$state11 = this.state,
//           angleAxisMap = _this$state11.angleAxisMap,
//           radiusAxisMap = _this$state11.radiusAxisMap;
//         if (angleAxisMap && radiusAxisMap) {
//           var angleAxis = getAnyElementOfObject(angleAxisMap);
//           return inRangeOfSector({
//             x: scaledX,
//             y: scaledY
//           }, angleAxis);
//         }
//         return null;
//       }
//     }, {
//       key: "parseEventsOfWrapper",
//       value: function parseEventsOfWrapper() {
//         var children = this.props.children;
//         var tooltipEventType = this.getTooltipEventType();
//         var tooltipItem = findChildByType(children, Tooltip);
//         var tooltipEvents = {};
//         if (tooltipItem && tooltipEventType === 'axis') {
//           if (tooltipItem.props.trigger === 'click') {
//             tooltipEvents = {
//               onClick: this.handleClick
//             };
//           } else {
//             tooltipEvents = {
//               onMouseEnter: this.handleMouseEnter,
//               onMouseMove: this.handleMouseMove,
//               onMouseLeave: this.handleMouseLeave,
//               onTouchMove: this.handleTouchMove,
//               onTouchStart: this.handleTouchStart,
//               onTouchEnd: this.handleTouchEnd
//             };
//           }
//         }

//         // @ts-expect-error adaptEventHandlers expects DOM Event but generateCategoricalChart works with React UIEvents
//         var outerEvents = adaptEventHandlers(this.props, this.handleOuterEvent);
//         return _objectSpread(_objectSpread({}, outerEvents), tooltipEvents);
//       }
//     }, {
//       key: "addListener",
//       value: function addListener() {
//         eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);
//       }
//     }, {
//       key: "removeListener",
//       value: function removeListener() {
//         eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);
//       }
//     }, {
//       key: "filterFormatItem",
//       value: function filterFormatItem(item, displayName, childIndex) {
//         var formattedGraphicalItems = this.state.formattedGraphicalItems;
//         for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
//           var entry = formattedGraphicalItems[i];
//           if (entry.item === item || entry.props.key === item.key || displayName === getDisplayName(entry.item.type) && childIndex === entry.childIndex) {
//             return entry;
//           }
//         }
//         return null;
//       }
//     }, {
//       key: "renderAxis",
//       value:
//       /**
//        * Draw axis
//        * @param {Object} axisOptions The options of axis
//        * @param {Object} element      The axis element
//        * @param {String} displayName  The display name of axis
//        * @param {Number} index        The index of element
//        * @return {ReactElement}       The instance of x-axes
//        */
//       function renderAxis(axisOptions, element, displayName, index) {
//         var _this$props5 = this.props,
//           width = _this$props5.width,
//           height = _this$props5.height;
//         return /*#__PURE__*/React__default.createElement(CartesianAxis, _extends({}, axisOptions, {
//           className: clsx("recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType), axisOptions.className),
//           key: element.key || "".concat(displayName, "-").concat(index),
//           viewBox: {
//             x: 0,
//             y: 0,
//             width: width,
//             height: height
//           },
//           ticksGenerator: this.axesTicksGenerator
//         }));
//       }
//     }, {
//       key: "renderClipPath",
//       value: function renderClipPath() {
//         var clipPathId = this.clipPathId;
//         var _this$state$offset = this.state.offset,
//           left = _this$state$offset.left,
//           top = _this$state$offset.top,
//           height = _this$state$offset.height,
//           width = _this$state$offset.width;
//         return /*#__PURE__*/React__default.createElement("defs", null, /*#__PURE__*/React__default.createElement("clipPath", {
//           id: clipPathId
//         }, /*#__PURE__*/React__default.createElement("rect", {
//           x: left,
//           y: top,
//           height: height,
//           width: width
//         })));
//       }
//     }, {
//       key: "getXScales",
//       value: function getXScales() {
//         var xAxisMap = this.state.xAxisMap;
//         return xAxisMap ? Object.entries(xAxisMap).reduce(function (res, _ref14) {
//           var _ref15 = _slicedToArray(_ref14, 2),
//             axisId = _ref15[0],
//             axisProps = _ref15[1];
//           return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
//         }, {}) : null;
//       }
//     }, {
//       key: "getYScales",
//       value: function getYScales() {
//         var yAxisMap = this.state.yAxisMap;
//         return yAxisMap ? Object.entries(yAxisMap).reduce(function (res, _ref16) {
//           var _ref17 = _slicedToArray(_ref16, 2),
//             axisId = _ref17[0],
//             axisProps = _ref17[1];
//           return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
//         }, {}) : null;
//       }
//     }, {
//       key: "getXScaleByAxisId",
//       value: function getXScaleByAxisId(axisId) {
//         var _this$state$xAxisMap;
//         return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap === void 0 ? void 0 : _this$state$xAxisMap.scale;
//       }
//     }, {
//       key: "getYScaleByAxisId",
//       value: function getYScaleByAxisId(axisId) {
//         var _this$state$yAxisMap;
//         return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap === void 0 ? void 0 : _this$state$yAxisMap.scale;
//       }
//     }, {
//       key: "getItemByXY",
//       value: function getItemByXY(chartXY) {
//         var _this$state12 = this.state,
//           formattedGraphicalItems = _this$state12.formattedGraphicalItems,
//           activeItem = _this$state12.activeItem;
//         if (formattedGraphicalItems && formattedGraphicalItems.length) {
//           for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
//             var graphicalItem = formattedGraphicalItems[i];
//             var props = graphicalItem.props,
//               item = graphicalItem.item;
//             var itemDisplayName = getDisplayName(item.type);
//             if (itemDisplayName === 'Bar') {
//               var activeBarItem = (props.data || []).find(function (entry) {
//                 return isInRectangle(chartXY, entry);
//               });
//               if (activeBarItem) {
//                 return {
//                   graphicalItem: graphicalItem,
//                   payload: activeBarItem
//                 };
//               }
//             } else if (itemDisplayName === 'RadialBar') {
//               var _activeBarItem = (props.data || []).find(function (entry) {
//                 return inRangeOfSector(chartXY, entry);
//               });
//               if (_activeBarItem) {
//                 return {
//                   graphicalItem: graphicalItem,
//                   payload: _activeBarItem
//                 };
//               }
//             } else if (isFunnel(graphicalItem, activeItem) || isPie(graphicalItem, activeItem) || isScatter(graphicalItem, activeItem)) {
//               var activeIndex = getActiveShapeIndexForTooltip({
//                 graphicalItem: graphicalItem,
//                 activeTooltipItem: activeItem,
//                 itemData: item.props.data
//               });
//               var childIndex = item.props.activeIndex === undefined ? activeIndex : item.props.activeIndex;
//               return {
//                 graphicalItem: _objectSpread(_objectSpread({}, graphicalItem), {}, {
//                   childIndex: childIndex
//                 }),
//                 payload: isScatter(graphicalItem, activeItem) ? item.props.data[activeIndex] : graphicalItem.props.data[activeIndex]
//               };
//             }
//           }
//         }
//         return null;
//       }
//     }, {
//       key: "render",
//       value: function render() {
//         var _this2 = this;
//         if (!validateWidthHeight(this)) {
//           return null;
//         }
//         var _this$props6 = this.props,
//           children = _this$props6.children,
//           className = _this$props6.className,
//           width = _this$props6.width,
//           height = _this$props6.height,
//           style = _this$props6.style,
//           compact = _this$props6.compact,
//           title = _this$props6.title,
//           desc = _this$props6.desc,
//           others = _objectWithoutProperties(_this$props6, _excluded2);
//         var attrs = filterProps(others);

//         // The "compact" mode is mainly used as the panorama within Brush
//         if (compact) {
//           return /*#__PURE__*/React__default.createElement(Surface, _extends({}, attrs, {
//             width: width,
//             height: height,
//             title: title,
//             desc: desc
//           }), this.renderClipPath(), renderByOrder(children, this.renderMap));
//         }
//         if (this.props.accessibilityLayer) {
//           var _this$props$tabIndex, _this$props$role;
//           // Set tabIndex to 0 by default (can be overwritten)
//           attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;
//           // Set role to img by default (can be overwritten)
//           attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : 'img';
//           attrs.onKeyDown = function (e) {
//             _this2.accessibilityManager.keyboardEvent(e);
//             // 'onKeyDown' is not currently a supported prop that can be passed through
//             // if it's added, this should be added: this.props.onKeyDown(e);
//           };

//           attrs.onFocus = function () {
//             _this2.accessibilityManager.focus();
//             // 'onFocus' is not currently a supported prop that can be passed through
//             // if it's added, the focus event should be forwarded to the prop
//           };
//         }

//         var events = this.parseEventsOfWrapper();
//         return /*#__PURE__*/React__default.createElement("div", _extends({
//           className: clsx('recharts-wrapper', className),
//           style: _objectSpread({
//             position: 'relative',
//             cursor: 'default',
//             width: width,
//             height: height
//           }, style)
//         }, events, {
//           ref: function ref(node) {
//             _this2.container = node;
//           },
//           role: "region"
//         }), /*#__PURE__*/React__default.createElement(Surface, _extends({}, attrs, {
//           width: width,
//           height: height,
//           title: title,
//           desc: desc,
//           style: FULL_WIDTH_AND_HEIGHT
//         }), this.renderClipPath(), renderByOrder(children, this.renderMap)), this.renderLegend(), this.renderTooltip());
//       }
//     }]);
//     return CategoricalChartWrapper;
//   }(Component), _defineProperty(_class, "displayName", chartName), _defineProperty(_class, "defaultProps", _objectSpread({
//     layout: 'horizontal',
//     stackOffset: 'none',
//     barCategoryGap: '10%',
//     barGap: 4,
//     margin: {
//       top: 5,
//       right: 5,
//       bottom: 5,
//       left: 5
//     },
//     reverseStackOrder: false,
//     syncMethod: 'index'
//   }, defaultProps)), _defineProperty(_class, "getDerivedStateFromProps", function (nextProps, prevState) {
//     var dataKey = nextProps.dataKey,
//       data = nextProps.data,
//       children = nextProps.children,
//       width = nextProps.width,
//       height = nextProps.height,
//       layout = nextProps.layout,
//       stackOffset = nextProps.stackOffset,
//       margin = nextProps.margin;
//     if (prevState.updateId === undefined) {
//       var defaultState = createDefaultState(nextProps);
//       return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {
//         updateId: 0
//       }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
//         props: nextProps
//       }, defaultState), {}, {
//         updateId: 0
//       }), prevState)), {}, {
//         prevDataKey: dataKey,
//         prevData: data,
//         prevWidth: width,
//         prevHeight: height,
//         prevLayout: layout,
//         prevStackOffset: stackOffset,
//         prevMargin: margin,
//         prevChildren: children
//       });
//     }
//     if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !shallowEqual(margin, prevState.prevMargin)) {
//       var _defaultState = createDefaultState(nextProps);

//       // Fixes https://github.com/recharts/recharts/issues/2143
//       var keepFromPrevState = {
//         // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid
//         // any flickering
//         chartX: prevState.chartX,
//         chartY: prevState.chartY,
//         // The tooltip should stay active when it was active in the previous render. If this is not
//         // the case, the tooltip disappears and immediately re-appears, causing a flickering effect
//         isTooltipActive: prevState.isTooltipActive
//       };
//       var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, {
//         updateId: prevState.updateId + 1
//       });
//       var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);
//       return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({
//         props: nextProps
//       }, newState), prevState)), {}, {
//         prevDataKey: dataKey,
//         prevData: data,
//         prevWidth: width,
//         prevHeight: height,
//         prevLayout: layout,
//         prevStackOffset: stackOffset,
//         prevMargin: margin,
//         prevChildren: children
//       });
//     }
//     if (!isChildrenEqual(children, prevState.prevChildren)) {
//       // update configuration in children
//       var hasGlobalData = !isNil$1(data);
//       var newUpdateId = hasGlobalData ? prevState.updateId : prevState.updateId + 1;
//       return _objectSpread(_objectSpread({
//         updateId: newUpdateId
//       }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
//         props: nextProps
//       }, prevState), {}, {
//         updateId: newUpdateId
//       }), prevState)), {}, {
//         prevChildren: children
//       });
//     }
//     return null;
//   }), _defineProperty(_class, "renderActiveDot", function (option, props) {
//     var dot;
//     if ( /*#__PURE__*/isValidElement(option)) {
//       dot = /*#__PURE__*/cloneElement(option, props);
//     } else if (isFunction(option)) {
//       dot = option(props);
//     } else {
//       dot = /*#__PURE__*/React__default.createElement(Dot, props);
//     }
//     return /*#__PURE__*/React__default.createElement(Layer, {
//       className: "recharts-active-dot",
//       key: props.key
//     }, dot);
//   }), _class;
// };

// /**
//  * @fileOverview Line Chart
//  */
// var LineChart = generateCategoricalChart({
//   chartName: 'LineChart',
//   GraphicalChild: Line,
//   axisComponents: [{
//     axisType: 'xAxis',
//     AxisComp: XAxis
//   }, {
//     axisType: 'yAxis',
//     AxisComp: YAxis
//   }],
//   formatAxisMap: formatAxisMap
// });

// var fontFamilyBase="Open Sans, Tahoma, Geneva, sans-serif";var fontSizeBase="1rem";var lineHeightBase="1rem";var bodyBg="#fff";var sumtCardBg="#f5f5f5";var brandPrimary="#227AB9";var btnPrimaryBg="#227AB9";var btnPrimaryColor="#FFF";var btnDefaultColor="#333";var brandInfo="#00AED3";var brandDanger="#b80000";var brandWarning="#ffc600";var brandSuccess="#1fbba6";var brandAttended="#277F2A";var brandOverdue="#AC0C0C";var brandInprogress="#663C00";var brandRegistered="#157989";var brandNotstarted="#824E3B";var brandAssigned="#11508C";var brandPending="#634A7E";var brandPendingapproval="#6C0505";var brandCanceled="#585858";var headerBarBackground="#494949";var headerBarColor="#EAE8DE";var leftNavHeaderBackground="#222222";var leftNavParentColor="#EAE8DE";var topbarNavActiveStateBackground="#6C6C6C";var topbarNavActiveStateTextColor="#EAE8DE";var topbarNavHoverStateBackground="#424242";var topbarNavHoverStateTextColor="#EAE8DE";var textColor="#333";var grayBase="#000";var sumtBtnDefaultColor="#333";var tableBorderColor="#dfe4e8";var tableHeaderBorderColor="#adadad";var btnLinkDisabledColor="#777777";var tableBgHover="#f4fbff";var tableBgAccent="#fafbfb";var listGroupHoverBg="#f5f5f5";var dropdownDividerBg="#e5e5e5";var toolbarBg="#fafbfb";var toolbarTextColor="#c7ab5f";var toolbarHover="#4a4a4a";var sumtWebpartHeaderText="inherit";var topbarNavTabOutlineColor="#FFFFFF";var defaultVariables = {fontFamilyBase:fontFamilyBase,fontSizeBase:fontSizeBase,lineHeightBase:lineHeightBase,bodyBg:bodyBg,sumtCardBg:sumtCardBg,brandPrimary:brandPrimary,btnPrimaryBg:btnPrimaryBg,btnPrimaryColor:btnPrimaryColor,btnDefaultColor:btnDefaultColor,brandInfo:brandInfo,brandDanger:brandDanger,brandWarning:brandWarning,brandSuccess:brandSuccess,brandAttended:brandAttended,brandOverdue:brandOverdue,brandInprogress:brandInprogress,brandRegistered:brandRegistered,brandNotstarted:brandNotstarted,brandAssigned:brandAssigned,brandPending:brandPending,brandPendingapproval:brandPendingapproval,brandCanceled:brandCanceled,headerBarBackground:headerBarBackground,headerBarColor:headerBarColor,leftNavHeaderBackground:leftNavHeaderBackground,leftNavParentColor:leftNavParentColor,topbarNavActiveStateBackground:topbarNavActiveStateBackground,topbarNavActiveStateTextColor:topbarNavActiveStateTextColor,topbarNavHoverStateBackground:topbarNavHoverStateBackground,topbarNavHoverStateTextColor:topbarNavHoverStateTextColor,textColor:textColor,grayBase:grayBase,sumtBtnDefaultColor:sumtBtnDefaultColor,tableBorderColor:tableBorderColor,tableHeaderBorderColor:tableHeaderBorderColor,btnLinkDisabledColor:btnLinkDisabledColor,tableBgHover:tableBgHover,tableBgAccent:tableBgAccent,listGroupHoverBg:listGroupHoverBg,dropdownDividerBg:dropdownDividerBg,toolbarBg:toolbarBg,toolbarTextColor:toolbarTextColor,toolbarHover:toolbarHover,sumtWebpartHeaderText:sumtWebpartHeaderText,topbarNavTabOutlineColor:topbarNavTabOutlineColor};

// /**
//  - Component for Line chart.
//  - A line chart displays information as a series of data points connected by straight line segments.
//  - A line chart is a way of visually representing an asset's price history using a single, continuous line.
//  - Line charts can be used for any timeframe.
//  - Here we are using Recharts library to implement line chart.
//  */

// function Linechart(_ref) {
//   var data = _ref.data,
//     title = _ref.title,
//     chartWidth = _ref.chartWidth,
//     chartHeight = _ref.chartHeight,
//     xAxisDataKey = _ref.xAxisDataKey,
//     lineDataKey = _ref.lineDataKey,
//     legendName = _ref.legendName,
//     lineType = _ref.lineType,
//     strokeDasharray = _ref.strokeDasharray,
//     connectNulls = _ref.connectNulls;
//   return /*#__PURE__*/React__default.createElement(LineChart, {
//     width: chartWidth,
//     height: chartHeight,
//     data: data,
//     title: title,
//     alt: "chart",
//     accessibilityLayer: true
//   }, /*#__PURE__*/React__default.createElement(XAxis, {
//     dataKey: xAxisDataKey
//   }), /*#__PURE__*/React__default.createElement(YAxis, null), /*#__PURE__*/React__default.createElement(CartesianGrid, {
//     stroke: defaultVariables.tableBorderColor,
//     strokeDasharray: strokeDasharray
//   }), /*#__PURE__*/React__default.createElement(Line, {
//     name: legendName,
//     type: lineType,
//     dataKey: lineDataKey,
//     stroke: defaultVariables.brandPrimary,
//     connectNulls: connectNulls
//   }), /*#__PURE__*/React__default.createElement(Tooltip, null), /*#__PURE__*/React__default.createElement(Legend, null));
// }
// Linechart.propTypes = {
//   /**
//    * The source data, in which each element is an object.
//    */
//   data: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * The title of chart container.
//    */
//   title: PropTypes__default.string,
//   /**
//    * The width of chart container.
//    */
//   chartWidth: PropTypes__default.number,
//   /**
//    * The height of chart container.
//    */
//   chartHeight: PropTypes__default.number,
//   /**
//    * The key of data displayed in the axis. It should match the data passed like 'year' in mock data passed
//    */
//   xAxisDataKey: PropTypes__default.string,
//   /**
//    * The key or getter of a group of data which should be unique in a LineChart
//    */
//   lineDataKey: PropTypes__default.string,
//   /**
//    * The name of data. This option will be used in tooltip and legend to represent a line. If no value was set to this option, the value of dataKey will be used alternatively.
//    */
//   legendName: PropTypes__default.string,
//   /**
//    * The interpolation type of line. And customized interpolation function can be set to type. It's the same as type in Area.
//    */
//   lineType: PropTypes__default.oneOf(['basis', 'basisClosed', 'basisOpen', 'linear', 'linearClosed', 'natural', 'monotoneX', 'monotoneY', 'monotone', 'step', 'stepBefore', 'stepAfter']),
//   /**
//    * The pattern of dashes and gaps used to paint the lines of the grid
//    */
//   strokeDasharray: PropTypes__default.string,
//   /**
//    * Whether to connect a graph line across null points.
//    */
//   connectNulls: PropTypes__default.bool
// };
// Linechart.defaultProps = {
//   data: [],
//   title: '',
//   chartWidth: 500,
//   chartHeight: 300,
//   xAxisDataKey: 'year',
//   lineDataKey: 'Percentage',
//   legendName: 'Growth',
//   lineType: 'monotone',
//   strokeDasharray: '5 5',
//   connectNulls: false
// };

// /**
//  * This component is used to render link as table cell content in DataGrid.
//  */
// function LinkCell(_ref) {
//   var className = _ref.className,
//     email = _ref.email;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue;
//   return /*#__PURE__*/React__default.createElement(Link$1, {
//     href: email ? "mailto:".concat(cellValue) : cellValue,
//     className: className
//   }, cellValue);
// }
// LinkCell.propTypes = {
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * If email is set to  true then it renders as email component
//    */
//   email: PropTypes__default.bool
// };
// LinkCell.defaultProps = {
//   className: undefined,
//   email: true
// };

// var _templateObject$G, _templateObject2$t, _templateObject3$k, _templateObject4$9, _templateObject5$5, _templateObject6$4, _templateObject7$4, _templateObject8$3;
// var ParentContainer = styled(Card)(_templateObject$G || (_templateObject$G = _taggedTemplateLiteral$1(["\n  min-width: ", ";\n  max-width: 18rem;\n  height: ", ";\n  margin: 0.5rem;\n  display: flex;\n  flex-wrap: nowrap;\n}\n"])), function (props) {
//   return props.width;
// }, function (props) {
//   return props.height;
// });
// var FlexyDiv = styled.div(_templateObject2$t || (_templateObject2$t = _taggedTemplateLiteral$1(["\n  display: flex;\n  flex-direction: row;\n  flex-grow: 1;\n}\n"])));
// var StyledDiv$1 = styled.div(_templateObject3$k || (_templateObject3$k = _taggedTemplateLiteral$1(["\n  height: 3rem;\n  width: 7.5rem;\n  max-width: 7.5rem;\n  max-height: 3rem;\n}\n"])));
// var StyledIconButton$3 = styled(IconButton)(_templateObject4$9 || (_templateObject4$9 = _taggedTemplateLiteral$1(["\n color: ", ";\n}\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var DefaultContent = styled(CardContent)(_templateObject5$5 || (_templateObject5$5 = _taggedTemplateLiteral$1(["\n  padding: 0rem 1rem;\n  text-align: left;\n"])));
// var NameContent = styled(CardContent)(_templateObject6$4 || (_templateObject6$4 = _taggedTemplateLiteral$1(["\n  padding: 0rem;\n  flex-grow: 1;\n  align-self: center;\n  text-align: center;\n  margin-bottom: -1.5rem;\n"])));
// var NameCard = styled(Card)(_templateObject7$4 || (_templateObject7$4 = _taggedTemplateLiteral$1(["\n  width: ", ";\n  height: ", ";\n  max-width: 9.5rem;\n  color: ", ";\n  display: flex;\n  border-left: 0.313rem solid ", ";\n  border-right: transparent;\n  border-top: transparent;\n  flex-shrink: 0;\n  background-color: ", ";\n  &.order {\n    order: -1;\n  }\n  ::before {\n    content: ''; /* Create a pseudo-element */\n    position: absolute;\n    top: 10%; /* Adjust the top position to control the divider's height */\n    right: 60%; /* Place the pseudo-element at the right edge of the name card */\n    width: 0.125rem; /* Set the width of the divider */\n    height: 80%; /* Set the divider's height to 80% of the card's height */\n    background-color: ", "; /* Color of the divider */\n  }\n"])), function (props) {
//   return props.width;
// }, function (props) {
//   return props.height;
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (props) {
//   return props.leftBorderColor;
// }, function (props) {
//   return props.theme.variables.bodyBg;
// }, function (props) {
//   return props.dividerColor;
// });
// var Clamp = styled(LineClampText)(_templateObject8$3 || (_templateObject8$3 = _taggedTemplateLiteral$1(["\n  color: ", ";\n  font-weight: bold;\n  flex-grow: 1;\n  line-height: 1.2rem;\n  &.name1-font {\n    font-size: 1.25rem;\n  }\n  &.name2-font {\n    font-size: 0.875rem;\n  }\n  &.title-font {\n    margin-top: 0.75rem;\n    font-size: 0.875rem;\n  }\n"])), function (props) {
//   return props.theme.variables.textColor;
// });

// /**
//  * The MarketSkillCard component is used to display Skills data.
//  */

// function MarketSkillCard(_ref) {
//   var id = _ref.id,
//     name1 = _ref.name1,
//     name2 = _ref.name2,
//     title = _ref.title,
//     description = _ref.description,
//     tooltipTitle = _ref.tooltipTitle,
//     tooltipId = _ref.tooltipId,
//     labelName = _ref.labelName,
//     labelStatus = _ref.labelStatus,
//     height = _ref.height,
//     width = _ref.width,
//     cardNameHeight = _ref.cardNameHeight,
//     cardNameWidth = _ref.cardNameWidth,
//     leftBorderColor = _ref.leftBorderColor,
//     dividerColor = _ref.dividerColor,
//     onClickEventHandle = _ref.onClickEventHandle,
//     onCardClickEvent = _ref.onCardClickEvent;
//   var skillObject = {
//     id: id,
//     name1: name1,
//     name2: name2,
//     title: title,
//     description: description,
//     tooltipId: tooltipId,
//     tooltipTitle: tooltipTitle
//   };
//   var addClick = function addClick(clickEventObject) {
//     onClickEventHandle(clickEventObject); // Passing the object on add icon click event
//   };
//   var cardClick = function cardClick(clickEventObject) {
//     onCardClickEvent(clickEventObject); // Passing the object on card click event
//   };
//   return /*#__PURE__*/React__default.createElement(ParentContainer, {
//     height: height,
//     width: width
//   }, /*#__PURE__*/React__default.createElement(Tooltip$1, {
//     arrow: true,
//     describeChild: true,
//     title: tooltipTitle
//   }, /*#__PURE__*/React__default.createElement("span", {
//     role: "tooltip"
//   }, /*#__PURE__*/React__default.createElement(CardActionArea, {
//     onClick: function onClick() {
//       cardClick(skillObject);
//     }
//   }, /*#__PURE__*/React__default.createElement(FlexyDiv, null, /*#__PURE__*/React__default.createElement(DefaultContent, null, /*#__PURE__*/React__default.createElement(StyledDiv$1, null, /*#__PURE__*/React__default.createElement(Clamp, {
//     className: "title-font",
//     maxLines: labelName && tooltipTitle ? 2 : 4
//   }, title)), labelName && tooltipTitle && /*#__PURE__*/React__default.createElement(StatusLabel, {
//     label: labelName,
//     status: labelStatus
//   }), /*#__PURE__*/React__default.createElement("span", {
//     role: "button",
//     "aria-label": tooltipTitle
//   })), /*#__PURE__*/React__default.createElement(NameCard, {
//     id: id,
//     variant: "outlined",
//     height: cardNameHeight,
//     width: cardNameWidth,
//     leftBorderColor: leftBorderColor,
//     dividerColor: dividerColor,
//     className: "order"
//   }, /*#__PURE__*/React__default.createElement(NameContent, null, /*#__PURE__*/React__default.createElement(Clamp, {
//     className: "name1-font"
//   }, name1), /*#__PURE__*/React__default.createElement(Clamp, {
//     className: "name2-font",
//     maxLines: 1
//   }, name2))))))), /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(StyledIconButton$3, {
//     id: "AddIcon_".concat(id),
//     size: "medium",
//     label: "add skill mapping",
//     onClick: function onClick() {
//       return addClick(skillObject);
//     }
//   }, /*#__PURE__*/React__default.createElement(Icon, {
//     iconType: "MaterialIcon",
//     iconName: "Add",
//     size: 1.25
//   }))));
// }
// // PropType check
// MarketSkillCard.propTypes = {
//   /**
//    * Id of the card
//    */
//   id: PropTypes__default.string,
//   /**
//    * Name1 to be displyed on the Name card
//    */
//   name1: PropTypes__default.string,
//   /**
//    * Name2 to be displyed on the Name card
//    */
//   name2: PropTypes__default.string,
//   /**
//    * Title to be displyed on the card
//    */
//   title: PropTypes__default.string,
//   /**
//    * Description of the card
//    */
//   description: PropTypes__default.string,
//   /**
//    * Title of the tooltip
//    */
//   tooltipTitle: PropTypes__default.string,
//   /**
//    * Id of the tooltip
//    */
//   tooltipId: PropTypes__default.string,
//   /**
//    * Name of the label
//    */
//   labelName: PropTypes__default.string,
//   /**
//    * Status type of the label
//    */
//   labelStatus: PropTypes__default.string,
//   /**
//    * Height of card
//    */
//   height: PropTypes__default.string,
//   /**
//    * Width of card
//    */
//   width: PropTypes__default.string,
//   /**
//    * Height of card name
//    */
//   cardNameHeight: PropTypes__default.string,
//   /**
//    * Width of card name
//    */
//   cardNameWidth: PropTypes__default.string,
//   /**
//    * Left Border Color of the Name card
//    */
//   leftBorderColor: PropTypes__default.string,
//   /**
//    * Divider Color of the Name card
//    */
//   dividerColor: PropTypes__default.string,
//   /**
//    * To pass add click event to parent
//    */
//   onClickEventHandle: PropTypes__default.func,
//   /**
//    * To pass card click event to parent
//    */
//   onCardClickEvent: PropTypes__default.func
// };
// MarketSkillCard.defaultProps = {
//   id: null,
//   name1: null,
//   name2: null,
//   title: null,
//   description: null,
//   tooltipTitle: '',
//   tooltipId: '',
//   labelName: '',
//   labelStatus: 'active',
//   height: '6rem',
//   width: '18rem',
//   cardNameHeight: '6rem',
//   cardNameWidth: '6rem',
//   leftBorderColor: null,
//   dividerColor: null,
//   onClickEventHandle: function onClickEventHandle() {
//     return null;
//   },
//   onCardClickEvent: function onCardClickEvent() {
//     return null;
//   }
// };

// var _templateObject$F;
// var StyledButton$3 = styled(SumtButtonWrapper)(_templateObject$F || (_templateObject$F = _taggedTemplateLiteral$1(["\ncolor: ", ";\nmin-height: 3.25rem;\nfont-weight:", ";\nbackground-color:\n", ";\nborder: 0rem;\nborder-radius: 0rem;\nfont-size: 0.875rem;\npadding: 0.375rem 1rem;\nbox-shadow: none;\ntext-transform: uppercase;\n&:hover {\ncolor: ", ";\n  background-color: transparent;\n  box-shadow: none;\n}\n&:active {\ncolor: ", ";\n  background-color: ", ";\n  font-weight:500;\n}\n&:focus {\ncolor: ", ";\n  background-color: ", ";\n  font-weight:500;\n}\n}\n"])), function (p) {
//   return p.isOpen ? p.theme.variables.leftNavParentColor : p.theme.variables.headerBarColor;
// }, function (props) {
//   return props.isOpen ? 500 : 400;
// }, function (p) {
//   return p.isOpen ? p.theme.variables.leftNavHeaderBackground : 'transparent';
// }, function (p) {
//   return p.isOpen ? p.theme.variables.leftNavParentColor : p.theme.variables.headerBarColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// });

// /**
//  * Component for MegaMenu Button.
//  * MegaMenu Button is used in the TopMenu(for Self, MyTeam and Administration Menus).
//  * On click of this button we show the MegaMenuContainer with MegaMenuHeader and MegaMenuList
//  */
// function MenuButton(_ref) {
//   var children = _ref.children,
//     endIcon = _ref.endIcon,
//     onClick = _ref.onClick,
//     iconType = _ref.iconType,
//     isOpen = _ref.isOpen,
//     menuOpenIcon = _ref.menuOpenIcon,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     onKeyDown = _ref.onKeyDown,
//     ariaLabel = _ref.ariaLabel,
//     ariaExpanded = _ref.ariaExpanded,
//     ariaHasPopUp = _ref.ariaHasPopUp,
//     id = _ref.id,
//     disableFocusRipple = _ref.disableFocusRipple;
//   var icon = endIcon;
//   icon = isOpen && menuOpenIcon ? menuOpenIcon : endIcon;
//   return /*#__PURE__*/React__default.createElement(StyledButton$3, {
//     onClick: onClick,
//     endIcon: /*#__PURE__*/React__default.createElement(Icon, {
//       iconName: icon,
//       iconType: iconType
//     }),
//     variant: "contained",
//     isOpen: isOpen,
//     className: className,
//     disabled: disabled,
//     ariaLabel: ariaLabel,
//     ariaExpanded: ariaExpanded,
//     ariaHasPopUp: ariaHasPopUp,
//     onKeyDown: onKeyDown,
//     id: id,
//     disableFocusRipple: disableFocusRipple
//   }, children);
// }

// // PropType check
// MenuButton.propTypes = {
//   /**
//    * End icon name
//    */
//   endIcon: PropTypes__default.string,
//   /**
//    * Type of the icon
//    */
//   iconType: PropTypes__default.oneOf(['MaterialIcon']),
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Text on the button
//    */
//   children: PropTypes__default.node,
//   /**
//    * Menu container open state flag
//    */
//   isOpen: PropTypes__default.bool,
//   /**
//    * End icon name when menu is open
//    */
//   menuOpenIcon: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * disable Menubutton
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * Id of the button
//    */
//   id: PropTypes__default.string,
//   /**
//    * Value of aria-expanded attribute to be used for button
//    */
//   ariaExpanded: PropTypes__default.bool,
//   /**
//    * Value of aria-haspopup attribute to be used for button
//    */
//   ariaHasPopUp: PropTypes__default.bool,
//   /**
//    * On onKeyDown handler
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * If true, the focus ripple effect will be disabled
//    */
//   disableFocusRipple: PropTypes__default.bool
// };
// MenuButton.defaultProps = {
//   endIcon: 'KeyboardArrowDown',
//   iconType: 'MaterialIcon',
//   children: undefined,
//   isOpen: false,
//   menuOpenIcon: '',
//   className: undefined,
//   disabled: false,
//   onClick: function onClick() {},
//   ariaLabel: null,
//   id: undefined,
//   ariaExpanded: undefined,
//   ariaHasPopUp: undefined,
//   onKeyDown: undefined,
//   disableFocusRipple: false
// };

// /**
//  * SumTotal wrapper for Material-UI DialogTitle component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  */
// function SumtDialogTitleWrapper(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(MuiDialogTitle, {
//     className: className
//   }, children);
// }
// SumtDialogTitleWrapper.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class Name
//    */
//   className: PropTypes__default.string
// };
// SumtDialogTitleWrapper.defaultProps = {
//   children: null,
//   className: undefined
// };

// /**
//  * SumTotal wrapper for Material-UI Dialog component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  */
// function SumtDialogWrapper(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     ariaLabelledBy = _ref.ariaLabelledBy,
//     ariaDescribedBy = _ref.ariaDescribedBy,
//     onClose = _ref.onClose,
//     open = _ref.open,
//     fullScreen = _ref.fullScreen,
//     fullWidth = _ref.fullWidth,
//     maxWidth = _ref.maxWidth;
//   return /*#__PURE__*/React__default.createElement(Dialog, {
//     className: className,
//     "aria-labelledby": ariaLabelledBy,
//     "aria-describedby": ariaDescribedBy,
//     onClose: onClose,
//     open: open,
//     fullScreen: fullScreen,
//     fullWidth: fullWidth,
//     maxWidth: maxWidth
//   }, children);
// }
// SumtDialogWrapper.propTypes = {
//   /**
//    * Dialog children, usually the included sub-components
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class Name
//    */
//   className: PropTypes__default.string,
//   /**
//    * The id(s) of the element(s) that label the dialog.
//    */
//   ariaLabelledBy: PropTypes__default.string,
//   /**
//    * The id(s) of the element(s) that describe the dialog.
//    */
//   ariaDescribedBy: PropTypes__default.string,
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * If true, the Dialog is open.
//    */
//   open: PropTypes__default.bool,
//   /**
//    * If `true`, the dialog will be full-screen
//    */
//   fullScreen: PropTypes__default.bool,
//   /**
//    * If `true`, the dialog stretches to `maxWidth`.
//    *
//    * Notice that the dialog width grow is limited by the default margin.
//    */
//   fullWidth: PropTypes__default.bool,
//   /**
//    * Determine the max-width of the dialog.
//    * The dialog width grows with the size of the screen.
//    * Set to `false` to disable `maxWidth`.
//    */
//   maxWidth: PropTypes__default.oneOf(['lg', 'md', 'sm', 'xl', 'xs', false])
// };
// SumtDialogWrapper.defaultProps = {
//   children: null,
//   className: undefined,
//   ariaLabelledBy: null,
//   ariaDescribedBy: null,
//   onClose: undefined,
//   open: false,
//   fullScreen: false,
//   fullWidth: false,
//   maxWidth: false
// };

// var _templateObject$E, _templateObject2$s;
// var StyledSumtModal = styled(SumtDialogWrapper)(_templateObject$E || (_templateObject$E = _taggedTemplateLiteral$1(["\n & .MuiDialog-paper{\n    height: ", ";\n  },\n  .MuiDialogTitle-root  {\n    padding: 1rem 1rem .25rem 1rem;\n    h2\n      {\n        width: 35rem;\n        color: ", ";\n        font-size: 1.5rem;\n        font-weight: bold;\n        line-height: 1.875rem;\n        text-transform: uppercase;\n        margin: 0;\n      }\n  }\n"])), function (props) {
//   return props.height;
// }, function (props) {
//   return props.theme.variables.textColor;
// });
// var StyledIconButton$2 = styled(IconButton)(_templateObject2$s || (_templateObject2$s = _taggedTemplateLiteral$1(["\n  position: absolute;\n  right: .5rem;\n  top: 1rem;\n  padding: .5rem;\n"])));

// /**
//  * The Modal pop-up is a dialog to display critical information or provide choices.
//  * It is for adding dynamic content and buttons as per requirement.
//  *
//  */
// var Modal = function Modal(props) {
//   var title = props.title,
//     children = props.children,
//     _onClose = props.onClose,
//     open = props.open,
//     height = props.height,
//     fullWidth = props.fullWidth,
//     maxWidth = props.maxWidth,
//     closeLabel = props.closeLabel,
//     className = props.className;
//   return /*#__PURE__*/React__default.createElement(StyledSumtModal, {
//     onClose: function onClose() {
//       return _onClose;
//     },
//     open: open,
//     fullWidth: fullWidth,
//     maxWidth: maxWidth,
//     ariaLabelledBy: "popupTitle",
//     ariaDescribedBy: "popupContent",
//     className: className,
//     height: height
//   }, /*#__PURE__*/React__default.createElement(SumtDialogTitleWrapper, null, title, /*#__PURE__*/React__default.createElement(StyledIconButton$2, {
//     onClick: _onClose,
//     color: "inherit",
//     label: closeLabel
//   }, /*#__PURE__*/React__default.createElement(Icon, {
//     iconType: "MaterialIcon",
//     iconName: "Close",
//     size: 1
//   }))), children);
// };
// Modal.propTypes = {
//   /**
//    * Title heading of the modal
//    */
//   title: PropTypes__default.string,
//   /**
//    * Modal children, usually the included sub-components
//    */
//   children: PropTypes__default.node,
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * If true, the Dialog is open.
//    */
//   open: PropTypes__default.bool,
//   /**
//    * Height of the modal
//    */
//   height: PropTypes__default.string,
//   /**
//    * If true, the dialog stretches to maxWidth
//    */
//   fullWidth: PropTypes__default.bool,
//   /**
//    * Determine the max-width of the dialog. The dialog width grows with the size of the screen.
//    */
//   maxWidth: PropTypes__default.oneOf(['lg', 'md', 'sm', 'xl', 'xs', false]),
//   /**
//    * Translated label for close button label
//    */
//   closeLabel: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// Modal.defaultProps = {
//   title: null,
//   children: null,
//   onClose: function onClose() {
//     return null;
//   },
//   open: null,
//   height: 'auto',
//   fullWidth: false,
//   maxWidth: 'sm',
//   closeLabel: 'Close',
//   className: ''
// };

// function InputLabel(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     focused = _ref.focused,
//     id = _ref.id,
//     required = _ref.required,
//     shrink = _ref.shrink;
//   return /*#__PURE__*/React__default.createElement(MuiInputLabel, {
//     className: className,
//     focused: focused,
//     required: required,
//     shrink: shrink,
//     id: id
//   }, children);
// }
// InputLabel.propTypes = {
//   /**
//    * the content of the component
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * className
//    */
//   className: PropTypes__default.string,
//   /**
//    * if true, the input of this label is focused
//    */
//   focused: PropTypes__default.bool,
//   /**
//    * id
//    */
//   id: PropTypes__default.string,
//   /**
//    * if true, the label will indicate that the input is required
//    */
//   required: PropTypes__default.bool,
//   /**
//    * if true, the label is shrunk
//    */
//   shrink: PropTypes__default.bool
// };
// InputLabel.defaultProps = {
//   className: undefined,
//   focused: undefined,
//   id: undefined,
//   required: false,
//   shrink: undefined
// };

// /**
//  * Select component is a component that allows users pick a value from predefined options.
//  */
// function Select(_ref) {
//   var autoWidth = _ref.autoWidth,
//     children = _ref.children,
//     className = _ref.className,
//     displayEmpty = _ref.displayEmpty,
//     label = _ref.label,
//     labelId = _ref.labelId,
//     menuProps = _ref.menuProps,
//     notched = _ref.notched,
//     multiple = _ref.multiple,
//     onChange = _ref.onChange,
//     onOpen = _ref.onOpen,
//     value = _ref.value,
//     variant = _ref.variant,
//     renderValue = _ref.renderValue;
//   return /*#__PURE__*/React__default.createElement(MuiSelect, {
//     autoWidth: autoWidth,
//     className: className,
//     displayEmpty: displayEmpty,
//     label: label,
//     labelId: labelId,
//     multiple: multiple,
//     notched: notched,
//     MenuProps: menuProps,
//     onChange: onChange,
//     onOpen: onOpen,
//     value: value,
//     variant: variant,
//     renderValue: renderValue
//   }, children);
// }
// Select.propTypes = {
//   /**
//    * to set the width of the popover
//    */
//   autoWidth: PropTypes__default.bool,
//   /**
//    * the option elements to populate the select with
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * className
//    */
//   className: PropTypes__default.string,
//   /**
//    * if true, a value is displayed even if no items are selected
//    */
//   displayEmpty: PropTypes__default.bool,
//   /**
//    * label
//    */
//   label: PropTypes__default.string,
//   /**
//    * the ID of an element that acts as an additional label
//    */
//   labelId: PropTypes__default.string,
//   /**
//    * props applied to the Menu element
//    */
//   menuProps: PropTypes__default.shape({}),
//   /**
//    * if true, the outline is notched to accommodate the label
//    */
//   notched: PropTypes__default.bool,
//   /**
//    * support for multiple selections
//    */
//   multiple: PropTypes__default.bool,
//   /**
//    * callback fired when a menu item is selected
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * onOpen
//    */
//   onOpen: PropTypes__default.func,
//   /**
//    * the input value
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.any]),
//   /**
//    * the variant to use
//    */
//   variant: PropTypes__default.oneOf(['filled', 'outlined', 'standard']),
//   /**
//    * render the selected value
//    */
//   renderValue: PropTypes__default.func
// };
// Select.defaultProps = {
//   autoWidth: false,
//   className: undefined,
//   displayEmpty: false,
//   label: '',
//   labelId: '',
//   menuProps: {},
//   multiple: false,
//   notched: undefined,
//   onChange: undefined,
//   onOpen: function onOpen() {},
//   value: '',
//   variant: undefined,
//   renderValue: undefined
// };

// var _excluded = ["className", "menuProps"];
// var _templateObject$D;
// var StyledSelect = styled(function (_ref) {
//   var _menuProps$classes;
//   var className = _ref.className,
//     menuProps = _ref.menuProps,
//     props = _objectWithoutProperties$j(_ref, _excluded);
//   var classList = className;
//   if (menuProps !== null && menuProps !== void 0 && (_menuProps$classes = menuProps.classes) !== null && _menuProps$classes !== void 0 && _menuProps$classes.paper) {
//     classList = "".concat(classList, " ").concat(menuProps.classes.paper);
//   }
//   return /*#__PURE__*/React__default.createElement(Select, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
//     menuProps: _objectSpread2$1(_objectSpread2$1({}, menuProps), {}, {
//       classes: {
//         paper: classList
//       }
//     })
//   }));
// })(_templateObject$D || (_templateObject$D = _taggedTemplateLiteral$1(["\n  overflow-y: hidden;\n"])));

// /**
//  * The MultiSelectCheckbox control is a Form Control designed to facilitate the selection of multiple items from a list of objects
//  */

// function MultiSelectCheckbox(_ref) {
//   var className = _ref.className,
//     displayEmpty = _ref.displayEmpty,
//     label = _ref.label,
//     labelId = _ref.labelId,
//     labelNotched = _ref.labelNotched,
//     labelShrink = _ref.labelShrink,
//     menuProps = _ref.menuProps,
//     onChange = _ref.onChange,
//     options = _ref.options,
//     renderValue = _ref.renderValue,
//     reset = _ref.reset,
//     variant = _ref.variant;
//   var _useState = useState$1([]),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     selectedOptions = _useState2[0],
//     setSelectedOptions = _useState2[1];
//   useEffect$2(function () {
//     if (reset) setSelectedOptions([]);
//   }, [reset]);
//   var handleOpen = function handleOpen() {
//     setTimeout(function () {
//       if (options[0]) {
//         var li = document.getElementById(options[0]);
//         if (li) {
//           li.focus();
//         }
//       }
//     }, 100);
//   };
//   var handleChange = function handleChange(clickedOption) {
//     var newSelectedOptions = selectedOptions.filter(function (option) {
//       return option !== clickedOption;
//     });
//     if (newSelectedOptions.length === selectedOptions.length) newSelectedOptions.push(clickedOption);
//     setSelectedOptions(newSelectedOptions);
//     onChange(_toConsumableArray$d(newSelectedOptions));
//   };
//   return /*#__PURE__*/React__default.createElement(FormControl, {
//     variant: variant,
//     className: className
//   }, label && /*#__PURE__*/React__default.createElement(InputLabel, {
//     id: labelId,
//     shrink: labelShrink
//   }, label), /*#__PURE__*/React__default.createElement(StyledSelect, {
//     displayEmpty: displayEmpty,
//     multiple: true,
//     menuProps: menuProps,
//     label: label || '',
//     labelId: labelId,
//     notched: variant === 'outlined' ? labelNotched : undefined,
//     onOpen: handleOpen,
//     value: selectedOptions,
//     renderValue: renderValue
//   }, /*#__PURE__*/React__default.createElement(CustomScrollbar, {
//     translateContentSizeYToHolder: true
//   }, options.map(function (option) {
//     return /*#__PURE__*/React__default.createElement(MenuItem, {
//       key: option,
//       value: option,
//       id: option,
//       role: "option",
//       "aria-selected": selectedOptions.includes(option),
//       onClick: function onClick() {
//         return handleChange(option);
//       }
//     }, /*#__PURE__*/React__default.createElement(Checkbox, {
//       checked: selectedOptions.includes(option)
//     }), /*#__PURE__*/React__default.createElement(ListItemText, {
//       primary: option
//     }));
//   }))));
// }
// MultiSelectCheckbox.propTypes = {
//   /**
//    * className
//    */
//   className: PropTypes__default.string,
//   /**
//    * if true, a value is displayed even if no items are selected
//    */
//   displayEmpty: PropTypes__default.bool,
//   /**
//    * label for the select
//    */
//   label: PropTypes__default.string,
//   /**
//    * the ID of an element that acts as an additional label
//    */
//   labelId: PropTypes__default.string,
//   /**
//    * if true, the outline is notched to accommodate the label
//    */
//   labelNotched: PropTypes__default.bool,
//   /**
//    * if true, the label is shrunk
//    */
//   labelShrink: PropTypes__default.bool,
//   /**
//    * props applied to the Menu element
//    */
//   menuProps: PropTypes__default.shape({}),
//   /**
//    * onChange handler
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * options array
//    */
//   options: PropTypes__default.arrayOf(PropTypes__default.string),
//   /**
//    * render the selected options
//    */
//   renderValue: PropTypes__default.func,
//   /**
//    * reset the selected values
//    */
//   reset: PropTypes__default.bool,
//   /**
//    * the variant to use
//    */
//   variant: PropTypes__default.oneOf(['outlined', 'filled', 'standard'])
// };
// MultiSelectCheckbox.defaultProps = {
//   className: undefined,
//   displayEmpty: undefined,
//   label: undefined,
//   labelId: undefined,
//   labelNotched: undefined,
//   labelShrink: undefined,
//   menuProps: {},
//   onChange: function onChange() {},
//   options: [],
//   renderValue: function renderValue(selected) {
//     return "".concat(selected.length, " selected");
//   },
//   reset: false,
//   variant: 'outlined'
// };

// var _templateObject$C;
// var StyledBreadCrumbs$1 = styled(MuiBreadcrumbs)(_templateObject$C || (_templateObject$C = _taggedTemplateLiteral$1(["\n .MuiBreadcrumbs-separator {\n color: ", ";\n font-size: 0.75rem;\n opacity: 0.5;\n margin-left: 0.25rem;\n margin-right: 0.25rem;\n }\n"])), function (props) {
//   return props.theme.variables.textColor;
// });

// /**
//  * Breadcrumb is a list of links that shows the location of the current page in an app hierarchy
//  */
// function Breadcrumbs(_ref) {
//   var separator = _ref.separator,
//     maxItems = _ref.maxItems,
//     itemsBeforeCollapse = _ref.itemsBeforeCollapse,
//     itemsAfterCollapse = _ref.itemsAfterCollapse,
//     children = _ref.children,
//     className = _ref.className,
//     ariaLabel = _ref.ariaLabel;
//   return /*#__PURE__*/React__default.createElement(StyledBreadCrumbs$1, {
//     separator: separator,
//     maxItems: maxItems,
//     itemsBeforeCollapse: itemsBeforeCollapse,
//     itemsAfterCollapse: itemsAfterCollapse,
//     className: className,
//     "aria-label": ariaLabel
//   }, children);
// }

// // PropType check
// Breadcrumbs.propTypes = {
//   /**
//    * Custom separator node
//    */
//   separator: PropTypes__default.node,
//   /**
//    * Maximum number of breadcrumbs to display
//    */
//   maxItems: PropTypes__default.number,
//   /**
//    * If max items is exceeded, the number of items to show before the ellipsis.
//    */
//   itemsBeforeCollapse: PropTypes__default.number,
//   /**
//    * If max items is exceeded, the number of items to show after the ellipsis.
//    */
//   itemsAfterCollapse: PropTypes__default.number,
//   /**
//    * Child elements for the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for Nav element
//    */
//   ariaLabel: PropTypes__default.string
// };
// Breadcrumbs.defaultProps = {
//   separator: '/',
//   maxItems: 8,
//   itemsBeforeCollapse: 1,
//   itemsAfterCollapse: 1,
//   children: undefined,
//   className: '',
//   ariaLabel: null
// };

// var _templateObject$B, _templateObject2$r, _templateObject3$j, _templateObject4$8;
// var StyledRoutLink = styled(RouteLink)(_templateObject$B || (_templateObject$B = _taggedTemplateLiteral$1(["\ndisplay: flex;\nalign-items: center;\nfont-size: 0.875rem;\ncolor: ", ";\ntext-decoration: none;\n&:focus{\n outline-color: -webkit-focus-ring-color;\n outline-style: auto;\n outline-width: 0.063rem;\n text-decoration: underline;\n}\n&:hover {\n text-decoration: underline;\n}\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var HomeStyledRoutLink = styled(StyledRoutLink)(_templateObject2$r || (_templateObject2$r = _taggedTemplateLiteral$1(["\npadding: 0.188rem;\n&:focus{\n background-color: ", ";\n}\n&:hover {\n background-color: ", ";\n border-radius: 50%;\n}\n"])), function (props) {
//   return alpha$1(props.theme.variables.btnPrimaryBg, 0.3);
// }, function (props) {
//   return alpha$1(props.theme.variables.btnPrimaryBg, 0.3);
// });
// var StyledBreadCrumbs = styled(Breadcrumbs)(_templateObject3$j || (_templateObject3$j = _taggedTemplateLiteral$1(["\n.MuiBreadcrumbs-separator {\ncolor: ", ";\nfont-size: 0.75rem;\nopacity: 0.5;\nmargin-left: 0.25rem;\nmargin-right: 0.25rem;\n}\n"])), function (props) {
//   return props.theme.variables.textColor;
// });
// var StyledSpan$1 = styled.span(_templateObject4$8 || (_templateObject4$8 = _taggedTemplateLiteral$1(["\ncolor: ", ";\nfont-size: 0.875rem;\n"])), function (props) {
//   return props.theme.variables.textColor;
// });

// /**
//  * NavigationBreadcrumbs provide links back to each previous page the user navigated through to get to the current page or—in hierarchical site structures—the parent pages of the current one.
//  */
// function NavigationBreadcrumbs(_ref) {
//   var breadCrumbsData = _ref.breadCrumbsData,
//     breadCrumbNavClick = _ref.breadCrumbNavClick,
//     navAriaLabel = _ref.navAriaLabel,
//     homeIconLabel = _ref.homeIconLabel,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledBreadCrumbs, {
//     ariaLabel: navAriaLabel,
//     className: className
//   }, /*#__PURE__*/React__default.createElement(Tooltip$1, {
//     arrow: true,
//     title: homeIconLabel
//   }, /*#__PURE__*/React__default.createElement(HomeStyledRoutLink, {
//     to: "/",
//     accessibilitylabel: homeIconLabel,
//     onClick: function onClick(e) {
//       return breadCrumbNavClick ? breadCrumbNavClick(e, 'Home') : null;
//     }
//   }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//     iconName: "Home",
//     size: 0.75
//   }))), breadCrumbsData.map(function (breadcrumb, index) {
//     return index < breadCrumbsData.length - 1 ? /*#__PURE__*/React__default.createElement(Tooltip$1, {
//       arrow: true,
//       title: breadcrumb.title,
//       key: breadcrumb.title
//     }, /*#__PURE__*/React__default.createElement(StyledRoutLink, {
//       to: breadcrumb.url,
//       onClick: function onClick(e) {
//         return breadCrumbNavClick ? breadCrumbNavClick(e, breadcrumb, index) : null;
//       }
//     }, breadcrumb.title.length > 50 ? "".concat(breadcrumb.title.substring(0, 50), "...") : breadcrumb.title)) : /*#__PURE__*/React__default.createElement(Tooltip$1, {
//       arrow: true,
//       title: breadcrumb.title,
//       key: breadcrumb.title
//     }, /*#__PURE__*/React__default.createElement(StyledSpan$1, null, breadcrumb.title.length > 50 ? "".concat(breadcrumb.title.substring(0, 50), "...") : breadcrumb.title));
//   }));
// }
// // PropType check
// NavigationBreadcrumbs.propTypes = {
//   /**
//    * NavigationBreadcrumbs data
//    */
//   breadCrumbsData: PropTypes$1.arrayOf(PropTypes$1.shape({})),
//   /**
//    * Callback fired when breadcrumbs link clicked.
//    */
//   breadCrumbNavClick: PropTypes$1.func,
//   /**
//    * Value of aria-label attribute to be used for Nav element
//    */
//   navAriaLabel: PropTypes$1.string,
//   /**
//    * Value of aria-label attribute to be used for Home Icon
//    */
//   homeIconLabel: PropTypes$1.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes$1.string
// };
// NavigationBreadcrumbs.defaultProps = {
//   breadCrumbsData: [],
//   breadCrumbNavClick: undefined,
//   navAriaLabel: null,
//   homeIconLabel: 'Home',
//   className: ''
// };

// var _templateObject$A, _templateObject2$q, _templateObject3$i;
// var NodataElement = styled.div(_templateObject$A || (_templateObject$A = _taggedTemplateLiteral$1(["\n  padding-top: 1.5rem;\n  text-align: center;\n  font-size: 1.5rem;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.textColor;
// });
// var IconContainer = styled.div(_templateObject2$q || (_templateObject2$q = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: center;\n  height: ", "rem;\n"])), function (props) {
//   return props.height;
// });
// var StyledImage$1 = styled(Image$1)(_templateObject3$i || (_templateObject3$i = _taggedTemplateLiteral$1(["\n  max-width: ", "rem;\n  max-height: ", "rem;\n"])), function (props) {
//   return props.maxWidth;
// }, function (props) {
//   return props.maxHeight;
// });

// /**
//  * Display custom message when there are no records to display.This components supports custom height and width as modal popups and few other screens will have smaller tables/less space to show this message.
//  */

// function NoRecordsPlaceholder(_ref) {
//   var maxHeight = _ref.maxHeight,
//     maxWidth = _ref.maxWidth,
//     src = _ref.src,
//     text = _ref.text,
//     ariaHidden = _ref.ariaHidden,
//     alt = _ref.alt;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(IconContainer, {
//     height: maxHeight
//   }, /*#__PURE__*/React__default.createElement(StyledImage$1, {
//     src: src,
//     maxHeight: maxHeight,
//     maxWidth: maxWidth,
//     alt: alt
//   })), /*#__PURE__*/React__default.createElement(NodataElement, {
//     "aria-hidden": ariaHidden
//   }, text));
// }

// // PropType check
// NoRecordsPlaceholder.propTypes = {
//   /**
//    * max-height of the image
//    */

//   maxHeight: PropTypes__default.number,
//   /**
//    * max-width of the image
//    */

//   maxWidth: PropTypes__default.number,
//   /**
//    * source url of the image
//    */
//   src: PropTypes__default.string,
//   /**
//    * display text
//    */
//   text: PropTypes__default.string,
//   /**
//    * aria-hidden for text
//    */
//   ariaHidden: PropTypes__default.bool,
//   /**
//    * alternate text of image
//    */
//   alt: PropTypes__default.string
// };
// NoRecordsPlaceholder.defaultProps = {
//   maxHeight: 6.25,
//   maxWidth: 6.25,
//   src: '',
//   text: '',
//   ariaHidden: undefined,
//   alt: ''
// };

// /**
//  * SumTotal wrapper for Material-UI Backdrop component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  */
// function SumtBackdropWrapper(_ref) {
//   var show = _ref.show,
//     className = _ref.className,
//     children = _ref.children;
//   return /*#__PURE__*/React__default.createElement(MuiBackdrop, {
//     open: show,
//     className: className
//   }, children);
// }
// SumtBackdropWrapper.propTypes = {
//   /**
//    * If `true`, the Backdrop is shown
//    */
//   show: PropTypes__default.bool,
//   /**
//    * Child elements for the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// SumtBackdropWrapper.defaultProps = {
//   show: false,
//   children: undefined,
//   className: undefined
// };

// var _templateObject$z;
// var StyledBackdrop = styled(SumtBackdropWrapper)(_templateObject$z || (_templateObject$z = _taggedTemplateLiteral$1(["\n  z-index: 2000;\n"])));

// /**
//  * The PageLoader component is used to provide emphasis loading on a page.
//  */
// function PageLoader(_ref) {
//   var show = _ref.show,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledBackdrop, {
//     show: show,
//     className: className
//   }, /*#__PURE__*/React__default.createElement(Loader, null));
// }
// PageLoader.propTypes = {
//   /**
//    * If `true`, the PageLoader is shown
//    */
//   show: PropTypes__default.bool,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string
// };
// PageLoader.defaultProps = {
//   show: false,
//   className: undefined
// };

// /**
//  * PageTitleDescription component is used to display page heading and description.
//  */

// function PageTitleDescription(_ref) {
//   var title = _ref.title,
//     description = _ref.description;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(PageTitle, {
//     title: title
//   }), /*#__PURE__*/React__default.createElement(BodyText, {
//     text: description
//   }));
// }

// // PropType check
// PageTitleDescription.propTypes = {
//   /**
//    * title text
//    */
//   title: PropTypes__default.string,
//   /**
//    * description text
//    */
//   description: PropTypes__default.string
// };
// PageTitleDescription.defaultProps = {
//   /**
//    * default title
//    */
//   title: '',
//   /**
//    * default title
//    */
//   description: ''
// };

// function useReactTable$1() {
//   var _useContext = useContext(TableContext),
//     tableInstance = _useContext.tableInstance;
//   return tableInstance;
// }
// function PaginationContainer(_ref) {
//   var children = _ref.children,
//     pageSize = _ref.pageSize,
//     pageIndex = _ref.pageIndex,
//     getRowsCount = _ref.getRowsCount;
//   var _useReactTable = useReactTable$1(),
//     setPageSize = _useReactTable.setPageSize,
//     gotoPage = _useReactTable.gotoPage,
//     rows = _useReactTable.rows,
//     state = _useReactTable.state;
//   useEffect$2(function () {
//     setPageSize(Number(pageSize));
//     if (getRowsCount) {
//       getRowsCount(rows.length);
//     }
//     gotoPage(pageIndex);
//   }, [pageSize, setPageSize, pageIndex, getRowsCount, rows.length, gotoPage]);
//   var handleItemOnClick = function handleItemOnClick(onClickFn) {
//     if (onClickFn) return function (e) {
//       onClickFn(e);
//       gotoPage(pageIndex);
//       setPageSize(e.target.value);
//     };
//   };
//   var handleNavigation = function handleNavigation(onChange) {
//     if (onChange) return function (e, newPage) {
//       onChange(e, newPage);
//       gotoPage(newPage - 1);
//     };
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, React__default.Children.map(children, function (child) {
//     if (child) {
//       return /*#__PURE__*/React__default.cloneElement(child, {
//         onChangeRowsPerPage: handleItemOnClick(child.props.onChangeRowsPerPage),
//         onChange: handleNavigation(child.props.onChange),
//         count: rows.length,
//         page: state.pageIndex + 1,
//         pageRange: state.pageIndex
//       });
//     }
//   }));
// }
// PaginationContainer.propTypes = {
//   /**
//    * pagination components .
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * The current page.
//    */
//   pageSize: PropTypes__default.number,
//   /**
//    * The set default page.
//    */
//   pageIndex: PropTypes__default.number,
//   getRowsCount: PropTypes__default.func
// };
// PaginationContainer.defaultProps = {
//   pageIndex: 0,
//   pageSize: 10,
//   getRowsCount: undefined
// };

// var _templateObject$y, _templateObject2$p, _templateObject3$h;
// var StyledDrawer = styled(Drawer)(_templateObject$y || (_templateObject$y = _taggedTemplateLiteral$1(["\n  .MuiDrawer-paper {\n    width: 33.938rem;\n    box-shadow: -0.25rem 0rem 0.25rem\n      ", ";\n    top: 9.063rem;\n    border-radius: 1.125rem 0rem 0rem 0rem;\n    background-color: ", ";\n    & .panel-header {\n      position: sticky;\n      top: 0;\n      z-index: 1;\n    }\n  }\n"])), function (props) {
//   return props.theme.variables.textColor;
// }, function (props) {
//   return curriedLighten$1(0.2, props.theme.variables.bodyBg);
// });
// var CloseButton = styled(IconButton)(_templateObject2$p || (_templateObject2$p = _taggedTemplateLiteral$1(["\n  position: absolute;\n  right: 0.375rem;\n  top: 0.375rem;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.headerBarColor;
// });
// var StyledTabs = styled(Tabs)(_templateObject3$h || (_templateObject3$h = _taggedTemplateLiteral$1(["\n  padding-left: 2rem;\n  padding-bottom: 0.5rem;\n  background-color: ", ";\n  .MuiTab-root {\n    color: ", ";\n  }\n  .MuiTabs-indicator {\n    background-color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.headerBarBackground;
// }, function (props) {
//   return props.theme.variables.headerBarColor;
// }, function (props) {
//   return props.theme.variables.headerBarColor;
// });

// function Panel(_ref) {
//   var anchor = _ref.anchor,
//     elevation = _ref.elevation,
//     children = _ref.children,
//     className = _ref.className,
//     open = _ref.open,
//     variant = _ref.variant,
//     hideBackdrop = _ref.hideBackdrop,
//     onCloseSlideout = _ref.onCloseSlideout,
//     onTabchange = _ref.onTabchange,
//     defaultTabValue = _ref.defaultTabValue,
//     closeButtonLabel = _ref.closeButtonLabel,
//     tabsInfo = _ref.tabsInfo;
//   var _useState = useState$1(defaultTabValue),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     tabValue = _useState2[0],
//     setTabValue = _useState2[1];
//   var handleTabChange = function handleTabChange(event, newValue) {
//     setTabValue(newValue);
//     onTabchange(newValue);
//   };
//   var handleSlideoutClose = function handleSlideoutClose() {
//     setTabValue(defaultTabValue);
//     onCloseSlideout();
//   };
//   return /*#__PURE__*/React__default.createElement(StyledDrawer, {
//     anchor: anchor,
//     elevation: elevation,
//     open: open,
//     variant: variant,
//     className: className,
//     hideBackdrop: hideBackdrop
//   }, /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
//     className: "panel-header"
//   }, /*#__PURE__*/React__default.createElement(StyledTabs, {
//     value: tabValue,
//     onChange: handleTabChange
//   }, tabsInfo.map(function (val) {
//     return /*#__PURE__*/React__default.createElement(Tab, {
//       id: "panel_".concat(val.key),
//       key: val.key,
//       value: val.value,
//       label: val.label
//     });
//   })), /*#__PURE__*/React__default.createElement(CloseButton, {
//     label: closeButtonLabel,
//     size: "small",
//     color: "primary",
//     disableRipple: false,
//     disableFocusRipple: false,
//     onClick: handleSlideoutClose
//   }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//     size: 0.88,
//     iconName: "Close"
//   }))), children));
// }

// // PropType check
// Panel.propTypes = {
//   /**
//    * Side from which the drawer will appear.The elevation of the drawer.
//    */
//   anchor: PropTypes__default.oneOf(['bottom', 'left', 'right', 'top']),
//   /**
//    * The elevation of the drawer.The content of the component.
//    */
//   elevation: PropTypes__default.number,
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * If true, the component is shown.
//    */
//   open: PropTypes__default.bool,
//   /**
//    * The variant to use.
//    */
//   variant: PropTypes__default.oneOf(['permanent', 'persistent', 'temporary']),
//   /**
//    * If true, the backdrop is not rendered.
//    */
//   hideBackdrop: PropTypes__default.bool,
//   /**
//    * Slide-out close call back method.
//    */
//   onCloseSlideout: PropTypes__default.func,
//   /**
//    * Tab change call back method.
//    */
//   onTabchange: PropTypes__default.func,
//   /**
//    * Default tab selected.
//    */
//   defaultTabValue: PropTypes__default.string,
//   /**
//    * close button label.
//    */
//   closeButtonLabel: PropTypes__default.string,
//   /**
//    * Tab values and labels for the tabs in the widget panel.
//    */
//   tabsInfo: PropTypes__default.arrayOf(PropTypes__default.shape({}))
// };
// Panel.defaultProps = {
//   anchor: undefined,
//   elevation: 16,
//   children: null,
//   className: '',
//   open: false,
//   variant: 'temporary',
//   hideBackdrop: false,
//   onCloseSlideout: undefined,
//   onTabchange: undefined,
//   defaultTabValue: 'Widgets',
//   closeButtonLabel: 'Close icon button',
//   tabsInfo: [{}]
// };

// var _templateObject$x;
// var PersonResultData = styled(LineClampText)(_templateObject$x || (_templateObject$x = _taggedTemplateLiteral$1(["\n  margin: 0 0 0.5rem;\n  font-size: 1rem;\n  line-height: 1.2;\n"])));

// function PersonSearchResult(_ref) {
//   var name = _ref.name,
//     secondaryInfo = _ref.secondaryInfo,
//     tertiaryInfo = _ref.tertiaryInfo,
//     avatarSource = _ref.avatarSource,
//     avatarSize = _ref.avatarSize;
//   return /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     spacing: 3,
//     justifyContent: "center",
//     alignItems: "center"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Avatar, {
//     src: avatarSource,
//     height: avatarSize,
//     width: avatarSize
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     xs: 12,
//     sm: true,
//     container: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     xs: true,
//     container: true,
//     direction: "column",
//     spacing: 2
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     xs: true
//   }, /*#__PURE__*/React__default.createElement(PersonResultData, {
//     maxLines: 1
//   }, /*#__PURE__*/React__default.createElement("strong", null, name)), /*#__PURE__*/React__default.createElement(PersonResultData, {
//     maxLines: 1
//   }, secondaryInfo), /*#__PURE__*/React__default.createElement(PersonResultData, {
//     maxLines: 1
//   }, tertiaryInfo)))));
// }
// PersonSearchResult.propTypes = {
//   name: PropTypes__default.string,
//   secondaryInfo: PropTypes__default.string,
//   tertiaryInfo: PropTypes__default.string,
//   avatarSource: PropTypes__default.string,
//   avatarSize: PropTypes__default.number
// };
// PersonSearchResult.defaultProps = {
//   name: '',
//   secondaryInfo: '',
//   tertiaryInfo: '',
//   avatarSource: '',
//   avatarSize: 3.75
// };

// var _templateObject$w, _templateObject2$o, _templateObject3$g, _templateObject4$7, _templateObject5$4, _templateObject6$3, _templateObject7$3, _templateObject8$2, _templateObject9$1;
// var TextElementStyled$2 = styled.p(_templateObject$w || (_templateObject$w = _taggedTemplateLiteral$1(["\n  font-size: 0.75rem;\n  margin: 0rem;\n  padding-top: 0.125rem;\n  word-break: break-word;\n  font-weight: normal;\n"])));
// var NameElementStyled = styled(TextElementStyled$2)(_templateObject2$o || (_templateObject2$o = _taggedTemplateLiteral$1(["\n  font-size: 0.875rem;\n  font-weight: 600;\n  padding-bottom: 0.125rem;\n"])));
// var MetricElementStyled = styled(TextElementStyled$2)(_templateObject3$g || (_templateObject3$g = _taggedTemplateLiteral$1(["\n  padding-top: 0.5rem;\n"])));
// var StyledButton$2 = styled(SumtButtonWrapper)(_templateObject4$7 || (_templateObject4$7 = _taggedTemplateLiteral$1(["\n  padding: 0rem;\n  width: 100%;\n  height: 100%;\n  border: none;\n  box-shadow: none;\n  margin-bottom: 0.25rem;\n  margin-top: -0.8rem;\n  &:hover,\n  &:active,\n  &:focus {\n    background-color: ", ";\n    border: none;\n    box-shadow: none;\n    transform: scale(1.0769);\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// });
// var AvatarMenuItem = styled(MenuItem)(_templateObject5$4 || (_templateObject5$4 = _taggedTemplateLiteral$1(["\n  cursor: ", ";\n  background-color: ", ";\n  justify-content: center;\n  margin-top: 0rem;\n  height: 7.5rem;\n  margin-bottom: 0rem;\n  padding: 1.125rem 1.5rem 0.8rem 0.75rem;\n  color: ", ";\n  &.MuiMenuItem-root {\n    line-height: 0rem;\n  }\n  &.Mui-focusVisible {\n    background-color: ", ";\n    #profileButton {\n      transform: scale(1.0769);\n    }\n  }\n  &:focus {\n    background-color: ", ";\n  }\n  &:active {\n    background-color: ", ";\n  }\n  &:hover {\n    background-color: ", ";\n  }\n"])), function (props) {
//   return props.$isGuestUser ? 'default' : 'auto';
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// });
// var UserInfoMenuItem = styled(MenuItem)(_templateObject6$3 || (_templateObject6$3 = _taggedTemplateLiteral$1(["\n  cursor: ", ";\n  justify-content: center;\n  display: list-item;\n  background-color: ", ";\n  margin-top: 0rem;\n  margin-bottom: 0rem;\n  padding: 0rem 0.75rem 1.125rem 0.75rem;\n  text-align: center;\n  word-break: break-word;\n  text-transform: capitalize;\n  color: ", ";\n  &.MuiMenuItem-root {\n    line-height: 1rem;\n  }\n  &.MuiListItem-root.Mui-focusVisible {\n    background-color: ", ";\n    #userInfoLink {\n      transform: scale(1.0769);\n    }\n  }\n  &:focus {\n    background-color: ", ";\n  }\n  &:active {\n    background-color: ", ";\n  }\n  &:hover {\n    background-color: ", ";\n  }\n"])), function (props) {
//   return props.$showLink ? 'auto' : 'default';
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// });
// var StyledRouteLink$3 = styled(RouteLink)(_templateObject7$3 || (_templateObject7$3 = _taggedTemplateLiteral$1(["\n  text-decoration: none;\n  font-size: 0.875rem;\n  font-weight: 600;\n  padding: 0.125rem 0rem;\n  color: ", ";\n  &:focus {\n    color: ", ";\n    transform: scale(1.0769);\n    outline: none;\n  }\n  &:hover {\n    color: ", ";\n    transform: scale(1.0769);\n    outline: none;\n  }\n  &:active {\n    color: ", ";\n    transform: scale(1.0769);\n    outline: none;\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });
// var StyledAvatar = styled(Avatar)(_templateObject8$2 || (_templateObject8$2 = _taggedTemplateLiteral$1(["\n  margin-bottom: 0.25rem;\n"])));
// var StyledAvatarWithoutDonut = styled(Avatar)(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteral$1(["\n  margin-bottom: -0.5rem;\n  margin-left: 0.4rem;\n  margin-top: 0.5rem;\n"])));

// /**
//  * Component for Profile Menu Body.
//  */

// function ProfilePopoutBody(_ref) {
//   var textLine1 = _ref.textLine1,
//     textLine2 = _ref.textLine2,
//     textLine3 = _ref.textLine3,
//     imagePath = _ref.imagePath,
//     url = _ref.url,
//     showLink = _ref.showLink,
//     isGuestUser = _ref.isGuestUser,
//     onAvatarClick = _ref.onAvatarClick,
//     onUserNameClick = _ref.onUserNameClick,
//     ariaLabelForTextLine1 = _ref.ariaLabelForTextLine1,
//     ariaLabelForTextLine2 = _ref.ariaLabelForTextLine2,
//     ariaLabelForTextLine3 = _ref.ariaLabelForTextLine3,
//     value = _ref.value,
//     donutVariant = _ref.donutVariant,
//     showDonut = _ref.showDonut;
//   // Function for wraping the text based on characters length
//   function WrapText(data, charlength, limit) {
//     return data && data.length > charlength ? "".concat(data.substring(0, limit), "...") : data;
//   }
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(AvatarMenuItem, {
//     tabIndex: -1,
//     $isGuestUser: isGuestUser,
//     disableRipple: isGuestUser
//   }, isGuestUser ? /*#__PURE__*/React__default.createElement(StyledAvatar, {
//     src: imagePath,
//     height: 4.0625,
//     width: 4.0625,
//     alt: textLine1,
//     ariaLabel: ariaLabelForTextLine1
//   }) : /*#__PURE__*/React__default.createElement(StyledButton$2, {
//     id: "profileButton",
//     onClick: onAvatarClick,
//     disableRipple: true,
//     ariaLabel: ariaLabelForTextLine1,
//     role: "none",
//     tabIndex: -1
//   }, !showDonut ? /*#__PURE__*/React__default.createElement(StyledAvatarWithoutDonut, {
//     src: imagePath,
//     height: 4.0625,
//     width: 4.0625,
//     alt: textLine1,
//     ariaLabel: ariaLabelForTextLine1
//   }) : /*#__PURE__*/React__default.createElement(AvatarDonut, {
//     donutVariant: donutVariant,
//     value: value,
//     imageUrl: imagePath,
//     alt: textLine1,
//     size: 77,
//     thickness: 2
//   }))), /*#__PURE__*/React__default.createElement(UserInfoMenuItem, {
//     tabIndex: -1,
//     $showLink: showLink,
//     disableRipple: !showLink
//   }, showLink ? /*#__PURE__*/React__default.createElement(StyledRouteLink$3, {
//     id: "userInfoLink",
//     to: url,
//     onClick: onUserNameClick,
//     role: "none",
//     txtarealabel: showDonut ? ariaLabelForTextLine2 : ariaLabelForTextLine3
//   }, WrapText(textLine1, 42, 39), textLine2 && textLine2.length > 0 && /*#__PURE__*/React__default.createElement(TextElementStyled$2, null, WrapText(textLine2, 56, 53)), textLine3 && textLine3.length > 0 && showDonut && /*#__PURE__*/React__default.createElement(MetricElementStyled, null, WrapText(textLine3, 56, 53))) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(NameElementStyled, null, WrapText(textLine1, 42, 39)), textLine2 && textLine2.length > 0 && /*#__PURE__*/React__default.createElement(TextElementStyled$2, null, WrapText(textLine2, 56, 53)), textLine3 && textLine3.length > 0 && showDonut && /*#__PURE__*/React__default.createElement(MetricElementStyled, null, WrapText(textLine3, 56, 53)))));
// }
// ProfilePopoutBody.propTypes = {
//   /**
//    * text to show in line 1
//    */
//   textLine1: PropTypes__default.string,
//   /**
//    * text to show in line 2
//    */
//   textLine2: PropTypes__default.string,
//   /**
//    * text to show in line 3
//    */
//   textLine3: PropTypes__default.string,
//   /**
//    * image path
//    */
//   imagePath: PropTypes__default.string,
//   /**
//    * url
//    */

//   url: PropTypes__default.string,
//   /**
//    * show/hide the link for username and jobtitle
//    */

//   showLink: PropTypes__default.bool,
//   /**
//    * Disable the click for avatar
//    */

//   isGuestUser: PropTypes__default.bool,
//   /**
//    * Parent callback event
//    */
//   onAvatarClick: PropTypes__default.func,
//   /**
//    * Parent callback event
//    */
//   onUserNameClick: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   ariaLabelForTextLine1: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   ariaLabelForTextLine2: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   ariaLabelForTextLine3: PropTypes__default.string,
//   value: PropTypes__default.number.isRequired,
//   donutVariant: PropTypes__default.oneOf(['Info', 'Warning', 'Success', 'Danger']),
//   /**
//    * showDonut to show donut or not.
//    */
//   showDonut: PropTypes__default.bool
// };
// // DefaultPropType check
// ProfilePopoutBody.defaultProps = {
//   textLine1: '',
//   textLine2: '',
//   textLine3: '',
//   imagePath: '',
//   url: '',
//   showLink: false,
//   isGuestUser: false,
//   onAvatarClick: undefined,
//   onUserNameClick: undefined,
//   ariaLabelForTextLine1: null,
//   ariaLabelForTextLine2: null,
//   ariaLabelForTextLine3: null,
//   donutVariant: 'Success',
//   showDonut: true
// };

// var _templateObject$v, _templateObject2$n, _templateObject3$f;
// var Label$6 = styled(FormLabel)(_templateObject$v || (_templateObject$v = _taggedTemplateLiteral$1(["\n  margin-top: 0.625rem;\n"])));
// var HintLabel$5 = styled(Label$6)(_templateObject2$n || (_templateObject2$n = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// styled.div(_templateObject3$f || (_templateObject3$f = _taggedTemplateLiteral$1(["\n  margin-top: 0.938rem;\n"])));

// /**
//  * Question Feedback component used in Question types e.g. Fill in the Blanks, Multiple Choice (Under Questions folder).
//  *
//  */

// var QuestionFeedback = function QuestionFeedback(_ref) {
//   var onCodeChange = _ref.onCodeChange,
//     onQuestionChange = _ref.onQuestionChange,
//     onFeedbackChange = _ref.onFeedbackChange,
//     codeLabel = _ref.codeLabel,
//     questionLabel = _ref.questionLabel,
//     questionMaximumLabel = _ref.questionMaximumLabel,
//     questionFeedbackLabel = _ref.questionFeedbackLabel,
//     editData = _ref.editData,
//     translationMode = _ref.translationMode;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     questionCode = _useState2[0],
//     setQuestionCode = _useState2[1];
//   var questionEditorRef = useRef$2(null);
//   var feedbackEditorRef = useRef$2(null);
//   var codeHandler = function codeHandler(event) {
//     var value = event.target.value;
//     setQuestionCode(value);
//     onCodeChange(value);
//   };
//   var questionHandler = function questionHandler(event) {
//     if (event !== undefined) {
//       var value = event.editor.getData();
//       onQuestionChange(value);
//     }
//   };
//   var feedbackHandler = function feedbackHandler(event) {
//     if (event !== undefined) {
//       var value = event.editor.getData();
//       onFeedbackChange(value);
//     }
//   };
//   useEffect$2(function () {
//     if (editData) {
//       setQuestionCode(editData.Code);

//       // Update CKEditor for question text
//       if (questionEditorRef.current && editData.QuestionText) {
//         questionEditorRef.current.editor.setData(editData.QuestionText);
//       }

//       // Update CKEditor for feedback
//       if (feedbackEditorRef.current && editData.QuestionFeedback) {
//         feedbackEditorRef.current.editor.setData(editData.QuestionFeedback);
//       }
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [editData]);
//   return /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label$6, null, codeLabel)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(TextField, {
//     id: "question-code",
//     value: questionCode,
//     disabled: translationMode,
//     onChange: function onChange(evt) {
//       return codeHandler(evt);
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$6, {
//     item: true
//   }, questionLabel), /*#__PURE__*/React__default.createElement(HintLabel$5, {
//     item: true
//   }, questionMaximumLabel))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "question",
//     onChange: function onChange(evt) {
//       return questionHandler(evt);
//     },
//     initData: editData === null || editData === void 0 ? void 0 : editData.QuestionText,
//     onReady: function onReady(editor) {
//       questionEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label$6, null, questionFeedbackLabel)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "question-feedback",
//     onChange: function onChange(evt) {
//       return feedbackHandler(evt);
//     },
//     initData: editData === null || editData === void 0 ? void 0 : editData.QuestionFeedback,
//     onReady: function onReady(editor) {
//       feedbackEditorRef.current = editor;
//     }
//   })));
// };
// var optionsPropTypes$5 = {
//   AnswerID: PropTypes__default.arrayOf(PropTypes__default.string),
//   AnswerText: PropTypes__default.arrayOf(PropTypes__default.string),
//   Feedback: PropTypes__default.string,
//   MatchAnswerText: PropTypes__default.string,
//   WeightPercent: PropTypes__default.string,
//   IsCorrect: PropTypes__default.bool,
//   IsCaseSensitive: PropTypes__default.bool,
//   Shuffle: PropTypes__default.bool
// };
// var editDataPropTypes$5 = {
//   QuestionType: PropTypes__default.number,
//   Code: PropTypes__default.string,
//   QuestionText: PropTypes__default.string,
//   QuestionFeedback: PropTypes__default.string,
//   Options: PropTypes__default.arrayOf(PropTypes__default.shape(optionsPropTypes$5))
// };
// QuestionFeedback.propTypes = {
//   /**
//    * editData contains all data for edit
//    */
//   editData: PropTypes__default.shape(editDataPropTypes$5),
//   /**
//    * onCodeChange executes callback to send Question Code value
//    */
//   onCodeChange: PropTypes__default.func.isRequired,
//   /**
//    * onQuestionChange executes callback to send Question value
//    */
//   onQuestionChange: PropTypes__default.func.isRequired,
//   /**
//    * onFeedbackChange executes callback to send Question Feedback value
//    */
//   onFeedbackChange: PropTypes__default.func.isRequired,
//   /**
//    * codeLabel displays Question Code label
//    */
//   codeLabel: PropTypes__default.string,
//   /**
//    * questionLabel displays Question label
//    */
//   questionLabel: PropTypes__default.string,
//   /**
//    * questionMaximumLabel displays Question Maximum Note
//    */
//   questionMaximumLabel: PropTypes__default.string,
//   /**
//    * questionFeedbackLabel displays Question Feedback label
//    */
//   questionFeedbackLabel: PropTypes__default.string,
//   /**
//    *   Action type translate based on this prop value disabling some of the input fields
//    *   which should not editable while adding the translated question from the base question
//    */
//   translationMode: PropTypes__default.bool
// };
// QuestionFeedback.defaultProps = {
//   codeLabel: 'Question Code:',
//   questionLabel: 'Question: *',
//   questionMaximumLabel: 'Question maximum: 4000 characters',
//   questionFeedbackLabel: 'Question Feedback:',
//   editData: undefined,
//   translationMode: false
// };

// /**
//  * SumTotal wrapper for Material-UI RadioGroup component
//  * This component is to be used only as a base component for building other components
//  * and shouldn't used directly in organisms or pages.
//  * Refer to RadioGroup components in Molecules section.
//  */
// function SumtRadioGroupWrapper(_ref) {
//   var ariaLabel = _ref.ariaLabel,
//     value = _ref.value,
//     onChange = _ref.onChange,
//     role = _ref.role,
//     children = _ref.children,
//     className = _ref.className,
//     onKeyDown = _ref.onKeyDown;
//   return /*#__PURE__*/React__default.createElement(MuiRadioGroup, {
//     "aria-label": ariaLabel,
//     value: value,
//     onChange: onChange,
//     role: role,
//     className: className,
//     onKeyDown: onKeyDown
//   }, children);
// }
// SumtRadioGroupWrapper.propTypes = {
//   /**
//    * Radio Group aria label.
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * value of the selected radio button
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * Callback fired when the state is changed.
//    *
//    * @param {object} event The event source of the callback.
//    * You can pull out the new value by accessing `event.target.value` (string).
//    * You can pull out the new checked state by accessing `event.target.checked` (boolean).
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Radio Group aria label.
//    */
//   role: PropTypes__default.string,
//   /**
//    * The content of the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * To handle key event fired.
//    */
//   onKeyDown: PropTypes__default.func
// };
// SumtRadioGroupWrapper.defaultProps = {
//   ariaLabel: undefined,
//   value: undefined,
//   onChange: undefined,
//   role: 'radiogroup',
//   children: undefined,
//   className: undefined,
//   onKeyDown: undefined
// };

// /**
//  * RadioGroup is a widget that allows you to define a set of radio buttons and the user can choose one of it as an option.
//  */
// function RadioGroup(_ref) {
//   var children = _ref.children,
//     value = _ref.value,
//     onChange = _ref.onChange,
//     label = _ref.label,
//     ariaLabel = _ref.ariaLabel,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     onKeyDown = _ref.onKeyDown;
//   return /*#__PURE__*/React__default.createElement(FormControl, {
//     className: className,
//     disabled: disabled
//   }, label && /*#__PURE__*/React__default.createElement(FormLabel, null, label), /*#__PURE__*/React__default.createElement(SumtRadioGroupWrapper, {
//     ariaLabel: ariaLabel,
//     value: value,
//     onChange: onChange,
//     role: ariaLabel ? 'radiogroup' : null,
//     onKeyDown: onKeyDown
//   }, children));
// }
// RadioGroup.propTypes = {
//   /**
//    * The content of the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * Callback fired when the state is changed.
//    *
//    * @param {object} event The event source of the callback.
//    * You can pull out the new value by accessing `event.target.value` (string).
//    * You can pull out the new checked state by accessing `event.target.checked` (boolean).
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * value of the selected radio button
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * Radio Group Label.
//    * Either label or ariaLabel is mandatory
//    */
//   label: PropTypes__default.string,
//   /**
//    * Radio Group aria label.
//    * Either label or ariaLabel is mandatory
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * disables all the controls in the group
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * To handle key event fired.
//    */
//   onKeyDown: PropTypes__default.func
// };
// RadioGroup.defaultProps = {
//   children: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   value: undefined,
//   label: undefined,
//   ariaLabel: undefined,
//   className: undefined,
//   disabled: false,
//   onKeyDown: undefined
// };

// /**
//  * Component for radio button with label.
//  */
// function RadioWithLabel(_ref) {
//   var label = _ref.label,
//     value = _ref.value,
//     checked = _ref.checked,
//     disabled = _ref.disabled,
//     onChange = _ref.onChange,
//     ariaLabel = _ref.ariaLabel,
//     inputProps = _ref.inputProps,
//     name = _ref.name,
//     id = _ref.id;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Label$8, {
//     label: label
//   }, /*#__PURE__*/React__default.createElement(Radio, {
//     value: value,
//     checked: checked,
//     disabled: disabled,
//     onChange: onChange,
//     ariaLabel: ariaLabel || label,
//     inputProps: inputProps,
//     name: name,
//     id: id
//   })));
// }
// RadioWithLabel.propTypes = {
//   /**
//    * Label text to be used for the input field
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * value of the selected radio button
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.number]),
//   /**
//    * If `true`, the component is checked. Keep this undefined to control from RadioGroup
//    */
//   checked: PropTypes__default.bool,
//   /**
//    * If `true`, the switch will be disabled. Keep this undefined to control from RadioGroup
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for input field
//    */
//   ariaLabel: PropTypes__default.string,
//   /**
//    * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
//    */
//   inputProps: PropTypes__default.shape({}),
//   /**
//    * Name text to be used for the input field
//    */
//   name: PropTypes__default.string,
//   /**
//    * Id of the Radio
//    */
//   id: PropTypes__default.string
// };
// RadioWithLabel.defaultProps = {
//   value: '',
//   disabled: undefined,
//   checked: undefined,
//   onChange: function onChange() {
//     return null;
//   },
//   ariaLabel: null,
//   inputProps: undefined,
//   name: undefined,
//   id: undefined
// };

// /**
//  * SectionTitleDescription component is used to display section heading and description.
//  */

// function SectionTitleDescription(_ref) {
//   var title = _ref.title,
//     description = _ref.description;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(SectionTitle, {
//     title: title
//   }), /*#__PURE__*/React__default.createElement(BodyText, {
//     text: description
//   }));
// }

// // PropType check
// SectionTitleDescription.propTypes = {
//   /**
//    * title text
//    */
//   title: PropTypes__default.string,
//   /**
//    * description text
//    */
//   description: PropTypes__default.string
// };
// SectionTitleDescription.defaultProps = {
//   /**
//    * default title
//    */
//   title: '',
//   /**
//    * default title
//    */
//   description: ''
// };

// var _templateObject$u, _templateObject2$m, _templateObject3$e;
// var StyledSpan = styled('span')(_templateObject$u || (_templateObject$u = _taggedTemplateLiteral$1(["\n  font-size: 0.875rem;\n  &.primary-style {\n    color: ", ";\n  }\n  &.primary-style-with-font {\n    color: ", ";\n    font-weight: bold;\n  }\n  &.secondary-style {\n    color: ", ";\n  }\n  &.secondary-style-with-font {\n    color: ", ";\n    font-weight: bold;\n  }\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.btnPrimaryBg;
// }, function (props) {
//   return props.theme.variables.textColor;
// }, function (props) {
//   return props.theme.variables.textColor;
// });
// var StyledListItem$2 = styled(ListItem)(_templateObject2$m || (_templateObject2$m = _taggedTemplateLiteral$1(["\n  line-height: 1.4rem;\n  padding: 0.01rem 0.5rem;\n  color: inherit;\n  border-left: 0.3125rem solid white;\n  border-bottom: 1px solid;\n\n  &.plain-list {\n    &.Mui-selected,\n    &.Mui-selected:hover {\n      background-color: transparent;\n      border-left: 0.3125rem solid\n        ", ";\n    }\n  }\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return theme.variables.btnPrimaryBg;
// });
// styled(Divider)(_templateObject3$e || (_templateObject3$e = _taggedTemplateLiteral$1(["\n  background: ", ";\n"])), function (props) {
//   return props.theme.variables.textColor;
// });

// /**
//  * The SelectList component is used to display List with Items selected bar when selected.
//  */

// function SelectList(_ref) {
//   var items = _ref.items,
//     onClickEventHandle = _ref.onClickEventHandle,
//     selectedKey = _ref.selectedKey;
//   var _useState = useState$1(false),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     selected = _useState2[0],
//     setSelected = _useState2[1];
//   var handleClick = function handleClick(i) {
//     setSelected(i);
//     onClickEventHandle(items[i]);
//   };
//   /**
//    * Logic to select ListItem by default
//    */
//   useEffect$2(function () {
//     handleClick(items.findIndex(function (_ref2) {
//       var key = _ref2.key;
//       return key === selectedKey;
//     }));
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [items]);
//   return /*#__PURE__*/React__default.createElement(MenuList, {
//     role: "listbox",
//     ariaLabel: "select list"
//   }, items.map(function (item, i) {
//     return /*#__PURE__*/React__default.createElement(StyledListItem$2, {
//       key: item.key,
//       role: "option",
//       className: "plain-list",
//       onClick: function onClick() {
//         setSelected(i);
//         handleClick(i);
//       },
//       selected: selected === i
//     }, /*#__PURE__*/React__default.createElement(ListItemText, {
//       primary: /*#__PURE__*/React__default.createElement(StyledSpan, {
//         className: selected === i ? 'primary-style-with-font' : 'primary-style'
//       }, item.title),
//       secondary: /*#__PURE__*/React__default.createElement(StyledSpan, {
//         className: selected === i ? 'secondary-style-with-font' : 'secondary-style'
//       }, item.subTitle)
//     }));
//   }));
// }
// var itemsShape$1 = {
//   /**
//    * title to be displayed
//    */
//   title: PropTypes__default.string.isRequired,
//   /**
//    * subTitle to be displayed
//    */
//   subTitle: PropTypes__default.string,
//   /**
//    * Unique key for the list item
//    */
//   key: PropTypes__default.string.isRequired
// };
// itemsShape$1.items = PropTypes__default.arrayOf(PropTypes__default.shape(itemsShape$1));
// SelectList.propTypes = {
//   /**
//    * List data to be displayed
//    */
//   items: PropTypes__default.arrayOf(PropTypes__default.shape(itemsShape$1)),
//   /**
//    * To pass event to parent
//    */
//   onClickEventHandle: PropTypes__default.func,
//   /**
//    * To select passing key by default
//    */
//   selectedKey: PropTypes__default.string
// };
// SelectList.defaultProps = {
//   items: [],
//   onClickEventHandle: function onClickEventHandle() {
//     return null;
//   },
//   selectedKey: 'null'
// };

// var _templateObject$t, _templateObject2$l, _templateObject3$d, _templateObject4$6, _templateObject5$3, _templateObject6$2, _templateObject7$2;
// var StyledDiv = styled.div(_templateObject$t || (_templateObject$t = _taggedTemplateLiteral$1(["\n  text-align: center;\n  margin-top: 0.5rem !important;\n"])));
// var StyledButton$1 = styled(Button$1)(_templateObject2$l || (_templateObject2$l = _taggedTemplateLiteral$1(["\n  padding: 0.5rem 2.125rem 0.5rem 2.125rem;\n  background-color: ", ";\n  height: 2.125rem;\n  min-width: 13.75rem;\n"])), function (props) {
//   return props.theme.variables.bodyBg;
// });
// var StyledDivider = styled(Divider)(_templateObject3$d || (_templateObject3$d = _taggedTemplateLiteral$1(["\n  margin-top: -1.125rem;\n  border-top: 0.063rem solid\n    ", ";\n"])), function (props) {
//   return props.theme.variables.tableHeaderBorderColor;
// });

// /* CSS for the animated ellipsis */
// var ellipsis = keyframes(_templateObject4$6 || (_templateObject4$6 = _taggedTemplateLiteral$1(["\n 0% {\n        opacity: 0;\n    }\n    50% {\n        opacity: 0;\n    }\n    100% {\n        opacity: 1;\n    }\n"])));
// var Dot1 = styled.span(_templateObject5$3 || (_templateObject5$3 = _taggedTemplateLiteral$1(["\n  margin-left: 0.15rem;\n  opacity: 0;\n  animation: ", " 1.3s infinite;\n  animation-delay: 0s;\n"])), ellipsis);
// var Dot2 = styled.span(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteral$1(["\n  margin-left: 0.15rem;\n  opacity: 0;\n  animation: ", " 1.3s infinite;\n  animation-delay: 0.2s;\n"])), ellipsis);
// var Dot3 = styled.span(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteral$1(["\n  margin-left: 0.15rem;\n  opacity: 0;\n  animation: ", " 1.3s infinite;\n  animation-delay: 0.4s;\n"])), ellipsis);

// /**
//  * ShowMoreResults button is a button at the bottom of a page that allows you to load more results.
//  */
// function ShowMoreResults(_ref) {
//   var className = _ref.className,
//     initialTitle = _ref.initialTitle,
//     onClickTitle = _ref.onClickTitle,
//     showMoreClickHandler = _ref.showMoreClickHandler;
//   var _useState = useState$1(false),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     showEllipsis = _useState2[0],
//     setShowEllipsis = _useState2[1];
//   var onClickHandler = function onClickHandler(event) {
//     if (showEllipsis) return;
//     setShowEllipsis(true);
//     showMoreClickHandler(event, setShowEllipsis);
//   };
//   return /*#__PURE__*/React__default.createElement(StyledDiv, {
//     className: className
//   }, /*#__PURE__*/React__default.createElement(StyledButton$1, {
//     onClick: onClickHandler,
//     ariaLive: "polite"
//   }, showEllipsis ? onClickTitle : initialTitle, showEllipsis && /*#__PURE__*/React__default.createElement("span", null, /*#__PURE__*/React__default.createElement(Dot1, null, "."), /*#__PURE__*/React__default.createElement(Dot2, null, "."), /*#__PURE__*/React__default.createElement(Dot3, null, "."))), /*#__PURE__*/React__default.createElement(StyledDivider, {
//     orientation: "horizontal"
//   }));
// }

// // PropTypes
// ShowMoreResults.propTypes = {
//   /**
//    * To allow styles from styled components
//    */
//   className: PropTypes__default.string,
//   /**
//    * initial title of the button
//    */
//   initialTitle: PropTypes__default.string,
//   /**
//    * title of the button after the button click
//    */
//   onClickTitle: PropTypes__default.string,
//   /**
//    * onClick function
//    */
//   showMoreClickHandler: PropTypes__default.func
// };

// // Default Props
// ShowMoreResults.defaultProps = {
//   className: '',
//   initialTitle: 'Show More Results',
//   onClickTitle: 'Loading',
//   showMoreClickHandler: undefined
// };

// /**
//  * Component to render SumtSliderWrapper
//  * Sliders allow users to make selections from a range of values
//  */
// function SumtSliderWrapper(_ref) {
//   var idProp = _ref.id,
//     ariaLabelledBy = _ref.ariaLabelledBy,
//     className = _ref.className,
//     disabled = _ref.disabled,
//     min = _ref.min,
//     marks = _ref.marks,
//     max = _ref.max,
//     onChange = _ref.onChange,
//     value = _ref.value;
//   var id = useId(idProp);
//   return /*#__PURE__*/React__default.createElement(MuiSlider, {
//     id: id,
//     className: className,
//     disabled: disabled,
//     min: min,
//     marks: marks,
//     max: max,
//     onChange: onChange,
//     value: value,
//     "aria-labelledby": ariaLabelledBy
//   });
// }
// SumtSliderWrapper.propTypes = {
//   id: PropTypes__default.string,
//   ariaLabelledBy: PropTypes__default.string,
//   className: PropTypes__default.string,
//   disabled: PropTypes__default.bool,
//   min: PropTypes__default.number,
//   marks: PropTypes__default.oneOfType([PropTypes__default.bool, PropTypes__default.arrayOf(PropTypes__default.object)]),
//   max: PropTypes__default.number,
//   onChange: PropTypes__default.func,
//   value: PropTypes__default.number
// };
// SumtSliderWrapper.defaultProps = {
//   id: undefined,
//   ariaLabelledBy: undefined,
//   className: undefined,
//   disabled: false,
//   min: 0,
//   marks: false,
//   max: 1,
//   onChange: undefined,
//   value: 0
// };

// var _templateObject$s, _templateObject2$k;
// var StyledGrid = styled(FlexGrid)(_templateObject$s || (_templateObject$s = _taggedTemplateLiteral$1(["\n  &.MuiGrid-root {\n    width: ", "px;\n  }\n  .MuiInputBase-root {\n    margin: 0;\n  }\n  .MuiInputBase-input {\n    padding: 0;\n  }\n"])), function (_ref) {
//   var width = _ref.width;
//   return width;
// });
// var StyledSlider = styled(SumtSliderWrapper)(_templateObject2$k || (_templateObject2$k = _taggedTemplateLiteral$1(["\n  &.MuiSlider-root {\n    height: 0.25rem;\n  }\n  & > .MuiSlider-rail {\n    height: inherit;\n    top: 50%;\n    transform: translateY(-50%);\n    color: ", ";\n    opacity: 1;\n  }\n  & > .MuiSlider-track {\n    height: inherit;\n    top: 50%;\n    transform: translateY(-50%);\n  }\n  & > .MuiSlider-thumb {\n    height: 1.25rem;\n    width: 1.25rem;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    margin: 0;\n  }\n  & > .MuiSlider-mark {\n    top: 50%;\n    transform: translate(-1px, -50%);\n  }\n"])), function (_ref2) {
//   var theme = _ref2.theme;
//   return theme.variables.btnLinkDisabledColor;
// });

// /**
//  * Component to render Slider
//  * Sliders allow users to make selections from a range of values
//  */
// function Slider(_ref) {
//   var idProp = _ref.id,
//     ariaLabelledBy = _ref.ariaLabelledBy,
//     disabled = _ref.disabled,
//     includeInput = _ref.includeInput,
//     min = _ref.min,
//     marks = _ref.marks,
//     max = _ref.max,
//     onSliderChange = _ref.onSliderChange,
//     onInputChange = _ref.onInputChange,
//     onInputBlur = _ref.onInputBlur,
//     value = _ref.value,
//     width = _ref.width;
//   var id = useId(idProp);
//   var marksArray = [];
//   if (marks === true) {
//     marksArray.push({
//       value: min,
//       label: min
//     });
//     marksArray.push({
//       value: max,
//       label: max
//     });
//   }
//   return /*#__PURE__*/React__default.createElement(StyledGrid, {
//     container: true,
//     spacing: 2,
//     width: width
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     xs: true
//   }, /*#__PURE__*/React__default.createElement(StyledSlider, {
//     id: id,
//     disabled: disabled,
//     min: min,
//     marks: marks ? marksArray : marks,
//     max: max,
//     onChange: onSliderChange,
//     value: value == null ? min : value,
//     ariaLabelledBy: ariaLabelledBy
//   })), includeInput && /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(TextField, {
//     disabled: disabled,
//     variant: "standard",
//     type: "number",
//     value: value == null ? min.toString() : value.toString(),
//     onChange: onInputChange,
//     onBlur: onInputBlur,
//     inputProps: {
//       min: min,
//       max: max,
//       'aria-labelledby': ariaLabelledBy
//     }
//   })));
// }
// Slider.propTypes = {
//   /**
//    * Id for the Slider
//    */
//   id: PropTypes__default.string,
//   /**
//    * Id for the Label
//    */
//   ariaLabelledBy: PropTypes__default.string,
//   /**
//    * If true, disable slider
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * If true, render textfield input
//    */
//   includeInput: PropTypes__default.bool,
//   /**
//    * Minimum slider value
//    */
//   min: PropTypes__default.number,
//   /**
//    * If true, show min/max labels under slider
//    */
//   marks: PropTypes__default.oneOfType([PropTypes__default.bool, PropTypes__default.arrayOf(PropTypes__default.object)]),
//   /**
//    * Maximum slider value
//    */
//   max: PropTypes__default.number,
//   /**
//    * Function for handling slider change
//    */
//   onSliderChange: PropTypes__default.func,
//   /**
//    * Function for handling input change
//    */
//   onInputChange: PropTypes__default.func,
//   /**
//    * Function for input blur
//    */
//   onInputBlur: PropTypes__default.func,
//   /**
//    * Overall width in pixels of component
//    */
//   width: PropTypes__default.number,
//   /**
//    * Numeric value for slider/input
//    */
//   value: PropTypes__default.number
// };
// Slider.defaultProps = {
//   id: undefined,
//   ariaLabelledBy: undefined,
//   disabled: false,
//   includeInput: false,
//   min: 0,
//   marks: false,
//   max: 1,
//   onSliderChange: undefined,
//   onInputChange: undefined,
//   onInputBlur: undefined,
//   width: 256,
//   value: 0
// };

// /**
//  * This component is used to render Slider as table cell content in DataGrid.
//  */
// function SliderCell(_ref) {
//   var maxValue = _ref.maxValue,
//     minValue = _ref.minValue,
//     disabled = _ref.disabled,
//     ariaLabelledByPropName = _ref.ariaLabelledByPropName;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue,
//     row = _useContext.row;
//   return /*#__PURE__*/React__default.createElement(Slider, {
//     includeInput: true,
//     max: maxValue,
//     min: minValue,
//     value: cellValue,
//     disabled: disabled,
//     ariaLabelledBy: "".concat(row.index, "_").concat(ariaLabelledByPropName)
//   });
// }
// SliderCell.propTypes = {
//   /**
//    * Max value
//    */
//   maxValue: PropTypes__default.number,
//   /**
//    * Min value
//    */
//   minValue: PropTypes__default.number,
//   /**
//    * Disabled
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * ariaLabelledByPropName
//    */
//   ariaLabelledByPropName: PropTypes__default.string
// };
// SliderCell.defaultProps = {
//   maxValue: 100,
//   minValue: 0,
//   disabled: false,
//   ariaLabelledByPropName: ''
// };

// /**
//  * This component is used to render status label as table cell content in DataGrid.
//  */
// function StatusLabelCell(_ref) {
//   _ref.className;
//     var severity = _ref.severity,
//     setSeverity = _ref.setSeverity;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue;
//   var _useState = useState$1(severity),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     status = _useState2[0],
//     setStatus = _useState2[1];
//   useEffect$2(function () {
//     if (setSeverity) {
//       setStatus(setSeverity(cellValue));
//     }
//   }, [cellValue, setSeverity]);
//   return /*#__PURE__*/React__default.createElement(StatusLabel, {
//     label: cellValue ? cellValue.toString() : '',
//     status: status
//   });
// }
// StatusLabelCell.propTypes = {
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * To set the severity
//    */
//   severity: PropTypes__default.string,
//   /**
//    * To set the severity
//    */
//   setSeverity: PropTypes__default.func
// };
// StatusLabelCell.defaultProps = {
//   className: undefined,
//   severity: 'inactive',
//   setSeverity: undefined
// };

// /**
//  * This component is used to render switch as table cell content in DataGrid.
//  */
// function SwitchCell(_ref) {
//   var className = _ref.className,
//     disabled = _ref.disabled,
//     onClick = _ref.onClick,
//     ariaLabel = _ref.ariaLabel;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue,
//     cell = _useContext.cell;
//   var handleClick = function handleClick(event) {
//     onClick(event, cell.props.row.id);
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(ToggleSwitch, {
//     className: className,
//     checked: cellValue,
//     disabled: disabled,
//     onChange: handleClick,
//     ariaLabel: ariaLabel
//   }));
// }
// SwitchCell.propTypes = {
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Button disable
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Value of aria-label attribute to be used for input field
//    */
//   ariaLabel: PropTypes__default.string
// };
// SwitchCell.defaultProps = {
//   className: '',
//   disabled: false,
//   onClick: function onClick() {
//     return null;
//   },
//   ariaLabel: null
// };

// var _templateObject$r;
// var StyledBasicTable = styled(BasicTable)(_templateObject$r || (_templateObject$r = _taggedTemplateLiteral$1(["\nborder-collapse: separate;\n"])));

// function Table(_ref) {
//   var children = _ref.children,
//     className = _ref.className;
//   var _useContext = useContext(TableContext),
//     tableInstance = _useContext.tableInstance;
//   return /*#__PURE__*/React__default.createElement(StyledBasicTable, _extends$v({}, tableInstance.getTableProps(), {
//     className: className
//   }), children);
// }
// Table.propTypes = {
//   /**
//    * The Head and Body of table component.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string
// };
// Table.defaultProps = {
//   className: undefined
// };

// function useReactTable() {
//   var _useContext = useContext(TableContext),
//     tableInstance = _useContext.tableInstance;
//   return tableInstance;
// }
// var TableBody = function TableBody(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     hover = _ref.hover,
//     striped = _ref.striped;
//   var _useReactTable = useReactTable(),
//     getTableBodyProps = _useReactTable.getTableBodyProps,
//     prepareRow = _useReactTable.prepareRow,
//     page = _useReactTable.page;
//   return /*#__PURE__*/React__default.createElement(BasicTableBody, _extends$v({}, getTableBodyProps(), {
//     className: className
//   }), page.map(function (row) {
//     prepareRow(row);
//     return /*#__PURE__*/React__default.createElement(BasicTableRow, _extends$v({
//       key: row.id
//     }, row.getRowProps(), {
//       hover: hover,
//       striped: striped
//     }), /*#__PURE__*/React__default.createElement(TableRowContextProvider, {
//       row: row
//     }, children));
//   }));
// };
// TableBody.propTypes = {
//   /**
//    * The table body content.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * If true, the table row will shade on hover..
//    */
//   hover: PropTypes__default.bool,
//   /**
//    * To enable striped rows.
//    */
//   striped: PropTypes__default.bool
// };
// TableBody.defaultProps = {
//   className: undefined,
//   hover: false,
//   striped: false
// };

// var _templateObject$q;
// var StyledTableHeadWrapper = styled(BasicTableHead)(_templateObject$q || (_templateObject$q = _taggedTemplateLiteral$1(["\ntop: 0;\nposition: sticky;\nZ-index: 300;\nbackground-color: ", ";\n"])), function (props) {
//   return curriedLighten$1(0.2, props.theme.variables.bodyBg);
// });

// /**
//  * This component used to render Table Header.
//  */
// function TableHead(_ref) {
//   var children = _ref.children,
//     className = _ref.className,
//     stickyHeader = _ref.stickyHeader;
//   var _useContext = useContext(TableContext),
//     setColumns = _useContext.setColumns,
//     tableInstance = _useContext.tableInstance;
//   useEffect$2(function () {
//     var childrenArray = React__default.Children.toArray(children);
//     var columnJson = [];
//     childrenArray.map(function (child) {
//       var columnProps = null;
//       if (!child.props.columnType) {
//         columnProps = {
//           Header: child.props.label,
//           accessor: child.props.property,
//           ariaLabel: child.props.ariaLabel,
//           filter: child.props.filterType
//         };
//       } else {
//         switch (child.props.columnType) {
//           case 'checkbox':
//             columnProps = CheckboxHeader(child.props.ariaLabel, child.props.className);
//             break;
//           default:
//             throw new Error('invalid value passed in for columntype prop. Valid values include - checkbox');
//         }
//       }
//       if (columnProps) {
//         columnJson.push(columnProps);
//       }
//       return null;
//     });
//     setColumns(columnJson);
//   }, [children, setColumns]);
//   var TableHeadComponent = stickyHeader ? StyledTableHeadWrapper : BasicTableHead;
//   return /*#__PURE__*/React__default.createElement(TableHeadComponent, {
//     className: className
//   }, tableInstance.headerGroups.map(function (headerGroup, index) {
//     var rowId = index;
//     return /*#__PURE__*/React__default.createElement(BasicTableRow, _extends$v({
//       key: rowId
//     }, headerGroup.getHeaderGroupProps()), children);
//   }));
// }
// TableHead.propTypes = {
//   /**
//    * The table head components.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    *To enable sticky header
//    */
//   stickyHeader: PropTypes__default.bool
// };
// TableHead.defaultProps = {
//   className: undefined,
//   stickyHeader: false
// };

// var _templateObject$p, _templateObject2$j;
// var StyledFormLabel = styled(FormLabel)(_templateObject$p || (_templateObject$p = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// var StyledFlexGrid = styled(FlexGrid)(_templateObject2$j || (_templateObject2$j = _taggedTemplateLiteral$1(["\n  margin: -0.375rem;\n  .MuiGrid-item {\n    padding: 0.375rem;\n  }\n"])));

// /**
//  * TablePaginationWithDisplayCount: This component for pagination with display count.
//  */
// function TablePaginationWithDisplayCount(_ref) {
//   var label = _ref.label,
//     count = _ref.count,
//     pageRange = _ref.pageRange,
//     rowsPerPage = _ref.rowsPerPage,
//     component = _ref.component,
//     onChangeRowsPerPage = _ref.onChangeRowsPerPage,
//     rowsPerPageOptions = _ref.rowsPerPageOptions,
//     labelRowsPerPage = _ref.labelRowsPerPage,
//     page = _ref.page,
//     onChange = _ref.onChange,
//     disabled = _ref.disabled,
//     onChangePage = _ref.onChangePage,
//     className = _ref.className,
//     translations = _ref.translations;
//   var pageCount = useMemo(function () {
//     return Math.ceil(count / rowsPerPage);
//   }, [count, rowsPerPage]);
//   return /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(StyledFlexGrid, {
//     container: true,
//     spacing: 3
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     xs: true
//   }, /*#__PURE__*/React__default.createElement(StyledFormLabel, null, label)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     xs: 7
//   }, /*#__PURE__*/React__default.createElement(Pagination$1, {
//     component: component,
//     count: pageCount,
//     page: page,
//     onChange: onChange,
//     disabled: disabled,
//     className: className
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     xs: 3
//   }, /*#__PURE__*/React__default.createElement(TablePagination, {
//     rowsPerPageOptions: rowsPerPageOptions,
//     count: count,
//     page: pageRange,
//     rowsPerPage: rowsPerPage,
//     onChangeRowsPerPage: onChangeRowsPerPage,
//     onChangePage: onChangePage,
//     hideactions: true,
//     labelRowsPerPage: labelRowsPerPage,
//     className: className,
//     translations: translations
//   }))));
// }
// TablePaginationWithDisplayCount.propTypes = {
//   /**
//    * Label text to be used for the input field
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * Count of the total number of pages.
//    */
//   count: PropTypes__default.number.isRequired,
//   /**
//    * The current page.
//    */
//   page: PropTypes__default.number.isRequired,
//   /**
//    * The current page.
//    */
//   pageRange: PropTypes__default.number.isRequired,
//   /**
//    * The number of rows per page.
//    */
//   rowsPerPage: PropTypes__default.number.isRequired,
//   /**
//    * Callback fired when the state is changed.
//    */
//   onChangePage: PropTypes__default.func,
//   /**
//    * Callback fired when the number of rows per page is change
//    */
//   onChangeRowsPerPage: PropTypes__default.func.isRequired,
//   /**
//    * labelRowsPerPage text to be used for the input field
//    */
//   labelRowsPerPage: PropTypes__default.string.isRequired,
//   /**
//    *The component used for the root node. Either a string to use a HTML element or a component
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * Customizes the options of the rows per page select field. If less than two options are available, no select field will be displayed.
//    */
//   rowsPerPageOptions: PropTypes__default.arrayOf(PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string])).isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Callback fired when the page is changed.
//    */
//   onChange: PropTypes__default.func.isRequired,
//   /**
//    * If disabled true, the pagination component will be disabled.
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string)
// };
// TablePaginationWithDisplayCount.defaultProps = {
//   component: 'div',
//   className: undefined,
//   onChangePage: null,
//   disabled: false,
//   translations: {}
// };

// var _templateObject$o;
// var StyledMuiToolBar = styled(MuiToolBar)(_templateObject$o || (_templateObject$o = _taggedTemplateLiteral$1(["\n  min-height: ", ";\n  padding: 0;\n  max-height: 3.25rem;\n"])), function (props) {
//   return props.minheight;
// });

// /**
//  * The Toolbar component is used to display its children with an inline display
//  */
// function ToolBar(_ref) {
//   var children = _ref.children,
//     minHeight = _ref.minHeight,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledMuiToolBar, {
//     minheight: minHeight,
//     className: className
//   }, children);
// }

// // PropType check
// ToolBar.propTypes = {
//   /**
//    * Children of the component, usually combnation of Icon button,Button...
//    */
//   children: PropTypes__default.node,
//   /**
//    * Minimum height of the toolbar
//    */
//   minHeight: PropTypes__default.string,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string
// };
// ToolBar.defaultProps = {
//   children: undefined,
//   minHeight: '3.25rem',
//   className: undefined
// };

// var _templateObject$n;
// var StyledTableToolBar = styled(ToolBar)(_templateObject$n || (_templateObject$n = _taggedTemplateLiteral$1(["\n  background-color: ", ";\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.toolbarBg;
// }, function (props) {
//   return props.theme.variables.toolbarTextColor;
// });

// /**
//  * The top table tool bar provides actions related table rows.
//  *
//  */
// function TableToolBar(_ref) {
//   var children = _ref.children,
//     toolBarMinHeight = _ref.toolBarMinHeight,
//     className = _ref.className;
//   return /*#__PURE__*/React__default.createElement(StyledTableToolBar, {
//     minheight: toolBarMinHeight,
//     className: className
//   }, children);
// }

// // PropType check
// TableToolBar.propTypes = {
//   /**
//    * Minmum height of the toolbar
//    */
//   toolBarMinHeight: PropTypes__default.string,
//   /**
//    * Child nodes for the component
//    */

//   children: PropTypes__default.node,
//   /**
//    * className.
//    */
//   className: PropTypes__default.string
// };
// TableToolBar.defaultProps = {
//   toolBarMinHeight: '3.25rem',
//   children: undefined,
//   className: undefined
// };

// /**
//  * react-number-format - 4.9.4
//  * Author : Sudhanshu Yadav
//  * Copyright (c) 2016, 2022 to Sudhanshu Yadav, released under the MIT license.
//  * https://github.com/s-yadav/react-number-format
//  */

// //     

                                                               

// // basic noop function
// function noop() {}
// function returnTrue() {
//   return true;
// }

// function charIsNumber(char         ) {
//   return !!(char || '').match(/\d/);
// }

// function isNil(val     ) {
//   return val === null || val === undefined;
// }

// function escapeRegExp(str        ) {
//   return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
// }

// function getThousandsGroupRegex(thousandsGroupStyle        ) {
//   switch (thousandsGroupStyle) {
//     case 'lakh':
//       return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
//     case 'wan':
//       return /(\d)(?=(\d{4})+(?!\d))/g;
//     case 'thousand':
//     default:
//       return /(\d)(?=(\d{3})+(?!\d))/g;
//   }
// }

// function applyThousandSeparator(
//   str        ,
//   thousandSeparator        ,
//   thousandsGroupStyle        
// ) {
//   var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
//   var index = str.search(/[1-9]/);
//   index = index === -1 ? str.length : index;
//   return (
//     str.substring(0, index) +
//     str.substring(index, str.length).replace(thousandsGroupRegex, '$1' + thousandSeparator)
//   );
// }

// //spilt a float number into different parts beforeDecimal, afterDecimal, and negation
// function splitDecimal(numStr        , allowNegative) {
//   if ( allowNegative === void 0 ) allowNegative          = true;

//   var hasNagation = numStr[0] === '-';
//   var addNegation = hasNagation && allowNegative;
//   numStr = numStr.replace('-', '');

//   var parts = numStr.split('.');
//   var beforeDecimal = parts[0];
//   var afterDecimal = parts[1] || '';

//   return {
//     beforeDecimal: beforeDecimal,
//     afterDecimal: afterDecimal,
//     hasNagation: hasNagation,
//     addNegation: addNegation,
//   };
// }

// function fixLeadingZero(numStr         ) {
//   if (!numStr) { return numStr; }
//   var isNegative = numStr[0] === '-';
//   if (isNegative) { numStr = numStr.substring(1, numStr.length); }
//   var parts = numStr.split('.');
//   var beforeDecimal = parts[0].replace(/^0+/, '') || '0';
//   var afterDecimal = parts[1] || '';

//   return ("" + (isNegative ? '-' : '') + beforeDecimal + (afterDecimal ? ("." + afterDecimal) : ''));
// }

// /**
//  * limit decimal numbers to given scale
//  * Not used .fixedTo because that will break with big numbers
//  */
// function limitToScale(numStr        , scale        , fixedDecimalScale         ) {
//   var str = '';
//   var filler = fixedDecimalScale ? '0' : '';
//   for (var i = 0; i <= scale - 1; i++) {
//     str += numStr[i] || filler;
//   }
//   return str;
// }

// function repeat(str, count) {
//   return Array(count + 1).join(str);
// }

// function toNumericString(num) {
//   num += ''; // typecast number to string

//   // store the sign and remove it from the number.
//   var sign = num[0] === '-' ? '-' : '';
//   if (sign) { num = num.substring(1); }

//   // split the number into cofficient and exponent
//   var ref = num.split(/[eE]/g);
//   var coefficient = ref[0];
//   var exponent = ref[1];

//   // covert exponent to number;
//   exponent = Number(exponent);

//   // if there is no exponent part or its 0, return the coffiecient with sign
//   if (!exponent) { return sign + coefficient; }

//   coefficient = coefficient.replace('.', '');

//   /**
//    * for scientific notation the current decimal index will be after first number (index 0)
//    * So effective decimal index will always be 1 + exponent value
//    */
//   var decimalIndex = 1 + exponent;

//   var coffiecientLn = coefficient.length;

//   if (decimalIndex < 0) {
//     // if decimal index is less then 0 add preceding 0s
//     // add 1 as join will have
//     coefficient = '0.' + repeat('0', Math.abs(decimalIndex)) + coefficient;
//   } else if (decimalIndex >= coffiecientLn) {
//     // if decimal index is less then 0 add leading 0s
//     coefficient = coefficient + repeat('0', decimalIndex - coffiecientLn);
//   } else {
//     // else add decimal point at proper index
//     coefficient =
//       (coefficient.substring(0, decimalIndex) || '0') + '.' + coefficient.substring(decimalIndex);
//   }

//   return sign + coefficient;
// }

// /**
//  * This method is required to round prop value to given scale.
//  * Not used .round or .fixedTo because that will break with big numbers
//  */
// function roundToPrecision(numStr        , scale        , fixedDecimalScale         ) {
//   //if number is empty don't do anything return empty string
//   if (['', '-'].indexOf(numStr) !== -1) { return numStr; }

//   var shoudHaveDecimalSeparator = numStr.indexOf('.') !== -1 && scale;
//   var ref = splitDecimal(numStr);
//   var beforeDecimal = ref.beforeDecimal;
//   var afterDecimal = ref.afterDecimal;
//   var hasNagation = ref.hasNagation;
//   var floatValue = parseFloat(("0." + (afterDecimal || '0')));
//   var floatValueStr =
//     afterDecimal.length <= scale ? ("0." + afterDecimal) : floatValue.toFixed(scale);
//   var roundedDecimalParts = floatValueStr.split('.');
//   var intPart = beforeDecimal
//     .split('')
//     .reverse()
//     .reduce(function (roundedStr, current, idx) {
//       if (roundedStr.length > idx) {
//         return (
//           (Number(roundedStr[0]) + Number(current)).toString() +
//           roundedStr.substring(1, roundedStr.length)
//         );
//       }
//       return current + roundedStr;
//     }, roundedDecimalParts[0]);

//   var decimalPart = limitToScale(
//     roundedDecimalParts[1] || '',
//     Math.min(scale, afterDecimal.length),
//     fixedDecimalScale
//   );
//   var negation = hasNagation ? '-' : '';
//   var decimalSeparator = shoudHaveDecimalSeparator ? '.' : '';
//   return ("" + negation + intPart + decimalSeparator + decimalPart);
// }

// /** set the caret positon in an input field **/
// function setCaretPosition(el                  , caretPos        ) {
//   el.value = el.value;
//   // ^ this is used to not only get 'focus', but
//   // to make sure we don't have it everything -selected-
//   // (it causes an issue in chrome, and having it doesn't hurt any other browser)
//   if (el !== null) {
//     if (el.createTextRange) {
//       var range = el.createTextRange();
//       range.move('character', caretPos);
//       range.select();
//       return true;
//     }
//     // (el.selectionStart === 0 added for Firefox bug)
//     if (el.selectionStart || el.selectionStart === 0) {
//       el.focus();
//       el.setSelectionRange(caretPos, caretPos);
//       return true;
//     }

//     // fail city, fortunately this never happens (as far as I've tested) :)
//     el.focus();
//     return false;
//   }
// }

// /**
//   Given previous value and newValue it returns the index
//   start - end to which values have changed.
//   This function makes assumption about only consecutive
//   characters are changed which is correct assumption for caret input.
// */
// function findChangedIndex(prevValue        , newValue        ) {
//   var i = 0,
//     j = 0;
//   var prevLength = prevValue.length;
//   var newLength = newValue.length;
//   while (prevValue[i] === newValue[i] && i < prevLength) { i++; }

//   //check what has been changed from last
//   while (
//     prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] &&
//     newLength - j > i &&
//     prevLength - j > i
//   ) {
//     j++;
//   }

//   return { start: i, end: prevLength - j };
// }

// /*
//   Returns a number whose value is limited to the given range
// */
// function clamp(num        , min        , max        ) {
//   return Math.min(Math.max(num, min), max);
// }

// function getCurrentCaretPosition(el                  ) {
//   /*Max of selectionStart and selectionEnd is taken for the patch of pixel and other mobile device caret bug*/
//   return Math.max(el.selectionStart, el.selectionEnd);
// }

// function addInputMode(format                                   ) {
//   return (
//     format ||
//     (typeof navigator !== 'undefined' &&
//       !(navigator.platform && /iPhone|iPod/.test(navigator.platform)))
//   );
// }

// //     
// function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

// var defaultProps = {
//   displayType: 'input',
//   decimalSeparator: '.',
//   thousandsGroupStyle: 'thousand',
//   fixedDecimalScale: false,
//   prefix: '',
//   suffix: '',
//   allowNegative: true,
//   allowEmptyFormatting: false,
//   allowLeadingZeros: false,
//   isNumericString: false,
//   type: 'text',
//   onValueChange: noop,
//   onChange: noop,
//   onKeyDown: noop,
//   onMouseUp: noop,
//   onFocus: noop,
//   onBlur: noop,
//   isAllowed: returnTrue,
// };
// var NumberFormat = /*@__PURE__*/(function (superclass) {
//   function NumberFormat(props        ) {
//     superclass.call(this, props);
//     var defaultValue = props.defaultValue;

//     //validate props
//     this.validateProps();

//     var formattedValue = this.formatValueProp(defaultValue);

//     this.state = {
//       value: formattedValue,
//       numAsString: this.removeFormatting(formattedValue),
//       mounted: false,
//     };

//     this.selectionBeforeInput = {
//       selectionStart: 0,
//       selectionEnd: 0,
//     };

//     this.onChange = this.onChange.bind(this);
//     this.onKeyDown = this.onKeyDown.bind(this);
//     this.onMouseUp = this.onMouseUp.bind(this);
//     this.onFocus = this.onFocus.bind(this);
//     this.onBlur = this.onBlur.bind(this);
//   }

//   if ( superclass ) NumberFormat.__proto__ = superclass;
//   NumberFormat.prototype = Object.create( superclass && superclass.prototype );
//   NumberFormat.prototype.constructor = NumberFormat;

//   NumberFormat.prototype.componentDidMount = function componentDidMount () {
//     // set mounted state
//     // eslint-disable-next-line react/no-did-mount-set-state
//     this.setState({
//       mounted: true,
//     });
//   };

//   NumberFormat.prototype.componentDidUpdate = function componentDidUpdate (prevProps        ) {
//     this.updateValueIfRequired(prevProps);
//   };

//   NumberFormat.prototype.componentWillUnmount = function componentWillUnmount () {
//     clearTimeout(this.focusTimeout);
//     clearTimeout(this.caretPositionTimeout);
//   };

//   NumberFormat.prototype.updateValueIfRequired = function updateValueIfRequired (prevProps        ) {
//     var ref = this;
//     var props = ref.props;
//     var state = ref.state;
//     var focusedElm = ref.focusedElm;
//     var stateValue = state.value;
//     var lastNumStr = state.numAsString; if ( lastNumStr === void 0 ) lastNumStr = '';

//     // If only state changed no need to do any thing
//     if (prevProps !== props) {
//       //validate props
//       this.validateProps();

//       var lastValueWithNewFormat = this.formatNumString(lastNumStr);

//       var formattedValue = isNil(props.value) ? lastValueWithNewFormat : this.formatValueProp();
//       var numAsString = this.removeFormatting(formattedValue);

//       var floatValue = parseFloat(numAsString);
//       var lastFloatValue = parseFloat(lastNumStr);

//       if (
//         //while typing set state only when float value changes
//         ((!isNaN(floatValue) || !isNaN(lastFloatValue)) && floatValue !== lastFloatValue) ||
//         //can also set state when float value is same and the format props changes
//         lastValueWithNewFormat !== stateValue ||
//         //set state always when not in focus and formatted value is changed
//         (focusedElm === null && formattedValue !== stateValue)
//       ) {
//         this.updateValue({
//           formattedValue: formattedValue,
//           numAsString: numAsString,
//           input: focusedElm,
//           source: 'prop',
//           event: null,
//         });
//       }
//     }
//   };

//   /** Misc methods **/
//   NumberFormat.prototype.getFloatString = function getFloatString (num) {
//     if ( num === void 0 ) num         = '';

//     var ref = this.props;
//     var decimalScale = ref.decimalScale;
//     var ref$1 = this.getSeparators();
//     var decimalSeparator = ref$1.decimalSeparator;
//     var numRegex = this.getNumberRegex(true);

//     //remove negation for regex check
//     var hasNegation = num[0] === '-';
//     if (hasNegation) { num = num.replace('-', ''); }

//     //if decimal scale is zero remove decimal and number after decimalSeparator
//     if (decimalSeparator && decimalScale === 0) {
//       num = num.split(decimalSeparator)[0];
//     }

//     num = (num.match(numRegex) || []).join('').replace(decimalSeparator, '.');

//     //remove extra decimals
//     var firstDecimalIndex = num.indexOf('.');

//     if (firstDecimalIndex !== -1) {
//       num = (num.substring(0, firstDecimalIndex)) + "." + (num
//         .substring(firstDecimalIndex + 1, num.length)
//         .replace(new RegExp(escapeRegExp(decimalSeparator), 'g'), ''));
//     }

//     //add negation back
//     if (hasNegation) { num = '-' + num; }

//     return num;
//   };

//   //returned regex assumes decimalSeparator is as per prop
//   NumberFormat.prototype.getNumberRegex = function getNumberRegex (g         , ignoreDecimalSeparator          ) {
//     var ref = this.props;
//     var format = ref.format;
//     var decimalScale = ref.decimalScale;
//     var customNumerals = ref.customNumerals;
//     var ref$1 = this.getSeparators();
//     var decimalSeparator = ref$1.decimalSeparator;
//     return new RegExp(
//       '[0-9' +
//         (customNumerals ? customNumerals.join('') : '') +
//         ']' +
//         (decimalSeparator && decimalScale !== 0 && !ignoreDecimalSeparator && !format
//           ? '|' + escapeRegExp(decimalSeparator)
//           : ''),
//       g ? 'g' : undefined
//     );
//   };

//   NumberFormat.prototype.getSeparators = function getSeparators () {
//     var ref = this.props;
//     var decimalSeparator = ref.decimalSeparator;
//     var ref$1 = this.props;
//     var thousandSeparator = ref$1.thousandSeparator;
//     var allowedDecimalSeparators = ref$1.allowedDecimalSeparators;

//     if (thousandSeparator === true) {
//       thousandSeparator = ',';
//     }
//     if (!allowedDecimalSeparators) {
//       allowedDecimalSeparators = [decimalSeparator, '.'];
//     }

//     return {
//       decimalSeparator: decimalSeparator,
//       thousandSeparator: thousandSeparator,
//       allowedDecimalSeparators: allowedDecimalSeparators,
//     };
//   };

//   NumberFormat.prototype.getMaskAtIndex = function getMaskAtIndex (index        ) {
//     var ref = this.props;
//     var mask = ref.mask; if ( mask === void 0 ) mask = ' ';
//     if (typeof mask === 'string') {
//       return mask;
//     }

//     return mask[index] || ' ';
//   };

//   NumberFormat.prototype.getValueObject = function getValueObject (formattedValue        , numAsString        ) {
//     var floatValue = parseFloat(numAsString);

//     return {
//       formattedValue: formattedValue,
//       value: numAsString,
//       floatValue: isNaN(floatValue) ? undefined : floatValue,
//     };
//   };

//   NumberFormat.prototype.validateProps = function validateProps () {
//     var ref = this.props;
//     var mask = ref.mask;

//     //validate decimalSeparator and thousandSeparator
//     var ref$1 = this.getSeparators();
//     var decimalSeparator = ref$1.decimalSeparator;
//     var thousandSeparator = ref$1.thousandSeparator;

//     if (decimalSeparator === thousandSeparator) {
//       throw new Error(("\n          Decimal separator can't be same as thousand separator.\n          thousandSeparator: " + thousandSeparator + " (thousandSeparator = {true} is same as thousandSeparator = \",\")\n          decimalSeparator: " + decimalSeparator + " (default value for decimalSeparator is .)\n       "));
//     }

//     //validate mask
//     if (mask) {
//       var maskAsStr = mask === 'string' ? mask : mask.toString();
//       if (maskAsStr.match(/\d/g)) {
//         throw new Error(("\n          Mask " + mask + " should not contain numeric character;\n        "));
//       }
//     }
//   };
//   /** Misc methods end **/

//   /** caret specific methods **/
//   NumberFormat.prototype.setPatchedCaretPosition = function setPatchedCaretPosition (el                  , caretPos        , currentValue        ) {
//     /* setting caret position within timeout of 0ms is required for mobile chrome,
//     otherwise browser resets the caret position after we set it
//     We are also setting it without timeout so that in normal browser we don't see the flickering */
//     setCaretPosition(el, caretPos);
//     this.caretPositionTimeout = setTimeout(function () {
//       if (el.value === currentValue) { setCaretPosition(el, caretPos); }
//     }, 0);
//   };

//   /* This keeps the caret within typing area so people can't type in between prefix or suffix */
//   NumberFormat.prototype.correctCaretPosition = function correctCaretPosition (value        , caretPos        , direction         ) {
//     var ref = this.props;
//     var prefix = ref.prefix;
//     var suffix = ref.suffix;
//     var format = ref.format;

//     //if value is empty return 0
//     if (value === '') { return 0; }

//     //caret position should be between 0 and value length
//     caretPos = clamp(caretPos, 0, value.length);

//     //in case of format as number limit between prefix and suffix
//     if (!format) {
//       var hasNegation = value[0] === '-';
//       return clamp(caretPos, prefix.length + (hasNegation ? 1 : 0), value.length - suffix.length);
//     }

//     //in case if custom format method don't do anything
//     if (typeof format === 'function') { return caretPos; }

//     /* in case format is string find the closest # position from the caret position */

//     //in case the caretPos have input value on it don't do anything
//     if (format[caretPos] === '#' && charIsNumber(value[caretPos])) {
//       return caretPos;
//     }

//     //if caretPos is just after input value don't do anything
//     if (format[caretPos - 1] === '#' && charIsNumber(value[caretPos - 1])) {
//       return caretPos;
//     }

//     //find the nearest caret position
//     var firstHashPosition = format.indexOf('#');
//     var lastHashPosition = format.lastIndexOf('#');

//     //limit the cursor between the first # position and the last # position
//     caretPos = clamp(caretPos, firstHashPosition, lastHashPosition + 1);

//     var nextPos = format.substring(caretPos, format.length).indexOf('#');
//     var caretLeftBound = caretPos;
//     var caretRightBound = caretPos + (nextPos === -1 ? 0 : nextPos);

//     //get the position where the last number is present
//     while (
//       caretLeftBound > firstHashPosition &&
//       (format[caretLeftBound] !== '#' || !charIsNumber(value[caretLeftBound]))
//     ) {
//       caretLeftBound -= 1;
//     }

//     var goToLeft =
//       !charIsNumber(value[caretRightBound]) ||
//       (direction === 'left' && caretPos !== firstHashPosition) ||
//       caretPos - caretLeftBound < caretRightBound - caretPos;

//     if (goToLeft) {
//       //check if number should be taken after the bound or after it
//       //if number preceding a valid number keep it after
//       return charIsNumber(value[caretLeftBound]) ? caretLeftBound + 1 : caretLeftBound;
//     }

//     return caretRightBound;
//   };

//   NumberFormat.prototype.getCaretPosition = function getCaretPosition (inputValue        , formattedValue        , caretPos        ) {
//     var ref = this.props;
//     var format = ref.format;
//     var stateValue = this.state.value;
//     var numRegex = this.getNumberRegex(true);
//     var inputNumber = (inputValue.match(numRegex) || []).join('');
//     var formattedNumber = (formattedValue.match(numRegex) || []).join('');
//     var j, i;

//     j = 0;

//     for (i = 0; i < caretPos; i++) {
//       var currentInputChar = inputValue[i] || '';
//       var currentFormatChar = formattedValue[j] || '';
//       //no need to increase new cursor position if formatted value does not have those characters
//       //case inputValue = 1a23 and formattedValue =  123
//       if (!currentInputChar.match(numRegex) && currentInputChar !== currentFormatChar) {
//         continue;
//       }

//       //When we are striping out leading zeros maintain the new cursor position
//       //Case inputValue = 00023 and formattedValue = 23;
//       if (
//         currentInputChar === '0' &&
//         currentFormatChar.match(numRegex) &&
//         currentFormatChar !== '0' &&
//         inputNumber.length !== formattedNumber.length
//       ) {
//         continue;
//       }

//       //we are not using currentFormatChar because j can change here
//       while (currentInputChar !== formattedValue[j] && j < formattedValue.length) {
//         j++;
//       }
//       j++;
//     }

//     if (typeof format === 'string' && !stateValue) {
//       //set it to the maximum value so it goes after the last number
//       j = formattedValue.length;
//     }

//     //correct caret position if its outside of editable area
//     j = this.correctCaretPosition(formattedValue, j);

//     return j;
//   };
//   /** caret specific methods ends **/

//   /** methods to remove formattting **/
//   NumberFormat.prototype.removePrefixAndSuffix = function removePrefixAndSuffix (val        ) {
//     var ref = this.props;
//     var format = ref.format;
//     var prefix = ref.prefix;
//     var suffix = ref.suffix;

//     //remove prefix and suffix
//     if (!format && val) {
//       var isNegative = val[0] === '-';

//       //remove negation sign
//       if (isNegative) { val = val.substring(1, val.length); }

//       //remove prefix
//       val = prefix && val.indexOf(prefix) === 0 ? val.substring(prefix.length, val.length) : val;

//       //remove suffix
//       var suffixLastIndex = val.lastIndexOf(suffix);
//       val =
//         suffix && suffixLastIndex !== -1 && suffixLastIndex === val.length - suffix.length
//           ? val.substring(0, suffixLastIndex)
//           : val;

//       //add negation sign back
//       if (isNegative) { val = '-' + val; }
//     }

//     return val;
//   };

//   NumberFormat.prototype.removePatternFormatting = function removePatternFormatting (val        ) {
//     var ref = this.props;
//     var format = ref.format;
//     var formatArray = format.split('#').filter(function (str) { return str !== ''; });
//     var start = 0;
//     var numStr = '';

//     for (var i = 0, ln = formatArray.length; i <= ln; i++) {
//       var part = formatArray[i] || '';

//       //if i is the last fragment take the index of end of the value
//       //For case like +1 (911) 911 91 91 having pattern +1 (###) ### ## ##
//       var index = i === ln ? val.length : val.indexOf(part, start);

//       /* in any case if we don't find the pattern part in the value assume the val as numeric string
//       This will be also in case if user has started typing, in any other case it will not be -1
//       unless wrong prop value is provided */
//       if (index === -1) {
//         numStr = val;
//         break;
//       } else {
//         numStr += val.substring(start, index);
//         start = index + part.length;
//       }
//     }

//     return (numStr.match(this.getNumberRegex(true)) || []).join('');
//   };

//   NumberFormat.prototype.removeFormatting = function removeFormatting (val        ) {
//     var ref = this.props;
//     var format = ref.format;
//     var removeFormatting = ref.removeFormatting;
//     if (!val) { return val; }

//     if (!format) {
//       val = this.removePrefixAndSuffix(val);
//       val = this.getFloatString(val);
//     } else if (typeof format === 'string') {
//       val = this.removePatternFormatting(val);
//     } else if (typeof removeFormatting === 'function') {
//       //condition need to be handled if format method is provide,
//       val = removeFormatting(val);
//     } else {
//       val = (val.match(this.getNumberRegex(true)) || []).join('');
//     }
//     return val;
//   };
//   /** methods to remove formattting end **/

//   /*** format specific methods start ***/
//   /**
//    * Format when # based string is provided
//    * @param  {string} numStr Numeric String
//    * @return {string}        formatted Value
//    */
//   NumberFormat.prototype.formatWithPattern = function formatWithPattern (numStr        ) {
//     var ref = this.props;
//     var format = ref.format;
//     var hashCount = 0;
//     var formattedNumberAry = format.split('');
//     for (var i = 0, ln = format.length; i < ln; i++) {
//       if (format[i] === '#') {
//         formattedNumberAry[i] = numStr[hashCount] || this.getMaskAtIndex(hashCount);
//         hashCount += 1;
//       }
//     }
//     return formattedNumberAry.join('');
//   };
//   /**
//    * @param  {string} numStr Numeric string/floatString] It always have decimalSeparator as .
//    * @return {string} formatted Value
//    */
//   NumberFormat.prototype.formatAsNumber = function formatAsNumber (numStr        ) {
//     var ref = this.props;
//     var decimalScale = ref.decimalScale;
//     var fixedDecimalScale = ref.fixedDecimalScale;
//     var prefix = ref.prefix;
//     var suffix = ref.suffix;
//     var allowNegative = ref.allowNegative;
//     var thousandsGroupStyle = ref.thousandsGroupStyle;
//     var ref$1 = this.getSeparators();
//     var thousandSeparator = ref$1.thousandSeparator;
//     var decimalSeparator = ref$1.decimalSeparator;

//     var hasDecimalSeparator = numStr.indexOf('.') !== -1 || (decimalScale && fixedDecimalScale);
//     var ref$2 = splitDecimal(numStr, allowNegative);
//     var beforeDecimal = ref$2.beforeDecimal;
//     var afterDecimal = ref$2.afterDecimal;
//     var addNegation = ref$2.addNegation; // eslint-disable-line prefer-const

//     //apply decimal precision if its defined
//     if (decimalScale !== undefined) {
//       afterDecimal = limitToScale(afterDecimal, decimalScale, fixedDecimalScale);
//     }

//     if (thousandSeparator) {
//       beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
//     }

//     //add prefix and suffix
//     if (prefix) { beforeDecimal = prefix + beforeDecimal; }
//     if (suffix) { afterDecimal = afterDecimal + suffix; }

//     //restore negation sign
//     if (addNegation) { beforeDecimal = '-' + beforeDecimal; }

//     numStr = beforeDecimal + ((hasDecimalSeparator && decimalSeparator) || '') + afterDecimal;

//     return numStr;
//   };

//   NumberFormat.prototype.formatNumString = function formatNumString (numStr) {
//     if ( numStr === void 0 ) numStr         = '';

//     var ref = this.props;
//     var format = ref.format;
//     var allowEmptyFormatting = ref.allowEmptyFormatting;
//     var customNumerals = ref.customNumerals;
//     var formattedValue = numStr;

//     if (customNumerals && customNumerals.length === 10) {
//       var customNumeralRegex = new RegExp('[' + customNumerals.join('') + ']', 'g');
//       formattedValue = numStr.replace(customNumeralRegex, function (digit) { return customNumerals.indexOf(digit).toString(); }
//       );
//     }

//     if (numStr === '' && !allowEmptyFormatting) {
//       formattedValue = '';
//     } else if (numStr === '-' && !format) {
//       formattedValue = '-';
//     } else if (typeof format === 'string') {
//       formattedValue = this.formatWithPattern(formattedValue);
//     } else if (typeof format === 'function') {
//       formattedValue = format(formattedValue);
//     } else {
//       formattedValue = this.formatAsNumber(formattedValue);
//     }

//     return formattedValue;
//   };

//   NumberFormat.prototype.formatValueProp = function formatValueProp (defaultValue                 ) {
//     var ref = this.props;
//     var format = ref.format;
//     var decimalScale = ref.decimalScale;
//     var fixedDecimalScale = ref.fixedDecimalScale;
//     var allowEmptyFormatting = ref.allowEmptyFormatting;
//     var ref$1 = this.props;
//     var value = ref$1.value;
//     var isNumericString = ref$1.isNumericString;

//     // if value is undefined or null, use defaultValue instead
//     value = isNil(value) ? defaultValue : value;

//     var isNonNumericFalsy = !value && value !== 0;

//     if (isNonNumericFalsy && allowEmptyFormatting) {
//       value = '';
//     }

//     // if value is not defined return empty string
//     if (isNonNumericFalsy && !allowEmptyFormatting) { return ''; }

//     if (typeof value === 'number') {
//       value = toNumericString(value);
//       isNumericString = true;
//     }

//     //change infinity value to empty string
//     if (value === 'Infinity' && isNumericString) {
//       value = '';
//     }

//     //round the number based on decimalScale
//     //format only if non formatted value is provided
//     if (isNumericString && !format && typeof decimalScale === 'number') {
//       value = roundToPrecision(value, decimalScale, fixedDecimalScale);
//     }

//     var formattedValue = isNumericString ? this.formatNumString(value) : this.formatInput(value);

//     return formattedValue;
//   };

//   NumberFormat.prototype.formatNegation = function formatNegation (value) {
//     if ( value === void 0 ) value         = '';

//     var ref = this.props;
//     var allowNegative = ref.allowNegative;
//     var negationRegex = new RegExp('(-)');
//     var doubleNegationRegex = new RegExp('(-)(.)*(-)');

//     // Check number has '-' value
//     var hasNegation = negationRegex.test(value);

//     // Check number has 2 or more '-' values
//     var removeNegation = doubleNegationRegex.test(value);

//     //remove negation
//     value = value.replace(/-/g, '');

//     if (hasNegation && !removeNegation && allowNegative) {
//       value = '-' + value;
//     }

//     return value;
//   };

//   NumberFormat.prototype.formatInput = function formatInput (value) {
//     if ( value === void 0 ) value         = '';

//     var ref = this.props;
//     var format = ref.format;

//     //format negation only if we are formatting as number
//     if (!format) {
//       value = this.removePrefixAndSuffix(value);
//       value = this.formatNegation(value);
//     }

//     //remove formatting from number
//     value = this.removeFormatting(value);

//     return this.formatNumString(value);
//   };

//   /*** format specific methods end ***/
//   NumberFormat.prototype.isCharacterAFormat = function isCharacterAFormat (caretPos        , value        ) {
//     var ref = this.props;
//     var format = ref.format;
//     var prefix = ref.prefix;
//     var suffix = ref.suffix;
//     var decimalScale = ref.decimalScale;
//     var fixedDecimalScale = ref.fixedDecimalScale;
//     var ref$1 = this.getSeparators();
//     var decimalSeparator = ref$1.decimalSeparator;

//     //check within format pattern
//     if (typeof format === 'string' && format[caretPos] !== '#') { return true; }

//     //check in number format
//     if (
//       !format &&
//       (caretPos < prefix.length ||
//         caretPos >= value.length - suffix.length ||
//         (decimalScale && fixedDecimalScale && value[caretPos] === decimalSeparator))
//     ) {
//       return true;
//     }

//     return false;
//   };

//   /**
//    * This will check if any formatting got removed by the delete or backspace and reset the value
//    * It will also work as fallback if android chome keyDown handler does not work
//    **/
//   NumberFormat.prototype.correctInputValue = function correctInputValue (caretPos        , lastValue        , value        ) {
//     var this$1$1 = this;

//     var ref = this.props;
//     var format = ref.format;
//     var allowNegative = ref.allowNegative;
//     var prefix = ref.prefix;
//     var suffix = ref.suffix;
//     var decimalScale = ref.decimalScale;
//     var ref$1 = this.getSeparators();
//     var allowedDecimalSeparators = ref$1.allowedDecimalSeparators;
//     var decimalSeparator = ref$1.decimalSeparator;
//     var lastNumStr = this.state.numAsString || '';
//     var ref$2 = this.selectionBeforeInput;
//     var selectionStart = ref$2.selectionStart;
//     var selectionEnd = ref$2.selectionEnd;
//     var ref$3 = findChangedIndex(lastValue, value);
//     var start = ref$3.start;
//     var end = ref$3.end;

//     /** Check for any allowed decimal separator is added in the numeric format and replace it with decimal separator */
//     if (
//       !format &&
//       start === end &&
//       allowedDecimalSeparators.indexOf(value[selectionStart]) !== -1
//     ) {
//       var separator = decimalScale === 0 ? '' : decimalSeparator;
//       return (
//         value.substr(0, selectionStart) + separator + value.substr(selectionStart + 1, value.length)
//       );
//     }

//     var leftBound = !!format ? 0 : prefix.length;
//     var rightBound = lastValue.length - (!!format ? 0 : suffix.length);

//     if (
//       // don't do anything if something got added
//       value.length > lastValue.length ||
//       // or if the new value is an empty string
//       !value.length ||
//       // or if nothing has changed, in which case start will be same as end
//       start === end ||
//       // or in case if whole input is selected and new value is typed
//       (selectionStart === 0 && selectionEnd === lastValue.length) ||
//       // or in case if the whole content is replaced by browser, example (autocomplete)
//       (start === 0 && end === lastValue.length) ||
//       // or if charcters between prefix and suffix is selected.
//       // For numeric inputs we apply the format so, prefix and suffix can be ignored
//       (selectionStart === leftBound && selectionEnd === rightBound)
//     ) {
//       return value;
//     }

//     // check whether the deleted portion has a character that is part of a format
//     var deletedValues = lastValue.substr(start, end - start);
//     var formatGotDeleted = !![].concat( deletedValues ).find(function (deletedVal, idx) { return this$1$1.isCharacterAFormat(idx + start, lastValue); }
//     );

//     // if it has, only remove characters that are not part of the format
//     if (formatGotDeleted) {
//       var deletedValuePortion = lastValue.substr(start);
//       var recordIndexOfFormatCharacters = {};
//       var resolvedPortion = [];
//       [].concat( deletedValuePortion ).forEach(function (currentPortion, idx) {
//         if (this$1$1.isCharacterAFormat(idx + start, lastValue)) {
//           recordIndexOfFormatCharacters[idx] = currentPortion;
//         } else if (idx > deletedValues.length - 1) {
//           resolvedPortion.push(currentPortion);
//         }
//       });

//       Object.keys(recordIndexOfFormatCharacters).forEach(function (idx) {
//         if (resolvedPortion.length > idx) {
//           resolvedPortion.splice(idx, 0, recordIndexOfFormatCharacters[idx]);
//         } else {
//           resolvedPortion.push(recordIndexOfFormatCharacters[idx]);
//         }
//       });

//       value = lastValue.substr(0, start) + resolvedPortion.join('');
//     }

//     //for numbers check if beforeDecimal got deleted and there is nothing after decimal,
//     //clear all numbers in such case while keeping the - sign
//     if (!format) {
//       var numericString = this.removeFormatting(value);
//       var ref$4 = splitDecimal(
//         numericString,
//         allowNegative
//       );
//       var beforeDecimal = ref$4.beforeDecimal;
//       var afterDecimal = ref$4.afterDecimal;
//       var addNegation = ref$4.addNegation; // eslint-disable-line prefer-const

//       //clear only if something got deleted
//       var isBeforeDecimalPoint = caretPos < value.indexOf(decimalSeparator) + 1;
//       if (
//         numericString.length < lastNumStr.length &&
//         isBeforeDecimalPoint &&
//         beforeDecimal === '' &&
//         !parseFloat(afterDecimal)
//       ) {
//         return addNegation ? '-' : '';
//       }
//     }

//     return value;
//   };

//   /** Update value and caret position */
//   NumberFormat.prototype.updateValue = function updateValue (params   
                           
                        
                       
                            
                               
                   
                     
                              
//    ) {
//     var formattedValue = params.formattedValue;
//     var input = params.input;
//     var setCaretPosition = params.setCaretPosition; if ( setCaretPosition === void 0 ) setCaretPosition = true;
//     var source = params.source;
//     var event = params.event;
//     var numAsString = params.numAsString;
//     var caretPos = params.caretPos;
//     var ref = this.props;
//     var onValueChange = ref.onValueChange;
//     var ref$1 = this.state;
//     var lastValue = ref$1.value;

//     if (input) {
//       //calculate caret position if not defined
//       if (caretPos === undefined && setCaretPosition) {
//         var inputValue = params.inputValue || input.value;

//         var currentCaretPosition = getCurrentCaretPosition(input);

//         /**
//          * set the value imperatively, this is required for IE fix
//          * This is also required as if new caret position is beyond the previous value.
//          * Caret position will not be set correctly
//          */
//         input.value = formattedValue;

//         //get the caret position
//         caretPos = this.getCaretPosition(inputValue, formattedValue, currentCaretPosition);
//       }

//       /**
//        * set the value imperatively, as we set the caret position as well imperatively.
//        * This is to keep value and caret position in sync
//        */
//       input.value = formattedValue;

//       //set caret position, and value imperatively when element is provided
//       if (setCaretPosition) {
//         //set caret position
//         this.setPatchedCaretPosition(input, caretPos, formattedValue);
//       }
//     }

//     //calculate numeric string if not passed
//     if (numAsString === undefined) {
//       numAsString = this.removeFormatting(formattedValue);
//     }

//     //update state if value is changed
//     if (formattedValue !== lastValue) {
//       this.setState({ value: formattedValue, numAsString: numAsString });

//       // trigger onValueChange synchronously, so parent is updated along with the number format. Fix for #277, #287
//       onValueChange(this.getValueObject(formattedValue, numAsString), { event: event, source: source });
//     }
//   };

//   NumberFormat.prototype.onChange = function onChange (e                     ) {
//     var el = e.target;
//     var inputValue = el.value;
//     var ref = this;
//     var state = ref.state;
//     var props = ref.props;
//     var isAllowed = props.isAllowed;
//     var lastValue = state.value || '';

//     var currentCaretPosition = getCurrentCaretPosition(el);

//     inputValue = this.correctInputValue(currentCaretPosition, lastValue, inputValue);

//     var formattedValue = this.formatInput(inputValue) || '';
//     var numAsString = this.removeFormatting(formattedValue);

//     var valueObj = this.getValueObject(formattedValue, numAsString);
//     var isChangeAllowed = isAllowed(valueObj);

//     if (!isChangeAllowed) {
//       formattedValue = lastValue;
//     }

//     this.updateValue({
//       formattedValue: formattedValue,
//       numAsString: numAsString,
//       inputValue: inputValue,
//       input: el,
//       event: e,
//       source: 'event',
//     });

//     if (isChangeAllowed) {
//       props.onChange(e);
//     }
//   };

//   NumberFormat.prototype.onBlur = function onBlur (e                     ) {
//     var ref = this;
//     var props = ref.props;
//     var state = ref.state;
//     var format = props.format;
//     var onBlur = props.onBlur;
//     var allowLeadingZeros = props.allowLeadingZeros;
//     var numAsString = state.numAsString;
//     var lastValue = state.value;
//     this.focusedElm = null;

//     clearTimeout(this.focusTimeout);
//     clearTimeout(this.caretPositionTimeout);

//     if (!format) {
//       // if the numAsString is not a valid number reset it to empty
//       if (isNaN(parseFloat(numAsString))) {
//         numAsString = '';
//       }

//       if (!allowLeadingZeros) {
//         numAsString = fixLeadingZero(numAsString);
//       }

//       var formattedValue = this.formatNumString(numAsString);

//       //change the state
//       if (formattedValue !== lastValue) {
//         // the event needs to be persisted because its properties can be accessed in an asynchronous way
//         this.updateValue({
//           formattedValue: formattedValue,
//           numAsString: numAsString,
//           input: e.target,
//           setCaretPosition: false,
//           event: e,
//           source: 'event',
//         });
//         onBlur(e);
//         return;
//       }
//     }
//     onBlur(e);
//   };

//   NumberFormat.prototype.onKeyDown = function onKeyDown (e                             ) {
//     var el = e.target;
//     var key = e.key;
//     var selectionStart = el.selectionStart;
//     var selectionEnd = el.selectionEnd;
//     var value = el.value; if ( value === void 0 ) value = '';
//     var expectedCaretPosition;
//     var ref = this.props;
//     var decimalScale = ref.decimalScale;
//     var fixedDecimalScale = ref.fixedDecimalScale;
//     var prefix = ref.prefix;
//     var suffix = ref.suffix;
//     var format = ref.format;
//     var onKeyDown = ref.onKeyDown;
//     var ignoreDecimalSeparator = decimalScale !== undefined && fixedDecimalScale;
//     var numRegex = this.getNumberRegex(false, ignoreDecimalSeparator);
//     var negativeRegex = new RegExp('-');
//     var isPatternFormat = typeof format === 'string';

//     this.selectionBeforeInput = {
//       selectionStart: selectionStart,
//       selectionEnd: selectionEnd,
//     };

//     //Handle backspace and delete against non numerical/decimal characters or arrow keys
//     if (key === 'ArrowLeft' || key === 'Backspace') {
//       expectedCaretPosition = selectionStart - 1;
//     } else if (key === 'ArrowRight') {
//       expectedCaretPosition = selectionStart + 1;
//     } else if (key === 'Delete') {
//       expectedCaretPosition = selectionStart;
//     }

//     //if expectedCaretPosition is not set it means we don't want to Handle keyDown
//     //also if multiple characters are selected don't handle
//     if (expectedCaretPosition === undefined || selectionStart !== selectionEnd) {
//       onKeyDown(e);
//       return;
//     }

//     var newCaretPosition = expectedCaretPosition;
//     var leftBound = isPatternFormat ? format.indexOf('#') : prefix.length;
//     var rightBound = isPatternFormat ? format.lastIndexOf('#') + 1 : value.length - suffix.length;

//     if (key === 'ArrowLeft' || key === 'ArrowRight') {
//       var direction = key === 'ArrowLeft' ? 'left' : 'right';
//       newCaretPosition = this.correctCaretPosition(value, expectedCaretPosition, direction);
//     } else if (
//       key === 'Delete' &&
//       !numRegex.test(value[expectedCaretPosition]) &&
//       !negativeRegex.test(value[expectedCaretPosition])
//     ) {
//       while (!numRegex.test(value[newCaretPosition]) && newCaretPosition < rightBound) {
//         newCaretPosition++;
//       }
//     } else if (key === 'Backspace' && !numRegex.test(value[expectedCaretPosition])) {
//       /* NOTE: This is special case when backspace is pressed on a
//       negative value while the cursor position is after prefix. We can't handle it on onChange because
//       we will not have any information of keyPress
//       */
//       if (selectionStart <= leftBound + 1 && value[0] === '-' && typeof format === 'undefined') {
//         var newValue = value.substring(1);
//         this.updateValue({
//           formattedValue: newValue,
//           caretPos: newCaretPosition,
//           input: el,
//           event: e,
//           source: 'event',
//         });
//       } else if (!negativeRegex.test(value[expectedCaretPosition])) {
//         while (!numRegex.test(value[newCaretPosition - 1]) && newCaretPosition > leftBound) {
//           newCaretPosition--;
//         }
//         newCaretPosition = this.correctCaretPosition(value, newCaretPosition, 'left');
//       }
//     }

//     if (
//       newCaretPosition !== expectedCaretPosition ||
//       expectedCaretPosition < leftBound ||
//       expectedCaretPosition > rightBound
//     ) {
//       e.preventDefault();
//       this.setPatchedCaretPosition(el, newCaretPosition, value);
//     }

//     /* NOTE: this is just required for unit test as we need to get the newCaretPosition,
//             Remove this when you find different solution */
//     if (e.isUnitTestRun) {
//       this.setPatchedCaretPosition(el, newCaretPosition, value);
//     }

//     onKeyDown(e);
//   };

//   /** required to handle the caret position when click anywhere within the input **/
//   NumberFormat.prototype.onMouseUp = function onMouseUp (e                          ) {
//     var el = e.target;

//     /**
//      * NOTE: we have to give default value for value as in case when custom input is provided
//      * value can come as undefined when nothing is provided on value prop.
//      */
//     var selectionStart = el.selectionStart;
//     var selectionEnd = el.selectionEnd;
//     var value = el.value; if ( value === void 0 ) value = '';

//     if (selectionStart === selectionEnd) {
//       var caretPosition = this.correctCaretPosition(value, selectionStart);
//       if (caretPosition !== selectionStart) {
//         this.setPatchedCaretPosition(el, caretPosition, value);
//       }
//     }

//     this.props.onMouseUp(e);
//   };

//   NumberFormat.prototype.onFocus = function onFocus (e                     ) {
//     var this$1$1 = this;

//     // Workaround Chrome and Safari bug https://bugs.chromium.org/p/chromium/issues/detail?id=779328
//     // (onFocus event target selectionStart is always 0 before setTimeout)
//     e.persist();

//     this.focusedElm = e.target;
//     this.focusTimeout = setTimeout(function () {
//       var el = e.target;
//       var selectionStart = el.selectionStart;
//       var selectionEnd = el.selectionEnd;
//       var value = el.value; if ( value === void 0 ) value = '';

//       var caretPosition = this$1$1.correctCaretPosition(value, selectionStart);

//       //setPatchedCaretPosition only when everything is not selected on focus (while tabbing into the field)
//       if (
//         caretPosition !== selectionStart &&
//         !(selectionStart === 0 && selectionEnd === value.length)
//       ) {
//         this$1$1.setPatchedCaretPosition(el, caretPosition, value);
//       }

//       this$1$1.props.onFocus(e);
//     }, 0);
//   };

//   NumberFormat.prototype.render = function render () {
//     var ref = this.props;
//     var type = ref.type;
//     var displayType = ref.displayType;
//     var customInput = ref.customInput;
//     var renderText = ref.renderText;
//     var getInputRef = ref.getInputRef;
//     var format = ref.format;
//     ref.thousandSeparator;
//     ref.decimalSeparator;
//     ref.allowedDecimalSeparators;
//     ref.thousandsGroupStyle;
//     ref.decimalScale;
//     ref.fixedDecimalScale;
//     ref.prefix;
//     ref.suffix;
//     ref.removeFormatting;
//     ref.mask;
//     ref.defaultValue;
//     ref.isNumericString;
//     ref.allowNegative;
//     ref.allowEmptyFormatting;
//     ref.allowLeadingZeros;
//     ref.onValueChange;
//     ref.isAllowed;
//     ref.customNumerals;
//     ref.onChange;
//     ref.onKeyDown;
//     ref.onMouseUp;
//     ref.onFocus;
//     ref.onBlur;
//     ref.value;
//     var rest = objectWithoutProperties( ref, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "thousandSeparator", "decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "decimalScale", "fixedDecimalScale", "prefix", "suffix", "removeFormatting", "mask", "defaultValue", "isNumericString", "allowNegative", "allowEmptyFormatting", "allowLeadingZeros", "onValueChange", "isAllowed", "customNumerals", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value"] );
//     var otherProps = rest;
//     var ref$1 = this.state;
//     var value = ref$1.value;
//     var mounted = ref$1.mounted;

//     // add input mode on element based on format prop and device once the component is mounted
//     var inputMode = mounted && addInputMode(format) ? 'numeric' : undefined;

//     var inputProps = Object.assign({ inputMode: inputMode }, otherProps, {
//       type: type,
//       value: value,
//       onChange: this.onChange,
//       onKeyDown: this.onKeyDown,
//       onMouseUp: this.onMouseUp,
//       onFocus: this.onFocus,
//       onBlur: this.onBlur,
//     });

//     if (displayType === 'text') {
//       return renderText ? (
//         renderText(value, otherProps) || null
//       ) : (
//         React__default.createElement( 'span', Object.assign({}, otherProps, { ref: getInputRef }),
//           value
//         )
//       );
//     } else if (customInput) {
//       var CustomInput = customInput;
//       return React__default.createElement( CustomInput, Object.assign({}, inputProps, { ref: getInputRef }));
//     }

//     return React__default.createElement( 'input', Object.assign({}, inputProps, { ref: getInputRef }));
//   };

//   return NumberFormat;
// }(React__default.Component));

// NumberFormat.defaultProps = defaultProps;

// var SumTNumberFormat = function SumTNumberFormat(_ref) {
//   var format = _ref.format,
//     mask = _ref.mask,
//     isNumericString = _ref.isNumericString,
//     inputRef = _ref.inputRef,
//     value = _ref.value,
//     type = _ref.type,
//     onValueChange = _ref.onValueChange,
//     onBlur = _ref.onBlur,
//     onFocus = _ref.onFocus,
//     onKeyDown = _ref.onKeyDown,
//     placeholder = _ref.placeholder,
//     disabled = _ref.disabled,
//     className = _ref.className,
//     thousandSeparator = _ref.thousandSeparator,
//     prefix = _ref.prefix,
//     allowEmptyFormatting = _ref.allowEmptyFormatting,
//     inputProps = _ref.inputProps;
//   return /*#__PURE__*/React__default.createElement(NumberFormat, _extends$v({}, inputProps, {
//     format: format,
//     mask: mask,
//     isNumericString: isNumericString,
//     getInputRef: inputRef,
//     value: value,
//     type: type,
//     onValueChange: onValueChange,
//     onBlur: onBlur,
//     onFocus: onFocus,
//     onKeyDown: onKeyDown,
//     placeholder: placeholder,
//     disabled: disabled,
//     className: className,
//     thousandSeparator: thousandSeparator,
//     prefix: prefix,
//     allowEmptyFormatting: allowEmptyFormatting
//   }));
// };
// SumTNumberFormat.propTypes = {
//   /**
//    * If format given as hash string allow number input inplace of hash.
//    * If format given as function, component calls the function with unformatted number and expects formatted number.
//    */
//   format: PropTypes__default.string,
//   /**
//    * If mask defined, component will show non entered placed with masked value.
//    */
//   mask: PropTypes__default.string,
//   /**
//    * If value is passed as string representation of numbers (unformatted) then this should be passed as true
//    */
//   isNumericString: PropTypes__default.bool,
//   /**
//    * Input type attribute
//    */
//   type: PropTypes__default.oneOf(['text']),
//   /**
//    * On Value Change handler
//    */
//   onValueChange: PropTypes__default.func,
//   /**
//    * Method to get reference of input, span (based on displayType prop) or the customInput's reference.
//    */
//   inputRef: PropTypes__default.func,
//   /**
//    * Value to the number format. It can be a float number, or formatted string.
//    * If value is string representation of number (unformatted), isNumericString props should be passed as true.
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string]),
//   /**
//    * On Blur handler
//    */
//   onBlur: PropTypes__default.func,
//   /**
//    * On Focus handler
//    */
//   onFocus: PropTypes__default.func,
//   /**
//    * On Key Down handler
//    */
//   onKeyDown: PropTypes__default.func,
//   /**
//    * Text for placeholder
//    */
//   placeholder: PropTypes__default.string,
//   /**
//    * Disable the number format
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * Add thousand separators on number
//    */
//   thousandSeparator: PropTypes__default.oneOfType([PropTypes__default.bool, PropTypes__default.string]),
//   /**
//    * Add a prefix before the number
//    */
//   prefix: PropTypes__default.string,
//   /**
//    * Apply formatting to empty inputs
//    */
//   allowEmptyFormatting: PropTypes__default.bool,
//   /**
//    * Props for input base
//    */
//   inputProps: PropTypes__default.shape({})
// };
// SumTNumberFormat.defaultProps = {
//   format: null,
//   mask: '',
//   isNumericString: false,
//   type: 'text',
//   value: null,
//   inputRef: function inputRef() {
//     return null;
//   },
//   onValueChange: function onValueChange() {
//     return null;
//   },
//   onBlur: function onBlur() {
//     return null;
//   },
//   onFocus: function onFocus() {
//     return null;
//   },
//   onKeyDown: function onKeyDown() {
//     return null;
//   },
//   disabled: false,
//   placeholder: '',
//   className: '',
//   thousandSeparator: true,
//   prefix: '',
//   allowEmptyFormatting: false,
//   inputProps: undefined
// };

// var MyInputComponent = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
//   return /*#__PURE__*/React__default.createElement(SumTNumberFormat, _extends$v({}, props, {
//     innerRef: ref
//   }));
// });

// /**
//  * Component which auto formats the input, ensure user clarity about how much information they need to enter.
//  */
// var TextWithNumberFormatting = function TextWithNumberFormatting(_ref) {
//   var format = _ref.format,
//     mask = _ref.mask,
//     isNumericString = _ref.isNumericString,
//     onChange = _ref.onChange,
//     value = _ref.value,
//     label = _ref.label,
//     placeholder = _ref.placeholder,
//     required = _ref.required,
//     helperText = _ref.helperText,
//     error = _ref.error,
//     disabled = _ref.disabled,
//     className = _ref.className,
//     thousandSeparator = _ref.thousandSeparator,
//     prefix = _ref.prefix,
//     allowEmptyFormatting = _ref.allowEmptyFormatting,
//     inputProps = _ref.inputProps;
//   return /*#__PURE__*/React__default.createElement(TextField, {
//     variant: "outlined",
//     label: label,
//     InputProps: {
//       inputComponent: MyInputComponent
//     },
//     inputLabelProps: {
//       shrink: true
//     },
//     required: required,
//     helperText: helperText,
//     error: error,
//     disabled: disabled,
//     placeholder: placeholder,
//     className: className,
//     inputProps: {
//       format: format,
//       mask: mask,
//       onValueChange: onChange,
//       isNumericString: isNumericString,
//       value: value,
//       thousandSeparator: thousandSeparator,
//       prefix: prefix,
//       allowEmptyFormatting: allowEmptyFormatting,
//       inputProps: inputProps
//     }
//   });
// };
// TextWithNumberFormatting.propTypes = {
//   /**
//    * If format given as hash string allow number input inplace of hash.
//    * If format given as function, component calls the function with unformatted number and expects formatted number.
//    */
//   format: PropTypes__default.string,
//   /**
//    * If mask defined, component will show non entered placed with masked value.
//    */
//   mask: PropTypes__default.string,
//   /**
//    * If value is passed as string representation of numbers (unformatted) then this should be passed as true
//    */
//   isNumericString: PropTypes__default.bool,
//   /**
//    * On Change handler
//    */
//   onChange: PropTypes__default.func,
//   /**
//    * Value to the number format. It can be a float number, or formatted string.
//    * If value is string representation of number (unformatted), isNumericString props should be passed as true.
//    */
//   value: PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.string]),
//   /**
//    * Text for label
//    */
//   label: PropTypes__default.string,
//   /**
//    * Text for placeholder
//    */
//   placeholder: PropTypes__default.string,
//   /**
//    * Label is displayed as required
//    */
//   required: PropTypes__default.bool,
//   /**
//    * Content for helper text
//    */
//   helperText: PropTypes__default.string,
//   /**
//    * Display label in error state
//    */
//   error: PropTypes__default.bool,
//   /**
//    * Disable the input
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Class name for manually added styles
//    */
//   className: PropTypes__default.string,
//   /**
//    * Add thousand separators on number
//    */
//   thousandSeparator: PropTypes__default.oneOfType([PropTypes__default.bool, PropTypes__default.string]),
//   /**
//    * Add a prefix before the number
//    */
//   prefix: PropTypes__default.string,
//   /**
//    * Apply formatting to empty inputs
//    */
//   allowEmptyFormatting: PropTypes__default.bool,
//   /**
//    * Props for input base
//    */
//   inputProps: PropTypes__default.shape({})
// };
// TextWithNumberFormatting.defaultProps = {
//   format: null,
//   mask: '',
//   isNumericString: false,
//   value: null,
//   onChange: function onChange() {
//     return null;
//   },
//   label: '',
//   placeholder: '',
//   required: false,
//   helperText: '',
//   error: false,
//   disabled: false,
//   className: '',
//   thousandSeparator: true,
//   prefix: null,
//   allowEmptyFormatting: false,
//   inputProps: undefined
// };

// /**
//  *This component used to render Tooltip element as table cell content.
//  */

// function TooltipCell(_ref) {
//   _ref.title;
//     var arrow = _ref.arrow,
//     placement = _ref.placement,
//     children = _ref.children,
//     className = _ref.className,
//     open = _ref.open,
//     PopperProps = _ref.PopperProps;
//   var _useContext = useContext(TableRowContext),
//     cellValue = _useContext.cellValue;
//   return cellValue !== null ? /*#__PURE__*/React__default.createElement(Tooltip$1, {
//     title: cellValue,
//     arrow: arrow,
//     placement: placement,
//     className: className,
//     open: open,
//     PopperProps: PopperProps
//   }, children) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null);
// }

// // PropType check
// TooltipCell.propTypes = {
//   /**
//    * Tooltip title
//    */
//   title: PropTypes__default.node,
//   /**
//    * adds an arrow to the tooltip
//    */
//   arrow: PropTypes__default.bool,
//   /**
//    * Tooltip placement
//    */
//   placement: PropTypes__default.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
//   /**
//    * Child elements for the component
//    * Note: Tooltip component expects children element that supports forwardref.
//    */
//   children: PropTypes__default.element,
//   /**
//    * className property to support styled function.
//    */
//   className: PropTypes__default.string,
//   /**
//    * Flag that determines if the tooltip is displayed
//    */
//   open: PropTypes__default.bool,
//   /**
//    * Object to set props on the Tooltip's Popper comopnoent
//    */
//   PopperProps: PropTypes__default.shape({})
// };
// TooltipCell.defaultProps = {
//   title: '',
//   arrow: false,
//   placement: 'bottom',
//   children: undefined,
//   className: '',
//   open: undefined,
//   PopperProps: undefined
// };

// var _templateObject$m;
// var TButton = styled(SumtButtonWrapper)(_templateObject$m || (_templateObject$m = _taggedTemplateLiteral$1(["\n  ", "\n"])), function () {
//   return "\n  color: #fff;\n  padding: 0.313rem 0.938rem;\n  background-color: transparent;\n  box-shadow: none;\n  &:hover,\n  &:focus,\n  &:active\n  {\n    background-color: ".concat(curriedTransparentize$1('0.15', '#fff'), ";\n    border: 0.0625rem solid #fff;\n  }\n  ");
// });

// /**
//  * Component for Transparent Button.
//  * It gets the background, text, border colors passed as style-component props.
//  */
// var TransparentButton = function TransparentButton(_ref) {
//   var onClick = _ref.onClick,
//     disabled = _ref.disabled,
//     endIcon = _ref.endIcon,
//     startIcon = _ref.startIcon,
//     children = _ref.children,
//     className = _ref.className,
//     size = _ref.size,
//     component = _ref.component,
//     path = _ref.path,
//     ariaLabel = _ref.ariaLabel;
//   return /*#__PURE__*/React__default.createElement(TButton, {
//     disabled: disabled,
//     onClick: onClick,
//     endIcon: endIcon,
//     startIcon: startIcon,
//     className: className,
//     size: size,
//     component: component,
//     path: path,
//     ariaLabel: ariaLabel
//   }, children);
// };
// TransparentButton.propTypes = {
//   /**
//    * On click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Disabled state of the button
//    */
//   disabled: PropTypes__default.bool,
//   /**
//    * Children component/element for the button
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * End icon node
//    */
//   endIcon: PropTypes__default.node,
//   /**
//    * Start icon node
//    */
//   startIcon: PropTypes__default.node,
//   /**
//    * Class Name
//    */
//   className: PropTypes__default.string,
//   /**
//    * Button size
//    */
//   size: PropTypes__default.string,
//   /**
//    * The component used for the root node.
//    */
//   component: PropTypes__default.elementType,
//   /**
//    * path to navigate, only applicable when component is `Link`
//    */
//   path: PropTypes__default.string,
//   /**
//    * Value of aria-label attribute to be used for button
//    */
//   ariaLabel: PropTypes__default.string
// };
// TransparentButton.defaultProps = {
//   onClick: undefined,
//   disabled: false,
//   endIcon: undefined,
//   startIcon: undefined,
//   className: undefined,
//   size: 'medium',
//   component: 'button',
//   path: undefined,
//   ariaLabel: null
// };

// var _templateObject$l, _templateObject2$i;
// var StyledRequiredIndicator = styled(RequiredIndicator)(_templateObject$l || (_templateObject$l = _taggedTemplateLiteral$1(["\n  padding-left: 0.1875rem;\n  .Mui-selected & {\n    color: inherit;\n  }\n  .Mui-selected.plain-list & {\n    color: ", ";\n  }\n"])), function (_ref) {
//   var theme = _ref.theme;
//   return theme.variables.brandDanger;
// });
// var StyledListItem$1 = styled(ListItem)(_templateObject2$i || (_templateObject2$i = _taggedTemplateLiteral$1(["\n  border-bottom-width: 0.0625rem;\n  line-height: 1.4rem;\n  margin-bottom: 0.255rem;\n  padding: 0.01rem 0.5rem;\n  border-bottom-width: 0px;\n  border-bottom-style: solid;\n  border-bottom-color: #d2d2d2;\n  color: inherit;\n\n  &:link {\n    color: inherit;\n  }\n  &.Mui-selected,\n  &.Mui-selected:hover {\n    background-color: ", ";\n    color: ", ";\n    border-left: none;\n  }\n\n  &.plain-list {\n    border-bottom-width: 0rem;\n    &.Mui-selected,\n    &.Mui-selected:hover {\n      background-color: transparent;\n      color: inherit;\n      border-left: 0.3125rem solid\n        ", ";\n    }\n  }\n"])), function (_ref2) {
//   var theme = _ref2.theme;
//   return theme.variables.btnPrimaryBg;
// }, function (_ref3) {
//   var theme = _ref3.theme;
//   return theme.variables.btnPrimaryColor;
// }, function (_ref4) {
//   var theme = _ref4.theme;
//   return theme.variables.btnPrimaryBg;
// });

// function TreeListItem(props) {
//   var isPlainList = props.isPlainList,
//     children = props.children,
//     required = props.required,
//     path = props.path;
//   return /*#__PURE__*/React__default.createElement(StyledListItem$1, _extends$v({}, props, {
//     className: isPlainList && 'plain-list',
//     component: !path ? 'div' : RouteLink
//   }), children, required && /*#__PURE__*/React__default.createElement(StyledRequiredIndicator, null));
// }
// TreeListItem.propTypes = {
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * If `true`, the label is displayed as required and the `input` element` will be required.
//    */
//   required: PropTypes__default.bool,
//   /**
//    * If `true`, the bottom border will be displayed for sub items.
//    */
//   isPlainList: PropTypes__default.bool,
//   /**
//    * path to navigate, only applicable when component is `Link`
//    */
//   path: PropTypes__default.string
// };
// TreeListItem.defaultProps = {
//   required: false,
//   children: undefined,
//   isPlainList: false,
//   path: undefined
// };

// var _templateObject$k, _templateObject2$h;
// var CollapseStyled = styled.div(_templateObject$k || (_templateObject$k = _taggedTemplateLiteral$1(["\n  margin-left: 1.4rem;\n"])));
// var IconStyled = styled.span(_templateObject2$h || (_templateObject2$h = _taggedTemplateLiteral$1(["\n  position: relative;\n  margin-left: -0.5rem;\n  height: 1.5rem;\n  &.expand {\n    transform: rotate(0deg);\n  }\n  &.closed {\n    transform: rotate(-90deg);\n  }\n"])));

// function CollapsibleListItem(_ref) {
//   var isPlainList = _ref.isPlainList,
//     label = _ref.label,
//     required = _ref.required,
//     children = _ref.children,
//     selected = _ref.selected,
//     expand = _ref.expand,
//     path = _ref.path;
//   var _useState = useState$1({
//       open: expand
//     }),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     state = _useState2[0],
//     setState = _useState2[1];
//   var handleClick = function handleClick() {
//     setState(function (prevState) {
//       return {
//         open: !prevState.open
//       };
//     });
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(TreeListItem, {
//     isPlainList: isPlainList,
//     required: required,
//     onClick: handleClick,
//     selected: selected,
//     path: path
//   }, children && /*#__PURE__*/React__default.createElement(IconStyled, {
//     className: state.open ? 'expand' : 'closed'
//   }, /*#__PURE__*/React__default.createElement(Icon, {
//     size: 1.5,
//     iconName: "ExpandMore"
//   })), label), /*#__PURE__*/React__default.createElement(Collapse, {
//     expand: state.open
//   }, /*#__PURE__*/React__default.createElement(CollapseStyled, null, children)));
// }
// CollapsibleListItem.propTypes = {
//   /**
//    * Label to be displayed
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * If `true`, the label is displayed as required.
//    */
//   required: PropTypes__default.bool,
//   /**
//    * Child elements for the component
//    */
//   children: PropTypes__default.node,
//   /**
//    * If `true`, the bottom border will be displayed for sub items.
//    */
//   isPlainList: PropTypes__default.bool,
//   /**
//    * If `true`, list item selected
//    */
//   selected: PropTypes__default.bool,
//   /**
//    * expand or collapse the content
//    */
//   expand: PropTypes__default.bool,
//   /**
//    * path to navigate, only applicable when component is `Link`
//    */
//   path: PropTypes__default.string
// };
// CollapsibleListItem.defaultProps = {
//   required: false,
//   children: undefined,
//   isPlainList: false,
//   selected: false,
//   expand: false,
//   path: undefined
// };

// var isItemSelected = function isItemSelected(selectedKeys, _ref) {
//   var key = _ref.key,
//     path = _ref.path,
//     items = _ref.items;
//   if (selectedKeys.includes(key) || selectedKeys.includes(path)) {
//     return true;
//   }
//   if (!items) {
//     return false;
//   }
//   var isSelected = false;
//   items.every(function (child) {
//     if (isItemSelected(selectedKeys, child)) {
//       isSelected = true;
//       return false;
//     }
//     return true;
//   });
//   return isSelected;
// };
// function TreeList(_ref2) {
//   var data = _ref2.data,
//     selected = _ref2.selected;
//   return /*#__PURE__*/React__default.createElement(List, {
//     component: "div"
//   }, data.map(function (_ref3) {
//     var key = _ref3.key,
//       label = _ref3.label,
//       required = _ref3.required,
//       items = _ref3.items,
//       path = _ref3.path,
//       unselectable = _ref3.unselectable;
//     return /*#__PURE__*/React__default.createElement(React__default.Fragment, {
//       key: key
//     }, /*#__PURE__*/React__default.createElement(CollapsibleListItem, {
//       isPlainList: !items || !items.length,
//       required: required,
//       label: label,
//       selected: !unselectable && isItemSelected(selected, {
//         key: key,
//         path: path,
//         items: items
//       }),
//       expand: isItemSelected(selected, {
//         key: key,
//         path: path,
//         items: items
//       }),
//       path: path
//     }, Array.isArray(items) && /*#__PURE__*/React__default.createElement(TreeList, {
//       data: items,
//       selected: selected
//     })));
//   }));
// }
// var itemsShape = {
//   /**
//    * Label to be displayed
//    */
//   label: PropTypes__default.string.isRequired,
//   /**
//    * Unique key for the list item
//    */
//   key: PropTypes__default.string.isRequired,
//   /**
//    * If `true`, the label is displayed as required.
//    */
//   required: PropTypes__default.bool,
//   /**
//    * path to navigate, only applicable when component is `Link`
//    */
//   path: PropTypes__default.string,
//   /**
//    * if list item can be selected.
//    */
//   unselectable: PropTypes__default.bool
// };
// itemsShape.items = PropTypes__default.arrayOf(PropTypes__default.shape(itemsShape));
// TreeList.propTypes = {
//   /**
//    * List data to be displayed
//    */
//   data: PropTypes__default.arrayOf(PropTypes__default.shape(itemsShape)),
//   /**
//    * Array of keys/paths to be selected
//    */
//   selected: PropTypes__default.arrayOf(PropTypes__default.string)
// };
// TreeList.defaultProps = {
//   data: null,
//   selected: []
// };

// var _templateObject$j, _templateObject2$g, _templateObject3$c, _templateObject4$5, _templateObject5$2, _templateObject6$1, _templateObject7$1, _templateObject8$1;
// var Container = styled.div(_templateObject$j || (_templateObject$j = _taggedTemplateLiteral$1(["\n  height: 16.188rem;\n  width: 23rem;\n  margin-left: -0.38rem;\n  position: relative;\n"])));
// var StyleList = styled(List)(_templateObject2$g || (_templateObject2$g = _taggedTemplateLiteral$1(["\n  width: 22rem;\n"])));
// var StyledBadge = styled(Badge)(_templateObject3$c || (_templateObject3$c = _taggedTemplateLiteral$1(["\n  padding-left: 1.8rem;\n"])));
// var DayContainer = styled.div(_templateObject4$5 || (_templateObject4$5 = _taggedTemplateLiteral$1(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  line-height: 0.063rem;\n"])));
// var StyledListItemText = styled(ListItemText)(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteral$1(["\n  margin: 0rem;\n  padding: 0rem;\n"])));
// var StyledListItemTextOnTheme = styled(ListItemText)(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteral$1(["\n  margin: 0rem;\n  padding: 0rem;\n  color: ", ";\n"])), function (props) {
//   return props.theme.variables.btnPrimaryBg;
// });
// var StyledListItem = styled(ListItem)(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteral$1(["\n  background-color: ", ";\n  margin-bottom: 0.413rem;\n  border-radius: 0.25rem;\n  height: 2.75rem;\n  border: ", ";\n"])), function (props) {
//   return props.isSelectedDay ? '#E0EFFC' : props.theme.variables.bodyBg;
// }, function (props) {
//   return props.isSelectedDay ? "0.031rem solid ".concat(props.theme.variables.btnPrimaryBg) : "0.031rem solid ".concat(props.theme.variables.bodyBg);
// });
// var VerticleLine = styled.div(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteral$1(["\n  border: ", ";\n  height: 2.188rem;\n  margin-left: 1rem;\n  margin-right: 0.5rem;\n"])), function (props) {
//   return props.isSelectedDay ? "0.031rem solid ".concat(props.theme.variables.btnPrimaryBg) : "0.031rem solid ".concat(props.theme.variables.headerBarColor);
// });

// /**
//  * Component for Calendar to show data week wise
//  */
// function WeekCalendar(_ref) {
//   var data = _ref.data,
//     onDayClick = _ref.onDayClick,
//     selectedDay = _ref.selectedDay;
//   var textSizeDay = {
//     fontSize: 26,
//     fontWeight: 600
//   };
//   var textSizeMonth = {
//     fontSize: 18,
//     fontWeight: 400,
//     lineHeight: 1.1
//   };
//   var textSizeWeekday = {
//     fontSize: 14,
//     fontWeight: 600,
//     lineHeight: 1.1
//   };
//   return /*#__PURE__*/React__default.createElement(Container, null, /*#__PURE__*/React__default.createElement(CustomScrollbar, {
//     translateContentSizeYToHolder: true,
//     "class": "StyledCustomScroll",
//     width: 5.83,
//     switchColor: true
//   }, /*#__PURE__*/React__default.createElement(StyleList, null, data.map(function (rowData) {
//     var date = rowData.date,
//       month = rowData.month,
//       year = rowData.year,
//       weekDay = rowData.weekDay,
//       badge = rowData.badge,
//       id = rowData.id;
//     return /*#__PURE__*/React__default.createElement(StyledListItem, {
//       onClick: function onClick() {
//         return onDayClick(id);
//       },
//       key: id,
//       isSelectedDay: selectedDay === id
//     }, /*#__PURE__*/React__default.createElement(StyledListItemTextOnTheme, {
//       primary: date < 10 ? "0".concat(date) : date,
//       primaryTypographyProps: {
//         style: textSizeDay
//       }
//     }), /*#__PURE__*/React__default.createElement(VerticleLine, {
//       isSelectedDay: selectedDay === id
//     }), /*#__PURE__*/React__default.createElement(DayContainer, null, /*#__PURE__*/React__default.createElement(StyledListItemText, {
//       primary: "".concat(month, "  ").concat(year),
//       primaryTypographyProps: {
//         style: textSizeMonth
//       }
//     }), /*#__PURE__*/React__default.createElement(StyledListItemTextOnTheme, {
//       primary: weekDay,
//       primaryTypographyProps: {
//         style: textSizeWeekday
//       }
//     })), /*#__PURE__*/React__default.createElement(StyledBadge, {
//       badgeContent: badge
//     }));
//   }))));
// }
// WeekCalendar.propTypes = {
//   /**
//    * Contains Date, Month ,Year Day Week, Badge data for calander
//    */
//   data: PropTypes__default.arrayOf(PropTypes__default.shape({
//     date: PropTypes__default.string.isRequired,
//     month: PropTypes__default.string.isRequired,
//     year: PropTypes__default.number.isRequired,
//     weekDay: PropTypes__default.string.isRequired,
//     badge: PropTypes__default.number
//   })),
//   /**
//    * Contains Date, Month ,Year Day Week, Badge data for calander
//    */
//   onDayClick: PropTypes__default.func,
//   selectedDay: PropTypes__default.number
// };
// WeekCalendar.defaultProps = {
//   data: [],
//   onDayClick: undefined,
//   selectedDay: undefined
// };

// var _templateObject$i;
// var StyledMuiAppBar = styled(MuiAppBar)(_templateObject$i || (_templateObject$i = _taggedTemplateLiteral$1(["\n  background-color: ", ";\n  box-shadow: none;\n"])), function (props) {
//   return props.theme.variables.headerBarBackground;
// });

// /**
//  * The top app bar provides content and actions related to the current screen.
//  * It’s used for branding, screen titles, navigation and actions.
//  *
//  */
// function AppBar(_ref) {
//   var children = _ref.children,
//     toolBarMinHeight = _ref.toolBarMinHeight;
//   return /*#__PURE__*/React__default.createElement(StyledMuiAppBar, {
//     position: "fixed"
//   }, /*#__PURE__*/React__default.createElement(ToolBar, {
//     minHeight: toolBarMinHeight
//   }, children));
// }

// // PropType check
// AppBar.propTypes = {
//   /**
//    * Minmum height of the toolbar
//    */
//   toolBarMinHeight: PropTypes__default.string,
//   /**
//    * Child nodes for the component
//    */

//   children: PropTypes__default.node
// };
// AppBar.defaultProps = {
//   toolBarMinHeight: '3.25rem',
//   children: undefined
// };

// var _templateObject$h, _templateObject2$f, _templateObject3$b;
// var TopNavMenuButton = styled(MenuButton)(_templateObject$h || (_templateObject$h = _taggedTemplateLiteral$1(["\n  &.Mui-disabled {\n    color: ", ";\n    background-color: transparent;\n    opacity: 0.5;\n  }\n  &:hover {\n    background-color: ", ";\n  }\n"])), function (props) {
//   return props.theme.variables.headerBarColor;
// }, function (props) {
//   return props.ariaExpanded ? props.theme.variables.leftNavHeaderBackground : 'none';
// });
// var StyledPopper = styled(Popper)(_templateObject2$f || (_templateObject2$f = _taggedTemplateLiteral$1(["\n  z-index: 10000;\n  @media (max-width: 1024px) {\n    transform: ", ";\n  }\n"])), function (props) {
//   return props.poperLeftPosition && props.poperTopPosition ? "translate3d(".concat(props.poperLeftPosition, "px, ").concat(props.poperTopPosition, "px, 0px) !important") : '';
// });
// var Menudiv = styled.div(_templateObject3$b || (_templateObject3$b = _taggedTemplateLiteral$1(["\n  display: flex;\n  background-color: ", ";\n"])), function (props) {
//   return props.theme.variables.headerBarBackground;
// });

// var _templateObject$g, _templateObject2$e, _templateObject3$a, _templateObject4$4;
// var StyledTextField = styled(TextField)(_templateObject$g || (_templateObject$g = _taggedTemplateLiteral$1(["\n  padding-left: 0.75rem;\n  input[type='text']::placeholder {\n    font-style: italic;\n    font-size: 0.75rem;\n    opacity: 0.9;\n  }\n  input[type='text']::-ms-clear {\n    display: none;\n  }\n  & .MuiInputBase-root {\n    color: ", ";\n  }\n\n  & .MuiInputBase-input {\n    color: ", ";\n    padding: 0.375rem 0 0.438rem;\n  }\n  & .MuiInput-underline:before {\n    border-bottom-color: ", ";\n  }\n\n  & .MuiInput-underline:hover:before {\n    border-bottom-color: ", ";\n  }\n  & .MuiInput-underline:after {\n    border-bottom-color: ", ";\n  }\n  & .MuiInputAdornment-root {\n    color: inherit;\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });

// // Container for search field and clear button
// var SearchContainer = styled.div(_templateObject2$e || (_templateObject2$e = _taggedTemplateLiteral$1(["\n  display: flex;\n  align-items: center;\n"])));
// var StyledIconButton$1 = styled(IconButton)(_templateObject3$a || (_templateObject3$a = _taggedTemplateLiteral$1(["\n  padding: 0.4rem;\n"])));
// var StyledIcon = styled(Icon)(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteral$1(["\n  margin-top: 0.5rem;\n"])));

// /**
//  * Component for menu search
//  */

// function MenuSearch(_ref) {
//   var translations = _ref.translations,
//     onSitemapSearch = _ref.onSitemapSearch;
//   var _useState = useState$1(false),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     showClearIcon = _useState2[0],
//     setShowClearIcon = _useState2[1];
//   var _useState3 = useState$1(''),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     searchTerm = _useState4[0],
//     setSearchTerm = _useState4[1];

//   // Function to handle search
//   var handleSearch = function handleSearch() {
//     onSitemapSearch(searchTerm.trim());
//   };

//   // Function to handle clear icon click
//   var handleClearIconClick = function handleClearIconClick() {
//     setShowClearIcon(false);
//     setSearchTerm('');
//     onSitemapSearch('');
//     var quickFind = document.getElementById('menuQuickfind');
//     if (quickFind) quickFind.focus();
//   };

//   // Function for onchane to show or hide the clear icon
//   var handleOnChange = function handleOnChange(e) {
//     setSearchTerm(e.target.value);
//     if (e.target.value !== '') {
//       setShowClearIcon(true);
//     } else {
//       setShowClearIcon(false);
//       onSitemapSearch('');
//     }
//   };
//   return /*#__PURE__*/React__default.createElement(SearchContainer, null, /*#__PURE__*/React__default.createElement(StyledTextField, {
//     id: "menuQuickfind",
//     variant: "standard",
//     placeholder: translations.RCORE_TOPNAV_MENU_QUICKFIND_SEARCH || 'Menu Quick Find Search',
//     type: "text",
//     InputProps: {
//       endAdornment: /*#__PURE__*/React__default.createElement(InputAdornment, {
//         position: "end"
//       }, /*#__PURE__*/React__default.createElement(StyledIconButton$1, {
//         onClick: handleSearch,
//         label: translations.RCORE_TOPNAV_MENU_LABEL_SEARCH || 'Search',
//         color: "inherit"
//       }, /*#__PURE__*/React__default.createElement(Icon, {
//         iconType: "MaterialIcon",
//         iconName: "Search",
//         size: 1
//       }))),
//       inputProps: {
//         'aria-label': translations.RCORE_TOPNAV_MENU_QUICKFIND_SEARCH || 'Menu Quick Find Search'
//       }
//     },
//     onChange: handleOnChange,
//     onKeyUp: function onKeyUp(e) {
//       if (e.keyCode === 13) {
//         handleSearch();
//       }
//     },
//     value: searchTerm,
//     autoFocus: true
//   }), showClearIcon && /*#__PURE__*/React__default.createElement(StyledIconButton$1, {
//     color: "inherit",
//     label: translations.RCORE_TOPNAV_SEARCH_CLEAR_TEXT || 'Clear search',
//     onClick: handleClearIconClick
//   }, /*#__PURE__*/React__default.createElement(StyledIcon, {
//     iconType: "MaterialIcon",
//     iconName: "Cancel",
//     size: 0.875
//   })));
// }
// MenuSearch.propTypes = {
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Event handler for switch containers
//    */
//   onSitemapSearch: PropTypes__default.func
// };
// MenuSearch.defaultProps = {
//   translations: {},
//   onSitemapSearch: undefined
// };

// var _templateObject$f, _templateObject2$d, _templateObject3$9, _templateObject4$3;

// // Outer container
// var HeaderContainer = styled.div(_templateObject$f || (_templateObject$f = _taggedTemplateLiteral$1(["\n  display: inline-flex;\n  width: 100%;\n  height: 1.875rem;\n  justify-content: space-between;\n  margin-right: 0.75rem;\n"])));
// var TopContainer = styled.div(_templateObject2$d || (_templateObject2$d = _taggedTemplateLiteral$1(["\n  padding-top: 0.75rem;\n  padding-bottom: 1.5rem;\n"])));

// // Container for action button and close button
// var ActionContainer = styled.div(_templateObject3$9 || (_templateObject3$9 = _taggedTemplateLiteral$1(["\n  color: ", ";\n  display: flex;\n  align-items: center;\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// });
// var StyledIconButton = styled(IconButton)(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteral$1(["\n  margin-right: 0.1875rem;\n  padding: 0.3125rem;\n  &:focus-visible {\n    border: 0.125rem solid ", ";\n  }\n"])), function (p) {
//   return p.theme.variables.topbarNavTabOutlineColor;
// });

// /**
//  *  Component for Mega menu header.
//  *  It is used in the MegaMenuContainer
//  *  to show the Search field, Additional Action button, Close Icon.
//  */
// var MegaMenuHeader = function MegaMenuHeader(_ref) {
//   var headerCustomElement = _ref.headerCustomElement,
//     onClose = _ref.onClose,
//     onSitemapSearch = _ref.onSitemapSearch,
//     translations = _ref.translations,
//     activeMenuKey = _ref.activeMenuKey;
//   var handleCloseClick = function handleCloseClick() {
//     return onClose();
//   };
//   var headerCustomComponent = null;
//   if (headerCustomElement) headerCustomComponent = /*#__PURE__*/cloneElement(headerCustomElement, {
//     callbackEvent: handleCloseClick
//   });
//   var closeLabel = activeMenuKey === 'admin_header' && translations.RCORE_TOPNAV_ADMINISTRATION_MENU_CLOSE || activeMenuKey === 'team_header' && translations.RCORE_TOPNAV_MY_TEAM_MENU_CLOSE || activeMenuKey === 'self_header' && translations.RCORE_TOPNAV_SELF_MENU_CLOSE || 'close menu';
//   return /*#__PURE__*/React__default.createElement(TopContainer, null, /*#__PURE__*/React__default.createElement(HeaderContainer, null, /*#__PURE__*/React__default.createElement(MenuSearch, {
//     translations: translations,
//     onSitemapSearch: onSitemapSearch
//   }), /*#__PURE__*/React__default.createElement(ActionContainer, null, headerCustomComponent, /*#__PURE__*/React__default.createElement(StyledIconButton, {
//     onClick: handleCloseClick,
//     edge: "start",
//     color: "inherit",
//     label: closeLabel,
//     disableRipple: false,
//     disableFocusRipple: false
//   }, /*#__PURE__*/React__default.createElement(Icon, {
//     iconType: "MaterialIcon",
//     iconName: "Close",
//     size: 1
//   })))));
// };
// MegaMenuHeader.propTypes = {
//   /**
//    * Header Custom Element
//    */
//   headerCustomElement: PropTypes__default.node,
//   /**
//    * Event handler for close button
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * Event handler for switch containers
//    */
//   onSitemapSearch: PropTypes__default.func,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Selected Menu Key
//    */
//   activeMenuKey: PropTypes__default.string
// };
// MegaMenuHeader.defaultProps = {
//   headerCustomElement: undefined,
//   onClose: undefined,
//   onSitemapSearch: undefined,
//   translations: {},
//   activeMenuKey: ''
// };

// var _templateObject$e, _templateObject2$c;
// var TextElementStyled$1 = styled.p(_templateObject$e || (_templateObject$e = _taggedTemplateLiteral$1(["\n  margin-top: 0px;\n  margin-bottom: 0px;\n"])));
// var StyledRouteLink$2 = styled(RouteLink)(_templateObject2$c || (_templateObject2$c = _taggedTemplateLiteral$1(["\n  text-decoration: none;\n  font-weight: bold;\n  color: ", ";\n  &:focus,\n  &:hover,\n  &:active {\n    color: ", ";\n    text-decoration: none;\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });

// /**
//  * Component for Sitemap SearchItem.
//  *Sitemap SearchItem are used within the Sitemap Search results.
//  */

// function SitemapSearchItem(_ref) {
//   var node = _ref.node,
//     searchText = _ref.searchText,
//     iconName = _ref.iconName,
//     iconType = _ref.iconType,
//     callbackEvent = _ref.callbackEvent;
//   return /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     spacing: 3
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Icon, {
//     iconName: iconName,
//     iconType: iconType
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     sm: 10
//   }, /*#__PURE__*/React__default.createElement(StyledRouteLink$2, {
//     to: node.url,
//     onClick: function onClick() {
//       return callbackEvent(node);
//     }
//   }, /*#__PURE__*/React__default.createElement(Highlighter, {
//     textToHighlight: node.name,
//     searchText: searchText
//   })), /*#__PURE__*/React__default.createElement(TextElementStyled$1, null, node.description), /*#__PURE__*/React__default.createElement(TextElementStyled$1, null, node.navigationPath)));
// }
// SitemapSearchItem.propTypes = {
//   /**
//    * node object
//    */
//   node: PropTypes__default.oneOfType([PropTypes__default.object]),
//   /**
//    * Search text
//    */
//   searchText: PropTypes__default.string,
//   /**
//    * Name of the icon
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * Type of the icon
//    */
//   iconType: PropTypes__default.string,
//   /**
//    * Parent callback event
//    */
//   callbackEvent: PropTypes__default.func
// };
// // DefaultPropType check
// SitemapSearchItem.defaultProps = {
//   /**
//    * node object
//    */
//   node: {},
//   /**
//    * Search text
//    */
//   searchText: '',
//   /**
//    * Name of the icon
//    */
//   iconName: 'InsertLink',
//   /**
//    * Type of the icon
//    */
//   iconType: 'MaterialIcon',
//   /**
//    * Parent callback event
//    */
//   callbackEvent: undefined
// };

// var _templateObject$d, _templateObject2$b, _templateObject3$8, _templateObject4$2;
// var ListItemStyled = styled(ListItem)(_templateObject$d || (_templateObject$d = _taggedTemplateLiteral$1(["\n  padding-left: 0.75rem;\n  padding-right: 0.75rem;\n"])));
// var StyledList = styled(List)(_templateObject2$b || (_templateObject2$b = _taggedTemplateLiteral$1(["\n  height: ", ";\n"])), function (props) {
//   return props.height;
// });
// var NoDataContainer = styled.div(_templateObject3$8 || (_templateObject3$8 = _taggedTemplateLiteral$1(["\n  display: flex;\n  justify-content: center;\n  margin-top: 2.25rem;\n  height: ", ";\n"])), function (props) {
//   return props.height;
// });
// var StyledNoData = styled.span(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteral$1(["\n  width: 21rem;\n  text-align: center;\n"])));

// var searchResults = [];

// // Function for handling the special characters entered in search text
// function handleSpecialCharacters(searchText) {
//   return searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// }
// function recursiveFilter(sitemapData, searchText, ResultsCallback) {
//   if (searchText != null && sitemapData && sitemapData.length > 0) {
//     var searchedText = handleSpecialCharacters(searchText);
//     eachDeep(sitemapData, function (node) {
//       if (node.nodeKey === 'self_quicklinks' || node.nodeKey === 'myteam_quicklinks' || node.nodeKey === 'administration_quicklinks') {
//         return false;
//       }
//       if (node.name.toLowerCase().search(searchedText.toLowerCase()) >= 0) {
//         if (node.childNodes === null || node.childNodes && node.childNodes.length === 0) {
//           searchResults.push(node);
//         }
//       }
//     }, {
//       childrenPath: 'childNodes'
//     });
//   }
//   ResultsCallback(searchResults.length, searchText);
//   return searchResults;
// }

// /**
//  * Component for showing Sitemap search results.
//  */

// function SiteMapSearchResults(_ref) {
//   var sitemapData = _ref.sitemapData,
//     searchText = _ref.searchText,
//     height = _ref.height,
//     callbackEvent = _ref.callbackEvent,
//     noDataFoundText = _ref.noDataFoundText,
//     ResultsCallback = _ref.ResultsCallback;
//   var _useState = useState$1([]),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     filterList = _useState2[0],
//     setFilterList = _useState2[1];
//   useEffect$2(function () {
//     setFilterList(recursiveFilter(sitemapData, searchText, ResultsCallback));
//     searchResults = [];
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [searchText, sitemapData]);
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, filterList.length > 0 ? /*#__PURE__*/React__default.createElement(StyledList, {
//     height: height
//   }, /*#__PURE__*/React__default.createElement(CustomScrollbar, {
//     translateContentSizeYToHolder: true
//   }, filterList.map(function (node) {
//     return /*#__PURE__*/React__default.createElement(ListItemStyled, {
//       onClick: null,
//       key: node.nodeKey
//     }, /*#__PURE__*/React__default.createElement(SitemapSearchItem, {
//       node: node,
//       callbackEvent: callbackEvent,
//       searchText: searchText
//     }));
//   }))) : /*#__PURE__*/React__default.createElement(NoDataContainer, {
//     height: height
//   }, /*#__PURE__*/React__default.createElement(StyledNoData, null, noDataFoundText)));
// }

// // PropType check
// SiteMapSearchResults.propTypes = {
//   /**
//    * node list
//    */
//   sitemapData: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * Search text
//    */
//   searchText: PropTypes__default.string,
//   /**
//    * Height of the container
//    */
//   height: PropTypes__default.string,
//   /**
//    * Parent callback event
//    */
//   callbackEvent: PropTypes__default.func,
//   /**
//    * display search text, when there is no data.
//    */
//   noDataFoundText: PropTypes__default.string,
//   /**
//    * Results callback event
//    */
//   ResultsCallback: PropTypes__default.func
// };

// // DefaultPropType check
// SiteMapSearchResults.defaultProps = {
//   sitemapData: [],
//   searchText: '',
//   height: undefined,
//   callbackEvent: undefined,
//   noDataFoundText: '',
//   ResultsCallback: function ResultsCallback() {}
// };

// var _templateObject$c;
// var ContainerSection = styled.section(_templateObject$c || (_templateObject$c = _taggedTemplateLiteral$1(["\nmin-width: 27.5rem;\nmax-width: 55rem;\n@media (min-width: 768px) and (max-width: 1024px){\n  width: ", "rem;\n  max-height: 34.125rem;\n}\nwidth: ", "rem;\nmin-height: 10rem;\nmax-height: 32.5rem;\nbackground-color: ", ";\ncolor: ", ";\n"])), function (props) {
//   return props.levels * 10.563;
// }, function (props) {
//   return props.levels * 13.75;
// }, function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.theme.variables.leftNavParentColor;
// });

// var _templateObject$b, _templateObject2$a, _templateObject3$7, _templateObject4$1, _templateObject5$1;
// var StyledRouteLink$1 = styled(RouteLink)(_templateObject$b || (_templateObject$b = _taggedTemplateLiteral$1(["\n  text-decoration: none;\n  width: 100%;\n  padding: 0.5rem 0.5rem ;\n  color: ", ";\n  &:focus {\n    background-color: ", ";\n    color: ", ";\n    border-radius: 0.1875rem;\n    text-decoration: none;\n    outline: none;\n  }\n  &:hover {\n    background-color: ", ";\n    color: ", ";\n    border-radius: 0.1875rem;\n    text-decoration: none;\n    outline: none;\n  }\n  &:focus-visible {\n    border: 0.125rem solid ", ";\n  &:active {\n    background-color: ", ";\n    color: ", ";\n    border-radius: 0.1875rem;\n    text-decoration: none;\n    outline: none;\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavTabOutlineColor;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateTextColor;
// });
// var TextElementStyled = styled.span(_templateObject2$a || (_templateObject2$a = _taggedTemplateLiteral$1(["\n  flex: 5;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  height: 100%;\n  line-height: 1rem;\n  font-size: 0.75rem;\n  text-align: left;\n  margin: 0px 1px 0px 1px;\n"])));
// var StyledMaterialIcon = styled(MaterialIcon)(_templateObject3$7 || (_templateObject3$7 = _taggedTemplateLiteral$1(["\n  ", ";\n"])), function (props) {
//   return props.theme.direction === 'rtl' && "\n       transform: rotate(180deg)};\n    ";
// });
// var StyledMenuItem = styled(MenuItem)(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral$1(["\n  display: inline-flex;\n  width: 100%;\n  margin: 0.09375rem 0rem 0.09375rem 0rem;\n  color: ", ";\n  font-weight: 500;\n  &:hover {\n    background-color: ", ";\n    color: ", ";\n    border-radius: 0.1875rem;\n  }\n  &:focus {\n    background-color: ", ";\n    color: ", ";\n    border-radius: 0.1875rem;\n  }\n  &:focus-visible {\n    border: 0.125rem solid ", ";\n  }\n  &:active {\n    background-color: ", ";\n    color: ", ";\n    border-radius: 0.1875rem;\n  }\n  &.Mui-selected {\n    background-color: ", ";\n    color: ", ";\n    border-radius: 0.1875rem;\n    &:hover {\n      background-color: ", ";\n      color: ", ";\n      border-radius: 0.1875rem;\n    }\n  }\n"])), function (props) {
//   return props.theme.variables.leftNavParentColor;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavTabOutlineColor;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavActiveStateTextColor;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateBackground;
// }, function (p) {
//   return p.theme.variables.topbarNavHoverStateTextColor;
// });
// var StyledAnchorMenuItem = styled(StyledMenuItem)(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteral$1(["\n  margin: 0.09375rem 0rem 0.09375rem 0rem;\n  padding: 0px;\n  font-weight: 500;\n  &.MuiListItem-root.Mui-focusVisible {\n    background-color: ", ";\n    border-radius: 0.1875rem;\n  }\n"])), function (props) {
//   return props.theme.variables.topbarNavHoverStateBackground;
// });

// /**
//  * Component for MegaMenu Item.
//  * MegaMenu Items are used within the MegaMenu list.
//  */

// function MegaMenuItem(_ref) {
//   var idProp = _ref.id,
//     node = _ref.node,
//     onClick = _ref.onClick,
//     iconName = _ref.iconName,
//     selected = _ref.selected,
//     children = _ref.children,
//     role = _ref.role,
//     ariaExpanded = _ref.ariaExpanded;
//   var id = useId(idProp);
//   var NavigationItem = function NavigationItem() {
//     return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(TextElementStyled, null, node.name), node.childNodes && node.childNodes.length > 0 && /*#__PURE__*/React__default.createElement(StyledMaterialIcon, {
//       iconName: iconName,
//       size: 0.75
//     }), children);
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !node.url ? /*#__PURE__*/React__default.createElement(StyledMenuItem, {
//     id: id,
//     minheight: 2,
//     selected: selected,
//     onClick: onClick,
//     role: role,
//     "aria-expanded": ariaExpanded
//   }, NavigationItem()) : /*#__PURE__*/React__default.createElement(StyledAnchorMenuItem, {
//     minheight: 2,
//     selected: selected,
//     tabIndex: -1,
//     role: "none"
//   }, /*#__PURE__*/React__default.createElement(StyledRouteLink$1, {
//     id: id,
//     to: node.url,
//     onClick: onClick,
//     tabIndex: 0
//   }, NavigationItem())));
// }

// // PropType check
// MegaMenuItem.propTypes = {
//   /**
//    * Id of the element
//    */
//   id: PropTypes__default.string,
//   /**
//    * node object
//    */
//   node: PropTypes__default.oneOfType([PropTypes__default.object]),
//   /**
//    * On Click handler
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Name of the icon
//    */
//   iconName: PropTypes__default.string,
//   /**
//    * MegaMenuItem selected state
//    */
//   selected: PropTypes__default.bool,
//   /**
//    * MenuList contents are normally MenuItems.
//    */
//   children: PropTypes__default.node,
//   /**
//    * role for menuitem
//    */
//   role: PropTypes__default.string,
//   /**
//    * Value of aria-expanded attribute to be used for menu item
//    */
//   ariaExpanded: PropTypes__default.bool
// };

// // DefaultPropType check
// MegaMenuItem.defaultProps = {
//   /**
//    * id of element
//    */
//   id: undefined,
//   /**
//    * node object
//    */
//   node: {},
//   /**
//    * On Click handler
//    */
//   onClick: undefined,
//   /**
//    * Name of the icon
//    */
//   iconName: 'ArrowForwardIos',
//   /**
//    * MegaMenuItem selected state
//    */
//   selected: false,
//   children: undefined,
//   role: 'menuitem',
//   ariaExpanded: undefined
// };

// var _templateObject$a;
// var StyledMenuList = styled(MenuList)(_templateObject$a || (_templateObject$a = _taggedTemplateLiteral$1(["\n  min-width: 13.75rem;\n  width: 13.75rem;\n  @media (min-width: 768px) and (max-width: 1024px) {\n    min-width: 10.563rem;\n    width: 10.563rem;\n    max-height: 30rem;\n  }\n  min-height: 5.875rem;\n  max-height: 28.375rem;\n  padding: 0 0.375rem 0.75rem 0.375rem;\n  &:focus {\n    outline: none;\n  }\n  display: ", ";\n  height: auto;\n"])), function (props) {
//   return props.visible ? 'block' : 'none';
// });

// /**
//  * Component for showing multi level mega menu list.
//  */

// function MegaMenuList(_ref) {
//   var nodeList = _ref.nodeList,
//     maxLevels = _ref.maxLevels,
//     selectedNodeKey = _ref.selectedNodeKey,
//     callbackEvent = _ref.callbackEvent,
//     translations = _ref.translations,
//     activeMenuName = _ref.activeMenuName;
//   // Method to set the next level visibility and menu items
//   function setSubMenuList(lists, currentLevel, currentNode) {
//     lists.forEach(function (x) {
//       var list = x;
//       if (list.level > currentLevel) {
//         if (list.level === currentLevel + 1) {
//           list.isVisible = true;
//           list.items = currentNode ? currentNode.childNodes : [];
//           list.selectedKey = '';
//           list.name = currentNode ? currentNode.name : '';
//         } else {
//           list.isVisible = false;
//           list.items = [];
//           list.selectedKey = '';
//         }
//       }
//     });
//   }
//   function initializeLists() {
//     var initLists = [];
//     var list = {};
//     var activeNodeKey = selectedNodeKey;
//     for (var i = 0; i < maxLevels; i += 1) {
//       if (i === 0) {
//         list = {
//           level: i,
//           isVisible: true,
//           items: nodeList,
//           selectedKey: activeNodeKey || ''
//         };
//       } else list = {
//         level: i,
//         isVisible: false,
//         items: [],
//         selectedKey: ''
//       };
//       initLists.push(list);
//     }
//     setSubMenuList(initLists, 0, nodeList.find(function (i) {
//       return i.nodeKey === activeNodeKey;
//     }));
//     return initLists;
//   }
//   var _useState = useState$1(initializeLists()),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     menuLists = _useState2[0],
//     updateMenuLists = _useState2[1];
//   var _useState3 = useState$1(0),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     calcHeight = _useState4[0],
//     updateCalcHeight = _useState4[1];
//   function onNodeClick(level, node, index, levelNodeCount) {
//     var KEYCODE_TAB = 9;
//     var prevMenuId;
//     function focusQuickFind(e) {
//       if (e.key === 'Tab' || e.keyCode === KEYCODE_TAB) {
//         if (!e.shiftKey) {
//           document.getElementById('menuQuickfind').focus();
//           e.preventDefault();
//         }
//       }
//     }
//     function focusPrevMenu(e, id) {
//       if (e.key === 'Tab' || e.keyCode === KEYCODE_TAB) {
//         if (!e.shiftKey) {
//           document.getElementById(id).focus();
//           e.preventDefault();
//         }
//       }
//     }
//     // if the node doesnot have submenu
//     if (!node.childNodes || node.childNodes.length === 0) {
//       callbackEvent(node);
//     } else {
//       // To avoid mutating the state object
//       var lists = Object.assign([], menuLists);
//       // Setting current level selectedKey
//       lists.find(function (list) {
//         return list.level === level;
//       }).selectedKey = node.nodeKey;
//       setSubMenuList(lists, level, node);
//       updateMenuLists(lists);

//       // Code to handle the Megamenu internal navigation is written in this timeout
//       setTimeout(function () {
//         var quickFind = document.getElementById('menuQuickfind');
//         var firstColLastElement = document.getElementById("menu-item-0-last");
//         firstColLastElement.addEventListener('keydown', focusQuickFind);
//         // focusing on the next column first element
//         var nextColFirstElement = document.getElementById("menu-item-".concat(level + 1, "-0"));
//         var nextColLastelement = document.getElementById("menu-item-".concat(level + 1, "-last"));
//         prevMenuId = "menu-item-".concat(level, "-").concat(index + 1);
//         if (index + 1 === levelNodeCount && level === 0) {
//           prevMenuId = 'menuQuickfind';
//         } else if (index + 1 === levelNodeCount) {
//           prevMenuId = document.getElementById("menu-item-".concat(level, "-last")).getAttribute('prevMenuId');
//         } else if (index + 1 === levelNodeCount - 1) {
//           prevMenuId = "menu-item-".concat(level, "-last");
//         }
//         if (nextColFirstElement) {
//           nextColFirstElement.focus();
//           nextColLastelement.setAttribute('prevMenuId', prevMenuId);
//           nextColLastelement.setAttribute('nextMenuId', "menu-item-".concat(level + 2, "-", 0));
//           nextColLastelement.addEventListener('keydown', function (e) {
//             return focusPrevMenu(e, prevMenuId);
//           });
//         }
//         // focusing on next column last element if first and last are same
//         else {
//           // focusing next item of previous menu selected item
//           nextColLastelement.focus();
//           nextColLastelement.setAttribute('prevMenuId', prevMenuId);
//           nextColLastelement.setAttribute('nextMenuId', "menu-item-".concat(level + 2, "-0"));
//           nextColLastelement.addEventListener('keydown', function (e) {
//             return focusPrevMenu(e, prevMenuId);
//           });
//         }
//         if (level + 1 > 1) {
//           var lev = level;
//           var _loop = function _loop() {
//             var currentLevelLastElemet = document.getElementById("menu-item-".concat(lev, "-last"));
//             var prevId = currentLevelLastElemet.getAttribute('prevMenuId');
//             currentLevelLastElemet.addEventListener('keydown', function (e) {
//               return focusPrevMenu(e, prevId);
//             });
//             lev -= 1;
//           };
//           while (lev > 0) {
//             _loop();
//           }
//         }

//         // removing eventlistener from firstcolumn last element once user reaches quickfind
//         quickFind.addEventListener('keydown', function handleListeners(e) {
//           if (e.key === 'Tab' || e.keyCode === KEYCODE_TAB) {
//             var _lev = maxLevels - 1;
//             var lastLevelFound = false;
//             var _loop2 = function _loop2() {
//               var levelLastElement = document.getElementById("menu-item-".concat(_lev, "-last"));
//               if (levelLastElement) {
//                 if (!lastLevelFound) {
//                   if (e.shiftKey) {
//                     levelLastElement.focus();
//                     e.preventDefault();
//                   }
//                   levelLastElement.addEventListener('keydown', focusQuickFind);
//                   lastLevelFound = true;
//                 } else if (_lev !== 0) {
//                   var nextId = levelLastElement.getAttribute('nextMenuId');
//                   if (document.getElementById(nextId)) {
//                     levelLastElement.addEventListener('keydown', function (event) {
//                       return (
//                         // focusing on next submenu first element
//                         focusPrevMenu(event, nextId)
//                       );
//                     });
//                   } else {
//                     // if there is only single element in next column
//                     levelLastElement.addEventListener('keydown', function (event) {
//                       return focusPrevMenu(event, "".concat(nextId.slice(0, -1), "last"));
//                     });
//                   }
//                 }
//               }
//               var secondColFirstElement = document.getElementById("menu-item-1-0");
//               if (secondColFirstElement) {
//                 document.getElementById('menu-item-0-last').addEventListener('keydown', function (event) {
//                   return focusPrevMenu(event, "menu-item-1-0");
//                 });
//               } else {
//                 document.getElementById('menu-item-0-last').addEventListener('keydown', function (event) {
//                   return focusPrevMenu(event, "menu-item-1-last");
//                 });
//               }
//               _lev -= 1;
//             };
//             while (_lev >= 0) {
//               _loop2();
//             }
//           }
//         });
//       }, 250);
//     }
//   }
//   useEffect$2(function () {
//     updateCalcHeight(document.getElementById('menu-list-level0').clientHeight);
//   }, [calcHeight]);
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start"
//   }, menuLists.map(function (list) {
//     return /*#__PURE__*/React__default.createElement(FlexGrid, {
//       item: true,
//       key: list.level
//     }, /*#__PURE__*/React__default.createElement(StyledMenuList, {
//       id: "menu-list-level".concat(list.level),
//       height: "".concat(calcHeight, "px"),
//       level: list.level,
//       visible: list.isVisible,
//       role: "none",
//       ariaLabel: list.level > 0 ? "".concat(list.name, " ").concat(translations.RCORE_TOPNAV_MENU_AREAS) : "".concat(activeMenuName, " ").concat(translations.RCORE_TOPNAV_MENU_AREAS)
//     }, /*#__PURE__*/React__default.createElement(CustomScrollbar, {
//       translateContentSizeYToHolder: true,
//       height: calcHeight >= (window.matchMedia('(min-width: 768px) and (max-width: 1024px)').matches ? 480 : 454) ? calcHeight : undefined
//     }, list.items.map(function (sitemapNode, index) {
//       return /*#__PURE__*/React__default.createElement(MegaMenuItem, {
//         role: "button",
//         id: "menu-item-".concat(list.level, "-").concat(list.items.length - 1 === index ? 'last' : index),
//         key: "".concat(sitemapNode.nodeKey, "-").concat(list.level),
//         node: sitemapNode,
//         iconName: "ArrowForwardIos",
//         onClick: function onClick() {
//           return onNodeClick(list.level, sitemapNode, index, list.items.length);
//         },
//         selected: sitemapNode.nodeKey === list.selectedKey,
//         ariaExpanded: sitemapNode.nodeKey === list.selectedKey
//       });
//     }))));
//   })));
// }

// // PropType check
// MegaMenuList.propTypes = {
//   /**
//    * node list
//    */
//   nodeList: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * Maximum levels supported
//    */
//   maxLevels: PropTypes__default.number,
//   /**
//    * selected node key in first level
//    */
//   selectedNodeKey: PropTypes__default.string,
//   /**
//    * Parent callback event
//    */
//   callbackEvent: PropTypes__default.func,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Selected Menu name
//    */
//   activeMenuName: PropTypes__default.string
// };

// // Default Properties
// MegaMenuList.defaultProps = {
//   nodeList: [],
//   maxLevels: 4,
//   selectedNodeKey: null,
//   callbackEvent: function callbackEvent() {},
//   translations: {},
//   activeMenuName: ''
// };

// /**
//  * Component for MegaMenuContainer.
//  * It has the MegaMenuHeader and MegaMenuList placed inside it.
//  * On Click of MegaMenu Buttons(Self, MyTeam or Administration)
//  * we show the corresponding MegaMenuContainer.
//  */
// function MegaMenuContainer(_ref) {
//   var maxDepthLevel = _ref.maxDepthLevel,
//     headerCustomElement = _ref.headerCustomElement,
//     closeMenu = _ref.closeMenu,
//     nodeList = _ref.nodeList,
//     selectedNodeKey = _ref.selectedNodeKey,
//     translations = _ref.translations,
//     activeMenuKey = _ref.activeMenuKey,
//     activeMenuName = _ref.activeMenuName,
//     ResultsCallback = _ref.ResultsCallback;
//   var _useState = useState$1(false),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     showSearch = _useState2[0],
//     setShowSearch = _useState2[1];
//   var _useState3 = useState$1(''),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     searchTerm = _useState4[0],
//     setSearchTerm = _useState4[1];
//   var _useState5 = useState$1(0),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     searchContainerHeight = _useState6[0],
//     setSearchContainerHeight = _useState6[1];

//   // Function to switch the search results and menulist
//   var handleSitemapSearch = function handleSitemapSearch(searchedText) {
//     if (searchedText !== '') {
//       if (searchContainerHeight === 0) {
//         setSearchContainerHeight(document.getElementById('menu-list-level0').clientHeight);
//       }
//       setShowSearch(true);
//       setSearchTerm(searchedText);
//     } else {
//       setShowSearch(false);
//       setSearchTerm('');
//     }
//   };
//   var sectionLabel = activeMenuKey === 'admin_header' && translations.RCORE_TOPNAV_ADMINISTRATION_MENU_SECTION || activeMenuKey === 'team_header' && translations.RCORE_TOPNAV_MY_TEAM_MENU_SECTION || activeMenuKey === 'self_header' && translations.RCORE_TOPNAV_SELF_MENU_SECTION || 'menu section';
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(ContainerSection, {
//     levels: maxDepthLevel,
//     "aria-label": sectionLabel
//   }, /*#__PURE__*/React__default.createElement(MegaMenuHeader, {
//     onClose: closeMenu,
//     headerCustomElement: headerCustomElement,
//     onSitemapSearch: handleSitemapSearch,
//     translations: translations,
//     activeMenuKey: activeMenuKey
//   }), showSearch ? /*#__PURE__*/React__default.createElement(SiteMapSearchResults, {
//     sitemapData: nodeList,
//     searchText: searchTerm,
//     height: "".concat(searchContainerHeight / 16, "rem"),
//     callbackEvent: closeMenu,
//     ResultsCallback: ResultsCallback,
//     noDataFoundText: translations.RCORE_TOPNAV_MENU_QUICKFIND_SEARCH_NODATA
//   }) : /*#__PURE__*/React__default.createElement(MegaMenuList, {
//     nodeList: nodeList,
//     selectedNodeKey: selectedNodeKey,
//     maxLevels: maxDepthLevel,
//     callbackEvent: closeMenu,
//     ResultsCallback: ResultsCallback,
//     translations: translations,
//     activeMenuName: activeMenuName
//   })));
// }
// MegaMenuContainer.propTypes = {
//   /**
//    * levels of menu
//    */
//   maxDepthLevel: PropTypes__default.number,
//   /**
//   /**
//    * Sitemap Node List
//    */
//   nodeList: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * Default selected Node key
//    */
//   selectedNodeKey: PropTypes__default.string,
//   /**
//    * Header Custom Element
//    */
//   headerCustomElement: PropTypes__default.node,
//   /**
//    * Close Menu click
//    */
//   closeMenu: PropTypes__default.func,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Selected Menu Key
//    */
//   activeMenuKey: PropTypes__default.string,
//   /**
//    * Selected Menu name
//    */
//   activeMenuName: PropTypes__default.string,
//   /**
//    * Results callback event
//    */
//   ResultsCallback: PropTypes__default.func
// };
// MegaMenuContainer.defaultProps = {
//   maxDepthLevel: 2,
//   headerCustomElement: undefined,
//   closeMenu: undefined,
//   nodeList: [],
//   selectedNodeKey: '',
//   translations: {},
//   activeMenuKey: '',
//   activeMenuName: '',
//   ResultsCallback: function ResultsCallback() {}
// };

// /**
//  * Component for TopMenu
//  *
//  */
// function TopMenu(_ref) {
//   var menusData = _ref.menusData,
//     disableTopMenu = _ref.disableTopMenu,
//     selfHeaderCustomElement = _ref.selfHeaderCustomElement,
//     teamHeaderCustomElement = _ref.teamHeaderCustomElement,
//     adminHeaderCustomElement = _ref.adminHeaderCustomElement,
//     translations = _ref.translations,
//     onMenuClose = _ref.onMenuClose,
//     onMenuOpen = _ref.onMenuOpen,
//     poperLeftPosition = _ref.poperLeftPosition,
//     poperTopPosition = _ref.poperTopPosition,
//     ResultsCallback = _ref.ResultsCallback;
//   var _useState = useState$1(null),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     popperAnchor = _useState2[0],
//     setPopperAnchor = _useState2[1];
//   var _useState3 = useState$1(null),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     selectedNode = _useState4[0],
//     setSelectedNode = _useState4[1];
//   var _useState5 = useState$1(false),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     isMenuOpen = _useState6[0],
//     setIsMenuOpen = _useState6[1];
//   var open = Boolean(popperAnchor);
//   var _useState7 = useState$1(false),
//     _useState8 = _slicedToArray$b(_useState7, 2),
//     showContainer = _useState8[0],
//     setShowContainer = _useState8[1];
//   var _useState9 = useState$1(null),
//     _useState10 = _slicedToArray$b(_useState9, 2),
//     quickLinksNode = _useState10[0],
//     setQuickLinksNode = _useState10[1];
//   var closeMenu = function closeMenu(clickedItem) {
//     if (!clickedItem && selectedNode) {
//       document.getElementById(selectedNode.nodeKey).focus();
//     }
//     setPopperAnchor(null);
//     setSelectedNode(null);
//     setIsMenuOpen(false);
//     setShowContainer(false);
//     setQuickLinksNode(null);
//     onMenuClose(clickedItem);
//   };
//   var menuButtonClick = function menuButtonClick(event, node) {
//     if (isMenuOpen && selectedNode.nodeKey === node.nodeKey) {
//       closeMenu();
//     } else {
//       if (!isMenuOpen) setShowContainer(true);else setShowContainer(false);
//       setPopperAnchor(event.currentTarget);
//       setSelectedNode(node);
//       setIsMenuOpen(true);
//       onMenuOpen(closeMenu);
//       if (node.childNodes.length > 0 && node.expandQuickLinksNodeKey !== undefined) {
//         setQuickLinksNode(node.expandQuickLinksNodeKey);
//       } else {
//         setQuickLinksNode(null);
//       }
//       setTimeout(function () {
//         var KEYCODE_TAB = 9;
//         var firstColLastElement = document.getElementById("menu-item-0-last");
//         var secondColLastElement = document.getElementById("menu-item-1-last");
//         var quickFind = document.getElementById('menuQuickfind');
//         // below adding tabindex -1 for scrollbar to fix issue in firefox/NVDA
//         // where focus going to scrollbar when tabbed from close button
//         Array.from(document.getElementsByClassName('ScrollbarsCustom-Scroller')).forEach(function (item, index) {
//           item.setAttribute('tabindex', '-1');
//         });
//         if (quickFind) {
//           quickFind.addEventListener('keydown', function handleListeners(e) {
//             if ((e.key === 'Tab' || e.keyCode === KEYCODE_TAB) && e.shiftKey) {
//               if (secondColLastElement) {
//                 secondColLastElement.focus();
//               } else {
//                 firstColLastElement.focus();
//               }
//               e.preventDefault();
//             }
//           });
//         }
//         if (secondColLastElement) {
//           secondColLastElement.addEventListener('keydown', function focusListener(e) {
//             if ((e.key === 'Tab' || e.keyCode === KEYCODE_TAB) && !e.shiftKey) {
//               quickFind.focus();
//               e.preventDefault();
//             }
//           });
//         } else if (firstColLastElement) {
//           firstColLastElement.addEventListener('keydown', function focusListener(e) {
//             if ((e.key === 'Tab' || e.keyCode === KEYCODE_TAB) && !e.shiftKey) {
//               quickFind.focus();
//               e.preventDefault();
//             }
//           });
//         }
//       }, 200);
//     }
//   };
//   useEffect$2(function () {
//     setShowContainer(true);
//   }, [selectedNode]);
//   return /*#__PURE__*/React__default.createElement(CloseOnEscape, {
//     close: isMenuOpen ? closeMenu : undefined
//   }, /*#__PURE__*/React__default.createElement(CloseOnClickAway, {
//     close: isMenuOpen ? closeMenu : undefined
//   }, /*#__PURE__*/React__default.createElement(Menudiv, null,
//   // eslint-disable-next-line operator-linebreak
//   menusData && menusData.map(function (node) {
//     return /*#__PURE__*/React__default.createElement(TopNavMenuButton, {
//       id: node.nodeKey,
//       endIcon: "KeyboardArrowDown",
//       menuOpenIcon: "KeyboardArrowUp",
//       key: node.nodeKey,
//       disableFocusRipple: true,
//       ariaExpanded: isMenuOpen && selectedNode ? selectedNode.nodeKey === node.nodeKey : false,
//       isOpen: isMenuOpen && selectedNode ? selectedNode.nodeKey === node.nodeKey : false,
//       onClick: function onClick(e) {
//         return menuButtonClick(e, node);
//       },
//       disabled: disableTopMenu
//     }, node.name);
//   }), selectedNode && showContainer && /*#__PURE__*/React__default.createElement(StyledPopper, {
//     toggle: open,
//     anchorEl: popperAnchor,
//     placement: "bottom-start",
//     role: "none",
//     poperLeftPosition: poperLeftPosition,
//     poperTopPosition: poperTopPosition
//   }, /*#__PURE__*/React__default.createElement(MegaMenuContainer, {
//     nodeList: selectedNode.childNodes,
//     selectedNodeKey: quickLinksNode,
//     headerCustomElement: selectedNode.nodeKey === 'admin_header' && adminHeaderCustomElement || selectedNode.nodeKey === 'team_header' && teamHeaderCustomElement || selectedNode.nodeKey === 'self_header' && selfHeaderCustomElement,
//     closeMenu: closeMenu,
//     activeMenuKey: selectedNode.nodeKey,
//     activeMenuName: selectedNode.name,
//     maxDepthLevel: selectedNode.maxDepthLevel,
//     translations: translations,
//     ResultsCallback: ResultsCallback
//   })))));
// }
// // PropType check
// TopMenu.propTypes = {
//   /**
//    * Disable/Enable TopMenu
//    */
//   disableTopMenu: PropTypes__default.bool,
//   /**
//    * Menus data
//    */
//   menusData: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * Self Header Custom Element
//    */
//   selfHeaderCustomElement: PropTypes__default.node,
//   /**
//    * Admin Header Custom Element
//    */
//   teamHeaderCustomElement: PropTypes__default.node,
//   /**
//    * Admin Header Custom Element
//    */
//   adminHeaderCustomElement: PropTypes__default.node,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Call back Event on top menu close
//    */
//   onMenuClose: PropTypes__default.func,
//   /**
//    * Call back Event on top menu open
//    */
//   onMenuOpen: PropTypes__default.func,
//   /**
//    * Poper left alignment for smaller resolution screen
//    */
//   poperLeftPosition: PropTypes__default.number,
//   /**
//    * Poper top alignment for smaller resolution screen
//    */
//   poperTopPosition: PropTypes__default.number,
//   /**
//    * Results callback event
//    */
//   ResultsCallback: PropTypes__default.func
// };
// TopMenu.defaultProps = {
//   disableTopMenu: false,
//   menusData: undefined,
//   selfHeaderCustomElement: undefined,
//   teamHeaderCustomElement: undefined,
//   adminHeaderCustomElement: undefined,
//   translations: {},
//   onMenuClose: function onMenuClose() {},
//   onMenuOpen: function onMenuOpen() {},
//   poperLeftPosition: undefined,
//   poperTopPosition: undefined,
//   ResultsCallback: function ResultsCallback() {}
// };

// var _templateObject$9, _templateObject2$9, _templateObject3$6, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10;
// var DisabledLink = styled(RouteLink)(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteral$1(["\npointer-events: none;\n"])));
// var StyledRouteLink = styled(RouteLink)(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteral$1(["\n  padding: 0.625rem 1rem 0.625rem 1rem;\n  outline-offset: -0.25rem;\n"])));
// var FlexGridForImg = styled(FlexGrid)(_templateObject3$6 || (_templateObject3$6 = _taggedTemplateLiteral$1(["\n  display: flex;\n  z-index: 100;\n"])));
// var FlexGridForLink = styled(FlexGrid)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral$1(["\n  position: absolute;\n  padding-top: 0.3rem;\n  padding-left: 0.1rem;\n"])));
// var ForLink = styled(Link$1)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral$1(["\n  color: transparent;\n  cursor: default;\n  :hover {\n    background-color: transparent;\n  }\n  :focus {\n    color: #ffffff;\n    background-color: #333333;\n    padding: 0.5rem;\n    position: relative;\n    z-index: 200;\n  }\n\n  :focus:not(:focus-visible) {\n    background: transparent;\n    color: transparent;\n    padding: 0rem;\n  }\n"])));
// var StyledImage = styled(Image$1)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral$1(["\n  max-width: ", "rem;\n  max-height: ", "rem;\n"])), function (props) {
//   return props.maxWidth;
// }, function (props) {
//   return props.maxHeight;
// });

// // To Handle the Negative margin that goes beyond the body element
// var RightContainer = styled.div(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral$1(["\n  overflow-x: hidden;\n  overflow-y: hidden;\n"])));
// var FlexGridForSearch = styled(FlexGrid)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral$1(["\n  @media (min-width: 600px) and (max-width: 1279px) {\n    width: auto;\n  }\n  @media (min-width: 1280px) and (max-width: 1920px) {\n    width: 100%;\n  }\n  @media (min-width: 1920px) {\n    width: 70%;\n  }\n"])));
// var FlexGridSmallScreenSearch = styled(FlexGrid)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral$1(["\n    background-color: ", ";\n    width: 100%;\n    align-self: center;\n    padding: 0.5rem;\n    margin-right: ", "rem;\n"])), function (props) {
//   return props.theme.variables.leftNavHeaderBackground;
// }, function (props) {
//   return props.rightMargin;
// });
// var FlexGridMain = styled(FlexGrid)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral$1(["\n  .MuiGrid-container{\n    flex-wrap: nowrap;\n  }\n"])));

// /**
//  *  AppHeader displays information and actions relating to the current screen. *
//  */
// function AppHeader(_ref) {
//   var disableAppHeader = _ref.disableAppHeader,
//     logoSrc = _ref.logoSrc,
//     logoClickUrl = _ref.logoClickUrl,
//     menusData = _ref.menusData,
//     profileMenu = _ref.profileMenu,
//     myGuideElement = _ref.myGuideElement,
//     notificationsElement = _ref.notificationsElement,
//     helpElement = _ref.helpElement,
//     selfHeaderCustomElement = _ref.selfHeaderCustomElement,
//     teamHeaderCustomElement = _ref.teamHeaderCustomElement,
//     adminHeaderCustomElement = _ref.adminHeaderCustomElement,
//     searchElement = _ref.searchElement,
//     shoppingCartElement = _ref.shoppingCartElement,
//     translations = _ref.translations,
//     hideMenus = _ref.hideMenus,
//     onMenuClose = _ref.onMenuClose,
//     onMenuOpen = _ref.onMenuOpen,
//     poperLeftPosition = _ref.poperLeftPosition,
//     poperTopPosition = _ref.poperTopPosition,
//     alt = _ref.alt,
//     skipLinkText = _ref.skipLinkText,
//     skipMenufocus = _ref.skipMenufocus,
//     ResultsCallback = _ref.ResultsCallback;
//   var CustomLink = disableAppHeader ? DisabledLink : StyledRouteLink;
//   return /*#__PURE__*/React__default.createElement(AppBar, {
//     toolBarMinHeight: "3.25rem"
//   }, /*#__PURE__*/React__default.createElement(FlexGridMain, {
//     container: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     sm: !hideMenus ? 8 : 10,
//     lg: 7
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true
//   }, /*#__PURE__*/React__default.createElement(FlexGridForLink, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(ForLink, {
//     onClick: function onClick(e) {
//       e.preventDefault();
//       skipMenufocus();
//     }
//   }, skipLinkText)), /*#__PURE__*/React__default.createElement(FlexGridForImg, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(CustomLink, {
//     to: logoClickUrl
//   }, /*#__PURE__*/React__default.createElement(StyledImage, {
//     src: logoSrc,
//     maxWidth: 18.75,
//     maxHeight: 2,
//     alt: alt,
//     id: "imgLogo"
//   }))), !hideMenus && /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(TopMenu, {
//     menusData: menusData,
//     disableTopMenu: disableAppHeader,
//     selfHeaderCustomElement: selfHeaderCustomElement,
//     teamHeaderCustomElement: teamHeaderCustomElement,
//     adminHeaderCustomElement: adminHeaderCustomElement,
//     translations: translations,
//     onMenuOpen: onMenuOpen,
//     onMenuClose: onMenuClose,
//     poperLeftPosition: poperLeftPosition,
//     poperTopPosition: poperTopPosition,
//     ResultsCallback: ResultsCallback
//   })), hideMenus && /*#__PURE__*/React__default.createElement(FlexGridSmallScreenSearch, {
//     item: true,
//     rightMargin: 0.5
//   }, searchElement))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true,
//     sm: !hideMenus ? 4 : 2,
//     lg: 5
//   }, /*#__PURE__*/React__default.createElement(RightContainer, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     alignItems: "center",
//     spacing: 2,
//     justify: "flex-end"
//   }, !hideMenus && /*#__PURE__*/React__default.createElement(FlexGridForSearch, {
//     item: true
//   }, searchElement), myGuideElement && /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, myGuideElement), shoppingCartElement && /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, shoppingCartElement), notificationsElement && /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, notificationsElement), helpElement && /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, helpElement), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, profileMenu))))));
// }

// // PropType check
// AppHeader.propTypes = {
//   /**
//    * disable/enable AppHeader
//    */
//   disableAppHeader: PropTypes__default.bool,
//   /**
//    * home logo Source
//    */
//   logoSrc: PropTypes__default.string,
//   /**
//    * home logo click
//    */
//   logoClickUrl: PropTypes__default.string,
//   /**
//    * Menus data
//    */
//   menusData: PropTypes__default.arrayOf(PropTypes__default.shape({})),
//   /**
//    * Profile Menu component
//    */
//   profileMenu: PropTypes__default.node,
//   /**
//    * Help Component.
//    */
//   helpElement: PropTypes__default.node,
//   /**
//    * My Guide Component.
//    */
//   myGuideElement: PropTypes__default.node,
//   /**
//    * Notifications Alert Component.
//    */
//   notificationsElement: PropTypes__default.node,
//   /**
//    * Self Header Custom Element
//    */
//   selfHeaderCustomElement: PropTypes__default.node,
//   /**
//    * Team Header Custom Element
//    */
//   teamHeaderCustomElement: PropTypes__default.node,
//   /**
//    * Admin Header Custom Element
//    */
//   adminHeaderCustomElement: PropTypes__default.node,
//   /**
//    * Search Element
//    */
//   searchElement: PropTypes__default.node,
//   /**
//    * shoppingCart Element
//    */
//   shoppingCartElement: PropTypes__default.node,
//   /**
//    * Translations required for this component
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    * Show/hide Menus.
//    */
//   hideMenus: PropTypes__default.bool,
//   /**
//    * Call back Event on menu close
//    */
//   onMenuClose: PropTypes__default.func,
//   /**
//    * Call back Event on menu open
//    */
//   onMenuOpen: PropTypes__default.func,
//   /**
//    * Poper left alignment for smaller resolution screen
//    */
//   poperLeftPosition: PropTypes__default.number,
//   /**
//    * Poper top alignment for smaller resolution screen
//    */
//   poperTopPosition: PropTypes__default.number,
//   /**
//    * alternate text of image
//    */
//   alt: PropTypes__default.string,
//   /**
//    * skip link text
//    */
//   skipLinkText: PropTypes__default.string,
//   /**
//    * skip link call back function
//    */
//   skipMenufocus: PropTypes__default.func,
//   /**
//    * Results callback event
//    */
//   ResultsCallback: PropTypes__default.func
// };
// AppHeader.defaultProps = {
//   disableAppHeader: false,
//   logoSrc: '',
//   logoClickUrl: undefined,
//   menusData: undefined,
//   profileMenu: undefined,
//   helpElement: undefined,
//   myGuideElement: undefined,
//   notificationsElement: undefined,
//   selfHeaderCustomElement: undefined,
//   teamHeaderCustomElement: undefined,
//   adminHeaderCustomElement: undefined,
//   searchElement: undefined,
//   shoppingCartElement: undefined,
//   translations: {},
//   hideMenus: false,
//   onMenuClose: function onMenuClose() {},
//   onMenuOpen: function onMenuOpen() {},
//   poperLeftPosition: undefined,
//   poperTopPosition: undefined,
//   alt: 'Home',
//   skipLinkText: undefined,
//   skipMenufocus: undefined,
//   ResultsCallback: function ResultsCallback() {}
// };

// var _templateObject$8, _templateObject2$8;
// var BadgeStyle = styled.span(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteral$1(["\n  &.BadgePadding {\n    padding: 0rem 1rem;\n  }\n  &.BadgeText {\n    padding: 0.5rem;\n    font-weight: bold;\n  }\n"])));
// var StyledButton = styled(Button$1)(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteral$1(["\n  color: black;\n  text-decoration: underline;\n"])));

// /**
//  * Badge Alert component is used to display important messages along with badge to the user.
//  * It can be closed using close icon.
//  * This component also support autohiding.
//  */

// function BadgeAlert(_ref) {
//   var severity = _ref.severity,
//     variant = _ref.variant,
//     onClose = _ref.onClose,
//     children = _ref.children,
//     closeText = _ref.closeText,
//     badgeCount = _ref.badgeCount,
//     showIcon = _ref.showIcon,
//     onClick = _ref.onClick,
//     open = _ref.open,
//     showDetailText = _ref.showDetailText;
//   var closeLable;
//   if (!closeText) {
//     closeLable = "close ".concat(severity, " notification");
//   } else {
//     closeLable = closeText;
//   }
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Collapse, {
//     expand: open
//   }, /*#__PURE__*/React__default.createElement(BaseAlert, {
//     severity: severity,
//     variant: variant,
//     closeText: closeLable,
//     onClose: onClose,
//     showIcon: showIcon
//   }, !showIcon && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(BadgeStyle, {
//     className: "BadgePadding"
//   }, /*#__PURE__*/React__default.createElement(Badge, {
//     anchorOrigin: {
//       horizontal: 'left',
//       vertical: 'top'
//     },
//     badgeContent: badgeCount
//   }))), /*#__PURE__*/React__default.createElement(BadgeStyle, {
//     className: "BadgeText"
//   }, children, !showIcon && /*#__PURE__*/React__default.createElement(StyledButton, {
//     variant: "text",
//     size: "small",
//     onClick: onClick
//   }, showDetailText)))));
// }

// // PropType check
// BadgeAlert.propTypes = {
//   /**
//    * The severity of the alert.
//    */
//   severity: PropTypes__default.oneOf(['error', 'info', 'success', 'warning']),
//   /**
//    *The variant to use.
//    */

//   variant: PropTypes__default.oneOf(['filled', 'outlined', 'standard']),
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Getter state varible for open/close the alert.
//    */

//   open: PropTypes__default.bool,
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * Override the default label for the close icon button
//    */
//   closeText: PropTypes__default.string,
//   /**
//    * use to show the label for button to open the modal.
//    */
//   showDetailText: PropTypes__default.string,
//   /**
//    * Show badge content
//    */
//   badgeCount: PropTypes__default.number,
//   /**
//    * Callback fired when the button is clicked.
//    */
//   onClick: PropTypes__default.func,
//   /**
//    * Hide the icon when we need to show the badge count
//    */
//   showIcon: PropTypes__default.bool
// };
// BadgeAlert.defaultProps = {
//   severity: 'success',
//   variant: 'outlined',
//   children: undefined,
//   open: false,
//   onClose: undefined,
//   closeText: undefined,
//   showDetailText: 'Show Detail',
//   onClick: undefined,
//   badgeCount: 0,
//   showIcon: false
// };

// var _templateObject$7, _templateObject2$7;
// var WordWrap = styled.div(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral$1(["\n  width: 32rem;\n  padding: 0.5rem 0rem 0rem 1rem;\n"])));
// var ModalSubHeaderStyle = styled.p(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteral$1(["\n  font-weight: bold;\n"])));

// function BadgeAlertModal(_ref) {
//   var severity = _ref.severity,
//     variant = _ref.variant,
//     onClose = _ref.onClose,
//     children = _ref.children,
//     open = _ref.open,
//     closeText = _ref.closeText,
//     badgeCount = _ref.badgeCount,
//     msgData = _ref.msgData,
//     modalHeader = _ref.modalHeader,
//     modalSubHeader = _ref.modalSubHeader,
//     showDetailText = _ref.showDetailText,
//     modalCloseText = _ref.modalCloseText;
//   var onClick = function onClick() {
//     setopenModal(true);
//   };
//   var handleOnClose = function handleOnClose(evt) {
//     setopenModal(false);
//   };
//   var _React$useState = React__default.useState(false),
//     _React$useState2 = _slicedToArray$b(_React$useState, 2),
//     openModal = _React$useState2[0],
//     setopenModal = _React$useState2[1];
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, open && msgData && /*#__PURE__*/React__default.createElement(Modal, {
//     height: "25rem",
//     open: openModal,
//     onClose: handleOnClose,
//     title: modalHeader
//   }, /*#__PURE__*/React__default.createElement(DialogContent, null, /*#__PURE__*/React__default.createElement(ModalSubHeaderStyle, null, modalSubHeader), msgData.map(function (message) {
//     return /*#__PURE__*/React__default.createElement(WordWrap, {
//       key: message.id
//     }, /*#__PURE__*/React__default.createElement(IconWithLabel, {
//       label: message.errorMsg,
//       iconName: message.iconName,
//       severity: message.modalAlertSeverity
//     }));
//   })), /*#__PURE__*/React__default.createElement(DialogActions, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     onClick: handleOnClose
//   }, modalCloseText))), /*#__PURE__*/React__default.createElement(BadgeAlert, {
//     severity: severity,
//     variant: variant,
//     open: open,
//     badgeCount: badgeCount,
//     onClick: onClick,
//     closeText: closeText,
//     onClose: onClose,
//     showDetailText: showDetailText,
//     showIcon: !(msgData && msgData.length > 1)
//   }, children));
// }

// // PropType check
// BadgeAlertModal.propTypes = {
//   /**
//    * The severity of the alert.
//    */
//   severity: PropTypes__default.oneOf(['error', 'info', 'success', 'warning']),
//   /**
//    *The variant to use.
//    */

//   variant: PropTypes__default.oneOf(['filled', 'outlined', 'standard']),
//   /**
//    * The content of the component.
//    */
//   children: PropTypes__default.node,
//   /**
//    * Getter state varible for open/close the alert.
//    */

//   open: PropTypes__default.bool,
//   /**
//    * Contains Error message data collection
//    */
//   msgData: PropTypes__default.arrayOf(PropTypes__default.shape({})).isRequired,
//   /**
//    * Modal Header
//    */
//   modalHeader: PropTypes__default.string,
//   /**
//    * Modal Sub Header
//    */
//   modalSubHeader: PropTypes__default.string,
//   /**
//    * Callback fired when the component requests to be closed.
//    */
//   onClose: PropTypes__default.func,
//   /**
//    * Override the default label for the close icon button
//    */
//   closeText: PropTypes__default.string,
//   /**
//    * Count of Badge
//    */
//   badgeCount: PropTypes__default.number,
//   /**
//    * Show the text of click button
//    */
//   showDetailText: PropTypes__default.string,
//   /**
//    * Show the text of close/cancel button in modal
//    */
//   modalCloseText: PropTypes__default.string
// };
// BadgeAlertModal.defaultProps = {
//   severity: 'success',
//   variant: 'standard',
//   children: undefined,
//   open: true,
//   onClose: undefined,
//   closeText: undefined,
//   modalHeader: 'VIEW ALERTS',
//   modalSubHeader: '3 Alerts.',
//   badgeCount: 0,
//   showDetailText: '',
//   modalCloseText: 'Cancel'
// };

// var TableContextProvider = function TableContextProvider(_ref) {
//   var setColumns = _ref.setColumns,
//     tableInstance = _ref.tableInstance,
//     children = _ref.children;
//   var value = {
//     setColumns: setColumns,
//     tableInstance: tableInstance
//   };
//   return /*#__PURE__*/React__default.createElement(TableContext.Provider, {
//     value: value
//   }, children);
// };
// TableContextProvider.propTypes = {
//   /**
//    * The function used to set columns data in table instance.
//    */
//   setColumns: PropTypes__default.func.isRequired,
//   /**
//    * The react table instance with the given hooks.
//    */
//   tableInstance: PropTypes__default.shape({}),
//   /**
//    * The grid child components.
//    */
//   children: PropTypes__default.node.isRequired
// };
// TableContextProvider.defaultProps = {
//   tableInstance: {}
// };

// /**
//   DataGrid is used to organize and display data efficiently. Data grid contains the following components:
//   *
// - Column – allows to set properties for each column header.
// - CellRenderer – allows to customize the row cell.
// - LabelCell – used to render text inside the cell. For eaxmple If we want to render a custom component let's say image inside a cell then we need to write a wrapper
//   similar to LabelCell but which should be like to render our custom image UI.
//  */
// function DataGrid(_ref) {
//   var data = _ref.data,
//     children = _ref.children;
//     _ref.className;
//     var serverPagination = _ref.serverPagination,
//     serverSorting = _ref.serverSorting,
//     getDataGridState = _ref.getDataGridState,
//     serverFiltering = _ref.serverFiltering,
//     rowSelectedKey = _ref.rowSelectedKey,
//     resetsetSelectedRows = _ref.resetsetSelectedRows,
//     skipPageReset = _ref.skipPageReset,
//     autoResetRows = _ref.autoResetRows,
//     autoFilterReset = _ref.autoFilterReset,
//     pageSize = _ref.pageSize,
//     preSelectedRows = _ref.preSelectedRows;
//   var _useState = useState$1([]),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     columns = _useState2[0],
//     setColumns = _useState2[1];
//   var tableInstance = useTable({
//     columns: columns,
//     data: data,
//     manualSortBy: serverSorting,
//     manualPagination: serverPagination,
//     manualFilters: serverFiltering,
//     autoResetSelectedRows: autoResetRows,
//     autoResetFilters: autoFilterReset,
//     autoResetPage: skipPageReset,
//     getRowId: function getRowId(row, index) {
//       return row[rowSelectedKey] || index;
//     },
//     initialState: {
//       pageSize: pageSize
//     }
//   }, useFilters, useSortBy, usePagination, useRowSelect, useRowState);
//   useEffect$2(function () {
//     if (getDataGridState) {
//       getDataGridState(tableInstance.state);
//     }
//   }, [tableInstance.state, getDataGridState]);
//   useEffect$2(function () {
//     tableInstance.state.selectedRowIds = preSelectedRows;
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [preSelectedRows]);
//   useEffect$2(function () {
//     if (resetsetSelectedRows) {
//       tableInstance.state.selectedRowIds = {};
//     }
//   }, [resetsetSelectedRows, tableInstance.state]);
//   return /*#__PURE__*/React__default.createElement(TableContextProvider, {
//     setColumns: setColumns,
//     tableInstance: tableInstance
//   }, children);
// }
// DataGrid.propTypes = {
//   /**
//    * Table Data to be displayed.
//    */
//   data: PropTypes__default.arrayOf(PropTypes__default.shape({})).isRequired,
//   /**
//    * Table child Components.
//    */
//   children: PropTypes__default.node.isRequired,
//   /**
//    * Class name
//    */
//   className: PropTypes__default.string,
//   /**
//    * to enable server side pagination.
//    */
//   serverPagination: PropTypes__default.bool,
//   /**
//    * to enable server side sorting.
//    */
//   serverSorting: PropTypes__default.bool,
//   /**
//    * to capture the datagrid state.
//    */
//   getDataGridState: PropTypes__default.func,
//   /**
//    * to enable server side filtering.
//    */
//   serverFiltering: PropTypes__default.bool,
//   /**
//    *  to enable multiselect with server side pagination
//    */
//   rowSelectedKey: PropTypes__default.string,
//   /**
//    *  to reset selected ids from the state after toolbar actions performed
//    */
//   resetsetSelectedRows: PropTypes__default.bool,
//   /**
//    *  to skip Page Reset
//    */
//   skipPageReset: PropTypes__default.bool,
//   /**
//    *  auto reset selected rows
//    */
//   autoResetRows: PropTypes__default.bool,
//   /**
//    *  When true, the filters state will automatically reset if data is changed.
//    */
//   autoFilterReset: PropTypes__default.bool,
//   /**
//    * Page size
//    */
//   pageSize: PropTypes__default.number,
//   /**
//    * Pre-select the rows, selectedRowIds will be auto updated if the data changes
//    */
//   preSelectedRows: PropTypes__default.shape({})
// };
// DataGrid.defaultProps = {
//   className: undefined,
//   serverPagination: false,
//   serverSorting: false,
//   getDataGridState: undefined,
//   serverFiltering: false,
//   rowSelectedKey: undefined,
//   resetsetSelectedRows: false,
//   skipPageReset: false,
//   autoResetRows: false,
//   autoFilterReset: true,
//   pageSize: 10,
//   preSelectedRows: {}
// };

// var sanitizeOption = function sanitizeOption(option) {
//   var cleanedOption = option.replace(/&nbsp;/g, ' ').replace(/<[^>]+>/g, '').replace(/\s+/g, '');

//   // Check if the cleaned option is empty and if it contains only an image, including base64-encoded images
//   if (cleanedOption.trim() === '' && /<img[^>]+src=['"]data:image\//.test(option)) {
//     return '<p>Image Only</p>'; // Return a placeholder if it's an image-only option
//   }
//   return cleanedOption;
// };

// var _templateObject$6, _templateObject2$6, _templateObject3$5;
// var Label$5 = styled(FormLabel)(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral$1(["\n  margin-top: 0.625rem;\n"])));
// var HintLabel$4 = styled(Label$5)(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// var AnswerDiv$5 = styled.div(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteral$1(["\n  margin-top: 0.938rem;\n"])));

// /**
//  * FillInTheBlanks component is a Question type which consists of a phrase, sentence, or paragraph with a blank space where a user provides the missing word or words.
//  *
//  */
// var FillInTheBlanks = function FillInTheBlanks(_ref) {
//   var translations = _ref.translations,
//     onAnother = _ref.onAnother,
//     onDone = _ref.onDone,
//     onCancel = _ref.onCancel,
//     editData = _ref.editData,
//     isEdit = _ref.isEdit,
//     translationMode = _ref.translationMode,
//     disableAction = _ref.disableAction;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     questionCode = _useState2[0],
//     setQuestionCode = _useState2[1];
//   var _useState3 = useState$1([]),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     question = _useState4[0],
//     setQuestion = _useState4[1];
//   var _useState5 = useState$1(''),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     questionFeedback = _useState6[0],
//     setQuestionFeedback = _useState6[1];
//   var _useState7 = useState$1(''),
//     _useState8 = _slicedToArray$b(_useState7, 2),
//     answer = _useState8[0],
//     setAnswer = _useState8[1];
//   var _useState9 = useState$1(''),
//     _useState10 = _slicedToArray$b(_useState9, 2),
//     answerFeedback = _useState10[0],
//     setAnswerFeedback = _useState10[1];
//   var _useState11 = useState$1(false),
//     _useState12 = _slicedToArray$b(_useState11, 2),
//     caseSensitive = _useState12[0],
//     setCaseSensitive = _useState12[1];
//   var _useState13 = useState$1(true),
//     _useState14 = _slicedToArray$b(_useState13, 2),
//     buttonDisable = _useState14[0],
//     setButtonDisable = _useState14[1];
//   var _useState15 = useState$1(false),
//     _useState16 = _slicedToArray$b(_useState15, 2),
//     questionChanged = _useState16[0],
//     setQuestionChanged = _useState16[1];
//   var answerFieldMultiLine = true;
//   var answerFieldFullWidth = true;
//   var answerFieldRows = 10;
//   var setAnswerFeedbackEditorRef = useRef$2(null);
//   var questionCodeChange = function questionCodeChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionCode(value);
//     }
//   };
//   var questionChange = function questionChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionChanged(true);
//       setQuestion([]);
//       question.push(value);
//       setQuestion(value);
//       disableHandler();
//     }
//   };
//   var questionFeedbackChange = function questionFeedbackChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionFeedback(value);
//     }
//   };
//   var answerChange = function answerChange(event) {
//     if (event !== undefined) {
//       setAnswer(event.target.value);
//       disableHandler();
//     }
//   };
//   var answerFeedbackChange = function answerFeedbackChange(event) {
//     if (event !== undefined) {
//       setAnswerFeedback(event.editor.getData());
//     }
//   };
//   useEffect$2(function () {
//     // Code to handle 'question' change
//     if (questionChanged) {
//       if (translationMode) {
//         if (isEdit && !!editData.Options) {
//           editData.Options.forEach(function (value) {
//             setAnswer(value.AnswerText.join('\n'));
//             setAnswerFeedback(value.Feedback);
//           });
//         }
//       }
//       disableHandler();
//     }
//     // Code to handle initial load
//     else if (editData && isEdit) {
//       setQuestionCode(editData.Code);
//       setQuestion(editData.QuestionText);
//       setQuestionFeedback(editData.QuestionFeedback);
//       if (isEdit && !!editData.Options) {
//         editData.Options.forEach(function (value) {
//           setAnswer(value.AnswerText.join('\n'));
//           setAnswerFeedback(value.Feedback);
//           setCaseSensitive(value.IsCaseSensitive);
//         });
//         disableHandler();
//       }
//       setButtonDisable(false);
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [question, editData]);
//   var handleCaseSensitiveChange = function handleCaseSensitiveChange(event) {
//     setCaseSensitive(event.target.checked);
//   };
//   var disableHandler = function disableHandler() {
//     if (!!question && question.length > 0 && !!answer && answer.trim().length > 0 && question[question.length - 1] !== '') {
//       if (sanitizeOption(question) !== '') {
//         setButtonDisable(false);
//       } else {
//         setButtonDisable(true);
//       }
//     } else {
//       setButtonDisable(true);
//     }
//   };
//   var buildQuestionObject = function buildQuestionObject() {
//     var questionObject = {
//       Code: questionCode,
//       QuestionText: question,
//       QuestionTextFmt: question,
//       QuestionType: null,
//       QuestionFeedback: questionFeedback,
//       Options: [],
//       Status: null
//     };
//     var splitAnswers = answer.split('\n');
//     var idList = [];
//     var idCounter = 1;
//     splitAnswers.forEach(function (f) {
//       idList.push(idCounter);
//       idCounter += 1;
//     });
//     questionObject.Options.push({
//       AnswerID: idList,
//       WeightPercent: '100',
//       AnswerText: splitAnswers,
//       MatchAnswerText: '',
//       MatchAnswerID: '1',
//       Feedback: answerFeedback,
//       IsCaseSensitive: caseSensitive,
//       QuestionBankType: null
//     });
//     return questionObject;
//   };
//   var doneClick = function doneClick() {
//     var requestObject = buildQuestionObject();
//     onDone(requestObject);
//   };
//   var anotherClick = function anotherClick() {
//     var requestObject = buildQuestionObject();
//     onAnother(requestObject);
//   };
//   var cancelClick = function cancelClick() {
//     onCancel();
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(QuestionFeedback, {
//     onCodeChange: questionCodeChange,
//     onQuestionChange: questionChange,
//     onFeedbackChange: questionFeedbackChange,
//     codeLabel: translations.CODE_LABEL,
//     questionLabel: translations.QUESTION_LABEL,
//     questionMaximumLabel: translations.QUESTION_MAX_LABEL,
//     questionFeedbackLabel: translations.QUESTION_FEEDBACK_LABEL,
//     editData: editData,
//     translationMode: translationMode
//   }), /*#__PURE__*/React__default.createElement(AnswerDiv$5, {
//     id: "answer-feedback"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$5, null, translations.ANSWER_LABEL), /*#__PURE__*/React__default.createElement(HintLabel$4, null, translations.MULTIPLE_ANSWERS_LABEL))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(TextField, {
//     id: "answer",
//     name: "answer",
//     type: "text",
//     multiline: answerFieldMultiLine,
//     rows: answerFieldRows,
//     fullWidth: answerFieldFullWidth,
//     onChange: function onChange(event) {
//       return answerChange(event);
//     },
//     onKeyUp: function onKeyUp(event) {
//       return answerChange(event);
//     },
//     value: answer
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label$5, null, translations.ANSWER_FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "answer-feedback",
//     onChange: function onChange(event) {
//       return answerFeedbackChange(event);
//     },
//     initData: isEdit && (editData === null || editData === void 0 ? void 0 : editData.Options) !== null && (editData === null || editData === void 0 ? void 0 : editData.Options) !== undefined && editData.Options.length !== 0 ? editData === null || editData === void 0 ? void 0 : editData.Options[0].Feedback : '',
//     onReady: function onReady(editor) {
//       setAnswerFeedbackEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(CheckboxWithLabel, {
//     id: "answer-case-sensitive",
//     label: translations.ANSWER_CASE_SENSITIVE_LABEL,
//     checked: caseSensitive,
//     onChange: handleCaseSensitiveChange,
//     disabled: translationMode
//   }))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$5, null, !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "another",
//     disabled: buttonDisable,
//     onClick: anotherClick
//   }, translations.ANOTHER_LABEL)), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "done",
//     disabled: buttonDisable || disableAction,
//     onClick: doneClick
//   }, translations.DONE_LABEL), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "cancel",
//     onClick: cancelClick
//   }, translations.CANCEL_LABEL)))));
// };
// var optionsPropTypes$4 = {
//   AnswerID: PropTypes__default.arrayOf(PropTypes__default.string),
//   AnswerText: PropTypes__default.arrayOf(PropTypes__default.string),
//   Feedback: PropTypes__default.string,
//   MatchAnswerText: PropTypes__default.string,
//   WeightPercent: PropTypes__default.string,
//   IsCorrect: PropTypes__default.bool,
//   IsCaseSensitive: PropTypes__default.bool,
//   Shuffle: PropTypes__default.bool
// };
// var editDataPropTypes$4 = {
//   QuestionType: PropTypes__default.number,
//   Code: PropTypes__default.string,
//   QuestionText: PropTypes__default.string,
//   QuestionFeedback: PropTypes__default.string,
//   Options: PropTypes__default.arrayOf(PropTypes__default.shape(optionsPropTypes$4))
// };
// FillInTheBlanks.propTypes = {
//   /**
//    * isEdit defines that it is Edit mode
//    */
//   isEdit: PropTypes__default.bool,
//   /**
//    * editData contains all data for edit
//    */
//   editData: PropTypes__default.shape(editDataPropTypes$4),
//   /**
//    * onDone callback function to pass request object
//    */
//   onDone: PropTypes__default.func.isRequired,
//   /**
//    * onAnother callback function to pass request object
//    */
//   onAnother: PropTypes__default.func.isRequired,
//   /**
//    * onCancel callback function
//    */
//   onCancel: PropTypes__default.func.isRequired,
//   /**
//   /**
//    * translations contains all string translations for FillInTheBlanks
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    *   Action type translate based on this prop value disabling some of the input fields 
//   // which should not editable while adding the translated question from the base question
//   */
//   translationMode: PropTypes__default.bool,
//   /**
//    * Disables done button if language dropdown has value '-1'
//    */
//   disableAction: PropTypes__default.bool
// };
// FillInTheBlanks.defaultProps = {
//   translations: {
//     CODE_LABEL: 'Question Code:',
//     QUESTION_LABEL: 'Question: *',
//     QUESTION_MAX_LABEL: 'Question maximum: 4000 characters',
//     QUESTION_FEEDBACK_LABEL: 'Question Feedback:',
//     ANSWER_LABEL: 'Answer: *',
//     MULTIPLE_ANSWERS_LABEL: 'Note : To insert multiple answers, type your answer and press ENTER.',
//     ANSWER_FEEDBACK_LABEL: 'Answer Feedback:',
//     ANSWER_CASE_SENSITIVE_LABEL: 'Answers must be case sensitive',
//     ANOTHER_LABEL: 'ADD ANOTHER QUESTION',
//     DONE_LABEL: 'DONE',
//     CANCEL_LABEL: 'CANCEL'
//   },
//   isEdit: false,
//   editData: undefined,
//   translationMode: false,
//   disableAction: false
// };

// /*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE */

// function _typeof(obj) {
//   "@babel/helpers - typeof";

//   return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
//     return typeof obj;
//   } : function (obj) {
//     return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
//   }, _typeof(obj);
// }

// function _setPrototypeOf(o, p) {
//   _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
//     o.__proto__ = p;
//     return o;
//   };

//   return _setPrototypeOf(o, p);
// }

// function _isNativeReflectConstruct() {
//   if (typeof Reflect === "undefined" || !Reflect.construct) return false;
//   if (Reflect.construct.sham) return false;
//   if (typeof Proxy === "function") return true;

//   try {
//     Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
//     return true;
//   } catch (e) {
//     return false;
//   }
// }

// function _construct(Parent, args, Class) {
//   if (_isNativeReflectConstruct()) {
//     _construct = Reflect.construct;
//   } else {
//     _construct = function _construct(Parent, args, Class) {
//       var a = [null];
//       a.push.apply(a, args);
//       var Constructor = Function.bind.apply(Parent, a);
//       var instance = new Constructor();
//       if (Class) _setPrototypeOf(instance, Class.prototype);
//       return instance;
//     };
//   }

//   return _construct.apply(null, arguments);
// }

// function _toConsumableArray(arr) {
//   return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
// }

// function _arrayWithoutHoles(arr) {
//   if (Array.isArray(arr)) return _arrayLikeToArray(arr);
// }

// function _iterableToArray(iter) {
//   if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
// }

// function _unsupportedIterableToArray(o, minLen) {
//   if (!o) return;
//   if (typeof o === "string") return _arrayLikeToArray(o, minLen);
//   var n = Object.prototype.toString.call(o).slice(8, -1);
//   if (n === "Object" && o.constructor) n = o.constructor.name;
//   if (n === "Map" || n === "Set") return Array.from(o);
//   if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
// }

// function _arrayLikeToArray(arr, len) {
//   if (len == null || len > arr.length) len = arr.length;

//   for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

//   return arr2;
// }

// function _nonIterableSpread() {
//   throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
// }

// var hasOwnProperty = Object.hasOwnProperty,
//     setPrototypeOf = Object.setPrototypeOf,
//     isFrozen = Object.isFrozen,
//     getPrototypeOf = Object.getPrototypeOf,
//     getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// var freeze = Object.freeze,
//     seal = Object.seal,
//     create = Object.create; // eslint-disable-line import/no-mutable-exports

// var _ref = typeof Reflect !== 'undefined' && Reflect,
//     apply = _ref.apply,
//     construct = _ref.construct;

// if (!apply) {
//   apply = function apply(fun, thisValue, args) {
//     return fun.apply(thisValue, args);
//   };
// }

// if (!freeze) {
//   freeze = function freeze(x) {
//     return x;
//   };
// }

// if (!seal) {
//   seal = function seal(x) {
//     return x;
//   };
// }

// if (!construct) {
//   construct = function construct(Func, args) {
//     return _construct(Func, _toConsumableArray(args));
//   };
// }

// var arrayForEach = unapply(Array.prototype.forEach);
// var arrayPop = unapply(Array.prototype.pop);
// var arrayPush = unapply(Array.prototype.push);
// var stringToLowerCase = unapply(String.prototype.toLowerCase);
// var stringToString = unapply(String.prototype.toString);
// var stringMatch = unapply(String.prototype.match);
// var stringReplace = unapply(String.prototype.replace);
// var stringIndexOf = unapply(String.prototype.indexOf);
// var stringTrim = unapply(String.prototype.trim);
// var regExpTest = unapply(RegExp.prototype.test);
// var typeErrorCreate = unconstruct(TypeError);
// function unapply(func) {
//   return function (thisArg) {
//     for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
//       args[_key - 1] = arguments[_key];
//     }

//     return apply(func, thisArg, args);
//   };
// }
// function unconstruct(func) {
//   return function () {
//     for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
//       args[_key2] = arguments[_key2];
//     }

//     return construct(func, args);
//   };
// }
// /* Add properties to a lookup table */

// function addToSet(set, array, transformCaseFunc) {
//   var _transformCaseFunc;

//   transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;

//   if (setPrototypeOf) {
//     // Make 'in' and truthy checks like Boolean(set.constructor)
//     // independent of any properties defined on Object.prototype.
//     // Prevent prototype setters from intercepting set as a this value.
//     setPrototypeOf(set, null);
//   }

//   var l = array.length;

//   while (l--) {
//     var element = array[l];

//     if (typeof element === 'string') {
//       var lcElement = transformCaseFunc(element);

//       if (lcElement !== element) {
//         // Config presets (e.g. tags.js, attrs.js) are immutable.
//         if (!isFrozen(array)) {
//           array[l] = lcElement;
//         }

//         element = lcElement;
//       }
//     }

//     set[element] = true;
//   }

//   return set;
// }
// /* Shallow clone an object */

// function clone(object) {
//   var newObject = create(null);
//   var property;

//   for (property in object) {
//     if (apply(hasOwnProperty, object, [property]) === true) {
//       newObject[property] = object[property];
//     }
//   }

//   return newObject;
// }
// /* IE10 doesn't support __lookupGetter__ so lets'
//  * simulate it. It also automatically checks
//  * if the prop is function or getter and behaves
//  * accordingly. */

// function lookupGetter(object, prop) {
//   while (object !== null) {
//     var desc = getOwnPropertyDescriptor(object, prop);

//     if (desc) {
//       if (desc.get) {
//         return unapply(desc.get);
//       }

//       if (typeof desc.value === 'function') {
//         return unapply(desc.value);
//       }
//     }

//     object = getPrototypeOf(object);
//   }

//   function fallbackValue(element) {
//     console.warn('fallback value for', element);
//     return null;
//   }

//   return fallbackValue;
// }

// var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

// var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
// var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
// // We still need to know them so that we can do namespace
// // checks properly in case one wants to add them to
// // allow-list.

// var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
// var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
// // even those that we disallow by default.

// var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
// var text = freeze(['#text']);

// var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
// var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
// var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
// var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

// var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
// var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
// var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

// var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

// var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
// );
// var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
// var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
// );
// var DOCTYPE_NAME = seal(/^html$/i);

// var getGlobal = function getGlobal() {
//   return typeof window === 'undefined' ? null : window;
// };
// /**
//  * Creates a no-op policy for internal use only.
//  * Don't export this function outside this module!
//  * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
//  * @param {Document} document The document object (to determine policy name suffix)
//  * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
//  * are not supported).
//  */


// var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
//   if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
//     return null;
//   } // Allow the callers to control the unique policy name
//   // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
//   // Policy creation with duplicate names throws in Trusted Types.


//   var suffix = null;
//   var ATTR_NAME = 'data-tt-policy-suffix';

//   if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
//     suffix = document.currentScript.getAttribute(ATTR_NAME);
//   }

//   var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

//   try {
//     return trustedTypes.createPolicy(policyName, {
//       createHTML: function createHTML(html) {
//         return html;
//       },
//       createScriptURL: function createScriptURL(scriptUrl) {
//         return scriptUrl;
//       }
//     });
//   } catch (_) {
//     // Policy creation failed (most likely another DOMPurify script has
//     // already run). Skip creating the policy, as this will only cause errors
//     // if TT are enforced.
//     console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
//     return null;
//   }
// };

// function createDOMPurify() {
//   var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

//   var DOMPurify = function DOMPurify(root) {
//     return createDOMPurify(root);
//   };
//   /**
//    * Version label, exposed for easier checks
//    * if DOMPurify is up to date or not
//    */


//   DOMPurify.version = '2.4.7';
//   /**
//    * Array of elements that DOMPurify removed during sanitation.
//    * Empty if nothing was removed.
//    */

//   DOMPurify.removed = [];

//   if (!window || !window.document || window.document.nodeType !== 9) {
//     // Not running in a browser, provide a factory function
//     // so that you can pass your own Window
//     DOMPurify.isSupported = false;
//     return DOMPurify;
//   }

//   var originalDocument = window.document;
//   var document = window.document;
//   var DocumentFragment = window.DocumentFragment,
//       HTMLTemplateElement = window.HTMLTemplateElement,
//       Node = window.Node,
//       Element = window.Element,
//       NodeFilter = window.NodeFilter,
//       _window$NamedNodeMap = window.NamedNodeMap,
//       NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
//       HTMLFormElement = window.HTMLFormElement,
//       DOMParser = window.DOMParser,
//       trustedTypes = window.trustedTypes;
//   var ElementPrototype = Element.prototype;
//   var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
//   var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
//   var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
//   var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
//   // new document created via createHTMLDocument. As per the spec
//   // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
//   // a new empty registry is used when creating a template contents owner
//   // document, so we use that as our parent document to ensure nothing
//   // is inherited.

//   if (typeof HTMLTemplateElement === 'function') {
//     var template = document.createElement('template');

//     if (template.content && template.content.ownerDocument) {
//       document = template.content.ownerDocument;
//     }
//   }

//   var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

//   var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
//   var _document = document,
//       implementation = _document.implementation,
//       createNodeIterator = _document.createNodeIterator,
//       createDocumentFragment = _document.createDocumentFragment,
//       getElementsByTagName = _document.getElementsByTagName;
//   var importNode = originalDocument.importNode;
//   var documentMode = {};

//   try {
//     documentMode = clone(document).documentMode ? document.documentMode : {};
//   } catch (_) {}

//   var hooks = {};
//   /**
//    * Expose whether this browser supports running the full DOMPurify.
//    */

//   DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined && documentMode !== 9;
//   var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
//       ERB_EXPR$1 = ERB_EXPR,
//       TMPLIT_EXPR$1 = TMPLIT_EXPR,
//       DATA_ATTR$1 = DATA_ATTR,
//       ARIA_ATTR$1 = ARIA_ATTR,
//       IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
//       ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
//   var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
//   /**
//    * We consider the elements and attributes below to be safe. Ideally
//    * don't add any new ones but feel free to remove unwanted ones.
//    */

//   /* allowed element names */

//   var ALLOWED_TAGS = null;
//   var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
//   /* Allowed attribute names */

//   var ALLOWED_ATTR = null;
//   var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
//   /*
//    * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
//    * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
//    * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
//    * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
//    */

//   var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
//     tagNameCheck: {
//       writable: true,
//       configurable: false,
//       enumerable: true,
//       value: null
//     },
//     attributeNameCheck: {
//       writable: true,
//       configurable: false,
//       enumerable: true,
//       value: null
//     },
//     allowCustomizedBuiltInElements: {
//       writable: true,
//       configurable: false,
//       enumerable: true,
//       value: false
//     }
//   }));
//   /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

//   var FORBID_TAGS = null;
//   /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

//   var FORBID_ATTR = null;
//   /* Decide if ARIA attributes are okay */

//   var ALLOW_ARIA_ATTR = true;
//   /* Decide if custom data attributes are okay */

//   var ALLOW_DATA_ATTR = true;
//   /* Decide if unknown protocols are okay */

//   var ALLOW_UNKNOWN_PROTOCOLS = false;
//   /* Decide if self-closing tags in attributes are allowed.
//    * Usually removed due to a mXSS issue in jQuery 3.0 */

//   var ALLOW_SELF_CLOSE_IN_ATTR = true;
//   /* Output should be safe for common template engines.
//    * This means, DOMPurify removes data attributes, mustaches and ERB
//    */

//   var SAFE_FOR_TEMPLATES = false;
//   /* Decide if document with <html>... should be returned */

//   var WHOLE_DOCUMENT = false;
//   /* Track whether config is already set on this instance of DOMPurify. */

//   var SET_CONFIG = false;
//   /* Decide if all elements (e.g. style, script) must be children of
//    * document.body. By default, browsers might move them to document.head */

//   var FORCE_BODY = false;
//   /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
//    * string (or a TrustedHTML object if Trusted Types are supported).
//    * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
//    */

//   var RETURN_DOM = false;
//   /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
//    * string  (or a TrustedHTML object if Trusted Types are supported) */

//   var RETURN_DOM_FRAGMENT = false;
//   /* Try to return a Trusted Type object instead of a string, return a string in
//    * case Trusted Types are not supported  */

//   var RETURN_TRUSTED_TYPE = false;
//   /* Output should be free from DOM clobbering attacks?
//    * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
//    */

//   var SANITIZE_DOM = true;
//   /* Achieve full DOM Clobbering protection by isolating the namespace of named
//    * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
//    *
//    * HTML/DOM spec rules that enable DOM Clobbering:
//    *   - Named Access on Window (§7.3.3)
//    *   - DOM Tree Accessors (§3.1.5)
//    *   - Form Element Parent-Child Relations (§4.10.3)
//    *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
//    *   - HTMLCollection (§4.2.10.2)
//    *
//    * Namespace isolation is implemented by prefixing `id` and `name` attributes
//    * with a constant string, i.e., `user-content-`
//    */

//   var SANITIZE_NAMED_PROPS = false;
//   var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
//   /* Keep element content when removing element? */

//   var KEEP_CONTENT = true;
//   /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
//    * of importing it into a new Document and returning a sanitized copy */

//   var IN_PLACE = false;
//   /* Allow usage of profiles like html, svg and mathMl */

//   var USE_PROFILES = {};
//   /* Tags to ignore content of when KEEP_CONTENT is true */

//   var FORBID_CONTENTS = null;
//   var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
//   /* Tags that are safe for data: URIs */

//   var DATA_URI_TAGS = null;
//   var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
//   /* Attributes safe for values like "javascript:" */

//   var URI_SAFE_ATTRIBUTES = null;
//   var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
//   var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
//   var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
//   var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
//   /* Document namespace */

//   var NAMESPACE = HTML_NAMESPACE;
//   var IS_EMPTY_INPUT = false;
//   /* Allowed XHTML+XML namespaces */

//   var ALLOWED_NAMESPACES = null;
//   var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
//   /* Parsing of strict XHTML documents */

//   var PARSER_MEDIA_TYPE;
//   var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
//   var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
//   var transformCaseFunc;
//   /* Keep a reference to config to pass to hooks */

//   var CONFIG = null;
//   /* Ideally, do not touch anything below this line */

//   /* ______________________________________________ */

//   var formElement = document.createElement('form');

//   var isRegexOrFunction = function isRegexOrFunction(testValue) {
//     return testValue instanceof RegExp || testValue instanceof Function;
//   };
//   /**
//    * _parseConfig
//    *
//    * @param  {Object} cfg optional config literal
//    */
//   // eslint-disable-next-line complexity


//   var _parseConfig = function _parseConfig(cfg) {
//     if (CONFIG && CONFIG === cfg) {
//       return;
//     }
//     /* Shield configuration object from tampering */


//     if (!cfg || _typeof(cfg) !== 'object') {
//       cfg = {};
//     }
//     /* Shield configuration object from prototype pollution */


//     cfg = clone(cfg);
//     PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
//     SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

//     transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
//     /* Set configuration parameters */

//     ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
//     ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
//     ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
//     URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
//     cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
//     transformCaseFunc // eslint-disable-line indent
//     ) // eslint-disable-line indent
//     : DEFAULT_URI_SAFE_ATTRIBUTES;
//     DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
//     cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
//     transformCaseFunc // eslint-disable-line indent
//     ) // eslint-disable-line indent
//     : DEFAULT_DATA_URI_TAGS;
//     FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
//     FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
//     FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
//     USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
//     ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

//     ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

//     ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

//     ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true

//     SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

//     WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

//     RETURN_DOM = cfg.RETURN_DOM || false; // Default false

//     RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

//     RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

//     FORCE_BODY = cfg.FORCE_BODY || false; // Default false

//     SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

//     SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

//     KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

//     IN_PLACE = cfg.IN_PLACE || false; // Default false

//     IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
//     NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
//     CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};

//     if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
//       CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
//     }

//     if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
//       CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
//     }

//     if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
//       CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
//     }

//     if (SAFE_FOR_TEMPLATES) {
//       ALLOW_DATA_ATTR = false;
//     }

//     if (RETURN_DOM_FRAGMENT) {
//       RETURN_DOM = true;
//     }
//     /* Parse profile info */


//     if (USE_PROFILES) {
//       ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
//       ALLOWED_ATTR = [];

//       if (USE_PROFILES.html === true) {
//         addToSet(ALLOWED_TAGS, html$1);
//         addToSet(ALLOWED_ATTR, html);
//       }

//       if (USE_PROFILES.svg === true) {
//         addToSet(ALLOWED_TAGS, svg$1);
//         addToSet(ALLOWED_ATTR, svg);
//         addToSet(ALLOWED_ATTR, xml);
//       }

//       if (USE_PROFILES.svgFilters === true) {
//         addToSet(ALLOWED_TAGS, svgFilters);
//         addToSet(ALLOWED_ATTR, svg);
//         addToSet(ALLOWED_ATTR, xml);
//       }

//       if (USE_PROFILES.mathMl === true) {
//         addToSet(ALLOWED_TAGS, mathMl$1);
//         addToSet(ALLOWED_ATTR, mathMl);
//         addToSet(ALLOWED_ATTR, xml);
//       }
//     }
//     /* Merge configuration parameters */


//     if (cfg.ADD_TAGS) {
//       if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
//         ALLOWED_TAGS = clone(ALLOWED_TAGS);
//       }

//       addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
//     }

//     if (cfg.ADD_ATTR) {
//       if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
//         ALLOWED_ATTR = clone(ALLOWED_ATTR);
//       }

//       addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
//     }

//     if (cfg.ADD_URI_SAFE_ATTR) {
//       addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
//     }

//     if (cfg.FORBID_CONTENTS) {
//       if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
//         FORBID_CONTENTS = clone(FORBID_CONTENTS);
//       }

//       addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
//     }
//     /* Add #text in case KEEP_CONTENT is set to true */


//     if (KEEP_CONTENT) {
//       ALLOWED_TAGS['#text'] = true;
//     }
//     /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


//     if (WHOLE_DOCUMENT) {
//       addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
//     }
//     /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


//     if (ALLOWED_TAGS.table) {
//       addToSet(ALLOWED_TAGS, ['tbody']);
//       delete FORBID_TAGS.tbody;
//     } // Prevent further manipulation of configuration.
//     // Not available in IE8, Safari 5, etc.


//     if (freeze) {
//       freeze(cfg);
//     }

//     CONFIG = cfg;
//   };

//   var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
//   var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
//   // namespace. We need to specify them explicitly
//   // so that they don't get erroneously deleted from
//   // HTML namespace.

//   var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
//   /* Keep track of all possible SVG and MathML tags
//    * so that we can perform the namespace checks
//    * correctly. */

//   var ALL_SVG_TAGS = addToSet({}, svg$1);
//   addToSet(ALL_SVG_TAGS, svgFilters);
//   addToSet(ALL_SVG_TAGS, svgDisallowed);
//   var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
//   addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
//   /**
//    *
//    *
//    * @param  {Element} element a DOM element whose namespace is being checked
//    * @returns {boolean} Return false if the element has a
//    *  namespace that a spec-compliant parser would never
//    *  return. Return true otherwise.
//    */

//   var _checkValidNamespace = function _checkValidNamespace(element) {
//     var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
//     // can be null. We just simulate parent in this case.

//     if (!parent || !parent.tagName) {
//       parent = {
//         namespaceURI: NAMESPACE,
//         tagName: 'template'
//       };
//     }

//     var tagName = stringToLowerCase(element.tagName);
//     var parentTagName = stringToLowerCase(parent.tagName);

//     if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
//       return false;
//     }

//     if (element.namespaceURI === SVG_NAMESPACE) {
//       // The only way to switch from HTML namespace to SVG
//       // is via <svg>. If it happens via any other tag, then
//       // it should be killed.
//       if (parent.namespaceURI === HTML_NAMESPACE) {
//         return tagName === 'svg';
//       } // The only way to switch from MathML to SVG is via`
//       // svg if parent is either <annotation-xml> or MathML
//       // text integration points.


//       if (parent.namespaceURI === MATHML_NAMESPACE) {
//         return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
//       } // We only allow elements that are defined in SVG
//       // spec. All others are disallowed in SVG namespace.


//       return Boolean(ALL_SVG_TAGS[tagName]);
//     }

//     if (element.namespaceURI === MATHML_NAMESPACE) {
//       // The only way to switch from HTML namespace to MathML
//       // is via <math>. If it happens via any other tag, then
//       // it should be killed.
//       if (parent.namespaceURI === HTML_NAMESPACE) {
//         return tagName === 'math';
//       } // The only way to switch from SVG to MathML is via
//       // <math> and HTML integration points


//       if (parent.namespaceURI === SVG_NAMESPACE) {
//         return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
//       } // We only allow elements that are defined in MathML
//       // spec. All others are disallowed in MathML namespace.


//       return Boolean(ALL_MATHML_TAGS[tagName]);
//     }

//     if (element.namespaceURI === HTML_NAMESPACE) {
//       // The only way to switch from SVG to HTML is via
//       // HTML integration points, and from MathML to HTML
//       // is via MathML text integration points
//       if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
//         return false;
//       }

//       if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
//         return false;
//       } // We disallow tags that are specific for MathML
//       // or SVG and should never appear in HTML namespace


//       return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
//     } // For XHTML and XML documents that support custom namespaces


//     if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
//       return true;
//     } // The code should never reach this place (this means
//     // that the element somehow got namespace that is not
//     // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
//     // Return false just in case.


//     return false;
//   };
//   /**
//    * _forceRemove
//    *
//    * @param  {Node} node a DOM node
//    */


//   var _forceRemove = function _forceRemove(node) {
//     arrayPush(DOMPurify.removed, {
//       element: node
//     });

//     try {
//       // eslint-disable-next-line unicorn/prefer-dom-node-remove
//       node.parentNode.removeChild(node);
//     } catch (_) {
//       try {
//         node.outerHTML = emptyHTML;
//       } catch (_) {
//         node.remove();
//       }
//     }
//   };
//   /**
//    * _removeAttribute
//    *
//    * @param  {String} name an Attribute name
//    * @param  {Node} node a DOM node
//    */


//   var _removeAttribute = function _removeAttribute(name, node) {
//     try {
//       arrayPush(DOMPurify.removed, {
//         attribute: node.getAttributeNode(name),
//         from: node
//       });
//     } catch (_) {
//       arrayPush(DOMPurify.removed, {
//         attribute: null,
//         from: node
//       });
//     }

//     node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

//     if (name === 'is' && !ALLOWED_ATTR[name]) {
//       if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
//         try {
//           _forceRemove(node);
//         } catch (_) {}
//       } else {
//         try {
//           node.setAttribute(name, '');
//         } catch (_) {}
//       }
//     }
//   };
//   /**
//    * _initDocument
//    *
//    * @param  {String} dirty a string of dirty markup
//    * @return {Document} a DOM, filled with the dirty markup
//    */


//   var _initDocument = function _initDocument(dirty) {
//     /* Create a HTML document */
//     var doc;
//     var leadingWhitespace;

//     if (FORCE_BODY) {
//       dirty = '<remove></remove>' + dirty;
//     } else {
//       /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
//       var matches = stringMatch(dirty, /^[\r\n\t ]+/);
//       leadingWhitespace = matches && matches[0];
//     }

//     if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
//       // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
//       dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
//     }

//     var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
//     /*
//      * Use the DOMParser API by default, fallback later if needs be
//      * DOMParser not work for svg when has multiple root element.
//      */

//     if (NAMESPACE === HTML_NAMESPACE) {
//       try {
//         doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
//       } catch (_) {}
//     }
//     /* Use createHTMLDocument in case DOMParser is not available */


//     if (!doc || !doc.documentElement) {
//       doc = implementation.createDocument(NAMESPACE, 'template', null);

//       try {
//         doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
//       } catch (_) {// Syntax error if dirtyPayload is invalid xml
//       }
//     }

//     var body = doc.body || doc.documentElement;

//     if (dirty && leadingWhitespace) {
//       body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
//     }
//     /* Work on whole document or just its body */


//     if (NAMESPACE === HTML_NAMESPACE) {
//       return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
//     }

//     return WHOLE_DOCUMENT ? doc.documentElement : body;
//   };
//   /**
//    * _createIterator
//    *
//    * @param  {Document} root document/fragment to create iterator for
//    * @return {Iterator} iterator instance
//    */


//   var _createIterator = function _createIterator(root) {
//     return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
//     NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
//   };
//   /**
//    * _isClobbered
//    *
//    * @param  {Node} elm element to check for clobbering attacks
//    * @return {Boolean} true if clobbered, false if safe
//    */


//   var _isClobbered = function _isClobbered(elm) {
//     return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
//   };
//   /**
//    * _isNode
//    *
//    * @param  {Node} obj object to check whether it's a DOM node
//    * @return {Boolean} true is object is a DOM node
//    */


//   var _isNode = function _isNode(object) {
//     return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
//   };
//   /**
//    * _executeHook
//    * Execute user configurable hooks
//    *
//    * @param  {String} entryPoint  Name of the hook's entry point
//    * @param  {Node} currentNode node to work on with the hook
//    * @param  {Object} data additional hook parameters
//    */


//   var _executeHook = function _executeHook(entryPoint, currentNode, data) {
//     if (!hooks[entryPoint]) {
//       return;
//     }

//     arrayForEach(hooks[entryPoint], function (hook) {
//       hook.call(DOMPurify, currentNode, data, CONFIG);
//     });
//   };
//   /**
//    * _sanitizeElements
//    *
//    * @protect nodeName
//    * @protect textContent
//    * @protect removeChild
//    *
//    * @param   {Node} currentNode to check for permission to exist
//    * @return  {Boolean} true if node was killed, false if left alive
//    */


//   var _sanitizeElements = function _sanitizeElements(currentNode) {
//     var content;
//     /* Execute a hook if present */

//     _executeHook('beforeSanitizeElements', currentNode, null);
//     /* Check if element is clobbered or can clobber */


//     if (_isClobbered(currentNode)) {
//       _forceRemove(currentNode);

//       return true;
//     }
//     /* Check if tagname contains Unicode */


//     if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
//       _forceRemove(currentNode);

//       return true;
//     }
//     /* Now let's check the element's type and name */


//     var tagName = transformCaseFunc(currentNode.nodeName);
//     /* Execute a hook if present */

//     _executeHook('uponSanitizeElement', currentNode, {
//       tagName: tagName,
//       allowedTags: ALLOWED_TAGS
//     });
//     /* Detect mXSS attempts abusing namespace confusion */


//     if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
//       _forceRemove(currentNode);

//       return true;
//     }
//     /* Mitigate a problem with templates inside select */


//     if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
//       _forceRemove(currentNode);

//       return true;
//     }
//     /* Remove element if anything forbids its presence */


//     if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
//       /* Check if we have a custom element to handle */
//       if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
//         if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
//         if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
//       }
//       /* Keep content except for bad-listed elements */


//       if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
//         var parentNode = getParentNode(currentNode) || currentNode.parentNode;
//         var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

//         if (childNodes && parentNode) {
//           var childCount = childNodes.length;

//           for (var i = childCount - 1; i >= 0; --i) {
//             parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
//           }
//         }
//       }

//       _forceRemove(currentNode);

//       return true;
//     }
//     /* Check whether element has a valid namespace */


//     if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
//       _forceRemove(currentNode);

//       return true;
//     }
//     /* Make sure that older browsers don't get fallback-tag mXSS */


//     if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
//       _forceRemove(currentNode);

//       return true;
//     }
//     /* Sanitize element content to be template-safe */


//     if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
//       /* Get the element's text content */
//       content = currentNode.textContent;
//       content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
//       content = stringReplace(content, ERB_EXPR$1, ' ');
//       content = stringReplace(content, TMPLIT_EXPR$1, ' ');

//       if (currentNode.textContent !== content) {
//         arrayPush(DOMPurify.removed, {
//           element: currentNode.cloneNode()
//         });
//         currentNode.textContent = content;
//       }
//     }
//     /* Execute a hook if present */


//     _executeHook('afterSanitizeElements', currentNode, null);

//     return false;
//   };
//   /**
//    * _isValidAttribute
//    *
//    * @param  {string} lcTag Lowercase tag name of containing element.
//    * @param  {string} lcName Lowercase attribute name.
//    * @param  {string} value Attribute value.
//    * @return {Boolean} Returns true if `value` is valid, otherwise false.
//    */
//   // eslint-disable-next-line complexity


//   var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
//     /* Make sure attribute cannot clobber */
//     if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
//       return false;
//     }
//     /* Allow valid data-* attributes: At least one character after "-"
//         (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
//         XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
//         We don't need to check the value; it's always URI safe. */


//     if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
//       if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
//       // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
//       // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
//       _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
//       // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
//       lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
//         return false;
//       }
//       /* Check value is safe. First, is attr inert? If so, is safe */

//     } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (value) {
//       return false;
//     } else ;

//     return true;
//   };
//   /**
//    * _basicCustomElementCheck
//    * checks if at least one dash is included in tagName, and it's not the first char
//    * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
//    * @param {string} tagName name of the tag of the node to sanitize
//    */


//   var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
//     return tagName.indexOf('-') > 0;
//   };
//   /**
//    * _sanitizeAttributes
//    *
//    * @protect attributes
//    * @protect nodeName
//    * @protect removeAttribute
//    * @protect setAttribute
//    *
//    * @param  {Node} currentNode to sanitize
//    */


//   var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
//     var attr;
//     var value;
//     var lcName;
//     var l;
//     /* Execute a hook if present */

//     _executeHook('beforeSanitizeAttributes', currentNode, null);

//     var attributes = currentNode.attributes;
//     /* Check if we have attributes; if not we might have a text node */

//     if (!attributes) {
//       return;
//     }

//     var hookEvent = {
//       attrName: '',
//       attrValue: '',
//       keepAttr: true,
//       allowedAttributes: ALLOWED_ATTR
//     };
//     l = attributes.length;
//     /* Go backwards over all attributes; safely remove bad ones */

//     while (l--) {
//       attr = attributes[l];
//       var _attr = attr,
//           name = _attr.name,
//           namespaceURI = _attr.namespaceURI;
//       value = name === 'value' ? attr.value : stringTrim(attr.value);
//       lcName = transformCaseFunc(name);
//       /* Execute a hook if present */

//       hookEvent.attrName = lcName;
//       hookEvent.attrValue = value;
//       hookEvent.keepAttr = true;
//       hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

//       _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

//       value = hookEvent.attrValue;
//       /* Did the hooks approve of the attribute? */

//       if (hookEvent.forceKeepAttr) {
//         continue;
//       }
//       /* Remove attribute */


//       _removeAttribute(name, currentNode);
//       /* Did the hooks approve of the attribute? */


//       if (!hookEvent.keepAttr) {
//         continue;
//       }
//       /* Work around a security issue in jQuery 3.0 */


//       if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
//         _removeAttribute(name, currentNode);

//         continue;
//       }
//       /* Sanitize attribute content to be template-safe */


//       if (SAFE_FOR_TEMPLATES) {
//         value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
//         value = stringReplace(value, ERB_EXPR$1, ' ');
//         value = stringReplace(value, TMPLIT_EXPR$1, ' ');
//       }
//       /* Is `value` valid for this attribute? */


//       var lcTag = transformCaseFunc(currentNode.nodeName);

//       if (!_isValidAttribute(lcTag, lcName, value)) {
//         continue;
//       }
//       /* Full DOM Clobbering protection via namespace isolation,
//        * Prefix id and name attributes with `user-content-`
//        */


//       if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
//         // Remove the attribute with this value
//         _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


//         value = SANITIZE_NAMED_PROPS_PREFIX + value;
//       }
//       /* Handle attributes that require Trusted Types */


//       if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
//         if (namespaceURI) ; else {
//           switch (trustedTypes.getAttributeType(lcTag, lcName)) {
//             case 'TrustedHTML':
//               {
//                 value = trustedTypesPolicy.createHTML(value);
//                 break;
//               }

//             case 'TrustedScriptURL':
//               {
//                 value = trustedTypesPolicy.createScriptURL(value);
//                 break;
//               }
//           }
//         }
//       }
//       /* Handle invalid data-* attribute set by try-catching it */


//       try {
//         if (namespaceURI) {
//           currentNode.setAttributeNS(namespaceURI, name, value);
//         } else {
//           /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
//           currentNode.setAttribute(name, value);
//         }

//         arrayPop(DOMPurify.removed);
//       } catch (_) {}
//     }
//     /* Execute a hook if present */


//     _executeHook('afterSanitizeAttributes', currentNode, null);
//   };
//   /**
//    * _sanitizeShadowDOM
//    *
//    * @param  {DocumentFragment} fragment to iterate over recursively
//    */


//   var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
//     var shadowNode;

//     var shadowIterator = _createIterator(fragment);
//     /* Execute a hook if present */


//     _executeHook('beforeSanitizeShadowDOM', fragment, null);

//     while (shadowNode = shadowIterator.nextNode()) {
//       /* Execute a hook if present */
//       _executeHook('uponSanitizeShadowNode', shadowNode, null);
//       /* Sanitize tags and elements */


//       if (_sanitizeElements(shadowNode)) {
//         continue;
//       }
//       /* Deep shadow DOM detected */


//       if (shadowNode.content instanceof DocumentFragment) {
//         _sanitizeShadowDOM(shadowNode.content);
//       }
//       /* Check attributes, sanitize if necessary */


//       _sanitizeAttributes(shadowNode);
//     }
//     /* Execute a hook if present */


//     _executeHook('afterSanitizeShadowDOM', fragment, null);
//   };
//   /**
//    * Sanitize
//    * Public method providing core sanitation functionality
//    *
//    * @param {String|Node} dirty string or DOM node
//    * @param {Object} configuration object
//    */
//   // eslint-disable-next-line complexity


//   DOMPurify.sanitize = function (dirty) {
//     var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
//     var body;
//     var importedNode;
//     var currentNode;
//     var oldNode;
//     var returnNode;
//     /* Make sure we have a string to sanitize.
//       DO NOT return early, as this will return the wrong type if
//       the user has requested a DOM object rather than a string */

//     IS_EMPTY_INPUT = !dirty;

//     if (IS_EMPTY_INPUT) {
//       dirty = '<!-->';
//     }
//     /* Stringify, in case dirty is an object */


//     if (typeof dirty !== 'string' && !_isNode(dirty)) {
//       if (typeof dirty.toString === 'function') {
//         dirty = dirty.toString();

//         if (typeof dirty !== 'string') {
//           throw typeErrorCreate('dirty is not a string, aborting');
//         }
//       } else {
//         throw typeErrorCreate('toString is not a function');
//       }
//     }
//     /* Check we can run. Otherwise fall back or ignore */


//     if (!DOMPurify.isSupported) {
//       if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
//         if (typeof dirty === 'string') {
//           return window.toStaticHTML(dirty);
//         }

//         if (_isNode(dirty)) {
//           return window.toStaticHTML(dirty.outerHTML);
//         }
//       }

//       return dirty;
//     }
//     /* Assign config vars */


//     if (!SET_CONFIG) {
//       _parseConfig(cfg);
//     }
//     /* Clean up removed elements */


//     DOMPurify.removed = [];
//     /* Check if dirty is correctly typed for IN_PLACE */

//     if (typeof dirty === 'string') {
//       IN_PLACE = false;
//     }

//     if (IN_PLACE) {
//       /* Do some early pre-sanitization to avoid unsafe root nodes */
//       if (dirty.nodeName) {
//         var tagName = transformCaseFunc(dirty.nodeName);

//         if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
//           throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
//         }
//       }
//     } else if (dirty instanceof Node) {
//       /* If dirty is a DOM element, append to an empty document to avoid
//          elements being stripped by the parser */
//       body = _initDocument('<!---->');
//       importedNode = body.ownerDocument.importNode(dirty, true);

//       if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
//         /* Node is already a body, use as is */
//         body = importedNode;
//       } else if (importedNode.nodeName === 'HTML') {
//         body = importedNode;
//       } else {
//         // eslint-disable-next-line unicorn/prefer-dom-node-append
//         body.appendChild(importedNode);
//       }
//     } else {
//       /* Exit directly if we have nothing to do */
//       if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
//       dirty.indexOf('<') === -1) {
//         return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
//       }
//       /* Initialize the document to work on */


//       body = _initDocument(dirty);
//       /* Check we have a DOM node from the data */

//       if (!body) {
//         return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
//       }
//     }
//     /* Remove first element node (ours) if FORCE_BODY is set */


//     if (body && FORCE_BODY) {
//       _forceRemove(body.firstChild);
//     }
//     /* Get node iterator */


//     var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
//     /* Now start iterating over the created document */


//     while (currentNode = nodeIterator.nextNode()) {
//       /* Fix IE's strange behavior with manipulated textNodes #89 */
//       if (currentNode.nodeType === 3 && currentNode === oldNode) {
//         continue;
//       }
//       /* Sanitize tags and elements */


//       if (_sanitizeElements(currentNode)) {
//         continue;
//       }
//       /* Shadow DOM detected, sanitize it */


//       if (currentNode.content instanceof DocumentFragment) {
//         _sanitizeShadowDOM(currentNode.content);
//       }
//       /* Check attributes, sanitize if necessary */


//       _sanitizeAttributes(currentNode);

//       oldNode = currentNode;
//     }

//     oldNode = null;
//     /* If we sanitized `dirty` in-place, return it. */

//     if (IN_PLACE) {
//       return dirty;
//     }
//     /* Return sanitized string or DOM */


//     if (RETURN_DOM) {
//       if (RETURN_DOM_FRAGMENT) {
//         returnNode = createDocumentFragment.call(body.ownerDocument);

//         while (body.firstChild) {
//           // eslint-disable-next-line unicorn/prefer-dom-node-append
//           returnNode.appendChild(body.firstChild);
//         }
//       } else {
//         returnNode = body;
//       }

//       if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
//         /*
//           AdoptNode() is not used because internal state is not reset
//           (e.g. the past names map of a HTMLFormElement), this is safe
//           in theory but we would rather not risk another attack vector.
//           The state that is cloned by importNode() is explicitly defined
//           by the specs.
//         */
//         returnNode = importNode.call(originalDocument, returnNode, true);
//       }

//       return returnNode;
//     }

//     var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
//     /* Serialize doctype if allowed */

//     if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
//       serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
//     }
//     /* Sanitize final string template-safe */


//     if (SAFE_FOR_TEMPLATES) {
//       serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
//       serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
//       serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, ' ');
//     }

//     return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
//   };
//   /**
//    * Public method to set the configuration once
//    * setConfig
//    *
//    * @param {Object} cfg configuration object
//    */


//   DOMPurify.setConfig = function (cfg) {
//     _parseConfig(cfg);

//     SET_CONFIG = true;
//   };
//   /**
//    * Public method to remove the configuration
//    * clearConfig
//    *
//    */


//   DOMPurify.clearConfig = function () {
//     CONFIG = null;
//     SET_CONFIG = false;
//   };
//   /**
//    * Public method to check if an attribute value is valid.
//    * Uses last set config, if any. Otherwise, uses config defaults.
//    * isValidAttribute
//    *
//    * @param  {string} tag Tag name of containing element.
//    * @param  {string} attr Attribute name.
//    * @param  {string} value Attribute value.
//    * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
//    */


//   DOMPurify.isValidAttribute = function (tag, attr, value) {
//     /* Initialize shared config vars if necessary. */
//     if (!CONFIG) {
//       _parseConfig({});
//     }

//     var lcTag = transformCaseFunc(tag);
//     var lcName = transformCaseFunc(attr);
//     return _isValidAttribute(lcTag, lcName, value);
//   };
//   /**
//    * AddHook
//    * Public method to add DOMPurify hooks
//    *
//    * @param {String} entryPoint entry point for the hook to add
//    * @param {Function} hookFunction function to execute
//    */


//   DOMPurify.addHook = function (entryPoint, hookFunction) {
//     if (typeof hookFunction !== 'function') {
//       return;
//     }

//     hooks[entryPoint] = hooks[entryPoint] || [];
//     arrayPush(hooks[entryPoint], hookFunction);
//   };
//   /**
//    * RemoveHook
//    * Public method to remove a DOMPurify hook at a given entryPoint
//    * (pops it from the stack of hooks if more are present)
//    *
//    * @param {String} entryPoint entry point for the hook to remove
//    * @return {Function} removed(popped) hook
//    */


//   DOMPurify.removeHook = function (entryPoint) {
//     if (hooks[entryPoint]) {
//       return arrayPop(hooks[entryPoint]);
//     }
//   };
//   /**
//    * RemoveHooks
//    * Public method to remove all DOMPurify hooks at a given entryPoint
//    *
//    * @param  {String} entryPoint entry point for the hooks to remove
//    */


//   DOMPurify.removeHooks = function (entryPoint) {
//     if (hooks[entryPoint]) {
//       hooks[entryPoint] = [];
//     }
//   };
//   /**
//    * RemoveAllHooks
//    * Public method to remove all DOMPurify hooks
//    *
//    */


//   DOMPurify.removeAllHooks = function () {
//     hooks = {};
//   };

//   return DOMPurify;
// }

// var purify = createDOMPurify();

// var _templateObject$5, _templateObject2$5, _templateObject3$4;
// var Label$4 = styled(FormLabel)(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral$1(["\n  margin-top: 0.625rem;\n"])));
// var HintLabel$3 = styled(Label$4)(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// var AnswerDiv$4 = styled.div(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteral$1(["\n  margin-top: 0.938rem;\n"])));

// /**
//  * MatchingItems component is a Question type which consists of table to add at least 2 options to be matched together.
//  *
//  */
// var MatchingItems = function MatchingItems(_ref) {
//   var translations = _ref.translations,
//     onAnother = _ref.onAnother,
//     onDone = _ref.onDone,
//     onCancel = _ref.onCancel,
//     editData = _ref.editData,
//     isEdit = _ref.isEdit,
//     translationMode = _ref.translationMode,
//     disableAction = _ref.disableAction;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     questionCode = _useState2[0],
//     setQuestionCode = _useState2[1];
//   var _useState3 = useState$1(''),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     question = _useState4[0],
//     setQuestion = _useState4[1];
//   var _useState5 = useState$1(''),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     questionFeedback = _useState6[0],
//     setQuestionFeedback = _useState6[1];
//   var _useState7 = useState$1(''),
//     _useState8 = _slicedToArray$b(_useState7, 2),
//     leftOption = _useState8[0],
//     setLeftOption = _useState8[1];
//   var _useState9 = useState$1(''),
//     _useState10 = _slicedToArray$b(_useState9, 2),
//     rightOption = _useState10[0],
//     setRightOption = _useState10[1];
//   var _useState11 = useState$1(),
//     _useState12 = _slicedToArray$b(_useState11, 2),
//     leftOptionEditor = _useState12[0],
//     setLeftOptionEditor = _useState12[1];
//   var _useState13 = useState$1(),
//     _useState14 = _slicedToArray$b(_useState13, 2),
//     rightOptionEditor = _useState14[0],
//     setRightOptionEditor = _useState14[1];
//   var _useState15 = useState$1(''),
//     _useState16 = _slicedToArray$b(_useState15, 2),
//     optionFeedback = _useState16[0],
//     setOptionFeedback = _useState16[1];
//   var _useState17 = useState$1(),
//     _useState18 = _slicedToArray$b(_useState17, 2),
//     optionFeedbackEditor = _useState18[0],
//     setOptionFeedbackEditor = _useState18[1];
//   var _useState19 = useState$1([]),
//     _useState20 = _slicedToArray$b(_useState19, 2),
//     setRows = _useState20[1];
//   var _useState21 = useState$1([]),
//     _useState22 = _slicedToArray$b(_useState21, 2),
//     data = _useState22[0],
//     setData = _useState22[1];
//   var _useState23 = useState$1(false),
//     _useState24 = _slicedToArray$b(_useState23, 2),
//     setLeftOptionValidation = _useState24[1];
//   var _useState25 = useState$1(false),
//     _useState26 = _slicedToArray$b(_useState25, 2),
//     setRightOptionValidation = _useState26[1];
//   var _useState27 = useState$1(true),
//     _useState28 = _slicedToArray$b(_useState27, 2),
//     buttonDisable = _useState28[0],
//     setButtonDisable = _useState28[1];
//   var _useState29 = useState$1(true),
//     _useState30 = _slicedToArray$b(_useState29, 2),
//     buttonUpdateDisable = _useState30[0],
//     setButtonUpdateDisable = _useState30[1];
//   var _useState31 = useState$1(''),
//     _useState32 = _slicedToArray$b(_useState31, 2),
//     currentID = _useState32[0],
//     setCurrentID = _useState32[1];
//   var _useState33 = useState$1(''),
//     _useState34 = _slicedToArray$b(_useState33, 2),
//     alertData = _useState34[0],
//     setAlertData = _useState34[1];
//   var _useState35 = useState$1(false),
//     _useState36 = _slicedToArray$b(_useState35, 2),
//     isDataAddDelete = _useState36[0],
//     setDataAddDelete = _useState36[1];

//   // Refs to store CKEditor instances
//   var setLeftOptionEditorRef = useRef$2(null);
//   var setRightOptionEditorRef = useRef$2(null);
//   var setOptionFeedbackEditorRef = useRef$2(null);

//   // Function to show the alert
//   var showAlert = function showAlert(alertInfo) {
//     setAlertData(alertInfo);
//     window.scrollTo(0, 0);
//   };
//   var hideAlert = function hideAlert() {
//     setAlertData(null);
//   };
//   var questionCodeChange = function questionCodeChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionCode(value);
//     }
//   };
//   var questionChange = function questionChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestion(value);
//       disableHandler(value);
//     }
//   };
//   var questionFeedbackChange = function questionFeedbackChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionFeedback(value);
//     }
//   };
//   var leftOptionChange = function leftOptionChange(event) {
//     if (event !== undefined) {
//       setLeftOptionValidation(false);
//       setLeftOption(event.editor.getData());
//       setLeftOptionEditor(event);
//     }
//   };
//   var rightOptionChange = function rightOptionChange(event) {
//     if (event !== undefined) {
//       setRightOptionValidation(false);
//       setRightOption(event.editor.getData());
//       setRightOptionEditor(event);
//     }
//   };
//   var optionFeedbackChange = function optionFeedbackChange(event) {
//     if (event !== undefined) {
//       setOptionFeedback(event.editor.getData());
//       setOptionFeedbackEditor(event);
//     }
//   };
//   var disableHandler = function disableHandler(questionLength) {
//     if (data.length < 2 || questionLength === 0) {
//       setButtonDisable(true);
//     } else {
//       setButtonDisable(false);
//     }
//   };
//   var addRow = function addRow() {
//     var validationFailed = false;
//     var maxId = 0;
//     if ((leftOption === '' || leftOption === null || leftOption === undefined) && (rightOption === '' || rightOption === null || rightOption === undefined)) {
//       setLeftOptionValidation(true);
//       setRightOptionValidation(true);
//       validationFailed = true;
//       showAlert({
//         severity: 'error',
//         timeOut: 5000,
//         onClose: hideAlert,
//         children: translations.VALIDATE_CHOICES
//       });
//     }
//     var idValues = data.map(function (option) {
//       return option.id;
//     });
//     // Get the maximum id value
//     if (idValues.length > 0) {
//       maxId = Math.max.apply(Math, _toConsumableArray$d(idValues));
//     }
//     if (!validationFailed) {
//       if (sanitizeOption(leftOption.trim()) !== '' && sanitizeOption(rightOption.trim()) !== '') {
//         if (data.length === 0) {
//           data.push({
//             id: 1,
//             // Assuming this is the first option, we start with id: 1
//             leftOption: leftOption,
//             rightOption: rightOption,
//             score: 0,
//             shuffle: true,
//             // shuffle value is always true for matching items
//             feedback: optionFeedback
//           });
//         } else {
//           data.push({
//             id: maxId + 1,
//             // avoid duplicate id values by incrementing the maximum id of the collection
//             leftOption: leftOption,
//             rightOption: rightOption,
//             score: 0,
//             shuffle: true,
//             feedback: optionFeedback
//           });
//         }
//         if ((leftOptionEditor === null || leftOptionEditor === void 0 ? void 0 : leftOptionEditor.editor) !== undefined) {
//           leftOptionEditor.editor.setData('');
//         }
//         if ((rightOptionEditor === null || rightOptionEditor === void 0 ? void 0 : rightOptionEditor.editor) !== undefined) {
//           rightOptionEditor.editor.setData('');
//         }
//         if ((optionFeedbackEditor === null || optionFeedbackEditor === void 0 ? void 0 : optionFeedbackEditor.editor) !== undefined) {
//           optionFeedbackEditor === null || optionFeedbackEditor === void 0 || optionFeedbackEditor.editor.setData('');
//         }
//         setOptionFeedback('');
//         setLeftOption('');
//         setRightOption('');
//         setDataAddDelete(true);
//       } else {
//         // Show an alert if either leftOption or rightOption is empty
//         showAlert({
//           severity: 'error',
//           timeOut: 5000,
//           onClose: hideAlert,
//           children: translations.VALIDATE_CHOICES
//         });
//       }
//     }
//     setRows([]);
//     disableHandler(question === null || question === void 0 ? void 0 : question.length);
//   };
//   var reset = function reset() {
//     if ((leftOptionEditor === null || leftOptionEditor === void 0 ? void 0 : leftOptionEditor.editor) !== undefined) {
//       leftOptionEditor.editor.setData('');
//     }
//     if ((rightOptionEditor === null || rightOptionEditor === void 0 ? void 0 : rightOptionEditor.editor) !== undefined) {
//       rightOptionEditor.editor.setData('');
//     }
//     if ((optionFeedbackEditor === null || optionFeedbackEditor === void 0 ? void 0 : optionFeedbackEditor.editor) !== undefined) {
//       optionFeedbackEditor === null || optionFeedbackEditor === void 0 || optionFeedbackEditor.editor.setData('');
//     }
//     setData([]);
//     setOptionFeedback('');
//     setLeftOption('');
//     setRightOption('');
//     setCurrentID('');
//     setButtonUpdateDisable(true);
//     setRows([]);
//     disableHandler(question.length);
//   };
//   var updateItem = function updateItem() {
//     var validationFailed = false;
//     if ((leftOption === '' || leftOption === null || leftOption === undefined) && (rightOption === '' || rightOption === null || rightOption === undefined)) {
//       setLeftOptionValidation(true);
//       setRightOptionValidation(true);
//       validationFailed = true;
//     }
//     if (!validationFailed) {
//       if (currentID !== null && currentID !== '' && currentID !== undefined) {
//         data.forEach(function (f) {
//           var element = f;
//           if (f.id === currentID) {
//             element.leftOption = leftOption;
//             element.rightOption = rightOption;
//             element.feedback = optionFeedback;
//           }
//         });
//         if ((leftOptionEditor === null || leftOptionEditor === void 0 ? void 0 : leftOptionEditor.editor) !== undefined) {
//           leftOptionEditor.editor.setData('');
//         }
//         if ((rightOptionEditor === null || rightOptionEditor === void 0 ? void 0 : rightOptionEditor.editor) !== undefined) {
//           rightOptionEditor.editor.setData('');
//         }
//         if ((optionFeedbackEditor === null || optionFeedbackEditor === void 0 ? void 0 : optionFeedbackEditor.editor) !== undefined) {
//           optionFeedbackEditor === null || optionFeedbackEditor === void 0 || optionFeedbackEditor.editor.setData('');
//         }
//         setOptionFeedback('');
//         setLeftOption('');
//         setRightOption('');
//         setCurrentID('');
//         setButtonUpdateDisable(true);
//       }
//     }
//     setRows([]);
//   };
//   var selectItem = function selectItem(ID) {
//     if (ID !== null && ID !== '' && ID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         if (f.id === ID) {
//           if ((leftOptionEditor === null || leftOptionEditor === void 0 ? void 0 : leftOptionEditor.editor) !== undefined) {
//             var _leftOptionEditor$edi;
//             leftOptionEditor === null || leftOptionEditor === void 0 || (_leftOptionEditor$edi = leftOptionEditor.editor) === null || _leftOptionEditor$edi === void 0 || _leftOptionEditor$edi.setData(element.leftOption);
//           }
//           if ((rightOptionEditor === null || rightOptionEditor === void 0 ? void 0 : rightOptionEditor.editor) !== undefined) {
//             var _rightOptionEditor$ed;
//             rightOptionEditor === null || rightOptionEditor === void 0 || (_rightOptionEditor$ed = rightOptionEditor.editor) === null || _rightOptionEditor$ed === void 0 || _rightOptionEditor$ed.setData(element.rightOption);
//           }
//           if ((optionFeedbackEditor === null || optionFeedbackEditor === void 0 ? void 0 : optionFeedbackEditor.editor) !== undefined) {
//             var _optionFeedbackEditor;
//             optionFeedbackEditor === null || optionFeedbackEditor === void 0 || (_optionFeedbackEditor = optionFeedbackEditor.editor) === null || _optionFeedbackEditor === void 0 || _optionFeedbackEditor.setData(element.feedback);
//           }
//           setOptionFeedback(element.feedback);
//           setLeftOption(element.leftOption);
//           setRightOption(element.rightOption);
//         }
//       });
//       setCurrentID(ID);
//       setButtonUpdateDisable(false);
//     }
//     setRows([]);
//   };
//   var deleteItem = function deleteItem(ID) {
//     if (ID !== null && ID !== '' && ID !== undefined) {
//       setData(data.filter(function (x) {
//         return x.id !== ID;
//       }));
//       setDataAddDelete(true);
//     }
//     if (data.length <= 2) {
//       setButtonDisable(true); // disable done and another button if there are less than 2 options after deletion.
//     }
//     setRows([]);
//   };
//   useEffect$2(function () {
//     if (editData && isEdit) {
//       setQuestionCode(editData.Code);
//       setQuestion(editData.QuestionText);
//       setQuestionFeedback(editData.QuestionFeedback);
//       data.length = 0;
//       if (editData.Options && editData.Options.length !== 0) {
//         editData.Options.forEach(function (value) {
//           data.push({
//             id: value.AnswerID[0],
//             leftOption: value.AnswerText[0],
//             rightOption: value.MatchAnswerText,
//             score: value.WeightPercent,
//             shuffle: value.Shuffle,
//             feedback: value.Feedback
//           });
//         });
//         // disableHandler(question.length);
//         setButtonDisable(false);
//       }
//       if ((leftOptionEditor === null || leftOptionEditor === void 0 ? void 0 : leftOptionEditor.editor) !== undefined) {
//         leftOptionEditor.editor.setData('');
//       }
//       if ((rightOptionEditor === null || rightOptionEditor === void 0 ? void 0 : rightOptionEditor.editor) !== undefined) {
//         rightOptionEditor.editor.setData('');
//       }
//       if ((optionFeedbackEditor === null || optionFeedbackEditor === void 0 ? void 0 : optionFeedbackEditor.editor) !== undefined) {
//         optionFeedbackEditor === null || optionFeedbackEditor === void 0 || optionFeedbackEditor.editor.setData('');
//       }
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [editData]);
//   var buildQuestionObject = function buildQuestionObject() {
//     var questionObject = {
//       Code: questionCode,
//       QuestionText: question,
//       QuestionTextFmt: question,
//       QuestionType: null,
//       QuestionFeedback: questionFeedback,
//       Options: [],
//       Status: null,
//       optionAddDelete: false
//     };
//     data.forEach(function (element) {
//       questionObject.Options.push({
//         AnswerID: [element.id.toString()],
//         WeightPercent: element.score,
//         AnswerText: [element.leftOption],
//         MatchAnswerID: element.id.toString(),
//         MatchAnswerText: element.rightOption,
//         Feedback: element.feedback,
//         Shuffle: element.shuffle,
//         IsCaseSensitive: false,
//         QuestionBankType: null
//       });
//     });
//     return questionObject;
//   };
//   var doneClick = function doneClick() {
//     var requestObj = buildQuestionObject();
//     if (ValidateWeightPercent(requestObj)) {
//       requestObj.optionAddDelete = isDataAddDelete;
//       onDone(requestObj);
//       // Reset the flag after passing it to the parent
//       setDataAddDelete(false);
//     }
//   };
//   var anotherClick = function anotherClick() {
//     var requestObj = buildQuestionObject();
//     if (ValidateWeightPercent(requestObj)) {
//       requestObj.optionAddDelete = isDataAddDelete;
//       onAnother(requestObj);
//       setDataAddDelete(false);
//     }
//   };
//   var ValidateWeightPercent = function ValidateWeightPercent(questionObject) {
//     var totalWeightPercent = 0;
//     var hasInvalidWeight = false;
//     // Removing correct option check as all the options for mathcing items should have weight ref STS-43156
//     questionObject.Options.forEach(function (element) {
//       if (element.WeightPercent !== null && element.WeightPercent !== '' && element.WeightPercent > 0) {
//         if (!isNaN(parseFloat(element.WeightPercent))) {
//           totalWeightPercent += parseFloat(element.WeightPercent);
//         }
//       } else {
//         hasInvalidWeight = true; // Set the flag if any option has invalid weight
//       }
//     });
//     if (totalWeightPercent < 100 || hasInvalidWeight) {
//       showAlert({
//         severity: 'error',
//         timeOut: 5000,
//         onClose: hideAlert,
//         children: translations.VALIDATE_WEIGHTPERCENT
//       });
//       return false;
//     }
//     return true;
//   };
//   var cancelClick = function cancelClick() {
//     onCancel();
//   };
//   var setScore = function setScore(event, id) {
//     if (event !== null && id !== null) {
//       data.forEach(function (f) {
//         var element = f;
//         if (element.id === id) {
//           element.score = Math.round(event.target.value);
//         }
//       });
//     }
//     setRows([]);
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Alert, {
//     open: !!alertData,
//     onClose: hideAlert,
//     severity: alertData === null || alertData === void 0 ? void 0 : alertData.severity,
//     timeOut: alertData === null || alertData === void 0 ? void 0 : alertData.timeOut
//   }, alertData === null || alertData === void 0 ? void 0 : alertData.children), /*#__PURE__*/React__default.createElement(QuestionFeedback, {
//     codeLabel: translations.CODE_LABEL,
//     questionLabel: translations.QUESTION_LABEL,
//     questionMaximumLabel: translations.QUESTION_MAX_LABEL,
//     questionFeedbackLabel: translations.QUESTION_FEEDBACK_LABEL,
//     onCodeChange: questionCodeChange,
//     onQuestionChange: questionChange,
//     onFeedbackChange: questionFeedbackChange,
//     editData: editData,
//     translationMode: translationMode
//   }), /*#__PURE__*/React__default.createElement(AnswerDiv$4, {
//     id: "answer-feedback"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.ANSWER_LABEL), /*#__PURE__*/React__default.createElement(HintLabel$3, {
//     item: true
//   }, translations.MULTIPLE_CHOICES_LABEL))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(BasicTableContainer, null, /*#__PURE__*/React__default.createElement(BasicTable, null, /*#__PURE__*/React__default.createElement(BasicTableHead, null, /*#__PURE__*/React__default.createElement(BasicTableRow, null, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.OPTION_LEFT_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.OPTION_RIGHT_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.SCORE_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.ACTIONS_LABEL)))), /*#__PURE__*/React__default.createElement(BasicTableBody, null, data.map(function (d) {
//     return /*#__PURE__*/React__default.createElement(BasicTableRow, {
//       key: d.id
//     }, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.leftOption)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.rightOption)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("input", {
//       type: "number",
//       step: "1",
//       id: "scoreField",
//       disabled: translationMode,
//       value: d.score !== null ? d.score : '',
//       onChange: function onChange(event) {
//         return setScore(event, d.id);
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.feedback)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(IconButton, {
//       color: "primary",
//       label: translations.SELECT_LABEL,
//       id: "select-question",
//       onClick: function onClick(e) {
//         selectItem(d.id);
//       }
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Edit"
//     })), /*#__PURE__*/React__default.createElement(IconButton, {
//       color: "primary",
//       label: translations.DELETE_LABEL.toLowerCase(),
//       id: "delete-question",
//       disabled: translationMode,
//       onClick: function onClick(e) {
//         deleteItem(d.id);
//       }
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Delete"
//     }))));
//   })))))), /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between",
//     spacing: 10
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     alignItems: "center",
//     container: true,
//     direction: "column"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.OPTIONS_LEFT_LABEL)))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     alignItems: "center",
//     container: true,
//     direction: "column",
//     wrap: "nowrap"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "add-question",
//     disabled: translationMode,
//     onClick: function onClick() {
//       return addRow();
//     }
//   }, translations.ADD_LABEL)))))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "option-left",
//     onChange: function onChange(event) {
//       return leftOptionChange(event);
//     },
//     onReady: function onReady(editor) {
//       setLeftOptionEditor(editor);
//       setLeftOptionEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.OPTIONS_RIGHT_LABEL))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "option-right",
//     onChange: function onChange(event) {
//       return rightOptionChange(event);
//     },
//     onReady: function onReady(editor) {
//       setRightOptionEditor(editor);
//       setRightOptionEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label$4, {
//     item: true
//   }, translations.OPTION_FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "option-feedback",
//     onChange: function onChange(event) {
//       return optionFeedbackChange(event);
//     },
//     onReady: function onReady(editor) {
//       setOptionFeedbackEditor(editor);
//       setOptionFeedbackEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$4, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "update",
//     disabled: buttonUpdateDisable,
//     onClick: function onClick() {
//       return updateItem();
//     }
//   }, translations.UPDATE_LABEL), "\xA0", !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "reset",
//     onClick: function onClick() {
//       return reset();
//     }
//   }, translations.RESET_LABEL))))))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$4, null, !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "another",
//     disabled: buttonDisable,
//     onClick: anotherClick
//   }, translations.ANOTHER_LABEL)), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "done",
//     disabled: buttonDisable || disableAction,
//     onClick: doneClick
//   }, translations.DONE_LABEL), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "cancel",
//     onClick: cancelClick
//   }, translations.CANCEL_LABEL))));
// };
// var optionsPropTypes$3 = {
//   AnswerID: PropTypes__default.arrayOf(PropTypes__default.string),
//   AnswerText: PropTypes__default.arrayOf(PropTypes__default.string),
//   Feedback: PropTypes__default.string,
//   MatchAnswerText: PropTypes__default.string,
//   WeightPercent: PropTypes__default.string,
//   IsCorrect: PropTypes__default.bool,
//   IsCaseSensitive: PropTypes__default.bool,
//   Shuffle: PropTypes__default.bool
// };
// var editDataPropTypes$3 = {
//   QuestionType: PropTypes__default.number,
//   Code: PropTypes__default.string,
//   QuestionText: PropTypes__default.string,
//   QuestionFeedback: PropTypes__default.string,
//   Options: PropTypes__default.arrayOf(PropTypes__default.shape(optionsPropTypes$3))
// };
// MatchingItems.propTypes = {
//   /**
//    * isEdit defines that it is Edit mode
//    */
//   isEdit: PropTypes__default.bool,
//   /**
//    * editData contains all data for edit
//    */
//   editData: PropTypes__default.shape(editDataPropTypes$3),
//   /**
//    * onDone callback function to pass request object
//    */
//   onDone: PropTypes__default.func.isRequired,
//   /**
//    * onAnother callback function to pass request object
//    */
//   onAnother: PropTypes__default.func.isRequired,
//   /**
//    * onCancel callback function
//    */
//   onCancel: PropTypes__default.func.isRequired,
//   /**
//    * translations contains all string translations for MatchingItems
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    *   Action type translate based on this prop value disabling some of the input fields
//    *   which should not editable while adding the translated question from the base question
//    */
//   translationMode: PropTypes__default.bool,
//   /**
//    * Disables done button if language dropdown has value '-1'
//    */
//   disableAction: PropTypes__default.bool
// };
// MatchingItems.defaultProps = {
//   translations: {
//     CODE_LABEL: 'Question Code:',
//     QUESTION_LABEL: 'Question: *',
//     QUESTION_MAX_LABEL: 'Question maximum: 4000 characters',
//     QUESTION_FEEDBACK_LABEL: 'Question Feedback:',
//     ANSWER_LABEL: 'Answer: *',
//     MULTIPLE_CHOICES_LABEL: 'Note : Add at least 2 choices.',
//     OPTIONS_LEFT_LABEL: 'Options on the left',
//     OPTIONS_RIGHT_LABEL: 'Options on the right',
//     OPTION_LEFT_LABEL: 'Option on the left: *',
//     OPTION_RIGHT_LABEL: 'Option on the right: *',
//     SCORE_LABEL: 'Score (%)',
//     FEEDBACK_LABEL: 'Feedback',
//     ADD_LABEL: 'ADD',
//     DELETE_LABEL: 'DELETE',
//     ACTIONS_LABEL: 'Actions',
//     SELECT_LABEL: 'Select',
//     OPTION_FEEDBACK_LABEL: 'Option Feedback:',
//     UPDATE_LABEL: 'UPDATE',
//     RESET_LABEL: 'RESET',
//     ANOTHER_LABEL: 'ADD ANOTHER QUESTION',
//     DONE_LABEL: 'DONE',
//     CANCEL_LABEL: 'CANCEL',
//     VALIDATE_CHOICES: 'Enter your choices below and click Add.',
//     VALIDATE_WEIGHTPERCENT: 'Score of each correct choice must be more than 0. The total score must be at least 100%.'
//   },
//   isEdit: false,
//   editData: undefined,
//   translationMode: false,
//   disableAction: false
// };

// var _templateObject$4, _templateObject2$4, _templateObject3$3;
// var Label$3 = styled(FormLabel)(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral$1(["\n  margin-top: 0.625rem;\n"])));
// var HintLabel$2 = styled(Label$3)(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// var AnswerDiv$3 = styled.div(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteral$1(["\n  margin-top: 0.938rem;\n"])));

// /**
//  * MultipleChoice component used in Question types consists of table to add rows for user to select a correct answer.
//  *
//  */
// var MultipleChoice = function MultipleChoice(_ref) {
//   var translations = _ref.translations,
//     onAnother = _ref.onAnother,
//     onDone = _ref.onDone,
//     onCancel = _ref.onCancel,
//     editData = _ref.editData,
//     isEdit = _ref.isEdit,
//     translationMode = _ref.translationMode,
//     disableAction = _ref.disableAction;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     questionCode = _useState2[0],
//     setQuestionCode = _useState2[1];
//   var _useState3 = useState$1(''),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     question = _useState4[0],
//     setQuestion = _useState4[1];
//   var _useState5 = useState$1(''),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     questionFeedback = _useState6[0],
//     setQuestionFeedback = _useState6[1];
//   var _useState7 = useState$1(''),
//     _useState8 = _slicedToArray$b(_useState7, 2),
//     choice = _useState8[0],
//     setChoice = _useState8[1];
//   var _useState9 = useState$1(),
//     _useState10 = _slicedToArray$b(_useState9, 2),
//     choiceEditor = _useState10[0],
//     setChoiceEditor = _useState10[1];
//   var _useState11 = useState$1(''),
//     _useState12 = _slicedToArray$b(_useState11, 2),
//     choiceFeedback = _useState12[0],
//     setChoiceFeedback = _useState12[1];
//   var _useState13 = useState$1(''),
//     _useState14 = _slicedToArray$b(_useState13, 2),
//     currentID = _useState14[0],
//     setCurrentID = _useState14[1];
//   var _useState15 = useState$1(),
//     _useState16 = _slicedToArray$b(_useState15, 2),
//     choiceFeedbackEditor = _useState16[0],
//     setChoiceFeedbackEditor = _useState16[1];
//   var _useState17 = useState$1(false),
//     _useState18 = _slicedToArray$b(_useState17, 2),
//     notRandomizeChoices = _useState18[0],
//     setNotRandomizeChoices = _useState18[1];
//   var _useState19 = useState$1([]),
//     _useState20 = _slicedToArray$b(_useState19, 2),
//     setRows = _useState20[1];
//   var _useState21 = useState$1([]),
//     _useState22 = _slicedToArray$b(_useState21, 2),
//     data = _useState22[0],
//     setData = _useState22[1];
//   var _useState23 = useState$1(false),
//     _useState24 = _slicedToArray$b(_useState23, 2),
//     setChoiceValidation = _useState24[1];
//   var _useState25 = useState$1(true),
//     _useState26 = _slicedToArray$b(_useState25, 2),
//     buttonDisable = _useState26[0],
//     setButtonDisable = _useState26[1];
//   var _useState27 = useState$1(true),
//     _useState28 = _slicedToArray$b(_useState27, 2),
//     buttonUpdateDisable = _useState28[0],
//     setButtonUpdateDisable = _useState28[1];
//   var _useState29 = useState$1(''),
//     _useState30 = _slicedToArray$b(_useState29, 2),
//     alertData = _useState30[0],
//     setAlertData = _useState30[1];
//   var _useState31 = useState$1(false),
//     _useState32 = _slicedToArray$b(_useState31, 2),
//     isDataAddDelete = _useState32[0],
//     setDataAddDelete = _useState32[1];

//   // Refs to store CKEditor instances
//   var choiceEditorRef = useRef$2(null);
//   var choiceFeedbackEditorRef = useRef$2(null);
//   var questionCodeChange = function questionCodeChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionCode(value);
//     }
//   };
//   var questionChange = function questionChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestion(value);
//       disableHandler(value === null || value === void 0 ? void 0 : value.length);
//     }
//   };
//   // Function to show the alert
//   var showAlert = function showAlert(alertInfo) {
//     setAlertData(alertInfo);
//     window.scrollTo(0, 0);
//   };
//   var hideAlert = function hideAlert() {
//     setAlertData(null);
//   };
//   var questionFeedbackChange = function questionFeedbackChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionFeedback(value);
//     }
//   };
//   var choiceChange = function choiceChange(event) {
//     if (event !== undefined) {
//       setChoiceValidation(false);
//       setChoice(event.editor.getData());
//       setChoiceEditor(event);
//     }
//   };
//   var choiceFeedbackChange = function choiceFeedbackChange(event) {
//     if (event !== undefined) {
//       setChoiceFeedback(event.editor.getData());
//       setChoiceFeedbackEditor(event);
//     }
//   };
//   var handleRandomizeChange = function handleRandomizeChange(event) {
//     setNotRandomizeChoices(event.target.checked);
//   };
//   var setCorrectItem = function setCorrectItem(dataID) {
//     if (dataID !== null && dataID !== '' && dataID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         element.correct = f.id === dataID;
//       });
//     }
//     setRows([]);
//   };
//   var disableHandler = function disableHandler(questionLength) {
//     if (data.length < 3 || questionLength === 0) {
//       setButtonDisable(true);
//     } else {
//       setButtonDisable(false);
//     }
//   };
//   var addRow = function addRow() {
//     var validationFailed = false;
//     var maxId = 0;
//     if (sanitizeOption(choice.trim()) === '' || sanitizeOption(choice.trim()) === null || sanitizeOption(choice.trim()) === undefined) {
//       setChoiceValidation(true);
//       validationFailed = true;
//       showAlert({
//         severity: 'error',
//         timeOut: 5000,
//         onClose: hideAlert,
//         children: translations.VALIDATE_CHOICES
//       });
//     }
//     var idValues = data.map(function (option) {
//       return option.id;
//     });
//     // Get the maximum id value
//     if (idValues.length > 0) {
//       maxId = Math.max.apply(Math, _toConsumableArray$d(idValues));
//     }
//     if (!validationFailed) {
//       if (data.length === 0) data.push({
//         id: 1,
//         choice: choice,
//         correct: true,
//         feedback: choiceFeedback
//       });else data.push({
//         id: maxId + 1,
//         choice: choice,
//         correct: false,
//         feedback: choiceFeedback
//       });
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//       setChoiceFeedback('');
//       setChoice('');
//       setDataAddDelete(true);
//     }
//     setRows([]);
//     disableHandler(question.length);
//   };
//   var reset = function reset() {
//     setChoiceValidation(false);
//     setData([]);
//     if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//       choiceEditor.editor.setData('');
//     }
//     if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//       choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//     }
//     setChoiceFeedback('');
//     setChoice('');
//     setCurrentID('');
//     setButtonUpdateDisable(true);
//     setRows([]);
//     disableHandler(question.length);
//   };
//   var updateItem = function updateItem() {
//     if (choice === '' || choice === null || choice === undefined) {
//       setChoiceValidation(true);
//     }
//     if (currentID !== null && currentID !== '' && currentID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         if (f.id === currentID) {
//           element.choice = choice;
//           element.feedback = choiceFeedback;
//         }
//       });
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//       setChoiceFeedback('');
//       setChoice('');
//       setCurrentID('');
//       setButtonUpdateDisable(true);
//     }
//     setRows([]);
//   };
//   var selectItem = function selectItem(ID) {
//     if (ID !== null && ID !== '' && ID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         if (f.id === ID) {
//           if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//             var _choiceEditor$editor;
//             choiceEditor === null || choiceEditor === void 0 || (_choiceEditor$editor = choiceEditor.editor) === null || _choiceEditor$editor === void 0 || _choiceEditor$editor.setData(element.choice);
//           }
//           if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//             var _choiceFeedbackEditor;
//             choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || (_choiceFeedbackEditor = choiceFeedbackEditor.editor) === null || _choiceFeedbackEditor === void 0 || _choiceFeedbackEditor.setData(element.feedback);
//           }
//           setChoice(element.choice);
//           setChoiceFeedback(element.feedback);
//         }
//       });
//       setCurrentID(ID);
//       setButtonUpdateDisable(false);
//     }
//     setRows([]);
//   };
//   var deleteItem = function deleteItem(ID) {
//     var questionObject = buildQuestionObject();
//     var correctOptions = questionObject.Options.filter(function (element) {
//       return element.IsCorrect === true;
//     });
//     if (ID !== null && ID !== '' && ID !== undefined) {
//       var isCorrectOption = questionObject.Options.filter(function (element) {
//         return element.IsCorrect === true && element.MatchAnswerID === ID.toString();
//       });
//       setData(data.filter(function (x) {
//         return x.id !== ID;
//       }));
//       if (isCorrectOption.length > 0 && correctOptions.length === 1) {
//         // If the deleted item was the only correct option,
//         // find the next available option and make it the correct one
//         var remainingOptions = data.filter(function (x) {
//           return x.id !== ID;
//         });
//         if (remainingOptions.length > 0) {
//           var nextCorrectOption = remainingOptions[0];
//           nextCorrectOption.correct = true;
//         }
//       }
//       setDataAddDelete(true);
//     }
//     if (data.length <= 3) {
//       setButtonDisable(true); // disable done and another button if there are less than 2 options after deletion.
//     }
//     setRows([]);
//   };
//   useEffect$2(function () {
//     if (editData && isEdit) {
//       setQuestionCode(editData.Code);
//       setQuestion(editData.QuestionText);
//       setQuestionFeedback(editData.QuestionFeedback);
//       data.length = 0;
//       if (editData.Options && editData.Options.length !== 0) {
//         editData.Options.forEach(function (value) {
//           data.push({
//             id: value.AnswerID[0],
//             choice: value.AnswerText[0],
//             correct: value.IsCorrect,
//             feedback: value.Feedback
//           });
//         });
//         setNotRandomizeChoices(!editData.Options[0].Shuffle);
//         // disableHandler(question.length);
//         setButtonDisable(false);
//       }
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [editData]);
//   var buildQuestionObject = function buildQuestionObject() {
//     var questionObject = {
//       Code: questionCode,
//       QuestionText: question,
//       QuestionTextFmt: question,
//       QuestionType: null,
//       QuestionFeedback: questionFeedback,
//       Options: [],
//       Status: null,
//       optionAddDelete: false
//     };
//     data.forEach(function (element) {
//       questionObject.Options.push({
//         AnswerID: [element.id.toString()],
//         Shuffle: !notRandomizeChoices,
//         WeightPercent: '',
//         AnswerText: [element.choice],
//         MatchAnswerID: element.id.toString(),
//         MatchAnswerText: '',
//         Feedback: element.feedback,
//         IsCorrect: element.correct,
//         IsCaseSensitive: false,
//         QuestionBankType: null
//       });
//     });
//     return questionObject;
//   };
//   var doneClick = function doneClick() {
//     var requestObj = buildQuestionObject();
//     requestObj.optionAddDelete = isDataAddDelete;
//     onDone(requestObj);
//     // Reset the flag after passing it to the parent
//     setDataAddDelete(false);
//   };
//   var anotherClick = function anotherClick() {
//     var requestObj = buildQuestionObject();
//     requestObj.optionAddDelete = isDataAddDelete;
//     onAnother(requestObj);
//     setDataAddDelete(false);
//   };
//   var cancelClick = function cancelClick() {
//     onCancel();
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Alert, {
//     open: !!alertData,
//     onClose: hideAlert,
//     severity: alertData === null || alertData === void 0 ? void 0 : alertData.severity,
//     timeOut: alertData === null || alertData === void 0 ? void 0 : alertData.timeOut
//   }, alertData === null || alertData === void 0 ? void 0 : alertData.children), /*#__PURE__*/React__default.createElement(QuestionFeedback, {
//     onCodeChange: questionCodeChange,
//     onQuestionChange: questionChange,
//     onFeedbackChange: questionFeedbackChange,
//     codeLabel: translations.CODE_LABEL,
//     questionLabel: translations.QUESTION_LABEL,
//     questionMaximumLabel: translations.QUESTION_MAX_LABEL,
//     questionFeedbackLabel: translations.QUESTION_FEEDBACK_LABEL,
//     editData: editData,
//     translationMode: translationMode
//   }), /*#__PURE__*/React__default.createElement(AnswerDiv$3, {
//     id: "answer-feedback"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$3, {
//     item: true
//   }, translations.ANSWER_LABEL), /*#__PURE__*/React__default.createElement(HintLabel$2, {
//     item: true
//   }, translations.MULTIPLE_CHOICES_LABEL))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(BasicTableContainer, null, /*#__PURE__*/React__default.createElement(BasicTable, null, /*#__PURE__*/React__default.createElement(BasicTableHead, null, /*#__PURE__*/React__default.createElement(BasicTableRow, null, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$3, {
//     item: true
//   }, translations.CHOICE_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$3, {
//     item: true
//   }, translations.CORRECT_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$3, {
//     item: true
//   }, translations.FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$3, {
//     item: true
//   }, translations.ACTIONS_LABEL)))), /*#__PURE__*/React__default.createElement(BasicTableBody, null, data.map(function (d) {
//     return /*#__PURE__*/React__default.createElement(BasicTableRow, {
//       key: d.id
//     }, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.choice)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("input", {
//       type: "radio",
//       checked: d.correct,
//       onChange: function onChange() {
//         return setCorrectItem(d.id);
//       },
//       disabled: translationMode
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.feedback)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(IconButton, {
//       color: "primary",
//       label: translations.SELECT_LABEL,
//       id: "select-question",
//       onClick: function onClick(e) {
//         selectItem(d.id);
//       }
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Edit"
//     })), /*#__PURE__*/React__default.createElement(IconButton, {
//       color: "primary",
//       label: translations.DELETE_LABEL.toLowerCase(),
//       id: "delete-question",
//       disabled: translationMode,
//       onClick: function onClick(e) {
//         deleteItem(d.id);
//       }
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Delete"
//     }))));
//   }))))), /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between",
//     spacing: 10
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(CheckboxWithLabel, {
//     id: "random",
//     label: translations.RANDOMIZE_LABEL,
//     checked: notRandomizeChoices,
//     onChange: handleRandomizeChange,
//     disabled: translationMode
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     alignItems: "center",
//     container: true,
//     direction: "column",
//     wrap: "nowrap"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "add-question",
//     disabled: translationMode,
//     onClick: function onClick() {
//       return addRow();
//     }
//   }, translations.ADD_LABEL)))))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$3, {
//     item: true
//   }, translations.CHOICE_HEADING))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "choice",
//     onChange: function onChange(event) {
//       return choiceChange(event);
//     },
//     onReady: function onReady(editor) {
//       setChoiceEditor(editor);
//       choiceEditorRef.current = editor;
//     },
//     initData: choice
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label$3, {
//     item: true
//   }, translations.CHOICE_FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "choice-feedback",
//     onChange: function onChange(event) {
//       return choiceFeedbackChange(event);
//     },
//     onReady: function onReady(editor) {
//       setChoiceFeedbackEditor(editor);
//       choiceFeedbackEditorRef.current = editor;
//     },
//     initData: choiceFeedback
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$3, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "update",
//     disabled: buttonUpdateDisable,
//     onClick: function onClick() {
//       return updateItem();
//     }
//   }, translations.UPDATE_LABEL), "\xA0", !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "reset",
//     onClick: function onClick() {
//       return reset();
//     }
//   }, translations.RESET_LABEL)))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$3, null, !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "another",
//     disabled: buttonDisable,
//     onClick: anotherClick
//   }, translations.ANOTHER_LABEL)), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "done",
//     disabled: buttonDisable || disableAction,
//     onClick: doneClick
//   }, translations.DONE_LABEL), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "cancel",
//     onClick: cancelClick
//   }, translations.CANCEL_LABEL)))))));
// };
// var optionsPropTypes$2 = {
//   AnswerID: PropTypes__default.arrayOf(PropTypes__default.string),
//   AnswerText: PropTypes__default.arrayOf(PropTypes__default.string),
//   Feedback: PropTypes__default.string,
//   MatchAnswerText: PropTypes__default.string,
//   WeightPercent: PropTypes__default.string,
//   IsCorrect: PropTypes__default.bool,
//   IsCaseSensitive: PropTypes__default.bool,
//   Shuffle: PropTypes__default.bool
// };
// var editDataPropTypes$2 = {
//   QuestionType: PropTypes__default.number,
//   Code: PropTypes__default.string,
//   QuestionText: PropTypes__default.string,
//   QuestionFeedback: PropTypes__default.string,
//   Options: PropTypes__default.arrayOf(PropTypes__default.shape(optionsPropTypes$2))
// };
// MultipleChoice.propTypes = {
//   /**
//    * isEdit defines that it is Edit mode
//    */
//   isEdit: PropTypes__default.bool,
//   /**
//    * editData contains all data for edit
//    */
//   editData: PropTypes__default.shape(editDataPropTypes$2),
//   /**
//    * onDone callback function to pass request object
//    */
//   onDone: PropTypes__default.func.isRequired,
//   /**
//    * onAnother callback function to pass request object
//    */
//   onAnother: PropTypes__default.func.isRequired,
//   /**
//    * onCancel callback function
//    */
//   onCancel: PropTypes__default.func.isRequired,
//   /**
//    * translations contains all string translations for MultipleChoice
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    *   Action type translate based on this prop value disabling some of the input fields 
//   // which should not editable while adding the translated question from the base question
//   */
//   translationMode: PropTypes__default.bool,
//   /**
//    * Disables done button if language dropdown has value '-1'
//    */
//   disableAction: PropTypes__default.bool
// };
// MultipleChoice.defaultProps = {
//   translations: {
//     CODE_LABEL: 'Question Code:',
//     QUESTION_LABEL: 'Question: *',
//     QUESTION_MAX_LABEL: 'Question maximum: 4000 characters',
//     QUESTION_FEEDBACK_LABEL: 'Question Feedback',
//     ANSWER_LABEL: 'Answer: *',
//     MULTIPLE_CHOICES_LABEL: 'Note : Add at least 3 choices.',
//     CHOICE_LABEL: 'Choice',
//     CHOICE_HEADING: 'Choice: *',
//     CORRECT_LABEL: 'Correct',
//     SCORE_LABEL: 'Score',
//     FEEDBACK_LABEL: 'Feedback',
//     ADD_LABEL: 'ADD',
//     DELETE_LABEL: 'DELETE',
//     ACTIONS_LABEL: 'Actions',
//     SELECT_LABEL: 'Select',
//     CHOICE_FEEDBACK_LABEL: 'Choice Feedback:',
//     RANDOMIZE_LABEL: 'Do not randomize the order of choices.',
//     UPDATE_LABEL: 'UPDATE',
//     RESET_LABEL: 'RESET',
//     ANOTHER_LABEL: 'ADD ANOTHER QUESTION',
//     DONE_LABEL: 'DONE',
//     CANCEL_LABEL: 'CANCEL',
//     VALIDATE_CHOICES: 'Enter your choices below and click Add.'
//   },
//   isEdit: false,
//   editData: undefined,
//   translationMode: false,
//   disableAction: false
// };

// var _templateObject$3, _templateObject2$3, _templateObject3$2;
// var Label$2 = styled(FormLabel)(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral$1(["\n  margin-top: 0.625rem;\n"])));
// var HintLabel$1 = styled(Label$2)(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// var AnswerDiv$2 = styled.div(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral$1(["\n  margin-top: 0.938rem;\n"])));

// /**
//  * MultipleSelect component used in Question types consists of table to add rows for user to select any correct answers.
//  *
//  */
// var MultipleSelect = function MultipleSelect(_ref) {
//   var translations = _ref.translations,
//     onDone = _ref.onDone,
//     onAnother = _ref.onAnother,
//     onCancel = _ref.onCancel,
//     editData = _ref.editData,
//     isEdit = _ref.isEdit,
//     translationMode = _ref.translationMode,
//     disableAction = _ref.disableAction;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     questionCode = _useState2[0],
//     setQuestionCode = _useState2[1];
//   var _useState3 = useState$1(''),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     question = _useState4[0],
//     setQuestion = _useState4[1];
//   var _useState5 = useState$1(''),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     questionFeedback = _useState6[0],
//     setQuestionFeedback = _useState6[1];
//   var _useState7 = useState$1(''),
//     _useState8 = _slicedToArray$b(_useState7, 2),
//     choice = _useState8[0],
//     setChoice = _useState8[1];
//   var _useState9 = useState$1(),
//     _useState10 = _slicedToArray$b(_useState9, 2),
//     choiceEditor = _useState10[0],
//     setChoiceEditor = _useState10[1];
//   var _useState11 = useState$1(''),
//     _useState12 = _slicedToArray$b(_useState11, 2),
//     choiceFeedback = _useState12[0],
//     setChoiceFeedback = _useState12[1];
//   var _useState13 = useState$1(),
//     _useState14 = _slicedToArray$b(_useState13, 2),
//     choiceFeedbackEditor = _useState14[0],
//     setChoiceFeedbackEditor = _useState14[1];
//   var _useState15 = useState$1(false),
//     _useState16 = _slicedToArray$b(_useState15, 2),
//     notRandomizeChoices = _useState16[0],
//     setNotRandomizeChoices = _useState16[1];
//   var _useState17 = useState$1([]),
//     _useState18 = _slicedToArray$b(_useState17, 2),
//     setRows = _useState18[1];
//   var _useState19 = useState$1([]),
//     _useState20 = _slicedToArray$b(_useState19, 2),
//     data = _useState20[0],
//     setData = _useState20[1];
//   var _useState21 = useState$1(false),
//     _useState22 = _slicedToArray$b(_useState21, 2),
//     setChoiceValidation = _useState22[1];
//   var _useState23 = useState$1(true),
//     _useState24 = _slicedToArray$b(_useState23, 2),
//     buttonDisable = _useState24[0],
//     setButtonDisable = _useState24[1];
//   var _useState25 = useState$1(true),
//     _useState26 = _slicedToArray$b(_useState25, 2),
//     buttonUpdateDisable = _useState26[0],
//     setButtonUpdateDisable = _useState26[1];
//   var _useState27 = useState$1(''),
//     _useState28 = _slicedToArray$b(_useState27, 2),
//     currentID = _useState28[0],
//     setCurrentID = _useState28[1];
//   var _useState29 = useState$1(''),
//     _useState30 = _slicedToArray$b(_useState29, 2),
//     alertData = _useState30[0],
//     setAlertData = _useState30[1];
//   var _useState31 = useState$1(false),
//     _useState32 = _slicedToArray$b(_useState31, 2),
//     isDataAddDelete = _useState32[0],
//     setDataAddDelete = _useState32[1];

//   // Refs to store CKEditor instances
//   var choiceEditorRef = useRef$2(null);
//   var choiceFeedbackEditorRef = useRef$2(null);

//   // Function to show the alert
//   var showAlert = function showAlert(alertInfo) {
//     setAlertData(alertInfo);
//     window.scrollTo(0, 0);
//   };
//   var hideAlert = function hideAlert() {
//     setAlertData(null);
//   };
//   var questionCodeChange = function questionCodeChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionCode(value);
//     }
//   };
//   var questionChange = function questionChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestion(value);
//       disableHandler(value === null || value === void 0 ? void 0 : value.length);
//     }
//   };
//   var questionFeedbackChange = function questionFeedbackChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionFeedback(value);
//     }
//   };
//   var choiceChange = function choiceChange(event) {
//     if (event !== undefined) {
//       setChoiceValidation(false);
//       setChoice(event.editor.getData());
//       setChoiceEditor(event);
//     }
//   };
//   var choiceFeedbackChange = function choiceFeedbackChange(event) {
//     if (event !== undefined) {
//       setChoiceFeedback(event.editor.getData());
//       setChoiceFeedbackEditor(event);
//     }
//   };
//   var handleRandomizeChange = function handleRandomizeChange(event) {
//     setNotRandomizeChoices(event.target.checked);
//   };
//   var setCorrectItem = function setCorrectItem(event, id) {
//     if (event !== null && id !== null) {
//       data.forEach(function (f) {
//         var element = f;
//         if (element.id === id) {
//           element.correct = event.target.checked;
//         }
//       });
//     }
//     setRows([]);
//   };
//   var setScore = function setScore(event, id) {
//     if (event !== null && id !== null) {
//       data.forEach(function (f) {
//         var element = f;
//         if (element.id === id) {
//           element.score = Math.round(event.target.value);
//         }
//       });
//     }
//     setRows([]);
//   };
//   var disableHandler = function disableHandler(questionLength) {
//     if (data.length < 2 || questionLength === 0) {
//       setButtonDisable(true);
//     } else {
//       setButtonDisable(false);
//     }
//   };
//   var addRow = function addRow() {
//     var validationFailed = false;
//     var maxId = 0;
//     if (sanitizeOption(choice.trim()) === '' || sanitizeOption(choice.trim()) === null || sanitizeOption(choice.trim()) === undefined) {
//       setChoiceValidation(true);
//       validationFailed = true;
//       showAlert({
//         severity: 'error',
//         timeOut: 5000,
//         onClose: hideAlert,
//         children: translations.VALIDATE_CHOICES
//       });
//     }
//     var idValues = data.map(function (option) {
//       return option.id;
//     });
//     // Get the maximum id value
//     if (idValues.length > 0) {
//       maxId = Math.max.apply(Math, _toConsumableArray$d(idValues));
//     }
//     if (!validationFailed) {
//       if (data.length === 0) {
//         data.push({
//           id: 1,
//           choice: choice,
//           score: 0,
//           correct: true,
//           feedback: choiceFeedback
//         });
//       } else {
//         data.push({
//           id: maxId + 1,
//           choice: choice,
//           score: 0,
//           correct: false,
//           feedback: choiceFeedback
//         });
//       }
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//       setChoiceFeedback('');
//       setChoice('');
//       setDataAddDelete(true);
//     }
//     setRows([]);
//     disableHandler(question === null || question === void 0 ? void 0 : question.length);
//   };
//   var reset = function reset() {
//     setChoiceValidation(false);
//     setData([]);
//     if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//       choiceEditor.editor.setData('');
//     }
//     if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//       choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//     }
//     setChoiceFeedback('');
//     setChoice('');
//     setCurrentID('');
//     setButtonUpdateDisable(true);
//     setRows([]);
//     disableHandler(question.length);
//   };
//   var updateItem = function updateItem() {
//     if (choice === '' || choice === null || choice === undefined) {
//       setChoiceValidation(true);
//     }
//     if (currentID !== null && currentID !== '' && currentID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         if (f.id === currentID) {
//           element.choice = choice;
//           element.feedback = choiceFeedback;
//         }
//       });
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//       setChoiceFeedback('');
//       setChoice('');
//       setCurrentID('');
//       setButtonUpdateDisable(true);
//     }
//     setRows([]);
//   };
//   var selectItem = function selectItem(ID) {
//     if (ID !== null && ID !== '' && ID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         if (f.id === ID) {
//           if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//             var _choiceEditor$editor;
//             choiceEditor === null || choiceEditor === void 0 || (_choiceEditor$editor = choiceEditor.editor) === null || _choiceEditor$editor === void 0 || _choiceEditor$editor.setData(element.choice);
//           }
//           if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//             var _choiceFeedbackEditor;
//             choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || (_choiceFeedbackEditor = choiceFeedbackEditor.editor) === null || _choiceFeedbackEditor === void 0 || _choiceFeedbackEditor.setData(element.feedback);
//           }
//           setChoice(element.choice);
//           setChoiceFeedback(element.feedback);
//         }
//       });
//       setCurrentID(ID);
//       setButtonUpdateDisable(false);
//     }
//     setRows([]);
//   };
//   var deleteItem = function deleteItem(ID) {
//     var questionObject = buildQuestionObject();
//     var correctOptions = questionObject.Options.filter(function (element) {
//       return element.IsCorrect === true;
//     });
//     if (ID !== null && ID !== '' && ID !== undefined) {
//       var isCorrectOption = questionObject.Options.filter(function (element) {
//         return element.IsCorrect === true && element.MatchAnswerID === ID.toString();
//       });
//       setData(data.filter(function (x) {
//         return x.id !== ID;
//       }));
//       if (isCorrectOption.length > 0 && correctOptions.length === 1) {
//         // If the deleted item was the only correct option,
//         // find the next available option and make it the correct one
//         var remainingOptions = data.filter(function (x) {
//           return x.id !== ID;
//         });
//         if (remainingOptions.length > 0) {
//           var nextCorrectOption = remainingOptions[0];
//           nextCorrectOption.correct = true;
//         }
//       }
//       setDataAddDelete(true);
//     }
//     if (data.length <= 2) {
//       setButtonDisable(true); // disable done and another button if there are less than 2 options after deletion.
//     }
//     setRows([]);
//   };
//   useEffect$2(function () {
//     if (editData && isEdit) {
//       setQuestionCode(editData.Code);
//       setQuestion(editData.QuestionText);
//       setQuestionFeedback(editData.QuestionFeedback);
//       data.length = 0;
//       if (editData.Options && editData.Options.length !== 0) {
//         editData.Options.forEach(function (value) {
//           data.push({
//             id: value.AnswerID[0],
//             choice: value.AnswerText[0],
//             score: value.WeightPercent,
//             correct: value.IsCorrect,
//             feedback: value.Feedback
//           });
//         });
//         setNotRandomizeChoices(!editData.Options[0].Shuffle);
//         disableHandler(question.length);
//         setButtonDisable(false);
//       }
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [editData]);
//   var buildQuestionObject = function buildQuestionObject() {
//     var questionObject = {
//       Code: questionCode,
//       QuestionText: question,
//       QuestionTextFmt: question,
//       QuestionType: null,
//       QuestionFeedback: questionFeedback,
//       Options: [],
//       Status: null,
//       optionAddDelete: false
//     };
//     data.forEach(function (element) {
//       questionObject.Options.push({
//         AnswerID: [element.id.toString()],
//         Shuffle: !notRandomizeChoices,
//         WeightPercent: element.score,
//         AnswerText: [element.choice],
//         MatchAnswerID: element.id.toString(),
//         MatchAnswerText: '',
//         Feedback: element.feedback,
//         IsCorrect: element.correct,
//         IsCaseSensitive: false,
//         QuestionBankType: null
//       });
//     });
//     return questionObject;
//   };
//   var doneClick = function doneClick() {
//     var questionObject = buildQuestionObject();
//     if (ValidateWeightPercent(questionObject)) {
//       questionObject.optionAddDelete = isDataAddDelete;
//       onDone(questionObject);
//       // Reset the flag after passing it to the parent
//       setDataAddDelete(false);
//     }
//   };
//   var ValidateWeightPercent = function ValidateWeightPercent(questionObject) {
//     var totalWeightPercent = 0;
//     var hasInvalidWeight = false;
//     var correctOptions = questionObject.Options.filter(function (option) {
//       return option.IsCorrect;
//     });
//     correctOptions.forEach(function (element) {
//       if (element.WeightPercent !== null && element.WeightPercent !== '' && element.WeightPercent > 0) {
//         if (!isNaN(parseFloat(element.WeightPercent))) {
//           totalWeightPercent += parseFloat(element.WeightPercent);
//         }
//       } else {
//         hasInvalidWeight = true; // Set the flag if any correct option has invalid weight
//       }
//     });
//     if (totalWeightPercent < 100 || hasInvalidWeight) {
//       showAlert({
//         severity: 'error',
//         timeOut: 5000,
//         onClose: hideAlert,
//         children: translations.VALIDATE_WEIGHTPERCENT
//       });
//       return false;
//     }
//     return true;
//   };
//   var anotherClick = function anotherClick() {
//     var questionObject = buildQuestionObject();
//     if (ValidateWeightPercent(questionObject)) {
//       questionObject.optionAddDelete = isDataAddDelete;
//       onAnother(questionObject);
//       setDataAddDelete(false);
//     }
//   };
//   var cancelClick = function cancelClick() {
//     onCancel();
//   };
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Alert, {
//     open: !!alertData,
//     onClose: hideAlert,
//     severity: alertData === null || alertData === void 0 ? void 0 : alertData.severity,
//     timeOut: alertData === null || alertData === void 0 ? void 0 : alertData.timeOut
//   }, alertData === null || alertData === void 0 ? void 0 : alertData.children), /*#__PURE__*/React__default.createElement(QuestionFeedback, {
//     onCodeChange: questionCodeChange,
//     onQuestionChange: questionChange,
//     onFeedbackChange: questionFeedbackChange,
//     codeLabel: translations.CODE_LABEL,
//     questionLabel: translations.QUESTION_LABEL,
//     questionMaximumLabel: translations.QUESTION_MAX_LABEL,
//     questionFeedbackLabel: translations.QUESTION_FEEDBACK_LABEL,
//     editData: editData,
//     translationMode: translationMode
//   }), /*#__PURE__*/React__default.createElement(AnswerDiv$2, {
//     id: "answer-feedback"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.ANSWER_LABEL), /*#__PURE__*/React__default.createElement(HintLabel$1, {
//     item: true
//   }, translations.MULTIPLE_CHOICES_LABEL))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(BasicTableContainer, null, /*#__PURE__*/React__default.createElement(BasicTable, null, /*#__PURE__*/React__default.createElement(BasicTableHead, null, /*#__PURE__*/React__default.createElement(BasicTableRow, null, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.CHOICE_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.CORRECT_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.SCORE_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.ACTIONS_LABEL)))), /*#__PURE__*/React__default.createElement(BasicTableBody, null, data.map(function (d) {
//     return /*#__PURE__*/React__default.createElement(BasicTableRow, {
//       key: d.id
//     }, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.choice)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("input", {
//       type: "checkbox",
//       checked: d.correct,
//       disabled: translationMode,
//       onChange: function onChange(event) {
//         return setCorrectItem(event, d.id);
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("input", {
//       type: "number",
//       step: "1",
//       id: "scoreField",
//       disabled: translationMode,
//       value: d.score !== null ? d.score : '',
//       onChange: function onChange(event) {
//         return setScore(event, d.id);
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.feedback)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(IconButton, {
//       color: "primary",
//       label: translations.SELECT_LABEL,
//       id: "select-question",
//       onClick: function onClick(e) {
//         selectItem(d.id);
//       }
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Edit"
//     })), /*#__PURE__*/React__default.createElement(IconButton, {
//       color: "primary",
//       label: translations.DELETE_LABEL.toLowerCase(),
//       id: "delete-question",
//       disabled: translationMode,
//       onClick: function onClick(e) {
//         deleteItem(d.id);
//       }
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Delete"
//     }))));
//   }))))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between",
//     spacing: 10
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(CheckboxWithLabel, {
//     id: "random",
//     label: translations.RANDOMIZE_LABEL,
//     checked: notRandomizeChoices,
//     disabled: translationMode,
//     onChange: handleRandomizeChange
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "add-question",
//     disabled: translationMode,
//     onClick: function onClick() {
//       return addRow();
//     }
//   }, translations.ADD_LABEL))))), /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.CHOICE_HEADING))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "choice",
//     onChange: function onChange(event) {
//       return choiceChange(event);
//     },
//     onReady: function onReady(editor) {
//       setChoiceEditor(editor);
//       choiceEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label$2, {
//     item: true
//   }, translations.CHOICE_FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "choice-feedback",
//     onChange: function onChange(event) {
//       return choiceFeedbackChange(event);
//     },
//     onReady: function onReady(editor) {
//       setChoiceFeedbackEditor(editor);
//       choiceFeedbackEditorRef.current = editor;
//     }
//   }))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$2, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "update",
//     disabled: buttonUpdateDisable,
//     onClick: function onClick() {
//       return updateItem();
//     }
//   }, translations.UPDATE_LABEL), "\xA0", !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "reset",
//     onClick: function onClick() {
//       return reset();
//     }
//   }, translations.RESET_LABEL)))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$2, null, !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "another",
//     disabled: buttonDisable,
//     onClick: anotherClick
//   }, translations.ANOTHER_LABEL)), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "done",
//     disabled: buttonDisable || disableAction,
//     onClick: doneClick
//   }, translations.DONE_LABEL), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "cancel",
//     onClick: cancelClick
//   }, translations.CANCEL_LABEL))))));
// };
// var optionsPropTypes$1 = {
//   AnswerID: PropTypes__default.arrayOf(PropTypes__default.string),
//   AnswerText: PropTypes__default.arrayOf(PropTypes__default.string),
//   Feedback: PropTypes__default.string,
//   MatchAnswerText: PropTypes__default.string,
//   WeightPercent: PropTypes__default.string,
//   IsCorrect: PropTypes__default.bool,
//   IsCaseSensitive: PropTypes__default.bool,
//   Shuffle: PropTypes__default.bool
// };
// var editDataPropTypes$1 = {
//   QuestionType: PropTypes__default.number,
//   Code: PropTypes__default.string,
//   QuestionText: PropTypes__default.string,
//   QuestionFeedback: PropTypes__default.string,
//   Options: PropTypes__default.arrayOf(PropTypes__default.shape(optionsPropTypes$1))
// };
// MultipleSelect.propTypes = {
//   /**
//    * isEdit defines that it is Edit mode
//    */
//   isEdit: PropTypes__default.bool,
//   /**
//    * editData contains all data for edit
//    */
//   editData: PropTypes__default.shape(editDataPropTypes$1),
//   /**
//    * onDone callback function to pass request object
//    */
//   onDone: PropTypes__default.func.isRequired,
//   /**
//    * onAnother callback function to pass request object
//    */
//   onAnother: PropTypes__default.func.isRequired,
//   /**
//    * onCancel callback function
//    */
//   onCancel: PropTypes__default.func.isRequired,
//   /**
//    * translations contains all string translations for MultipleSelect
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    *   Action type translate based on this prop value disabling some of the input fields
//    *   which should not editable while adding the translated question from the base question
//    */
//   translationMode: PropTypes__default.bool,
//   /**
//    * Disables done button if language dropdown has value '-1'
//    */
//   disableAction: PropTypes__default.bool
// };
// MultipleSelect.defaultProps = {
//   translations: {
//     CODE_LABEL: 'Question Code:',
//     QUESTION_LABEL: 'Question: *',
//     QUESTION_MAX_LABEL: 'Question maximum: 4000 characters',
//     QUESTION_FEEDBACK_LABEL: 'Question Feedback:',
//     ANSWER_LABEL: 'Answer: *',
//     MULTIPLE_CHOICES_LABEL: 'Note : Add at least 2 choices.',
//     CHOICE_HEADING: 'Choice: *',
//     CHOICE_LABEL: 'Choice',
//     SCORE_LABEL: 'Score (%)',
//     CORRECT_LABEL: 'Correct:',
//     FEEDBACK_LABEL: 'Feedback:',
//     RANDOMIZE_LABEL: 'Do not randomize the order of choices.',
//     CHOICE_FEEDBACK_LABEL: 'Choice Feedback:',
//     ADD_LABEL: 'ADD',
//     DELETE_LABEL: 'DELETE',
//     ACTIONS_LABEL: 'Actions',
//     SELECT_LABEL: 'Select',
//     UPDATE_LABEL: 'UPDATE',
//     RESET_LABEL: 'RESET',
//     ANOTHER_LABEL: 'ADD ANOTHER QUESTION',
//     DONE_LABEL: 'DONE',
//     CANCEL_LABEL: 'CANCEL',
//     VALIDATE_CHOICES: 'Enter your choices below and click Add.',
//     VALIDATE_WEIGHTPERCENT: 'Score of each correct choice must be more than 0. The total score must be at least 100%.'
//   },
//   isEdit: false,
//   editData: undefined,
//   translationMode: false,
//   disableAction: false
// };

// var _templateObject$2, _templateObject2$2, _templateObject3$1;
// var Label$1 = styled(FormLabel)(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral$1(["\n  margin-top: 0.625rem;\n"])));
// var HintLabel = styled(Label$1)(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// var AnswerDiv$1 = styled.div(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral$1(["\n  margin-top: 0.938rem;\n"])));

// /**
//  * OpenEnded component used in Question types consists of a question and blank text field for user to answer.
//  *
//  */

// var OpenEnded = function OpenEnded(_ref) {
//   var questionLabel = _ref.questionLabel,
//     questionMaximumLabel = _ref.questionMaximumLabel,
//     anotherLabel = _ref.anotherLabel,
//     doneLabel = _ref.doneLabel,
//     cancelLabel = _ref.cancelLabel,
//     onAnother = _ref.onAnother,
//     onDone = _ref.onDone,
//     onCancel = _ref.onCancel;
//   var _useState = useState$1([]),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     question = _useState2[0],
//     setQuestion = _useState2[1];
//   var _useState3 = useState$1(true),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     buttonDisable = _useState4[0],
//     setButtonDisable = _useState4[1];
//   var questionChange = function questionChange(val) {
//     if (val !== null && val !== undefined) {
//       setQuestion([]);
//       question.push(val);
//       setQuestion(val);
//       disableHandler();
//     }
//   };
//   var disableHandler = function disableHandler() {
//     if (question !== null && question.length > 0 && question[question.length - 1] !== '') {
//       setButtonDisable(false);
//     } else {
//       setButtonDisable(true);
//     }
//   };
//   var buildQuestionObject = function buildQuestionObject() {
//     var questionObject = {
//       QuestionText: question,
//       QuestionTextFmt: question,
//       QuestionType: null,
//       Status: null
//     };
//     questionObject.Options.push({
//       AnswerID: ['1'],
//       WeightPercent: '100',
//       QuestionBankType: null
//     });
//     return questionObject;
//   };
//   var doneClick = function doneClick() {
//     var requestObj = buildQuestionObject();
//     onDone(requestObj);
//   };
//   var anotherClick = function anotherClick() {
//     var requestObj = buildQuestionObject();
//     onAnother(requestObj);
//   };
//   var cancelClick = function cancelClick() {
//     onCancel();
//   };
//   return /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label$1, {
//     item: true
//   }, questionLabel), /*#__PURE__*/React__default.createElement(HintLabel, {
//     item: true
//   }, questionMaximumLabel))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "question",
//     onChange: function onChange(event) {
//       return questionChange(event);
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv$1, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "another",
//     disabled: buttonDisable,
//     onClick: anotherClick
//   }, anotherLabel), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "done",
//     disabled: buttonDisable,
//     onClick: doneClick
//   }, doneLabel), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "cancel",
//     onClick: cancelClick
//   }, cancelLabel)))));
// };
// OpenEnded.propTypes = {
//   /**
//    * questionLabel displays Question label
//    */
//   questionLabel: PropTypes__default.string,
//   /**
//    * questionMaximumLabel displays Question Maximum Note
//    */
//   questionMaximumLabel: PropTypes__default.string,
//   /**
//    * anotherLabel displays Add another question label
//    */
//   anotherLabel: PropTypes__default.string,
//   /**
//    * doneLabel displays Done label
//    */
//   doneLabel: PropTypes__default.string,
//   /**
//    * cancelLabel displays Cancel label
//    */
//   cancelLabel: PropTypes__default.string,
//   /**
//    * onDone callback function to pass request object
//    */
//   onDone: PropTypes__default.func.isRequired,
//   /**
//    * onAnother callback function to pass request object
//    */
//   onAnother: PropTypes__default.func.isRequired,
//   /**
//    * onCancel callback function
//    */
//   onCancel: PropTypes__default.func.isRequired
// };
// OpenEnded.defaultProps = {
//   questionLabel: 'Question: *',
//   questionMaximumLabel: 'Question maximum: 4000 characters',
//   anotherLabel: 'ADD ANOTHER QUESTION',
//   doneLabel: 'DONE',
//   cancelLabel: 'CANCEL'
// };

// /**
//  * Add all the global style overrides for MuiButton to this method
//  * @param {Theme } variables
//  */
// var overrideMuiButton = function overrideMuiButton(variables, spacing) {
//   return {
//     styleOverrides: {
//       root: {
//         fontSize: '0.875rem',
//         fontWeight: '700',
//         padding: spacing(1.5, 3),
//         minHeight: '2.1875rem',
//         lineHeight: '1rem',
//         borderRadius: '0.25rem'
//       },
//       sizeSmall: {
//         fontSize: '0.75rem',
//         minHeight: '1.5625rem',
//         borderRadius: '0.1875rem',
//         padding: spacing(1.25, 2.5),
//         lineHeight: '0.8125rem'
//       },
//       sizeLarge: {
//         fontSize: '1.375rem',
//         minHeight: '2.6875rem',
//         borderRadius: '0.375rem',
//         padding: spacing(2.5, 4),
//         lineHeight: '1.33rem'
//       },
//       iconSizeSmall: {
//         '& > *:first-child': {
//           fontSize: '1.05rem'
//         }
//       },
//       iconSizeMedium: {
//         '& > *:first-child': {
//           fontSize: '1.175rem'
//         }
//       },
//       iconSizeLarge: {
//         '& > *:first-child': {
//           fontSize: '1.675rem'
//         }
//       },
//       contained: {
//         border: '0.125rem solid transparent',
//         color: variables.btnPrimaryColor,
//         '&:hover': {
//           backgroundColor: darken$1(variables.btnPrimaryBg, 0.1),
//           color: variables.btnPrimaryColor
//         },
//         '&:focus': {
//           backgroundColor: darken$1(variables.btnPrimaryBg, 0.1),
//           color: variables.btnPrimaryColor
//         },
//         '&:disabled': {
//           backgroundColor: lighten$1(variables.btnPrimaryBg, 0.5),
//           color: variables.btnPrimaryColor
//         }
//       },
//       containedPrimary: {
//         backgroundColor: variables.btnPrimaryBg,
//         color: variables.btnPrimaryColor
//       },
//       outlinedPrimary: {
//         border: '0.125rem solid',
//         padding: '0.375rem 0.75rem',
//         borderColor: variables.btnPrimaryBg,
//         color: variables.sumtBtnDefaultColor,
//         backgroundColor: variables.btnDefaultBg,
//         '&:hover': {
//           backgroundColor: variables.btnPrimaryBg,
//           color: variables.btnPrimaryColor,
//           border: "0.125rem solid ".concat(variables.btnPrimaryBg)
//         },
//         '&:focus': {
//           backgroundColor: variables.btnPrimaryBg,
//           color: variables.btnPrimaryColor,
//           borderColor: variables.btnPrimaryBg
//         },
//         '&:disabled': {
//           color: lighten$1(variables.btnPrimaryBg, 0.5),
//           borderColor: lighten$1(variables.btnPrimaryBg, 0.5)
//         }
//       },
//       textPrimary: {
//         color: variables.btnPrimaryBg,
//         '&:hover': {
//           color: darken$1(variables.btnPrimaryBg, 0.17)
//         },
//         '&:focus': {
//           color: darken$1(variables.btnPrimaryBg, 0.17)
//         },
//         '&:active': {
//           boxShadow: 'none',
//           backgroundColor: variables.btnPrimaryBg,
//           color: variables.btnPrimaryColor,
//           opacity: 1
//         },
//         '&:disabled': {
//           color: variables.btnPrimaryBg,
//           opacity: 0.5
//         },
//         iconSizeMedium: {
//           '& > *:first-child': {
//             fontSize: '1rem'
//           }
//         }
//       }
//     }
//   };
// };

// var overrideMuiMenuItem = function overrideMuiMenuItem(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         fontSize: '0.75rem',
//         fontWeight: '600',
//         whiteSpace: 'unset',
//         textTransform: 'none'
//       },
//       gutters: {
//         padding: '0.375rem 0.375rem 0.375rem 0.375rem',
//         marginTop: '0.125rem',
//         marginBottom: '0.125rem'
//       }
//     }
//   };
// };

// var overrideMuiSvgIcon = function overrideMuiSvgIcon() {
//   return {
//     styleOverrides: {
//       root: {
//         fontSize: 'inherit'
//       },
//       fontSizeSmall: {
//         fontSize: '1rem'
//       },
//       fontSizeLarge: {
//         fontSize: '2.5rem'
//       }
//     }
//   };
// };

// var overrideMuiListItem = function overrideMuiListItem(variables) {
//   return {
//     styleOverrides: {
//       selected: {
//         fontWeight: 550,
//         textAlign: 'left'
//       },
//       root: {}
//     }
//   };
// };

// var overrideMuiList = function overrideMuiList() {
//   return {
//     styleOverrides: {
//       root: {
//         fontSize: '0.875rem',
//         textAlign: 'left'
//       }
//     }
//   };
// };

// var overrideMuiGrid = function overrideMuiGrid() {
//   return {
//     styleOverrides: {
//       root: {
//         textTransform: 'initial'
//       }
//     }
//   };
// };

// var overrideMuiLabel = function overrideMuiLabel(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         overflow: 'visible'
//       },
//       asterisk: {
//         color: variables.brandDanger
//       },
//       outlined: {
//         '&.MuiInputLabel-shrink': {
//           transform: 'translate(0.875rem, 0.375rem) scale(0.75) !important'
//         },
//         transform: 'translate(0.875rem, 1.6rem) scale(1)',
//         fontSize: '0.875rem',
//         color: variables.textColor
//       },
//       formControl: {
//         lineHeight: '1em'
//       },
//       filled: {
//         '&.MuiInputLabel-shrink': {
//           transform: 'translate(0.75rem, 0.625rem) scale(0.75)'
//         }
//       }
//     }
//   };
// };

// /**
//  * Add all the global style overrides for MuiInput to this method
//  * @param {Theme } variables
//  */
// var overrideMuiInput = function overrideMuiInput() {
//   return {
//     styleOverrides: {
//       root: {
//         fontSize: '0.75rem',
//         paddingLeft: '0.5rem'
//       },
//       underline: {
//         '&:before': {
//           borderBottomWidth: '0.0625rem',
//           borderBottomStyle: 'solid'
//         },
//         '&:after': {
//           borderBottomWidth: '0.125rem',
//           borderBottomStyle: 'solid'
//         },
//         '&:hover:not($disabled):before': {
//           borderBottomWidth: '0.0625rem',
//           borderBottomStyle: 'solid'
//         }
//       }
//     }
//   };
// };

// var overrideMuiSwitch = function overrideMuiSwitch(variables) {
//   return {
//     styleOverrides: {
//       colorPrimary: _defineProperty$C(_defineProperty$C(_defineProperty$C(_defineProperty$C(_defineProperty$C({
//         color: curriedLighten$1(0.4, variables.textColor),
//         '&:hover': {
//           backgroundColor: 'rgb(51 51 51 / 11%)'
//         }
//       }, "&.".concat(switchClasses.checked), {
//         '&:hover': {
//           backgroundColor: 'rgb(30 112 177 / 20%)'
//         },
//         color: variables.btnPrimaryBg
//       }), "&.".concat(switchClasses.disabled), _defineProperty$C({
//         color: alpha$1(curriedLighten$1(0.5, variables.textColor), 0.7)
//       }, "&.".concat(switchClasses.checked), {
//         color: alpha$1(variables.btnPrimaryBg, 0.5)
//       })), "&.".concat(switchClasses.switchBase, ".").concat(switchClasses.disabled, " + .").concat(switchClasses.track), {
//         backgroundColor: curriedLighten$1(0.5, variables.textColor),
//         opacity: 0.15
//       }), "&.".concat(switchClasses.switchBase, ".").concat(switchClasses.checked, " + .").concat(switchClasses.track), {
//         backgroundColor: variables.btnPrimaryBg
//       }), '&.Mui-focusVisible', {
//         backgroundColor: 'rgb(51 51 51 / 11%)'
//       }),
//       track: {
//         backgroundColor: curriedLighten$1(0.2, variables.textColor),
//         opacity: 0.4
//       }
//     }
//   };
// };

// var overrideMuiRadio = function overrideMuiRadio(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         color: variables.textColor
//       },
//       colorPrimary: {
//         '&:hover': {
//           backgroundColor: 'rgb(51 51 51 / 11%)'
//         },
//         '&.Mui-checked': {
//           color: variables.btnPrimaryBg,
//           '&:hover': {
//             backgroundColor: alpha$1(variables.btnPrimaryBg, 0.25)
//           }
//         },
//         '&.Mui-disabled': {
//           '&.Mui-checked': {
//             color: alpha$1(variables.btnPrimaryBg, 0.5)
//           },
//           color: alpha$1(variables.textColor, 0.5)
//         }
//       }
//     }
//   };
// };

// var overrideMuiInputBase = function overrideMuiInputBase(variables) {
//   return {
//     styleOverrides: {
//       input: _defineProperty$C(_defineProperty$C(_defineProperty$C({
//         fontSize: '0.875rem',
//         color: variables.textColor,
//         lineHeight: '1.25rem'
//       }, "&.".concat(inputBaseClasses.disabled), {
//         color: alpha$1(variables.grayBase, 0.38)
//       }), "height", 'auto'), '&:-internal-autofill-selected', {
//         border: 'none',
//         'background-color': 'transparent',
//         color: "".concat(variables.textColor),
//         '-webkit-box-shadow': 'none'
//       }),
//       root: {
//         marginTop: '0.75rem',
//         '& input::-ms-reveal': {
//           display: 'none'
//         },
//         color: variables.textColor
//       }
//     }
//   };
// };

// var overrideMuiOutlinedInput = function overrideMuiOutlinedInput(variables) {
//   return {
//     styleOverrides: {
//       input: {
//         padding: '0.625rem 0.875rem'
//       },
//       notchedOutline: {
//         borderColor: variables.textColor,
//         borderRadius: '0.25rem',
//         border: '0.063rem solid',
//         fontSize: '0.875rem'
//       },
//       root: {
//         '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
//           borderColor: variables.btnPrimaryBg
//         },
//         '&.Mui-error .MuiOutlinedInput-notchedOutline': {
//           borderColor: variables.brandDanger
//         },
//         '&:hover .MuiOutlinedInput-notchedOutline': {
//           borderColor: variables.btnPrimaryBg
//         }
//       },
//       adornedEnd: {
//         paddingRight: '0.06rem'
//       },
//       multiline: {
//         padding: '0rem'
//       },
//       inputAdornedEnd: {
//         paddingRight: '0rem'
//       }
//     }
//   };
// };

// var overrideMuiPickersDay = function overrideMuiPickersDay(variables) {
//   return {
//     styleOverrides: {
//       day: {
//         color: variables.textColor
//       },
//       daySelected: {
//         backgroundColor: variables.btnPrimaryBg,
//         color: variables.btnPrimaryColor
//       },
//       dayDisabled: {
//         color: alpha$1(variables.textColor, 0.38)
//       }
//     }
//   };
// };

// var overrideMuiFormHelperText = function overrideMuiFormHelperText(variables) {
//   return {
//     styleOverrides: {
//       root: _defineProperty$C({
//         fontSize: '0.75rem',
//         marginTop: '0rem',
//         lineHeight: '1.25rem'
//       }, "&.".concat(formHelperTextClasses.error), {
//         color: variables.brandDanger
//       }),
//       contained: {
//         paddingTop: '0.25rem',
//         color: variables.textColor
//       }
//     }
//   };
// };

// var overrideMuiFormLabel = function overrideMuiFormLabel(variables) {
//   return {
//     styleOverrides: {
//       root: _defineProperty$C(_defineProperty$C({
//         fontSize: '0.875rem'
//       }, "&.".concat(formLabelClasses.focused), {
//         color: variables.btnPrimaryBg
//       }), "&.".concat(formLabelClasses.error), {
//         color: variables.brandDanger
//       })
//     }
//   };
// };

// var overrideMuiAutoComplete = function overrideMuiAutoComplete(variables) {
//   return {
//     styleOverrides: {
//       inputRoot: {
//         '&[class*="MuiOutlinedInput-root"]': {
//           padding: '0rem'
//         }
//       },
//       input: {
//         '&[class*="MuiOutlinedInput-input"]': {
//           padding: '0.625rem 0.625rem 0.625rem 0.875rem'
//         }
//       },
//       clearIndicator: {
//         color: alpha$1(variables.grayBase, 0.66),
//         '&:hover': {
//           backgroundColor: 'transparent',
//           color: variables.btnPrimaryBg
//         }
//       },
//       popupIndicator: {
//         color: alpha$1(variables.grayBase, 0.66),
//         '&:hover': {
//           backgroundColor: 'transparent',
//           color: variables.btnPrimaryBg
//         }
//       },
//       tag: {
//         margin: '0.5625rem 0rem 0.3125rem 0.5rem',
//         '&:first-child': {
//           marginLeft: '0.875rem'
//         }
//       }
//     }
//   };
// };

// var overrideMuiPickersToolbar = function overrideMuiPickersToolbar(pickers) {
//   return {
//     styleOverrides: {
//       toolbar: {
//         backgroundColor: pickers.btnPrimaryBg
//       }
//     }
//   };
// };

// var overrideMuiPickersToolbarText = function overrideMuiPickersToolbarText(pickers) {
//   return {
//     styleOverrides: {
//       toolbarTxt: {
//         color: alpha$1(pickers.btnPrimaryColor, 0.54),
//         '&.MuiTypography-h4': {
//           fontSize: '2.125rem',
//           textTransform: 'none'
//         },
//         '&.MuiTypography-h3': {
//           fontSize: '3rem',
//           textTransform: 'none'
//         },
//         '&.MuiTypography-subtitle1': {
//           fontSize: '1rem'
//         }
//       },
//       toolbarBtnSelected: {
//         color: pickers.btnPrimaryColor
//       }
//     }
//   };
// };

// var overrideMuiPickersYear = function overrideMuiPickersYear(variables) {
//   return {
//     styleOverrides: {
//       yearSelected: {
//         color: variables.btnPrimaryBg
//       }
//     }
//   };
// };

// var overrideMuiPickersClock = function overrideMuiPickersClock(variables) {
//   return {
//     styleOverrides: {
//       pin: {
//         backgroundColor: variables.btnPrimaryBg
//       },
//       clock: {
//         backgroundColor: darken$2(variables.bodyBg, 0.07)
//       }
//     }
//   };
// };

// var overrideMuiPickersClockNumber = function overrideMuiPickersClockNumber(variables) {
//   return {
//     styleOverrides: {
//       clockNumberSelected: {
//         backgroundColor: variables.btnPrimaryBg,
//         color: variables.btnPrimaryColor
//       },
//       clockNumber: {
//         color: variables.textColor
//       }
//     }
//   };
// };

// var overrideMuiTypography = function overrideMuiTypography(variables) {
//   return {
//     styleOverrides: {
//       body1: {
//         fontSize: '0.875rem'
//       }
//     }
//   };
// };

// var overrideMuiFab = function overrideMuiFab(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         borderWidth: '0.0625rem',
//         borderStyle: 'solid',
//         boxShadow: '0px 2px 5px 1px rgba(0,0,0,0.75)'
//       },
//       primary: {
//         backgroundColor: variables.btnPrimaryBg,
//         color: variables.btnPrimaryColor,
//         borderColor: variables.btnPrimaryColor
//       }
//     }
//   };
// };

// var overrideMuiChip = function overrideMuiChip(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         backgroundColor: alpha$1(variables.grayBase, 0.1),
//         height: '1.625rem',
//         fontSize: '0.75rem'
//       },
//       label: {
//         lineHeight: '1.0625rem',
//         paddingLeft: '0.625rem',
//         paddingRight: '0.25rem',
//         paddingTop: '0.25rem',
//         paddingBottom: '0.25rem',
//         color: variables.textColor
//       },
//       deleteIcon: {
//         paddingRight: '0.625rem',
//         margin: '0',
//         width: '25px',
//         color: alpha$1(variables.grayBase, 0.5)
//       }
//     }
//   };
// };

// var overrideMuiSelect = function overrideMuiSelect(variables) {
//   return {
//     styleOverrides: {
//       select: {
//         '&:focus': {
//           backgroundColor: variables.btnPrimaryColor
//         }
//       },
//       outlined: {
//         paddingRight: '1.5rem !important'
//       },
//       icon: {
//         top: 'auto',
//         color: variables.textColor
//       }
//     }
//   };
// };

// var overrideMuiNativeSelect = function overrideMuiNativeSelect(variables) {
//   return {
//     styleOverrides: {
//       select: {
//         '&:focus': {
//           backgroundColor: variables.btnPrimaryColor
//         }
//       },
//       outlined: {
//         paddingRight: '1.5rem !important'
//       },
//       icon: {
//         top: 'auto',
//         color: variables.textColor
//       }
//     }
//   };
// };

// var overrideMuiBackdrop = function overrideMuiBackdrop(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         backgroundColor: alpha$1(variables.bodyBg, 0.75)
//       },
//       invisible: {
//         backgroundColor: 'transparent'
//       }
//     }
//   };
// };

// var overrideMuiCheckbox = function overrideMuiCheckbox(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         color: variables.textColor
//       },
//       colorPrimary: {
//         '&:hover': {
//           backgroundColor: 'rgb(51 51 51 / 11%)'
//         },
//         '&.Mui-checked': {
//           color: variables.btnPrimaryBg,
//           '&:hover': {
//             backgroundColor: alpha$1(variables.btnPrimaryBg, 0.25)
//           }
//         },
//         '&.Mui-disabled': {
//           '&.Mui-checked': {
//             color: alpha$1(variables.btnPrimaryBg, 0.5)
//           },
//           color: alpha$1(variables.textColor, 0.5)
//         }
//       }
//     }
//   };
// };

// var overrideMuiFormControl = function overrideMuiFormControl() {
//   return {
//     styleOverrides: {
//       root: {
//         /**
//          * Workaround. Keeping border 0px causing flickering.
//          */
//         border: '0.0625rem solid transparent'
//       }
//     }
//   };
// };

// var overrideMuiPaper = function overrideMuiPaper(variables) {
//   return {
//     styleOverrides: {
//       rounded: {
//         borderRadius: '0.25rem',
//         color: variables.textColor,
//         backgroundColor: curriedLighten$1(0.2, variables.bodyBg)
//       }
//     }
//   };
// };

// var overrideMuiTableCell = function overrideMuiTableCell(variables) {
//   return {
//     styleOverrides: {
//       head: {
//         fontWeight: 'bold',
//         color: variables.textColor,
//         fontSize: '0.875rem',
//         borderBottomColor: variables.tableHeaderBorderColor
//       },
//       body: {
//         fontWeight: 'normal',
//         color: variables.textColor,
//         fontSize: '0.875rem',
//         borderBottomColor: variables.tableBorderColor
//       }
//     }
//   };
// };

// var overrideMuiTableContainer = function overrideMuiTableContainer() {
//   return {
//     styleOverrides: {
//       root: {
//         padding: '0rem 1rem 1rem'
//       }
//     }
//   };
// };

// var overrideMuiAlert = function overrideMuiAlert(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         borderRadius: '0rem',
//         padding: '0.25rem 1rem',
//         '& .MuiAlert-action': {
//           padding: '0rem 0rem 0rem 1rem',
//           'align-items': 'center'
//         }
//       },
//       icon: {
//         fontSize: '1.25rem'
//       },
//       message: {
//         fontSize: '0.875rem'
//       },
//       outlinedSuccess: {
//         color: curriedDarken$1(0.2, variables.brandSuccess),
//         border: '0.0625rem solid',
//         backgroundColor: curriedLighten$1(0.5, variables.brandSuccess),
//         borderColor: variables.brandSuccess,
//         '& .MuiAlert-icon': {
//           color: variables.brandSuccess
//         }
//       },
//       outlinedInfo: {
//         color: curriedDarken$1(0.2, variables.brandInfo),
//         border: '0.0625rem solid',
//         backgroundColor: curriedLighten$1(0.5, variables.brandInfo),
//         borderColor: variables.brandInfo,
//         '& .MuiAlert-icon': {
//           color: variables.brandInfo
//         }
//       },
//       outlinedWarning: {
//         color: curriedDarken$1(0.2, variables.brandWarning),
//         border: '0.0625rem solid',
//         backgroundColor: curriedLighten$1(0.65, variables.brandWarning),
//         borderColor: variables.brandWarning,
//         '& .MuiAlert-icon': {
//           color: variables.brandWarning
//         }
//       },
//       outlinedError: {
//         color: curriedDarken$1(0.2, variables.brandDanger),
//         border: '0.0625rem solid',
//         backgroundColor: curriedLighten$1(0.5, variables.brandDanger),
//         borderColor: variables.brandDanger,
//         '& .MuiAlert-icon': {
//           color: variables.brandDanger
//         }
//       }
//     }
//   };
// };

// var overrideMuiIconButton = function overrideMuiIconButton(variables) {
//   return {
//     styleOverrides: {
//       primary: {
//         color: variables.btnPrimaryBg
//       },
//       colorInherit: {
//         color: 'inherit'
//       },
//       sizeSmall: {
//         padding: '0.188rem'
//       }
//     }
//   };
// };

// var overrideMuiFormControlLabel = function overrideMuiFormControlLabel(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         color: variables.textColor
//       },
//       label: {
//         '&.Mui-disabled': {
//           color: alpha$1(variables.textColor, 0.5)
//         }
//       }
//     }
//   };
// };

// var overrideMuiPickersCalendarHeader = function overrideMuiPickersCalendarHeader(variables) {
//   return {
//     styleOverrides: {
//       dayLabel: {
//         color: variables.textColor
//       },
//       iconButton: {
//         backgroundColor: variables.bodyBg,
//         color: variables.btnPrimaryBg,
//         '&:disabled': {
//           color: alpha$1(variables.btnPrimaryBg, 0.26)
//         }
//       }
//     }
//   };
// };

// var overrideMuiStepConnector = function overrideMuiStepConnector(variables) {
//   return {
//     styleOverrides: {
//       root: _defineProperty$C(_defineProperty$C(_defineProperty$C({
//         alternativeLabel: {
//           top: '0.5rem'
//         }
//       }, "&.".concat(stepConnectorClasses.active), {
//         '& .MuiStepConnector-line': {
//           borderColor: variables.btnPrimaryBg
//         }
//       }), "&.".concat(stepConnectorClasses.completed), {
//         '& .MuiStepConnector-line': {
//           borderColor: variables.btnPrimaryBg
//         }
//       }), '& .MuiStepConnector-line', {
//         borderColor: '#8d8d8d'
//       })
//     }
//   };
// };

// var overrideMuiStepLabel = function overrideMuiStepLabel(variables) {
//   return {
//     styleOverrides: {
//       label: _defineProperty$C(_defineProperty$C({
//         fontSize: '0.875rem',
//         color: variables.textColor
//       }, "&.".concat(stepLabelClasses.completed), {
//         color: variables.textColor
//       }), "&.".concat(stepLabelClasses.active), {
//         color: variables.textColor,
//         fontWeight: 'bold'
//       })
//     }
//   };
// };

// var overrideMuiStepIcon = function overrideMuiStepIcon(variables) {
//   return {
//     styleOverrides: {
//       root: _defineProperty$C(_defineProperty$C({
//         fontSize: 'larger',
//         color: '#8d8d8d'
//       }, "&.".concat(stepIconClasses.active), {
//         color: variables.btnPrimaryBg
//       }), "&.".concat(stepIconClasses.completed), {
//         color: variables.btnPrimaryBg
//       }),
//       text: {
//         fill: variables.bodyBg
//       }
//     }
//   };
// };

// var overrideMuiStepper = function overrideMuiStepper(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         padding: 24,
//         backgroundColor: 'inherit'
//       }
//     }
//   };
// };

// var overrideMuiLink = function overrideMuiLink(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         color: variables.btnPrimaryBg,
//         fontSize: '0.875rem',
//         fontWeight: 'Bold',
//         '&.Mui-focusVisible': {
//           outline: 'none',
//           textDecoration: 'underline'
//         }
//       }
//     }
//   };
// };

// var overrideMuiTableRow = function overrideMuiTableRow(variables) {
//   return {
//     styleOverrides: {
//       hover: {
//         color: variables.tableBgHover
//       }
//     }
//   };
// };

// var overrideMuiAccordion = function overrideMuiAccordion(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         backgroundColor: variables.bodyBg
//       }
//     }
//   };
// };

// var overrideMuiAccordionDetails = function overrideMuiAccordionDetails(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         color: variables.textColor
//       }
//     }
//   };
// };

// var overrideMuiAccordionSummary = function overrideMuiAccordionSummary(variables) {
//   return {
//     styleOverrides: {
//       root: {
//         '& .MuiAccordionSummary-expandIconWrapper': {
//           color: variables.textColor
//         },
//         '& .MuiAccordionSummary-content': {
//           color: variables.textColor
//         }
//       }
//     }
//   };
// };

// var convertToPxNumber = function convertToPxNumber(size) {
//   if (size.includes('px')) return parseInt(size, 10);
//   if (size.includes('rem')) return parseInt(size, 10) * 16;
//   return parseInt(size, 10);
// };
// var buildMuiTheme = function buildMuiTheme(variables) {
//   var muiTheme = createTheme$1({
//     palette: {
//       primary: {
//         main: variables.btnPrimaryBg
//       },
//       secondary: {
//         main: '#8cd136'
//       }
//     },
//     typography: {
//       fontFamily: variables.fontFamilyBase,
//       fontSize: convertToPxNumber(variables.fontSizeBase)
//     },
//     spacing: function spacing(factor) {
//       return "".concat(0.25 * factor, "rem");
//     }
//     // Ex: theme.spacing(2);  = 0.25 * 2rem = 0.5rem = 8px
//   });
//   muiTheme.components.MuiButton = overrideMuiButton(variables, muiTheme.spacing);
//   muiTheme.components.MuiMenuItem = overrideMuiMenuItem();
//   muiTheme.components.MuiSvgIcon = overrideMuiSvgIcon();
//   muiTheme.components.MuiListItem = overrideMuiListItem();
//   muiTheme.components.MuiList = overrideMuiList();
//   muiTheme.components.MuiGrid = overrideMuiGrid();
//   muiTheme.components.MuiInputLabel = overrideMuiLabel(variables);
//   muiTheme.components.MuiInput = overrideMuiInput();
//   muiTheme.components.MuiSwitch = overrideMuiSwitch(variables);
//   muiTheme.components.MuiRadio = overrideMuiRadio(variables);
//   muiTheme.components.MuiInputBase = overrideMuiInputBase(variables);
//   muiTheme.components.MuiOutlinedInput = overrideMuiOutlinedInput(variables);
//   muiTheme.components.MuiPickersDay = overrideMuiPickersDay(variables);
//   muiTheme.components.MuiFormHelperText = overrideMuiFormHelperText(variables);
//   muiTheme.components.MuiFormLabel = overrideMuiFormLabel(variables);
//   muiTheme.components.MuiAutocomplete = overrideMuiAutoComplete(variables);
//   muiTheme.components.MuiPickersToolbar = overrideMuiPickersToolbar(variables);
//   muiTheme.components.MuiPickersToolbarText = overrideMuiPickersToolbarText(variables);
//   muiTheme.components.MuiPickersYear = overrideMuiPickersYear(variables);
//   muiTheme.components.MuiPickersClock = overrideMuiPickersClock(variables);
//   muiTheme.components.MuiPickersClockNumber = overrideMuiPickersClockNumber(variables);
//   muiTheme.components.MuiTypography = overrideMuiTypography();
//   muiTheme.components.MuiFab = overrideMuiFab(variables);
//   muiTheme.components.MuiChip = overrideMuiChip(variables);
//   muiTheme.components.MuiSelect = overrideMuiSelect(variables);
//   muiTheme.components.MuiNativeSelect = overrideMuiNativeSelect(variables);
//   muiTheme.components.MuiBackdrop = overrideMuiBackdrop(variables);
//   muiTheme.components.MuiCheckbox = overrideMuiCheckbox(variables);
//   muiTheme.components.MuiFormControl = overrideMuiFormControl();
//   muiTheme.components.MuiPaper = overrideMuiPaper(variables);
//   muiTheme.components.MuiTableCell = overrideMuiTableCell(variables);
//   muiTheme.components.MuiTableContainer = overrideMuiTableContainer();
//   muiTheme.components.MuiAlert = overrideMuiAlert(variables);
//   muiTheme.components.MuiIconButton = overrideMuiIconButton(variables);
//   muiTheme.components.MuiFormControlLabel = overrideMuiFormControlLabel(variables);
//   muiTheme.components.MuiPickersCalendarHeader = overrideMuiPickersCalendarHeader(variables);
//   muiTheme.components.MuiStepConnector = overrideMuiStepConnector(variables);
//   muiTheme.components.MuiStepLabel = overrideMuiStepLabel(variables);
//   muiTheme.components.MuiStepIcon = overrideMuiStepIcon(variables);
//   muiTheme.components.MuiStepper = overrideMuiStepper();
//   muiTheme.components.MuiLink = overrideMuiLink(variables);
//   muiTheme.components.MuiTableRow = overrideMuiTableRow(variables);
//   muiTheme.components.MuiAccordion = overrideMuiAccordion(variables);
//   muiTheme.components.MuiAccordionDetails = overrideMuiAccordionDetails(variables);
//   muiTheme.components.MuiAccordionSummary = overrideMuiAccordionSummary(variables);
//   return muiTheme;
// };

// // ----------------------------------------------------------------------

// function Theme(variables) {
//   var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
//   var vars = variables;
//   if (!variables) vars = defaultVariables;
//   var muiTheme = buildMuiTheme(vars);
//   return _objectSpread2$1(_objectSpread2$1({}, muiTheme), {}, {
//     variables: _objectSpread2$1({}, vars),
//     direction: isRTL ? 'rtl' : 'ltr'
//   });
// }

// var _templateObject$1, _templateObject2$1, _templateObject3;
// var Label = styled(FormLabel)(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral$1(["\n  margin-top: 0.625rem;\n"])));
// styled(Label)(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral$1(["\n  font-weight: normal;\n"])));
// var AnswerDiv = styled.div(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral$1(["\n  margin-top: 0.938rem;\n"])));

// /**
//  * TrueOrFalse component used in Question types
//  *
//  */
// var TrueOrFalse = function TrueOrFalse(_ref) {
//   var translations = _ref.translations,
//     onAnother = _ref.onAnother,
//     onDone = _ref.onDone,
//     onCancel = _ref.onCancel,
//     editData = _ref.editData,
//     isEdit = _ref.isEdit,
//     translationMode = _ref.translationMode,
//     disableAction = _ref.disableAction;
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     questionCode = _useState2[0],
//     setQuestionCode = _useState2[1];
//   var _useState3 = useState$1(''),
//     _useState4 = _slicedToArray$b(_useState3, 2),
//     question = _useState4[0],
//     setQuestion = _useState4[1];
//   var _useState5 = useState$1(''),
//     _useState6 = _slicedToArray$b(_useState5, 2),
//     questionFeedback = _useState6[0],
//     setQuestionFeedback = _useState6[1];
//   var _useState7 = useState$1(true),
//     _useState8 = _slicedToArray$b(_useState7, 2),
//     buttonDisable = _useState8[0],
//     setButtonDisable = _useState8[1];
//   var _useState9 = useState$1(true),
//     _useState10 = _slicedToArray$b(_useState9, 2),
//     buttonUpdateDisable = _useState10[0],
//     setButtonUpdateDisable = _useState10[1];
//   var _useState11 = useState$1(''),
//     _useState12 = _slicedToArray$b(_useState11, 2),
//     choice = _useState12[0],
//     setChoice = _useState12[1];
//   var _useState13 = useState$1(),
//     _useState14 = _slicedToArray$b(_useState13, 2),
//     choiceEditor = _useState14[0],
//     setChoiceEditor = _useState14[1];
//   var _useState15 = useState$1(''),
//     _useState16 = _slicedToArray$b(_useState15, 2),
//     choiceFeedback = _useState16[0],
//     setChoiceFeedback = _useState16[1];
//   var _useState17 = useState$1(),
//     _useState18 = _slicedToArray$b(_useState17, 2),
//     choiceFeedbackEditor = _useState18[0],
//     setChoiceFeedbackEditor = _useState18[1];
//   var _useState19 = useState$1(false),
//     _useState20 = _slicedToArray$b(_useState19, 2),
//     setChoiceValidation = _useState20[1];
//   var _useState21 = useState$1(''),
//     _useState22 = _slicedToArray$b(_useState21, 2),
//     currentID = _useState22[0],
//     setCurrentID = _useState22[1];
//   var _useState23 = useState$1([]),
//     _useState24 = _slicedToArray$b(_useState23, 2),
//     setRows = _useState24[1];
//   var _useState25 = useState$1([]),
//     _useState26 = _slicedToArray$b(_useState25, 1),
//     data = _useState26[0];

//   // Refs to store CKEditor instances
//   var choiceEditorRef = useRef$2(null);
//   var choiceFeedbackEditorRef = useRef$2(null);
//   var questionCodeChange = function questionCodeChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionCode(value);
//     }
//   };
//   var questionChange = function questionChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestion(value);
//       disableHandler(value === null || value === void 0 ? void 0 : value.length);
//     }
//   };
//   var questionFeedbackChange = function questionFeedbackChange(value) {
//     if (value !== null && value !== undefined) {
//       setQuestionFeedback(value);
//     }
//   };
//   var choiceChange = function choiceChange(event) {
//     if (event !== undefined) {
//       setChoiceValidation(false);
//       setChoice(event.editor.getData());
//       setChoiceEditor(event);
//     }
//   };
//   var choiceFeedbackChange = function choiceFeedbackChange(event) {
//     if (event !== undefined) {
//       setChoiceFeedback(event.editor.getData());
//       setChoiceFeedbackEditor(event);
//     }
//   };
//   var setCorrectItem = function setCorrectItem(dataID) {
//     if (dataID !== null && dataID !== '' && dataID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         element.correct = f.id === dataID;
//       });
//     }
//     setRows([]);
//   };
//   var disableHandler = function disableHandler(questionLength) {
//     if (questionLength === 0) {
//       setButtonDisable(true);
//     } else {
//       setButtonDisable(false);
//     }
//   };
//   var reset = function reset() {
//     setChoiceValidation(false);
//     if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//       choiceEditor.editor.setData('');
//     }
//     if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//       choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//     }
//     setChoiceFeedback('');
//     setChoice('');
//     setCurrentID('');
//     setButtonUpdateDisable(true);
//     setRows([]);
//     disableHandler(question.length);
//   };
//   var updateItem = function updateItem() {
//     if (choice === '' || choice === null || choice === undefined) {
//       setChoiceValidation(true);
//     }
//     if (currentID !== null && currentID !== '' && currentID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         if (f.id === currentID) {
//           element.choice = choice;
//           element.feedback = choiceFeedback;
//         }
//       });
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//       setChoiceFeedback('');
//       setChoice('');
//       setCurrentID('');
//       setButtonUpdateDisable(true);
//     }
//     setRows([]);
//   };
//   var selectItem = function selectItem(ID) {
//     if (ID !== null && ID !== '' && ID !== undefined) {
//       data.forEach(function (f) {
//         var element = f;
//         if (f.id === ID) {
//           if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//             var _choiceEditor$editor;
//             choiceEditor === null || choiceEditor === void 0 || (_choiceEditor$editor = choiceEditor.editor) === null || _choiceEditor$editor === void 0 || _choiceEditor$editor.setData(element.choice);
//           }
//           if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//             var _choiceFeedbackEditor;
//             choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || (_choiceFeedbackEditor = choiceFeedbackEditor.editor) === null || _choiceFeedbackEditor === void 0 || _choiceFeedbackEditor.setData(element.feedback);
//           }
//           setChoice(element.choice);
//           setChoiceFeedback(element.feedback);
//         }
//       });
//       setCurrentID(ID);
//       setButtonUpdateDisable(false);
//     }
//     setRows([]);
//   };
//   useEffect$2(function () {
//     if (editData && isEdit) {
//       setQuestionCode(editData.Code);
//       setQuestion(editData.QuestionText);
//       setQuestionFeedback(editData.QuestionFeedback);
//       data.length = 0;
//       if (editData.Options) {
//         editData.Options.forEach(function (value) {
//           data.push({
//             id: value.AnswerID[0],
//             choice: value.AnswerText[0],
//             correct: value.IsCorrect,
//             feedback: value.Feedback
//           });
//         });
//         setButtonDisable(false);
//       }
//       if ((choiceEditor === null || choiceEditor === void 0 ? void 0 : choiceEditor.editor) !== undefined) {
//         choiceEditor.editor.setData('');
//       }
//       if ((choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 ? void 0 : choiceFeedbackEditor.editor) !== undefined) {
//         choiceFeedbackEditor === null || choiceFeedbackEditor === void 0 || choiceFeedbackEditor.editor.setData('');
//       }
//     } else {
//       data.push({
//         id: 0,
//         choice: 'True',
//         score: '',
//         correct: true,
//         feedback: ''
//       });
//       data.push({
//         id: 1,
//         choice: 'False',
//         score: '',
//         correct: false,
//         feedback: ''
//       });
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [editData]);
//   var buildQuestionObject = function buildQuestionObject() {
//     var questionObject = {
//       Code: questionCode,
//       QuestionText: question,
//       QuestionTextFmt: question,
//       QuestionType: null,
//       QuestionFeedback: questionFeedback,
//       Options: [],
//       Status: null
//     };
//     data.forEach(function (el) {
//       questionObject.Options.push({
//         AnswerID: [el.id.toString()],
//         // Shuffle: !notRandomizeChoices,
//         WeightPercent: null,
//         AnswerText: [el.choice],
//         MatchAnswerID: el.id.toString(),
//         MatchAnswerText: '',
//         Feedback: el.feedback,
//         IsCorrect: el.correct,
//         IsCaseSensitive: false,
//         QuestionBankType: null
//       });
//     });
//     return questionObject;
//   };
//   var doneClick = function doneClick() {
//     var requestObj = buildQuestionObject();
//     onDone(requestObj);
//   };
//   var anotherClick = function anotherClick() {
//     var requestObj = buildQuestionObject();
//     onAnother(requestObj);
//   };
//   var cancelClick = function cancelClick() {
//     onCancel();
//   };
//   return /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(QuestionFeedback, {
//     onCodeChange: questionCodeChange,
//     onQuestionChange: questionChange,
//     onFeedbackChange: questionFeedbackChange,
//     codeLabel: translations.CODE_LABEL,
//     questionLabel: translations.QUESTION_LABEL,
//     questionMaximumLabel: translations.QUESTION_MAX_LABEL,
//     questionFeedbackLabel: translations.QUESTION_FEEDBACK_LABEL,
//     editData: editData,
//     translationMode: translationMode
//   }), /*#__PURE__*/React__default.createElement(AnswerDiv, {
//     id: "answer-feedback"
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label, {
//     item: true
//   }, translations.ANSWER_LABEL))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(BasicTableContainer, null, /*#__PURE__*/React__default.createElement(BasicTable, null, /*#__PURE__*/React__default.createElement(BasicTableHead, null, /*#__PURE__*/React__default.createElement(BasicTableRow, null, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label, {
//     item: true
//   }, translations.CHOICE_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label, {
//     item: true
//   }, translations.CORRECT_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label, {
//     item: true
//   }, translations.FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(Label, {
//     item: true
//   }, translations.ACTIONS_LABEL)))), /*#__PURE__*/React__default.createElement(BasicTableBody, null, data.map(function (d) {
//     return /*#__PURE__*/React__default.createElement(BasicTableRow, {
//       key: d.id
//     }, /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.choice)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("input", {
//       type: "radio",
//       checked: d.correct,
//       disabled: translationMode,
//       onChange: function onChange() {
//         return setCorrectItem(d.id);
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement("span", {
//       // eslint-disable-next-line react/no-danger
//       dangerouslySetInnerHTML: {
//         __html: purify.sanitize(d.feedback)
//       }
//     })), /*#__PURE__*/React__default.createElement(BasicTableCell, null, /*#__PURE__*/React__default.createElement(IconButton, {
//       color: "primary",
//       label: translations.UPDATE_LABEL,
//       id: "select-question",
//       onClick: function onClick(e) {
//         selectItem(d.id);
//       }
//     }, /*#__PURE__*/React__default.createElement(MaterialIcon, {
//       iconName: "Edit"
//     }))));
//   }))))), /*#__PURE__*/React__default.createElement(FlexGrid, null, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-start",
//     justify: "space-between"
//   }, /*#__PURE__*/React__default.createElement(Label, {
//     item: true
//   }, translations.CHOICE_HEADING))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "choice",
//     onChange: function onChange(event) {
//       return choiceChange(event);
//     },
//     onReady: function onReady(editor) {
//       setChoiceEditor(editor);
//       choiceEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(Label, {
//     item: true
//   }, translations.CHOICE_FEEDBACK_LABEL)), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     item: true
//   }, /*#__PURE__*/React__default.createElement(RichTextEditor, {
//     name: "choice-feedback",
//     onChange: function onChange(event) {
//       return choiceFeedbackChange(event);
//     },
//     onReady: function onReady(editor) {
//       setChoiceFeedbackEditor(editor);
//       choiceFeedbackEditorRef.current = editor;
//     }
//   })), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "update",
//     disabled: buttonUpdateDisable,
//     onClick: function onClick() {
//       return updateItem();
//     }
//   }, translations.UPDATE_LABEL), "\xA0", !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "reset",
//     onClick: function onClick() {
//       return reset();
//     }
//   }, translations.RESET_LABEL)))))), /*#__PURE__*/React__default.createElement(FlexGrid, {
//     container: true,
//     direction: "row",
//     alignItems: "flex-end",
//     justify: "flex-end"
//   }, /*#__PURE__*/React__default.createElement(AnswerDiv, null, !translationMode && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "another",
//     disabled: buttonDisable,
//     onClick: anotherClick
//   }, translations.ANOTHER_LABEL)), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "done",
//     disabled: buttonDisable || disableAction,
//     onClick: doneClick
//   }, translations.DONE_LABEL), "\xA0", /*#__PURE__*/React__default.createElement(Button$1, {
//     type: "button",
//     id: "cancel",
//     onClick: cancelClick
//   }, translations.CANCEL_LABEL)))));
// };
// var optionsPropTypes = {
//   AnswerID: PropTypes__default.arrayOf(PropTypes__default.string),
//   AnswerText: PropTypes__default.arrayOf(PropTypes__default.string),
//   Feedback: PropTypes__default.string,
//   MatchAnswerText: PropTypes__default.string,
//   WeightPercent: PropTypes__default.string,
//   IsCorrect: PropTypes__default.bool,
//   IsCaseSensitive: PropTypes__default.bool,
//   Shuffle: PropTypes__default.bool
// };
// var editDataPropTypes = {
//   QuestionType: PropTypes__default.number,
//   Code: PropTypes__default.string,
//   QuestionText: PropTypes__default.string,
//   QuestionFeedback: PropTypes__default.string,
//   Options: PropTypes__default.arrayOf(PropTypes__default.shape(optionsPropTypes))
// };
// TrueOrFalse.propTypes = {
//   /**
//    * isEdit defines that it is Edit mode
//    */
//   isEdit: PropTypes__default.bool,
//   /**
//    * editData contains all data for edit
//    */
//   editData: PropTypes__default.shape(editDataPropTypes),
//   /**
//    * onDone callback function to pass request object
//    */
//   onDone: PropTypes__default.func.isRequired,
//   /**
//    * onAnother callback function to pass request object
//    */
//   onAnother: PropTypes__default.func.isRequired,
//   /**
//    * onCancel callback function
//    */
//   onCancel: PropTypes__default.func.isRequired,
//   /**
//    * translations contains all string translations for TrueOrFalse
//    */
//   translations: PropTypes__default.objectOf(PropTypes__default.string),
//   /**
//    *   Action type translate based on this prop value disabling some of the input fields 
//   // which should not editable while adding the translated question from the base question
//   */
//   translationMode: PropTypes__default.bool,
//   /**
//    * Disables done button if language dropdown has value '-1'
//    */
//   disableAction: PropTypes__default.bool
// };
// TrueOrFalse.defaultProps = {
//   translations: {
//     CODE_LABEL: 'Question Code:',
//     QUESTION_LABEL: 'Question: *',
//     QUESTION_MAX_LABEL: 'Question maximum: 4000 characters',
//     QUESTION_FEEDBACK_LABEL: 'Question Feedback:',
//     ANSWER_LABEL: 'Answer: *',
//     CHOICE_LABEL: 'Choice',
//     CHOICE_HEADING: 'Choice: *',
//     CORRECT_LABEL: 'Correct',
//     FEEDBACK_LABEL: 'Feedback',
//     ACTIONS_LABEL: 'Actions',
//     CHOICE_FEEDBACK_LABEL: 'Choice Feedback:',
//     UPDATE_LABEL: 'UPDATE',
//     RESET_LABEL: 'RESET',
//     ANOTHER_LABEL: 'ADD ANOTHER QUESTION',
//     DONE_LABEL: 'DONE',
//     CANCEL_LABEL: 'CANCEL'
//   },
//   isEdit: false,
//   editData: undefined,
//   translationMode: false,
//   disableAction: false
// };

// var _templateObject, _templateObject2;
// var HeaderSection = styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral$1(["\n  height: ", ";\n"])), function (props) {
//   return props.headerHeight;
// });
// var BodySection = styled.div(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral$1(["\n  margin: 30px;\n  position: relative;\n  height: 100%;\n  width: 100%;\n"])));

// /**
// -AppLayout with a header section and body section
// * */
// function AppLayout(_ref) {
//   var headerHeight = _ref.headerHeight,
//     headerElements = _ref.headerElements,
//     bodyElements = _ref.bodyElements;
//   return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, headerElements ? /*#__PURE__*/React__default.createElement(HeaderSection, {
//     headerHeight: headerHeight
//   }, headerElements) : null, bodyElements ? /*#__PURE__*/React__default.createElement(BodySection, null, bodyElements) : null);
// }
// AppLayout.propTypes = {
//   /**
//    * height of header
//    */
//   headerHeight: PropTypes__default.string,
//   /**
//    * header elements
//    */
//   headerElements: PropTypes__default.node,
//   /**
//    * body elements
//    */
//   bodyElements: PropTypes__default.node
// };
// AppLayout.defaultProps = {
//   headerHeight: '42px',
//   headerElements: null,
//   bodyElements: null
// };

// /**
//  * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
//  * `date` as it will be rendered in the `timeZone`.
//  */
// function tzTokenizeDate(date, timeZone) {
//   var dtf = getDateTimeFormat(timeZone);
//   return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date)
// }

// var typeToPos = {
//   year: 0,
//   month: 1,
//   day: 2,
//   hour: 3,
//   minute: 4,
//   second: 5,
// };

// function partsOffset(dtf, date) {
//   try {
//     var formatted = dtf.formatToParts(date);
//     var filled = [];
//     for (var i = 0; i < formatted.length; i++) {
//       var pos = typeToPos[formatted[i].type];

//       if (pos >= 0) {
//         filled[pos] = parseInt(formatted[i].value, 10);
//       }
//     }
//     return filled
//   } catch (error) {
//     if (error instanceof RangeError) {
//       return [NaN]
//     }
//     throw error
//   }
// }

// function hackyOffset(dtf, date) {
//   var formatted = dtf.format(date).replace(/\u200E/g, '');
//   var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
//   // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
//   // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]
//   return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]]
// }

// // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
// // to get deterministic local date/time output according to the `en-US` locale which
// // can be used to extract local time parts as necessary.
// var dtfCache = {};
// function getDateTimeFormat(timeZone) {
//   if (!dtfCache[timeZone]) {
//     // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
//     var testDateFormatted = new Intl.DateTimeFormat('en-US', {
//       hour12: false,
//       timeZone: 'America/New_York',
//       year: 'numeric',
//       month: 'numeric',
//       day: '2-digit',
//       hour: '2-digit',
//       minute: '2-digit',
//       second: '2-digit',
//     }).format(new Date('2014-06-25T04:00:00.123Z'));
//     var hourCycleSupported =
//       testDateFormatted === '06/25/2014, 00:00:00' ||
//       testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00';

//     dtfCache[timeZone] = hourCycleSupported
//       ? new Intl.DateTimeFormat('en-US', {
//           hour12: false,
//           timeZone: timeZone,
//           year: 'numeric',
//           month: 'numeric',
//           day: '2-digit',
//           hour: '2-digit',
//           minute: '2-digit',
//           second: '2-digit',
//         })
//       : new Intl.DateTimeFormat('en-US', {
//           hourCycle: 'h23',
//           timeZone: timeZone,
//           year: 'numeric',
//           month: 'numeric',
//           day: '2-digit',
//           hour: '2-digit',
//           minute: '2-digit',
//           second: '2-digit',
//         });
//   }
//   return dtfCache[timeZone]
// }

// /**
//  * Use instead of `new Date(Date.UTC(...))` to support years below 100 which doesn't work
//  * otherwise due to the nature of the
//  * [`Date` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years.
//  *
//  * For `Date.UTC(...)`, use `newDateUTC(...).getTime()`.
//  */
// function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
//   var utcDate = new Date(0);
//   utcDate.setUTCFullYear(fullYear, month, day);
//   utcDate.setUTCHours(hour, minute, second, millisecond);
//   return utcDate
// }

// var MILLISECONDS_IN_HOUR$1 = 3600000;
// var MILLISECONDS_IN_MINUTE$1 = 60000;

// var patterns$1 = {
//   timezone: /([Z+-].*)$/,
//   timezoneZ: /^(Z)$/,
//   timezoneHH: /^([+-]\d{2})$/,
//   timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/,
// };

// // Parse various time zone offset formats to an offset in milliseconds
// function tzParseTimezone(timezoneString, date, isUtcDate) {
//   var token;
//   var absoluteOffset;

//   // Empty string
//   if (!timezoneString) {
//     return 0
//   }

//   // Z
//   token = patterns$1.timezoneZ.exec(timezoneString);
//   if (token) {
//     return 0
//   }

//   var hours;

//   // ±hh
//   token = patterns$1.timezoneHH.exec(timezoneString);
//   if (token) {
//     hours = parseInt(token[1], 10);

//     if (!validateTimezone(hours)) {
//       return NaN
//     }

//     return -(hours * MILLISECONDS_IN_HOUR$1)
//   }

//   // ±hh:mm or ±hhmm
//   token = patterns$1.timezoneHHMM.exec(timezoneString);
//   if (token) {
//     hours = parseInt(token[1], 10);
//     var minutes = parseInt(token[2], 10);

//     if (!validateTimezone(hours, minutes)) {
//       return NaN
//     }

//     absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$1;
//     return hours > 0 ? -absoluteOffset : absoluteOffset
//   }

//   // IANA time zone
//   if (isValidTimezoneIANAString(timezoneString)) {
//     date = new Date(date || Date.now());
//     var utcDate = isUtcDate ? date : toUtcDate(date);

//     var offset = calcOffset(utcDate, timezoneString);

//     var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);

//     return -fixedOffset
//   }

//   return NaN
// }

// function toUtcDate(date) {
//   return newDateUTC(
//     date.getFullYear(),
//     date.getMonth(),
//     date.getDate(),
//     date.getHours(),
//     date.getMinutes(),
//     date.getSeconds(),
//     date.getMilliseconds()
//   )
// }

// function calcOffset(date, timezoneString) {
//   var tokens = tzTokenizeDate(date, timezoneString);

//   // ms dropped because it's not provided by tzTokenizeDate
//   var asUTC = newDateUTC(
//     tokens[0],
//     tokens[1] - 1,
//     tokens[2],
//     tokens[3] % 24,
//     tokens[4],
//     tokens[5],
//     0
//   ).getTime();

//   var asTS = date.getTime();
//   var over = asTS % 1000;
//   asTS -= over >= 0 ? over : 1000 + over;
//   return asUTC - asTS
// }

// function fixOffset(date, offset, timezoneString) {
//   var localTS = date.getTime();

//   // Our UTC time is just a guess because our offset is just a guess
//   var utcGuess = localTS - offset;

//   // Test whether the zone matches the offset for this ts
//   var o2 = calcOffset(new Date(utcGuess), timezoneString);

//   // If so, offset didn't change, and we're done
//   if (offset === o2) {
//     return offset
//   }

//   // If not, change the ts by the difference in the offset
//   utcGuess -= o2 - offset;

//   // If that gives us the local time we want, we're done
//   var o3 = calcOffset(new Date(utcGuess), timezoneString);
//   if (o2 === o3) {
//     return o2
//   }

//   // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time
//   return Math.max(o2, o3)
// }

// function validateTimezone(hours, minutes) {
//   return -23 <= hours && hours <= 23 && (minutes == null || (0 <= minutes && minutes <= 59))
// }

// var validIANATimezoneCache = {};
// function isValidTimezoneIANAString(timeZoneString) {
//   if (validIANATimezoneCache[timeZoneString]) return true
//   try {
//     new Intl.DateTimeFormat(undefined, { timeZone: timeZoneString });
//     validIANATimezoneCache[timeZoneString] = true;
//     return true
//   } catch (error) {
//     return false
//   }
// }

// /** Regex to identify the presence of a time zone specifier in a date string */
// var tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;

// var MILLISECONDS_IN_HOUR = 3600000;
// var MILLISECONDS_IN_MINUTE = 60000;
// var DEFAULT_ADDITIONAL_DIGITS = 2;

// var patterns = {
//   dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
//   datePattern: /^([0-9W+-]+)(.*)/,
//   plainTime: /:/,

//   // year tokens
//   YY: /^(\d{2})$/,
//   YYY: [
//     /^([+-]\d{2})$/, // 0 additional digits
//     /^([+-]\d{3})$/, // 1 additional digit
//     /^([+-]\d{4})$/, // 2 additional digits
//   ],
//   YYYY: /^(\d{4})/,
//   YYYYY: [
//     /^([+-]\d{4})/, // 0 additional digits
//     /^([+-]\d{5})/, // 1 additional digit
//     /^([+-]\d{6})/, // 2 additional digits
//   ],

//   // date tokens
//   MM: /^-(\d{2})$/,
//   DDD: /^-?(\d{3})$/,
//   MMDD: /^-?(\d{2})-?(\d{2})$/,
//   Www: /^-?W(\d{2})$/,
//   WwwD: /^-?W(\d{2})-?(\d{1})$/,

//   HH: /^(\d{2}([.,]\d*)?)$/,
//   HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
//   HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,

//   // time zone tokens (to identify the presence of a tz)
//   timeZone: tzPattern,
// };

// /**
//  * @name toDate
//  * @category Common Helpers
//  * @summary Convert the given argument to an instance of Date.
//  *
//  * @description
//  * Convert the given argument to an instance of Date.
//  *
//  * If the argument is an instance of Date, the function returns its clone.
//  *
//  * If the argument is a number, it is treated as a timestamp.
//  *
//  * If an argument is a string, the function tries to parse it.
//  * Function accepts complete ISO 8601 formats as well as partial implementations.
//  * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
//  * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
//  *
//  * If the argument is none of the above, the function returns Invalid Date.
//  *
//  * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
//  * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
//  *
//  * @param {Date|String|Number} argument - the value to convert
//  * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
//  * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
//  * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
//  * @returns {Date} the parsed date in the local time zone
//  * @throws {TypeError} 1 argument required
//  * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
//  *
//  * @example
//  * // Convert string '2014-02-11T11:30:30' to date:
//  * var result = toDate('2014-02-11T11:30:30')
//  * //=> Tue Feb 11 2014 11:30:30
//  *
//  * @example
//  * // Convert string '+02014101' to date,
//  * // if the additional number of digits in the extended year format is 1:
//  * var result = toDate('+02014101', {additionalDigits: 1})
//  * //=> Fri Apr 11 2014 00:00:00
//  */
// function toDate(argument, dirtyOptions) {
//   if (arguments.length < 1) {
//     throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
//   }

//   if (argument === null) {
//     return new Date(NaN)
//   }

//   var options = dirtyOptions || {};

//   var additionalDigits =
//     options.additionalDigits == null
//       ? DEFAULT_ADDITIONAL_DIGITS
//       : toInteger$1(options.additionalDigits);
//   if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
//     throw new RangeError('additionalDigits must be 0, 1 or 2')
//   }

//   // Clone the date
//   if (
//     argument instanceof Date ||
//     (typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]')
//   ) {
//     // Prevent the date to lose the milliseconds when passed to new Date() in IE10
//     return new Date(argument.getTime())
//   } else if (
//     typeof argument === 'number' ||
//     Object.prototype.toString.call(argument) === '[object Number]'
//   ) {
//     return new Date(argument)
//   } else if (
//     !(
//       typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]'
//     )
//   ) {
//     return new Date(NaN)
//   }

//   var dateStrings = splitDateString(argument);

//   var parseYearResult = parseYear(dateStrings.date, additionalDigits);
//   var year = parseYearResult.year;
//   var restDateString = parseYearResult.restDateString;

//   var date = parseDate(restDateString, year);

//   if (isNaN(date)) {
//     return new Date(NaN)
//   }

//   if (date) {
//     var timestamp = date.getTime();
//     var time = 0;
//     var offset;

//     if (dateStrings.time) {
//       time = parseTime(dateStrings.time);

//       if (isNaN(time)) {
//         return new Date(NaN)
//       }
//     }

//     if (dateStrings.timeZone || options.timeZone) {
//       offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
//       if (isNaN(offset)) {
//         return new Date(NaN)
//       }
//     } else {
//       // get offset accurate to hour in time zones that change offset
//       offset = getTimezoneOffsetInMilliseconds$1(new Date(timestamp + time));
//       offset = getTimezoneOffsetInMilliseconds$1(new Date(timestamp + time + offset));
//     }

//     return new Date(timestamp + time + offset)
//   } else {
//     return new Date(NaN)
//   }
// }

// function splitDateString(dateString) {
//   var dateStrings = {};
//   var parts = patterns.dateTimePattern.exec(dateString);
//   var timeString;

//   if (!parts) {
//     parts = patterns.datePattern.exec(dateString);
//     if (parts) {
//       dateStrings.date = parts[1];
//       timeString = parts[2];
//     } else {
//       dateStrings.date = null;
//       timeString = dateString;
//     }
//   } else {
//     dateStrings.date = parts[1];
//     timeString = parts[3];
//   }

//   if (timeString) {
//     var token = patterns.timeZone.exec(timeString);
//     if (token) {
//       dateStrings.time = timeString.replace(token[1], '');
//       dateStrings.timeZone = token[1].trim();
//     } else {
//       dateStrings.time = timeString;
//     }
//   }

//   return dateStrings
// }

// function parseYear(dateString, additionalDigits) {
//   var patternYYY = patterns.YYY[additionalDigits];
//   var patternYYYYY = patterns.YYYYY[additionalDigits];

//   var token;

//   // YYYY or ±YYYYY
//   token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
//   if (token) {
//     var yearString = token[1];
//     return {
//       year: parseInt(yearString, 10),
//       restDateString: dateString.slice(yearString.length),
//     }
//   }

//   // YY or ±YYY
//   token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
//   if (token) {
//     var centuryString = token[1];
//     return {
//       year: parseInt(centuryString, 10) * 100,
//       restDateString: dateString.slice(centuryString.length),
//     }
//   }

//   // Invalid ISO-formatted year
//   return {
//     year: null,
//   }
// }

// function parseDate(dateString, year) {
//   // Invalid ISO-formatted year
//   if (year === null) {
//     return null
//   }

//   var token;
//   var date;
//   var month;
//   var week;

//   // YYYY
//   if (dateString.length === 0) {
//     date = new Date(0);
//     date.setUTCFullYear(year);
//     return date
//   }

//   // YYYY-MM
//   token = patterns.MM.exec(dateString);
//   if (token) {
//     date = new Date(0);
//     month = parseInt(token[1], 10) - 1;

//     if (!validateDate(year, month)) {
//       return new Date(NaN)
//     }

//     date.setUTCFullYear(year, month);
//     return date
//   }

//   // YYYY-DDD or YYYYDDD
//   token = patterns.DDD.exec(dateString);
//   if (token) {
//     date = new Date(0);
//     var dayOfYear = parseInt(token[1], 10);

//     if (!validateDayOfYearDate(year, dayOfYear)) {
//       return new Date(NaN)
//     }

//     date.setUTCFullYear(year, 0, dayOfYear);
//     return date
//   }

//   // yyyy-MM-dd or YYYYMMDD
//   token = patterns.MMDD.exec(dateString);
//   if (token) {
//     date = new Date(0);
//     month = parseInt(token[1], 10) - 1;
//     var day = parseInt(token[2], 10);

//     if (!validateDate(year, month, day)) {
//       return new Date(NaN)
//     }

//     date.setUTCFullYear(year, month, day);
//     return date
//   }

//   // YYYY-Www or YYYYWww
//   token = patterns.Www.exec(dateString);
//   if (token) {
//     week = parseInt(token[1], 10) - 1;

//     if (!validateWeekDate(year, week)) {
//       return new Date(NaN)
//     }

//     return dayOfISOWeekYear(year, week)
//   }

//   // YYYY-Www-D or YYYYWwwD
//   token = patterns.WwwD.exec(dateString);
//   if (token) {
//     week = parseInt(token[1], 10) - 1;
//     var dayOfWeek = parseInt(token[2], 10) - 1;

//     if (!validateWeekDate(year, week, dayOfWeek)) {
//       return new Date(NaN)
//     }

//     return dayOfISOWeekYear(year, week, dayOfWeek)
//   }

//   // Invalid ISO-formatted date
//   return null
// }

// function parseTime(timeString) {
//   var token;
//   var hours;
//   var minutes;

//   // hh
//   token = patterns.HH.exec(timeString);
//   if (token) {
//     hours = parseFloat(token[1].replace(',', '.'));

//     if (!validateTime(hours)) {
//       return NaN
//     }

//     return (hours % 24) * MILLISECONDS_IN_HOUR
//   }

//   // hh:mm or hhmm
//   token = patterns.HHMM.exec(timeString);
//   if (token) {
//     hours = parseInt(token[1], 10);
//     minutes = parseFloat(token[2].replace(',', '.'));

//     if (!validateTime(hours, minutes)) {
//       return NaN
//     }

//     return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE
//   }

//   // hh:mm:ss or hhmmss
//   token = patterns.HHMMSS.exec(timeString);
//   if (token) {
//     hours = parseInt(token[1], 10);
//     minutes = parseInt(token[2], 10);
//     var seconds = parseFloat(token[3].replace(',', '.'));

//     if (!validateTime(hours, minutes, seconds)) {
//       return NaN
//     }

//     return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000
//   }

//   // Invalid ISO-formatted time
//   return null
// }

// function dayOfISOWeekYear(isoWeekYear, week, day) {
//   week = week || 0;
//   day = day || 0;
//   var date = new Date(0);
//   date.setUTCFullYear(isoWeekYear, 0, 4);
//   var fourthOfJanuaryDay = date.getUTCDay() || 7;
//   var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
//   date.setUTCDate(date.getUTCDate() + diff);
//   return date
// }

// // Validation functions

// var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
// var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// function isLeapYearIndex(year) {
//   return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
// }

// function validateDate(year, month, date) {
//   if (month < 0 || month > 11) {
//     return false
//   }

//   if (date != null) {
//     if (date < 1) {
//       return false
//     }

//     var isLeapYear = isLeapYearIndex(year);
//     if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
//       return false
//     }
//     if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
//       return false
//     }
//   }

//   return true
// }

// function validateDayOfYearDate(year, dayOfYear) {
//   if (dayOfYear < 1) {
//     return false
//   }

//   var isLeapYear = isLeapYearIndex(year);
//   if (isLeapYear && dayOfYear > 366) {
//     return false
//   }
//   if (!isLeapYear && dayOfYear > 365) {
//     return false
//   }

//   return true
// }

// function validateWeekDate(year, week, day) {
//   if (week < 0 || week > 52) {
//     return false
//   }

//   if (day != null && (day < 0 || day > 6)) {
//     return false
//   }

//   return true
// }

// function validateTime(hours, minutes, seconds) {
//   if (hours != null && (hours < 0 || hours >= 25)) {
//     return false
//   }

//   if (minutes != null && (minutes < 0 || minutes >= 60)) {
//     return false
//   }

//   if (seconds != null && (seconds < 0 || seconds >= 60)) {
//     return false
//   }

//   return true
// }

// /**
//  * @name utcToZonedTime
//  * @category Time Zone Helpers
//  * @summary Get a date/time representing local time in a given time zone from the UTC date
//  *
//  * @description
//  * Returns a date instance with values representing the local time in the time zone
//  * specified of the UTC time from the date provided. In other words, when the new date
//  * is formatted it will show the equivalent hours in the target time zone regardless
//  * of the current system time zone.
//  *
//  * @param {Date|String|Number} date - the date with the relevant UTC time
//  * @param {String} timeZone - the time zone to get local time for, can be an offset or IANA time zone
//  * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
//  * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
//  * @returns {Date} the new date with the equivalent time in the time zone
//  * @throws {TypeError} 2 arguments required
//  * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
//  *
//  * @example
//  * // In June 10am UTC is 6am in New York (-04:00)
//  * const result = utcToZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
//  * //=> Jun 25 2014 06:00:00
//  */
// function utcToZonedTime(dirtyDate, timeZone, options) {
//   var date = toDate(dirtyDate, options);

//   var offsetMilliseconds = tzParseTimezone(timeZone, date, true);

//   var d = new Date(date.getTime() - offsetMilliseconds);

//   var resultDate = new Date(0);

//   resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());

//   resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());

//   return resultDate
// }

// /**
//  * @name zonedTimeToUtc
//  * @category Time Zone Helpers
//  * @summary Get the UTC date/time from a date representing local time in a given time zone
//  *
//  * @description
//  * Returns a date instance with the UTC time of the provided date of which the values
//  * represented the local time in the time zone specified. In other words, if the input
//  * date represented local time in time time zone, the timestamp of the output date will
//  * give the equivalent UTC of that local time regardless of the current system time zone.
//  *
//  * @param {Date|String|Number} date - the date with values representing the local time
//  * @param {String} timeZone - the time zone of this local time, can be an offset or IANA time zone
//  * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
//  * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
//  * @returns {Date} the new date with the equivalent time in the time zone
//  * @throws {TypeError} 2 arguments required
//  * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
//  *
//  * @example
//  * // In June 10am in Los Angeles is 5pm UTC
//  * const result = zonedTimeToUtc(new Date(2014, 5, 25, 10, 0, 0), 'America/Los_Angeles')
//  * //=> 2014-06-25T17:00:00.000Z
//  */
// function zonedTimeToUtc(date, timeZone, options) {
//   if (typeof date === 'string' && !date.match(tzPattern)) {
//     var extendedOptions = cloneObject(options);
//     extendedOptions.timeZone = timeZone;
//     return toDate(date, extendedOptions)
//   }

//   var d = toDate(date, options);

//   var utc = newDateUTC(
//     d.getFullYear(),
//     d.getMonth(),
//     d.getDate(),
//     d.getHours(),
//     d.getMinutes(),
//     d.getSeconds(),
//     d.getMilliseconds()
//   ).getTime();

//   var offsetMilliseconds = tzParseTimezone(timeZone, new Date(utc));

//   return new Date(utc + offsetMilliseconds)
// }

// /**
//  * A react helper to convert UTCDate to localeDate based on timeZone
//  * @param {String} utcDateValue
//  * @param {String} timeZone
//  * @returns {Date} convertedDateTime
//  */
// var FormattedDateTimeHelper = function FormattedDateTimeHelper(utcDateValue, timeZone) {
//   var parsedDate = parseISO(utcDateValue);
//   var utcDate = zonedTimeToUtc(parsedDate, 'UTC');
//   return utcToZonedTime(utcDate, timeZone);
// };

// var CopyHelper = /*#__PURE__*/function () {
//   var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(e, ref) {
//     var copyTextarea;
//     return _regeneratorRuntime().wrap(function _callee$(_context) {
//       while (1) switch (_context.prev = _context.next) {
//         case 0:
//           copyTextarea = document.createElement('textarea');
//           copyTextarea.style.position = 'fixed';
//           copyTextarea.style.opacity = '0';
//           // when the value was empty updating the value with space for clearing prviously copied value
//           copyTextarea.textContent = ref.current.value !== '' ? ref.current.value : ' ';
//           document.body.appendChild(copyTextarea);
//           copyTextarea.select();
//           document.execCommand('copy');
//           document.body.removeChild(copyTextarea);
//         case 8:
//         case "end":
//           return _context.stop();
//       }
//     }, _callee);
//   }));
//   return function CopyHelper(_x, _x2) {
//     return _ref.apply(this, arguments);
//   };
// }();

// var defaultLocaleContext = {
//   dateTimeFormat: 'MM/dd/yyyy hh:mm aaa',
//   timeZone: 'America/New_York',
//   dateFormat: 'MM/dd/yyyy',
//   timeFormat: 'hh:mm aaa',
//   locale: ''
// };

// // Will provide locale related user information such as date formats and timezone
// var LocaleContextProvider = function LocaleContextProvider(props) {
//   var _useState = useState$1(defaultLocaleContext),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     localeContext = _useState2[0],
//     setLocaleContext = _useState2[1];
//   var value = {
//     localeContext: localeContext,
//     setLocaleContext: setLocaleContext
//   };
//   return /*#__PURE__*/React__default.createElement(LocaleContext.Provider, _extends$v({
//     value: value
//   }, props));
// };

// var LiveRegionContextProvider = function LiveRegionContextProvider(props) {
//   var _useState = useState$1(''),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     liveRegionMessage = _useState2[0],
//     setLiveRegionMessage = _useState2[1];
//   var value = {
//     liveRegionMessage: liveRegionMessage,
//     setLiveRegionMessage: setLiveRegionMessage
//   };
//   return /*#__PURE__*/React__default.createElement(LiveRegionContext.Provider, _extends$v({
//     value: value
//   }, props));
// };

// var defaultGridContext = {
//   itemRefs: []
// };
// var GridContextProvider = function GridContextProvider(props) {
//   var _useState = useState$1(defaultGridContext),
//     _useState2 = _slicedToArray$b(_useState, 2),
//     gridContext = _useState2[0],
//     setGridContext = _useState2[1];
//   var value = {
//     gridContext: gridContext,
//     setGridContext: setGridContext
//   };
//   return /*#__PURE__*/React__default.createElement(GridContext.Provider, _extends$v({
//     value: value
//   }, props));
// };

// export { AccessDenied, Accordion, AccordionDetails, AccordionSummary, ActionsCell, ActionsList, Alert, AppHeader, AppLayout, AutoComplete as AutoSuggest, Avatar, AvatarCell, AvatarDonut, Backdrop, Badge, BadgeAlertModal, BaseAlert, BasicTable, BasicTableBody, BasicTableCell, BasicTableContainer, BasicTableHead, BasicTableRow, BodyText, Button$1 as Button, ButtonCell, ButtonGroup, CalendarContainer, Card, CardActionArea, CardDescription, CardImage, CardName, CardPreview, Carousel, CellRenderer, CheckboxCell, CheckboxWithLabel, CloseOnClickAway, CloseOnEscape, CollapseTransition, Column, ComboBox, ComboBoxOption, ComboBoxRenderer, ControlPanel, ControlPanelItem, ControlPanelPreviewItem, CopyHelper, CustomScrollbar as CustomScroll, DataGrid, DataListItem, DatePicker, DateTimePicker, DayCalendar, Divider, Drawer, EditableTableCellContainer, FileUploadButton, FillInTheBlanks, FilterCard, FilterSectionContainer, FlexGrid, FloatingAlert, FloatingButton, FormGroup, FormLabel, FormattedDateTime, FormattedDateTimeHelper, GridContextProvider, GridList, GridStackContainer, GridStackDraggableContainer, GridStackItem, Grow, Highlighter as Hightlighter, Icon, IconActionList, IconButton, IconCell, IconMenu, IconWithLabel, InputAdornment, Label$8 as Label, LabelCell, LabelledImage, LightMenuList, Linechart as LineChart, LineClampText, Link$1 as Link, LinkCell, List, ListItem, LiveRegion, LiveRegionContext, LiveRegionContextProvider, Loader, LocaleContextProvider, MarketSkillCard, MatchingItems, MenuButton, MenuItem, MenuList, Modal, DialogActions as ModalActionWrapper, DialogContent as ModalContentWrapper, MultiSelectCheckbox, MultipleChoice, MultipleSelect, NavigationBreadcrumbs, NoRecordsPlaceholder as NoRecords, OpenEnded, PageLoader, PageTitle, PageTitleDescription, Pagination$1 as Pagination, PaginationContainer, Panel, Paper, PersonSearchResult, Popper, ProfilePopoutBody, ProgressBar, QuestionFeedback, Radio, RadioButtonCell, RadioGroup, RadioWithLabel, RichTextEditor, RouteLink, RouterScrollContainer, SectionTitle, SectionTitleDescription, SelectList, ShowMoreResults, Slider, SliderCell, SortAndFilterPanel, StatusLabel, StatusLabelCell, StatusRibbon, Step, StepLabel, Stepper, SwitchCell, SwitchWithLabel, Tab, Table, TableBody, TableHead, TablePagination, TablePaginationWithDisplayCount, TableToolBar, Tabs, TextField, TextWithNumberFormatting, Theme, TimeConversion, Tooltip$1 as Tooltip, TooltipCell, TransparentButton, TreeItem, TreeList, TreeView, TrueOrFalse, WeekCalendar, useLiveRegionContext, useLocaleContext };
